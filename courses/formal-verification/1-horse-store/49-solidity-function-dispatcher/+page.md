---
title: Solidity's Function Dispatcher
---

---

# Dissecting Solidity's Function Dispatching: An In-depth Code Walkthrough

Hello everyone! Today, we're going on an exciting journey through some fascinating, yet complex, sections of Solidity code. It's a bit like solving a puzzle—figuring out where a piece of code starts and stops. But fear not, I'll guide us through it step by step. So let's roll up our sleeves and get into it!

## The Love for `push zero` and `call data load`

In this code snippet, we kick things off with what I like to fondly call the `push zero` opcode. It's a simple operation that often pops up, and it holds a special place in my heart. Next, we encounter `call data load`, which is equally adored for its usefulness in dealing with call data. For those who need a little refresher, `call data load` is our go-to when we want to fetch call data from a specific byte offset and push it onto the stack as a 32-byte value. It's like a magic trick—voilà, 32 bytes of data appear!

```js
push 0
// We start with push zerocallDataLoad
// Bring in the call data load
```

Imagine peeling an onion—when we process the call data, we reveal layers until we reach the piece we're interested in. At this stage, we are dealing with a chunk starting from byte zero to byte four, which we suspect is the function selector. That's Solidity's way of directing traffic. It routes the incoming function calls to their respective functions without us having to write a single line of code for it.

## Function Selector Decoding and Gas Efficiency

After successfully loading our data, we're met with a `right shift` operation. Remember it? It handles the job of adjusting the bits over to the right by a specified number of places—in our case, 224 (or, in hex, `0xe0`). This process isolates the required function selector from the call data.

```
// Shifting the call data to extract our function selector0xe0 >> (right shift operation)
```

As we unravel the code together, we begin to see the resemblance to the function dispatcher mechanism we've coded ourselves using `huff`. The Solidity compiler has its version, which we'll compare against our workmanship. We'll determine whether the native compiler dispatching is more gas-efficient or if our manually coded logic reigns supreme.

## The Face-off: Huff's Dispatcher vs. Solidity's

The beauty of this code is highlighted when we reach the comparison section. Solidity uses `dupe1` to duplicate the top element on the stack for comparison purposes. It checks if the function selector matches the designated function — in our case, `update number of horses`. If it does, then the code will execute a conditional jump to the address `0x34`. Here, the structure is strikingly similar to Huff's:

```
dupe1
// Duplicate top of stackpush updateNumberHorses
// Pushing our function selectorequals
// Does it equate?jumpi 0x34
// Conditional jump to 0x34
```

"Comparison is the seed of truth" - a notion that proves true as we see the optimizations we've made in Huff, specifically the absence of the `dupe1` operation, making our code slightly more gas-optimized than Solidity's autogenerated code. Pat on the back for us!

## Onward to Reading the Number of Horses

Continuing our adventure through the bytes, we come across another piece of the code that deals with `read number of horses`. The structure is similar to before, with `dupe1` and `push` followed by an `equals`, and conditional `jumpi`.

```solidity
dupe1
// Duplicate top of stackpush readNumberHorses
// Pushing our function selectorequals
// Does it equate?jumpi 0x45
// Jump if a match is found
```

Comparing this snippet to our hand-coded dispatcher reveals another optimization - the missing `dupe1` makes our version leaner. As we dive deeper, the elegance of Huff's design becomes increasingly evident.

## Default Safety: Revert on No Match

We now arrive at a crucial point - what if no function match occurs? Here, Solidity defaults to safety with `jumpdest` and `revert`, avoiding unintended execution. Huff lacks this explicit failsafe, potentially allowing unchecked code execution if decoding fails.

While Huff's design trusts the developer, Solidity focuses on safety for all. As with most choices in coding, there are merits to both approaches. Huff grants flexibility, while Solidity prioritizes robustness.

## Wrapping Up the Journey

We've now successfully parsed Solidity's autogenerated dispatcher, gaining valuable insights. Huff's hand-optimization reminds us that understanding such lower-level mechanics can make us better developers. We appreciate both the elegant efficiency of Huff and Solidity's focus on reliability.
