---
title: using
---

## Setting the Coding Scene

Imagine you've concocted a brilliant method aptly named `f`, and your goal is to invoke this little wizard on both your NFT marketplace smart contract and another platform that we will refer to as `gas bad`. The idea here is to unleash `f` onto these different contracts to compare what they return. That’s where the magic starts and, trust me, we’re about to roll up our coding sleeves and delve right in.

### Initialize the Environment

This snippet of code could very well be the preliminary incantation we cast to get the ball rolling. Now, it's important to note that in the realm of smart contracts, when you invoke a function like this, you're calling it on the current contract that we are in.

But if you've indulged in a bit of blockchain code, you know it's not just about casting spells on your own turf. You want those spells to travel far and wide—or in our case, to `gas bad NFT marketplace` and the `NFT marketplace`.

## Linking our Sorcerous Command to Multiple Recesses

Enter the keyword `using`. This is our portal, our bridge to connect with the external contracts we wish to interact with:

Now, take a step back. Inhale the lines of code that stare back at you from the abyss of your coding screen. When you use the `using` directive, what you’re essentially aiming for is to bring another contract into your sphere of command to invoke `f`. It might sound mystical, but it's as practical as it gets.

### Comparing Contractual Conundrums

The real twist in our tale comes when we want to juxtapose the outputs of `f` from `gas bad NFT marketplace` and `NFT marketplace`. Why, you ask? Well, wouldn't you want to know how your NFT hotspot reacts as compared to `gas bad` when predicated with the same set of incantations? It's a bout of smart contract gladiators, if you will.

And this brings us to a crucial point in our journey—coding is not just about making functions work. It's also about observation, hypothesis, and analysis.

### Navigating the Quirks of Contract Calls

Contract interactions in the blockchain world can be tricky business. It's not just about writing impeccable code; it's also about understanding the environment that your code lives in. Each blockchain platform has its rules, its gas computations, and its quirky behaviors that can turn a simple function call into something akin to negotiating with a sly genie.

This where our `f` function becomes less of a lone ranger and more of a knight in shining armor, galloping across contracts, seeking truth and consistency in a network that's inherently trustless.

Do you follow me? Good, because we're about to embark on a deeper journey, one that takes our initial spells and incantations and wraps them into a real-world context that can either make or break your next big NFT venture.
