---
title: Exploit - Storage Collision - Diagram
---

# Understanding Ethereum Smart Contract Proxies and Upgrades

In the exciting world of Ethereum smart contracts, the design pattern of using proxies for contract upgrades provides an effective solution to the otherwise immutable nature of contracts. However, this approach is not devoid of complexities, and amateur developers may often encounter problems with storage slots during contract upgrades. Let's delve into an illustrative example to understand better how this works.

## Fundamentals of Proxy Interaction

To kick off, let's take a closer look at the basic principles of proxy interaction with smart contracts.

To put it simply, imagine we have an implementation contract. When a user executes a function, say `setValue(x)`, the call initially goes to the proxy. The proxy is programmed to look at the implementation contract for executing the function. For example, if our contract has an instruction to set its value to `x`, the logic gets sent to the proxy.

Once inside, the proxy modifies its internal state, storing the new value at a defined storage location. Typically, the first storage slot (slot 0) is used for this purpose.

This gives us a simplistic view of how the proxy pattern helps align storage with contract implementations.

![](https://cdn.videotap.com/WUQkx9srA6tjA8Yo5lRL-42.36.png)

## The Upgrade Process: What Happens within the Proxy

Now let's see what happens when we decide to upgrade our contract.

In an upgrade scenario, the proxy points from implementation contract `A` to a new implementation contract `B`. However, the storage inside the proxy remains intact. It will simply start referring to the new contract to carry out its logic.

> Note: The essence of the upgrade process is that the proxy's storage does not get changed or migrated. It just adopts a new source of instruction.

![](https://cdn.videotap.com/gKwLO8tKUQsQFgdhAmZB-72.62.png)

## Potential Issues with Storage Slot Misalignment

The seamless continuation of storage masks a potential pitfall â€“ storage slot misalignment. If the new implementation isn't mindful of how the storage was structured in the previous implementation, chaos can erupt!

Let's continue our example to see how. Our user calls `setValue(10)` which now points to logic `B`. If `B` has instructions that alter the storage structure like,

In this situation, `value` gets stored in slot 1 since `initialized` has taken up slot 0. Now, proxy's storage looks completely different with value 5 still in slot 0 and the new value of 10 in slot 1.

Storage slot misalignment might result in overriding storage slots, uninitialized variables, and other issues leading to potential contract vulnerabilities.

![](https://cdn.videotap.com/nvkgWHqUU232F6YtZgQD-111.95.png)

## Diving Deeper with Remix

To see this in action and further understand, we can use Ethereum's browser-based IDE, [Remix](https://remix.ethereum.org/). In the follow-up post, we'll walk through an immersive hands-on example using Remix to intricately explore the subtleties of contract upgrades and proxy interactions. Stay tuned!
