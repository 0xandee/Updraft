---
title: Exploit - Deposit Instead of Repay
---

---

## title: "Uncovering Unexpected Bugs in Defi Smart Contracts with Thunderlone"date: "2021-07-18"author: "DeFi Geek"

Welcome back fellow DeFi enthusiasts! Get ready as we dive into our awesome bug-hunting exercise featuring - Thunderlone and Thunderlone upgraded.

In this article, I am excited to reveal not just one, but two juicy bugs for you today. One is in the original Thunderlone smart contract, and the other one is lurking in the upgraded version of Thunderlone, which we'll dissect later on.

Bear with me as we uncover these bugs and provide strategies to squish them.

## Unearthing Bugs in DeFi Smart Contracts

Before delving into the bugs, let me remind you - you're doing great. If you're new to DeFi, this section might be a little tough, but hang in there, we're almost at the finish line.

### Bug Hunting Begins!

With our newfound expertise in flash loans, we've managed to uncover some interesting behaviors and potential oversights.

Our journey began with a simple question: _What other ways exist to get money into this contract, outside of repaying or sending assets directly, that can potentially pull it out later?_

How did we answer this? For this, we ran a quick scan of Thunderlone's methods.

This gave us a comprehensive overview of all the methods that Thunderlone has, and their respective function signatures. As we analyzed this information, one function jumped out - _deposit_.

### The "Deposit" Function – A New Way to Leverage the System?

Until now, deposit was mainly used by whales to put their tokens in and redeem them later. But we started wondering, what if the system allowed us to deposit tokens and then redeem them without calling repay?

Sounds like a twist in the plot, doesn't it? This interesting loophole sparked our curiosity, leading us to write a proof of code.

### Writing Test to Verify The Bug

Our next step was to create a test scenario. Our test involved initiating a flash loan, after which the user would need to deposit a certain amount.

```markdown
Test scenario:1. Start loan2. Deposit assets3. Redeem money4. Conclude loan
```

### Test Results – Validation of the Bug

What did we find? We found a loophole – stealing money. You heard right! It turns out that our users can manipulate the system by initiating a flash loan and then merely depositing it. Next, they can redeem all the money, causing a huge loss for our liquidity providers.

Check it out; the test along with the results of this big reveal is available at `test_number1` on our repository.

## Thunderlone Upgraded - Examination and Exploration

With Thunderlone dissected, it was time to aim our magnifying lens on Thunderlone Upgraded. Remember, Thunderlone Upgraded was supposed to be the improved version. Did it hold up to expectations? Let's find out.

Since this is an upgradable contract, we had two paths to explore:

1. Starting from scratch - study the code line by line as we did with Thunderlone.
2. Use **diff** - a command used to spot the differences between two files.

In this case, we chose the **diff** command as the more efficient approach.

To see the differences between the two files, we use the diff command:

Thanks to **diff**, we got a comprehensive report sifting through lines of codes and comments. This method helped us identify that they planned on swapping the storage spots of `sFlash Loan fee` which would lead to a disastrous storage collision issue!

### Introducing Storage Collision Attack

This brings us to our second bug - a _storage collision attack_.

Take a moment to imagine a world where a programmer decided to make a quick swap in the storage variables. Initially, you may think it's an innocent programming overlook, right? However, it's an altering decision that will wreak havoc on the entire storage structure, leading to a storage collision attack.

In short, you can't just swap the storage spots!

In the original Thunder Loan, `sFlashLoanFee` is present at slot 3, but in the upgraded version, it's present at slot 2. This shift increases the chances of a fatal storage collision. As such, the swap would directly affect the asset owners, hence, leading us down the path of financial discrepancy.

---

As a final thought, let me just remind you - no matter how minor the change in the code appears, it can have major impacts on your contract's functionality. In this case, this seemingly insignificant storage variable swap has the potential to lead us down a path of storage collision, causing a significant catastrophe.

Happy bug hunting!Stay Safe. Stay Decentralized!

That's all for now, fellow developers and DeFi enthusiasts. See you in the next venture, decoding, dissecting, and debugging DeFi contracts.

Until then - keep defying, keep decoding!
