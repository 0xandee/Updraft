---
title: Exploit - Storage Collision - Remix Example
---

# Understanding the Storage Collision in Ethereum Smart Contracts

In this blog post, we're going to dive deep into understanding one of the common issues Ethereum smart contract developers encounter: the storage collision. In this exploration, we'll utilize Storage Collision, a contract we've sketched in Remix â€” an open-source tool developed by the Ethereum community to help you build smart contracts.

## Introduction to Storage Collision Contract

Scroll down in the remix interface and you'll come across the Storage Collision contract. Opening this contract, there are quite a number of lines to dissect. You'll see a special type of contract called `proxy`. Its pivotal role is to call the `set implementation` function.

There are also helper functions in this contract whose primary task is to read data from the contract. For example, the `readStorage` function checks and fetches the value stored in a specific storage slot.

## Implementation A and B and their peculiarities

The contract contains two distinct implementations labeled as `implementation A` and `implementation B`, mirroring what was shown in the initial diagram.

- **Implementation A** has `value` located at storage slot zero.
- **Implementation B** is a bit more complex with `initialized` at storage slot zero. By default, `initialized` should be `false`. But if there's a value in the corresponding slot, `initialized` becomes `true`.

## Deployment and Compilation

Next on the stop, is to compile and deploy these contracts: `Implementation A`, `Implementation B`, and `Storage Collision Proxy`. It's important to note that the `Storage Collision Proxy` is first associated with the contract address for `implementation A`.

Now, we've set our Proxy to point to `implementation A` and we can interact with it accordingly.

## Interacting with Implementation A

To do this, copy the Proxy address into `implementation A`, allowing us to work directly with `implementation A`.

When we check the `value`, it reads '0' because we haven't assigned any value yet. But when we assign 15 to the `value`, the `value` in `implementation A` changes to 15.

It's worth noting that in solidity, anything aside from 0 is considered `true`. Hence, the `bool public initialize` in `implementation B` is expected to default to `false`. But let's see if that's the case.

## Transition to Implementation B and the Twist

Switching to `Implementation B`, we change the implementation address in our `Storage Collision Proxy` and then inspect the `value`.

Surprisingly, our `value` reads zero - this is because we have upgraded the contract. However, we can imitate the previous process with `implementation A` and interact with `implementation B`.

When we call `initialized`, contrary to the default being `false`, it returns `true`. This happens because within the proxy, the `readStorage()` function is indicating that there's a '15' at storage slot zero.

Since `initialized` is coupled to storage slot zero, the non-zero value makes it return `true`.

The next process is to set the `value` of `implementation B` to a new number, which affects the `storage slot one`.

The consequence of this action reveals a **storage collision**.

> In essence, the 'storage collision' is a situation whereby values in the storage slots overlap as a result of an upgrade, causing unexpected changes in the system.

## In Conclusion

In Ethereum smart contracts, collision issues are something we ought to be wary about. As we've noticed, our upgraded contract seems to be colliding due to these issues, causing unintended changes in the system. Careful architecture of contracts and more thorough analysis are needed to mitigate this risk. As always, understanding the underpinnings of the system and how actions interact with it is key to a successful deployment and operation of your Ethereum smart contracts.
