---
title: Exploit - Storage Collision - Storage Refresher
---

# Understanding the Mechanism of Ethereum Smart Contract Storage.

The vast and innovative landscape of Ethereum smart contracts demands a comprehensive understanding of the subtle ways in which these self-executing bits of code work. In this article, we aim to unpack the operational mechanism of smart contract storage, drawing focus on its organization, types of variables, and implications of upgrades. Without further ado, let's dive straight into understanding contract storage.

## Variable Placement in Storage

Storage, in essence, can be understood as a giant array containing variables. Sequential variables get chronologically placed into this array, with each variable occupying a unique storage slot.

For instance, let's consider a simple variable - `int256 favoriteNumber`. As a first variable, it's placed into `storage slot 0`. If we add another variable, such as a boolean `bool someValue`, it follows suit and gets stacked into `storage slot 1`.

![](https://cdn.videotap.com/fqXHyZ8Wd1AmcWeZV9jE-24.png)

### Variable Packing

While this description captures the essence of storage placement, there's an added layer of complexity; Solidity does some interesting stuff like "packing variables". However, that's a topic for another day. Rest assured, this bit of information won't interfere with the fundamental understanding of storage.

## Arrays and Mappings in Storage

Storage gets slightly trickier to comprehend when dealing with arrays and mappings. The organization of an array is a tad bit complicated - the length of the array gets positioned in a slot analogous to a regular variable. The actual elements of the array, however, find their home in a hash of the storage slot of the array length.

![](https://cdn.videotap.com/JMGwpAcocpS7uwDvgxPP-45.png)

## The Storage Exceptions: Constants and Function Variables

Two types of variables are exempted from having storage slots - constants and function variables.

- **Constants**: Constant variables do not warrant storage slots as they are hard-coded directly into the bytecode. Consequently, we don't need to worry about constant variables while delving into storage.

- **Function Variables**: Such variables—often initialized during the execution of a function— are temporary and exist only for the duration of the function call. Hence, they are stored in memory space, not in storage slots.

## Storage Slots Upon Contract Upgrade

A key question arises - what happens to the storage slots when a contract is upgraded? Well, the order of variables in our upgraded contract is assigned new storage slots, but it also inherits the previous order of variables.

> "We've just totally messed up storage by upgrading our contract to some new nonsense."

Let's say the boolean variable `someBool` was initially in `storage slot 1`, but upon contract upgrade, the variable shifts to `storage slot 2`. This transition recapsulates the flexibility, albeit complexity, of the Ethereum storage structure.

![](https://cdn.videotap.com/UvEwzYfKpxND8OGan5AW-114.png)

In conclusion, understanding the storage behavior in Ethereum smart contracts is fundamental for anyone trying to navigate the rich ecosystem. The mappings and order change can surely create some confusion, but with time and practice, managing storage slots becomes second nature.
