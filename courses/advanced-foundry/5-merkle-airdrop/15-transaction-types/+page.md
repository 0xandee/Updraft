## Understanding EIP-4844: Proto-Danksharding and Blob Transactions

Ethereum Improvement Proposal (EIP) 4844, commonly known as "Proto-Danksharding," represents a significant step forward in Ethereum's scalability roadmap. Activated on March 13, 2024, as part of the Dencun network upgrade, EIP-4844 introduced a new transaction type called Blob Transactions (Type 3).

The core objective of EIP-4844 is to drastically lower the costs associated with Layer 2 (L2) rollups posting their transaction data back to the Ethereum Layer 1 (L1) mainnet. By making this process cheaper for rollups, the proposal aims to significantly reduce transaction fees for end-users interacting with L2 solutions like Optimism, Arbitrum, and zkSync. It achieves this by creating a new, temporary data storage mechanism ("blobs") and a dedicated fee market for this blob space, separate from traditional transaction calldata.

Proto-Danksharding gets its name from the researchers involved, Protolambda and Dankrad Feist, and signifies that it's an initial ("Proto") implementation step towards the more comprehensive "Danksharding" scaling solution planned for Ethereum's future.

## The Challenge: Why Layer 2 Rollups Needed Cheaper Data Availability

Layer 2 scaling solutions, particularly rollups, are widely regarded as the primary method for scaling Ethereum for the foreseeable future. They work by executing transactions off-chain on the L2 network, bundling or "rolling up" many transactions into batches, and then posting summary data and proofs back to the L1 Ethereum chain for security and finality.

A critical component of this process is **data availability**. For the L2 state to be verifiable and secure, the underlying transaction data for the rollup batches must be posted to the L1. This ensures that anyone can reconstruct and verify the L2 state if needed, preventing censorship or fraud by the L2 operator.

Before EIP-4844, rollups had only one option for posting this data: using the `calldata` field of standard Ethereum transactions (like Type 2, EIP-1559 transactions). However, `calldata` has two major drawbacks for this use case:
1.  **Cost:** Storing data in `calldata` consumes L1 gas and can be very expensive, especially for the large amounts of data generated by active rollups. This L1 cost is the primary driver of fees paid by users on L2.
2.  **Permanence:** Data stored in `calldata` becomes a permanent part of the Ethereum blockchain history, contributing to "state bloat." Rollups, however, only need the data to be available temporarily â€“ long enough for honest network participants to verify the L2 state transition (typically days or weeks). Storing this data permanently on L1 is inefficient and unnecessarily burdensome. Imagine being forced to permanently carry every exam paper you ever wrote.

This high cost and unnecessary permanence of using `calldata` created a significant bottleneck for L2 scalability and affordability.

## The Solution: Introducing Type 3 Blob Transactions

EIP-4844 addresses this challenge by introducing **Blob Transactions (Type 3)**. These transactions function similarly to standard transactions but include an additional component: attached data "blobs."

Here's how they differ from traditional transactions (Type 0, 1, or 2):

*   **Standard Data:** Blob transactions still contain the usual transaction information (sender, receiver, value, nonce, gas fees, etc.), which is processed by the Ethereum Virtual Machine (EVM) and stored permanently in L1 state/history like regular `calldata`.
*   **Attached Blobs:** Additionally, a Type 3 transaction can carry one or more "blobs." A blob (Binary Large Object) is a substantial chunk of data, approximately 128 KB in size.
*   **Temporary Storage:** Crucially, the data within these blobs is **not** stored permanently on the L1 execution layer. It's not part of the Ethereum state tree and is not accessible directly by the EVM. L1 consensus nodes guarantee the *availability* of blob data for a specific, relatively short period (targeted around 18 days, though the window can range roughly from 18 to potentially 90 days depending on network parameters). After this window, nodes are expected to prune (delete) the blob data.
*   **Purpose-Built for Rollups:** This temporary availability model perfectly matches the needs of L2 rollups. They get a dedicated, cheaper space to post their batch data, ensuring it's available long enough for verification without incurring the cost and storage burden of permanent L1 calldata.

Think of a blob as a temporary sidecar attached to a motorcycle (the transaction). It carries extra cargo (data) for a specific part of the journey but is then detached and discarded, rather than being permanently welded to the frame.

## Verifying Blob Data Without Direct EVM Access

A key design feature of blobs is that their content is **not directly accessible** by smart contracts running on the L1 EVM. This prevents blobs from inadvertently burdening the execution state and keeps their processing lightweight. This raises a critical question: if L1 contracts (like the rollup's bridge contract) cannot read the blob data, how can they verify that the correct data was submitted?

The answer lies in advanced cryptography, specifically **KZG (Kate-Zaverucha-Goldberg) commitments** and proofs. EIP-4844 introduces two new cryptographic tools to enable this verification:

1.  **`BLOBHASH` Opcode:** A new EVM opcode (`0x48`) that allows a smart contract to retrieve a special type of cryptographic hash of a specific blob attached to the transaction. This hash is not a simple SHA-3 hash but a **KZG commitment** (specifically, a versioned hash derived from the commitment). This commitment acts as a secure and unique fingerprint of the blob's contents.
2.  **Point Evaluation Precompile:** EIP-4844 introduces a new precompiled contract at address `0x0A`. This precompile is highly optimized C++ code designed to efficiently perform complex cryptographic operations, specifically verifying KZG proofs. A rollup contract can call this precompile, providing:
    *   The blob's versioned hash (obtained via the `BLOBHASH` opcode).
    *   Specific points within the blob data that need checking.
    *   Corresponding KZG proofs provided by the L2 sequencer when submitting the blob.

The precompile verifies if the provided proofs are valid for the claimed data points against the blob's KZG commitment (the versioned hash). If the verification succeeds, the L1 contract knows, with cryptographic certainty, that the blob data submitted corresponds to the commitment, effectively verifying the integrity and content of the blob data without ever needing the EVM to access the raw blob data itself.

For example, a ZK Sync L1 contract might call an internal function like `_verifyBlobInformation`. This function would use the `BLOBHASH` opcode (perhaps abstracted away) to get the `blobVersionedHash` for each attached blob. It would then call the Point Evaluation Precompile, passing this `blobVersionedHash` along with proof data (`_pubdataCommitments` or similar) received from the L2 to confirm the validity of the submitted L2 batch data contained within the blobs.

## The Blob Gas Market: Multidimensional Fee Pricing

EIP-4844 doesn't just introduce blobs; it also establishes a completely separate **fee market for blob data**, distinct from the existing EIP-1559 gas market that prices L1 computation and calldata storage.

This means that the cost of including blob data in an L1 block is determined independently from the cost of executing smart contracts or storing regular calldata. The blob fee market adjusts based on the supply and demand for blob space, using a mechanism similar to EIP-1559's base fee adjustments, targeting a specific number of blobs per block (e.g., 3 blobs target, 6 blobs max per block initially).

This separation creates what is sometimes referred to as **multidimensional gas pricing**. Ethereum block space now has (at least) two dimensions of cost:
1.  **Execution Gas:** For computation, standard transaction calldata, state changes, etc.
2.  **Blob Gas:** Specifically for the data included in blobs.

The price for each dimension can fluctuate independently. If there's high demand for L2 rollups posting data but low demand for L1 smart contract execution, blob gas prices might rise while execution gas prices remain stable, or vice versa. This allows for more efficient resource pricing on the network. Users sending blob transactions need to specify both a `maxFeePerGas` (for execution) and a `maxFeePerBlobGas` (for the blobs).

## Creating and Sending Blob Transactions with Python

Developers interacting with Ethereum via libraries like `web3.py` can now construct and send Type 3 Blob Transactions. Here are the key considerations and code patterns involved, illustrated with conceptual Python snippets:

1.  **Blob Padding:** Blobs must conform to a strict size requirement: exactly 4096 field elements, each 32 bytes long, totaling 131,072 bytes (~128 KB). If your actual data is smaller, you *must* pad it, typically with leading zero bytes, to reach this exact size.

    ```python
    # Example: Your actual data encoded
    encoded_text = b"<( o.o )>"
    # Calculate padding needed (each element is 32 bytes)
    data_elements = (len(encoded_text) + 31) // 32 # Number of 32-byte elements used by data
    padding_elements = 4096 - data_elements
    # Create the padded blob data
    padded_blob_data = (b'\x00' * 32 * padding_elements) + encoded_text.ljust(data_elements * 32, b'\x00')

    # Ensure the final blob is the correct size
    assert len(padded_blob_data) == 4096 * 32
    ```
    *Note: The exact padding method might vary based on cryptographic requirements (e.g., ensuring data aligns with field elements), but the principle of reaching the fixed size is constant.*

2.  **Transaction Dictionary Setup:** When creating the transaction dictionary, you need to specify `type: 3` and include the new blob-specific gas parameter `maxFeePerBlobGas`.

    ```python
    from web3.auto import w3 # Assume w3 is configured
    from web3 import Web3

    # Assume 'acct' is your loaded account object
    # Assume 'padded_blob_data' is your prepared blob data

    # Estimate regular gas (implementation-specific)
    gas_estimate = 21000 + 100000 # Placeholder estimate

    tx_params = {
        "type": 3, # Specify Type 3 Transaction
        "chainId": w3.eth.chain_id, # Get chain ID dynamically
        "from": acct.address,
        "to": "0x...", # Recipient address
        "value": 0,
        "maxFeePerGas": w3.to_wei(20, 'gwei'), # Max fee for L1 execution gas
        "maxPriorityFeePerGas": w3.to_wei(1, 'gwei'), # Tip for L1 validator
        # New field for blob gas:
        "maxFeePerBlobGas": w3.to_wei(10, 'gwei'), # Max fee for blob gas (adjust based on current blob market)
        "nonce": w3.eth.get_transaction_count(acct.address),
        "gas": gas_estimate,
        # 'data': '0x...' # Optional: Standard calldata can still be included
    }
    ```

3.  **Signing and Including Blobs:** The crucial step is passing the prepared blob data (as a list of bytes objects) to the signing function using the `blobs` keyword argument. The library handles calculating the necessary KZG commitments and versioned hashes behind the scenes and incorporating them into the signed transaction structure.

    ```python
    # Sign the transaction, providing the prepared blob data
    signed_tx = acct.sign_transaction(tx_params, blobs=[padded_blob_data])

    # Send the raw transaction
    tx_hash = w3.eth.send_raw_transaction(signed_tx.rawTransaction)
    print(f"Sent Blob Transaction: {tx_hash.hex()}")
    ```

By following these steps, developers can leverage the cost savings of blob space for applications requiring temporary data availability on L1, primarily benefiting L2 rollups.

## EIP-4844's Role in Ethereum Scaling: Proto-Danksharding

It's important to understand that EIP-4844, or Proto-Danksharding, is an intermediate step towards Ethereum's long-term scaling vision, known as **full Danksharding**.

Proto-Danksharding implements the transaction format, verification logic (KZG precompile), and fee market changes required for blobs. However, it doesn't fully implement the scaling aspect of Danksharding itself. Initially, the number of blobs per block is limited (e.g., target 3, max 6).

Full Danksharding aims to significantly expand this capacity, potentially allowing for many more blobs per block (e.g., 64 or more). This will require further changes to Ethereum's consensus layer, particularly around data availability sampling (DAS), allowing nodes to verify the availability of all blob data without needing to download every single blob.

EIP-4844 provides the foundational elements and immediate cost relief for L2s, paving the way for these future enhancements.

## Key Takeaways of EIP-4844

*   **Introduced Blob Transactions (Type 3):** Enables attaching large (~128KB) temporary data blobs to Ethereum transactions.
*   **Lowered L2 Costs:** Drastically reduces the cost for L2 rollups to post data to L1 by using cheaper blob space instead of permanent calldata.
*   **Temporary Data Availability:** Blob data is guaranteed to be available only for a short period (~18 days) and is then pruned by L1 nodes, mitigating L1 storage bloat.
*   **Cryptographic Verification:** Uses KZG commitments (`BLOBHASH` opcode) and proofs (verified by a Point Evaluation Precompile) to allow L1 contracts to verify blob contents without direct EVM access.
*   **Blob Gas Market:** Creates a separate fee market for blob data, leading to multidimensional gas pricing (execution vs. blob data).
*   **Proto-Danksharding:** Represents the first phase towards full Danksharding, providing immediate scalability benefits while laying groundwork for future improvements.

By significantly reducing the data availability costs for Layer 2 solutions, EIP-4844 marks a crucial milestone in making Ethereum more scalable and affordable for users interacting via rollups.