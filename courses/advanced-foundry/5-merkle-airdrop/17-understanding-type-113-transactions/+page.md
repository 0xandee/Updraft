## Implementing EIP-712 Signature Verification in a Merkle Airdrop Contract

This lesson demonstrates how to enhance a Solidity `MerkleAirdrop` contract by implementing EIP-712 compliant signature verification. This modification allows a third-party, often called a relayer, to execute the `claim` function on behalf of the intended recipient. The relayer submits a valid signature from the recipient alongside the claim request, proving the recipient's consent. This pattern is fundamental for enabling features like gasless transactions, where users sign messages off-chain, and a separate entity pays the gas fees to submit the transaction to the network.

We will modify an existing `MerkleAirdrop` contract, leveraging OpenZeppelin's robust implementations of ECDSA and EIP-712 standards.

**Key Concepts:**

*   **Digital Signatures (ECDSA):** Signatures (`v`, `r`, `s` components) are generated by signing a message hash with a private key. They allow verification of authenticity and integrity using the corresponding public key (Ethereum address).
*   **EIP-712:** A standard for signing typed structured data instead of arbitrary byte strings. It improves user experience by making signed messages human-readable in wallets and enhances security by providing domain separation (preventing replay attacks across different contracts or chains).
*   **Gasless (Meta-)Transactions:** A pattern where a user signs an intent (message) off-chain, and a relayer submits this intent along with the signature to a smart contract. The contract verifies the signature before executing the action, and the relayer pays the transaction gas fees.

**Implementation Steps:**

### 1. Modifying the `claim` Function Signature

To enable signature verification, the `claim` function must accept the signature components as arguments.

```solidity
// Previous function signature (for context):
// function claim(address account, uint256 amount, bytes32[] calldata merkleProof) external { ... }

// New function signature:
function claim(
    address account,
    uint256 amount,
    bytes32[] calldata merkleProof,
    uint8 v,
    bytes32 r,
    bytes32 s
) external {
    // ... implementation to follow ...
}
```

The added parameters `v`, `r`, and `s` represent the components of the ECDSA signature provided by the recipient (`account`).

### 2. Defining a Custom Error for Invalid Signatures

Using custom errors is more gas-efficient than revert strings. We define an error specifically for signature verification failures.

```solidity
error MerkleAirdrop_InvalidSignature();
```

### 3. Integrating Signature Verification Logic into `claim`

Inside the `claim` function, before executing the core Merkle proof verification and token transfer, we must verify the provided signature.

```solidity
function claim(
    address account,
    uint256 amount,
    bytes32[] calldata merkleProof,
    uint8 v,
    bytes32 r,
    bytes32 s
) external {
    // Existing check: Ensure the account hasn't claimed already
    if (s_hasClaimed[account]) {
        revert MerkleAirdrop_AlreadyClaimed();
    }

    // --- New Signature Verification Logic ---
    // 1. Calculate the expected EIP-712 message digest
    bytes32 messageDigest = getMessage(account, amount);

    // 2. Verify the signature against the digest and the expected signer (account)
    if (! _isValidSignature(account, messageDigest, v, r, s)) {
        revert MerkleAirdrop_InvalidSignature(); // Revert if signature is invalid
    }
    // --- End of Signature Verification Logic ---

    // Existing Merkle proof verification logic
    bytes32 leaf = keccak256(bytes.concat(keccak256(abi.encode(account, amount))));
    if (!MerkleProof.verify(merkleProof, i_merkleRoot, leaf)) {
        revert MerkleAirdrop_InvalidProof();
    }

    // Mark as claimed and transfer tokens
    s_hasClaimed[account] = true;
    emit Claim(account, amount);
    i_airdropToken.safeTransfer(account, amount);
}
```

This logic introduces two helper functions: `getMessage` (to compute the EIP-712 digest) and `_isValidSignature` (to perform the ECDSA verification).

### 4. Defining the EIP-712 Data Structure

EIP-712 requires defining the structure of the data being signed. In our case, it's the claim details: the recipient's address and the amount.

```solidity
struct AirdropClaim {
    address account;
    uint256 amount;
}
```

### 5. Defining the EIP-712 Message Type Hash

EIP-712 uses a type hash to identify the structure being signed. This is a `keccak256` hash of the structure's definition string.

```solidity
// EIP-712 type definition string: "AirdropClaim(address account,uint256 amount)"
bytes32 private constant MESSAGE_TYPEHASH =
    keccak256("AirdropClaim(address account,uint256 amount)");
```

### 6. Implementing the `getMessage` Function

This function constructs the EIP-712 compliant digest that the user needs to sign off-chain. It combines the domain separator (handled by OpenZeppelin's `EIP712` base contract) with the hash of the specific `AirdropClaim` data instance.

```solidity
/**
 * @notice Calculates the EIP-712 digest for an airdrop claim.
 * @param account The address claiming the airdrop.
 * @param amount The amount being claimed.
 * @return digest The EIP-712 digest to be signed.
 */
function getMessage(address account, uint256 amount) public view returns (bytes32 digest) {
    // 1. Calculate the hash of the specific data struct instance
    bytes32 structHash = keccak256(abi.encode(
        MESSAGE_TYPEHASH,
        AirdropClaim({account: account, amount: amount}) // Instantiating the struct with provided values
    ));

    // 2. Combine with domain separator using OpenZeppelin's EIP712 helper
    // _hashTypedDataV4 incorporates the domain separator and follows EIP-712 spec:
    // keccak256("\x19\x01" || domainSeparator || structHash)
    return _hashTypedDataV4(structHash);
}
```

Making this function `public view` allows off-chain clients (like user interfaces or relayers) to easily compute the correct digest that needs signing.

### 7. Importing and Inheriting OpenZeppelin Contracts

We need to import and inherit the necessary OpenZeppelin contracts for EIP-712 and ECDSA functionality.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

// Import necessary OpenZeppelin contracts
import { EIP712 } from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";
import { ECDSA } from "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import { MerkleProof } from "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol"; // Likely already present
import { IERC20, SafeERC20 } from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; // Likely already present

// Inherit from EIP712
contract MerkleAirdrop is EIP712 {
    using SafeERC20 for IERC20; // Likely already present

    // Custom Errors (add the new one)
    error MerkleAirdrop_AlreadyClaimed();
    error MerkleAirdrop_InvalidProof();
    error MerkleAirdrop_InvalidSignature(); // New error

    // State Variables (existing)
    bytes32 public immutable i_merkleRoot;
    IERC20 public immutable i_airdropToken;
    mapping(address => bool) private s_hasClaimed;

    // EIP-712 Struct and TypeHash (defined above)
    struct AirdropClaim {
        address account;
        uint256 amount;
    }
    bytes32 private constant MESSAGE_TYPEHASH =
        keccak256("AirdropClaim(address account,uint256 amount)");

    // Events (existing)
    event Claim(address indexed account, uint256 amount);

    // Constructor (needs update - see next step)
    // Functions (claim, getMessage, _isValidSignature - see other steps)
    // ... rest of contract definition ...
}

```

### 8. Updating the Constructor for EIP-712 Domain Separation

The `EIP712` base contract constructor requires a name and version string. These are used to compute the domain separator, ensuring signatures are unique to this specific contract instance and version.

```solidity
constructor(bytes32 merkleRoot, IERC20 airdropToken)
    // Initialize EIP712 with a unique name and version for the domain separator
    EIP712("MerkleAirdrop", "1")
{
    i_merkleRoot = merkleRoot;
    i_airdropToken = airdropToken;
}
```

### 9. Implementing the `_isValidSignature` Function

This internal function performs the core ECDSA signature recovery and verification using OpenZeppelin's `ECDSA` library.

```solidity
/**
 * @notice Verifies if a signature is valid for a given digest and expected signer.
 * @dev Uses ECDSA.tryRecover for safe recovery, returning address(0) on failure.
 * @param account The address expected to have signed the message.
 * @param digest The EIP-712 digest that was signed.
 * @param v The recovery ID component of the signature.
 * @param r The r component of the signature.
 * @param s The s component of the signature.
 * @return bool True if the signature is valid and matches the account, false otherwise.
 */
function _isValidSignature(
    address account,
    bytes32 digest,
    uint8 v,
    bytes32 r,
    bytes32 s
) internal pure returns (bool) {
    // Use tryRecover for safe signature recovery.
    // It returns address(0) if the signature is invalid or malformed,
    // preventing reverts within this function.
    address actualSigner = ECDSA.tryRecover(digest, v, r, s);

    // Check if the recovered signer address matches the expected account address.
    // Since tryRecover returns address(0) on error, this check implicitly handles
    // invalid signatures (as address(0) will not match a valid 'account').
    // Note: 'account' should never be address(0) in a valid claim scenario.
    return actualSigner == account;
}
```

Using `ECDSA.tryRecover` is preferred over `ECDSA.recover` or the raw `ecrecover` precompile. `tryRecover` handles potential errors during recovery (like invalid signature components or signature malleability issues) by returning `address(0)` instead of reverting the entire transaction. This allows our `claim` function to catch the invalid signature condition and revert with the specific `MerkleAirdrop_InvalidSignature` error.

**Important Considerations and Best Practices:**

*   **`ECDSA.tryRecover`:** Use this for robust signature verification that avoids internal reverts on invalid inputs.
*   **EIP-712:** Essential for user-friendly signing prompts in wallets and crucial for preventing replay attacks across different applications or chains via the domain separator.
*   **OpenZeppelin:** Rely on audited, standard implementations for complex cryptographic operations like ECDSA and EIP-712 hashing.
*   **Custom Errors:** Improve gas efficiency and provide clearer error reporting compared to `require` statements with strings.
*   **Function Visibility:** Make `getMessage` `public view` for off-chain accessibility and `_isValidSignature` `internal pure` as it's a stateless utility function used only within the contract.

**Conclusion:**

By incorporating these changes, the `MerkleAirdrop` contract now supports EIP-712 signature verification. This allows users to authorize claims by signing a structured message off-chain, which can then be submitted by a relayer. This pattern unlocks possibilities like gasless airdrop claims, significantly improving the user experience for recipients who may not have ETH to pay for gas. The next logical step after implementing these changes is to write comprehensive tests to ensure the signature verification logic works correctly under various conditions.