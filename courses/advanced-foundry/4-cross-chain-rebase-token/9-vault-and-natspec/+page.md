## Building the Vault Contract

Welcome! In this lesson, we'll construct the core component of our system: the `Vault` smart contract. This contract will manage the Ether (ETH) deposited by users, interact with our `RebaseToken` contract to mint and burn tokens, and serve as the central hub for rewards. Before we dive in, remember the importance of clear documentation. Using NatSpec comments (`/** ... */`) rather than standard multi-line comments (`/* ... */`) ensures your documentation tags (`@notice`, `@param`, etc.) are properly recognized by development tools, enhancing readability and maintainability.

## Introducing the Vault's Role

The `Vault` contract is the primary interaction point for users. Its responsibilities include:

1.  **Accepting ETH Deposits:** Users send ETH to the Vault.
2.  **Minting Tokens:** In exchange for deposited ETH, the Vault instructs the `RebaseToken` contract to mint new tokens for the user.
3.  **Holding ETH:** All deposited ETH (and any accrued rewards) are held within this contract.
4.  **Handling Redemptions:** Users burn their `RebaseToken`s via the Vault to withdraw their corresponding share of ETH.
5.  **Receiving Rewards:** The Vault needs a mechanism to receive ETH representing rewards generated by the protocol or sent from external sources.

Think of the Vault as the secure lockbox holding the ETH that backs the value of the `RebaseToken`s.

## Setting Up the Vault Contract File

Let's start by creating the basic structure. Create a new file named `Vault.sol` inside your `src` directory. Add the standard license identifier and pragma statement, followed by the contract definition:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

// Forward declaration for the interface we'll create later
interface IRebaseToken;

contract Vault {
    // Contract logic will go here
}
```

We've included a forward declaration for `IRebaseToken` which we'll define fully later. This helps keep the code organized.

## Implementing the Constructor

The `Vault` needs to know the address of the `RebaseToken` contract it must interact with (to call `mint` and `burn`). We'll pass this address when deploying the `Vault` contract using a constructor.

To store this address efficiently and securely, we'll use an `immutable` state variable. Immutable variables can only be set once within the constructor and cannot be changed later. This provides a gas saving compared to regular storage variables and clearly signals the variable's intended immutability. We'll prefix immutable variables with `i_` as a convention.

Instead of storing just the `address`, we'll store it as the interface type `IRebaseToken`. This provides type safety and allows us to directly call functions defined in the interface.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {IRebaseToken} from "./interfaces/IRebaseToken.sol"; // Import the interface

contract Vault {
    // State Variables
    /**
     * @notice Address of the RebaseToken contract this vault interacts with.
     * @dev Stored as an immutable interface type for gas savings and type safety.
     */
    IRebaseToken private immutable i_rebaseToken;

    /**
     * @notice Sets the RebaseToken address upon deployment.
     * @param _rebaseToken The address of the deployed RebaseToken contract.
     */
    constructor(IRebaseToken _rebaseToken) {
        i_rebaseToken = _rebaseToken;
    }

    /**
     * @notice Retrieves the address of the associated RebaseToken contract.
     * @return Address of the RebaseToken contract.
     */
    function getRebaseTokenAddress() external view returns (address) {
        return address(i_rebaseToken); // Cast back to address for external view
    }

    // Other functions will follow...
}

```

We also added a public `getRebaseTokenAddress` function so external parties can query which token this vault is linked to. Notice how we explicitly cast the `IRebaseToken` type back to `address` in the return statement.

## Receiving ETH Rewards

The Vault needs a way to receive ETH that represents rewards (e.g., protocol fees, external contributions) without requiring a specific function call. Solidity provides the special `receive()` fallback function for this purpose. It's automatically executed when ETH is sent to the contract address with empty calldata.

It must be declared `external payable`. For this example, its implementation is minimal â€“ it simply accepts the ETH. In real-world applications, this function might contain more complex logic related to reward tracking or distribution.

```solidity
// Inside the Vault contract

/**
 * @notice Allows the contract to receive ETH transfers (e.g., rewards).
 */
receive() external payable {}
```

## Handling User Deposits

Now, let's implement the `deposit` function. Users will call this function, sending ETH along with the call, and receive `RebaseToken`s in return. In our simple model, 1 wei of ETH corresponds to 1 wei of `RebaseToken`.

The function needs to be `external` (callable from outside) and `payable` (so it can accept the user's ETH). The amount of ETH sent is available via the global `msg.value` variable. The user initiating the call is `msg.sender`.

The core logic involves calling the `mint` function on the `RebaseToken` contract (`i_rebaseToken`), specifying `msg.sender` as the recipient and `msg.value` as the amount.

We'll also define and emit a `Deposit` event to log these actions, making it easier for off-chain services to track deposits. We mark the `user` address as `indexed` to allow efficient filtering of events for specific users.

```solidity
// Inside the Vault contract

// Events
/**
 * @notice Emitted when a user successfully deposits ETH.
 * @param user The address of the depositor (indexed for filtering).
 * @param amount The amount of ETH deposited (and tokens minted).
 */
event Deposit(address indexed user, uint256 amount);

/**
 * @notice Allows users to deposit ETH and receive an equivalent amount of RebaseTokens.
 * @dev Mints RebaseTokens to the sender equal to the msg.value sent.
 */
function deposit() external payable {
    // We'll need the RebaseToken's mint function here
    // Requires interaction via the IRebaseToken interface
    uint256 amount = msg.value; // Get the amount of ETH sent

    // Mint tokens to the user
    i_rebaseToken.mint(msg.sender, amount);

    // Emit an event
    emit Deposit(msg.sender, amount);
}
```

However, if we hadn't already set up `i_rebaseToken` as type `IRebaseToken` (and perhaps left it as `address`), the line `i_rebaseToken.mint(...)` would cause a compiler error: `Member "mint" not found or not visible after argument-dependent lookup in address`. This is because the Solidity compiler doesn't inherently know that a variable of type `address` points to a contract with a specific function like `mint`. This leads us to the crucial role of interfaces.

## Defining and Using Interfaces for Interaction

To solve the interaction problem and provide type safety, we use interfaces. An interface defines *what* functions a contract exposes externally (their names, parameters, return types) without specifying *how* they are implemented. It's like a contract's public API blueprint.

1.  **Create the Interface File:** Create a new folder named `interfaces` within `src`. Inside `interfaces`, create a file named `IRebaseToken.sol`.
2.  **Define the Interface:** Define the `IRebaseToken` interface with the signatures of the functions the `Vault` needs to call on the `RebaseToken` contract (`mint` and `burn`). Functions in interfaces are always `external`.

```solidity
// src/interfaces/IRebaseToken.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

/**
 * @title IRebaseToken Interface
 * @notice Defines the external functions of the RebaseToken contract
 *         that the Vault needs to interact with.
 */
interface IRebaseToken {
    /**
     * @notice Mints new tokens to a specified address.
     * @param _to The address to receive the tokens.
     * @param _amount The amount of tokens to mint.
     */
    function mint(address _to, uint256 _amount) external;

    /**
     * @notice Burns tokens from a specified address.
     * @param _from The address to burn tokens from.
     * @param _amount The amount of tokens to burn.
     */
    function burn(address _from, uint256 _amount) external;
}
```

3.  **Import and Use in Vault:** As shown previously, import the interface in `Vault.sol` (`import {IRebaseToken} from "./interfaces/IRebaseToken.sol";`) and use `IRebaseToken` as the type for the `i_rebaseToken` state variable and the constructor parameter.

By using the interface type `IRebaseToken` for `i_rebaseToken`, the compiler now understands that this variable represents a contract implementing the `mint` and `burn` functions, resolving the previous error and enabling type-safe interaction.

## Implementing Token Redemption

The `redeem` function allows users to reverse the deposit process: they burn their `RebaseToken`s and receive the corresponding amount of ETH back from the Vault.

The function takes the `_amount` of tokens the user wishes to redeem as an argument and should be `external`.

We'll follow the **Checks-Effects-Interactions** pattern for security:

1.  **Checks:** (Implicit) The `burn` function within `RebaseToken` (not shown here, but assumed to exist) should handle checks like ensuring the user has enough balance. We don't need explicit checks for balance in the `Vault` itself if the token handles it.
2.  **Effects:** First, modify the state internal to this system. We call the `burn` function on the `i_rebaseToken` contract to destroy the user's (`msg.sender`) tokens.
3.  **Interactions:** Only after internal state changes are made, interact with external addresses/contracts. Here, we send the ETH back to the user.

For sending ETH, using the low-level `call` method is generally preferred over `transfer` or `send` due to security considerations (mitigating reentrancy risks related to fixed gas stipends).

We need to:
*   Cast the recipient (`msg.sender`) to `payable`.
*   Use `.call{value: _amount}("")` to send `_amount` ETH with empty calldata.
*   Check the boolean `success` return value of `call`. If it's `false`, the ETH transfer failed, and we must revert the entire transaction to prevent the user's tokens from being burned without receiving ETH.

For reverting, we'll use a **custom error**. Custom errors are more gas-efficient than `require` statements with string messages.

Finally, we define and emit a `Redeem` event, again indexing the `user`.

```solidity
// Inside the Vault contract

// Custom Errors
/**
 * @notice Indicates that the ETH transfer during redemption failed.
 */
error Vault_RedeemFailed();

// Events
/**
 * @notice Emitted when a user successfully redeems tokens for ETH.
 * @param user The address of the redeemer (indexed for filtering).
 * @param amount The amount of tokens redeemed (and ETH sent).
 */
event Redeem(address indexed user, uint256 amount);

/**
 * @notice Allows users to burn their RebaseTokens and receive an equivalent amount of ETH.
 * @param _amount The amount of RebaseTokens to burn.
 * @dev Follows Checks-Effects-Interactions pattern. Uses .call for safer ETH transfer.
 */
function redeem(uint256 _amount) external {
    // Effects: Burn the user's tokens first
    i_rebaseToken.burn(msg.sender, _amount);

    // Interactions: Send ETH back to the user
    (bool success, ) = payable(msg.sender).call{value: _amount}("");

    // Check: Revert if the ETH transfer failed
    if (!success) {
        revert Vault_RedeemFailed();
    }

    // Emit event on success
    emit Redeem(msg.sender, _amount);
}
```

## Adding Documentation (NatSpec)

Finally, ensure your public functions and state variables have clear NatSpec comments (`/** ... */`). This improves understanding and automatically generates documentation for users and developers interacting with your contract.

```solidity
// Example NatSpec for the redeem function (already added above)
/**
 * @notice Allows users to burn their RebaseTokens and receive an equivalent amount of ETH.
 * @param _amount The amount of RebaseTokens to burn.
 * @dev Follows Checks-Effects-Interactions pattern. Uses .call for safer ETH transfer.
 */
 function redeem(uint256 _amount) external { // ... function body ... }
```

With this, our `Vault.sol` contract has the essential functionalities: receiving ETH deposits, minting tokens via an interface, receiving reward ETH, and handling token redemption with secure ETH transfers. The next logical step is to write comprehensive tests to ensure all these components work correctly together.