## Vulnerabilities and cross-chain intro

Before we move on and make our token work cross-chain, I just wanted to walk you through two very small issues with this smart contract. Well, not really issues but they're just sort of like floors in the design incentive. The first one we touched on a little bit earlier, which is that in the transfer and transfer from functions, if the user that you are sending the recipient does not yet have their own interest rate, ie they haven't yet deposited, they don't have a balance yet, then you inherit the interest rate of the sending wallet. And, if they don't, or if they do already have an interest rate, then nothing happens, they keep their original interest rate. Now, the sort of bug or design flaw here is that if I were to do a small deposit early on in the protocol when the interest rate of the smart contract is still high, because remember the interest rate of the contract is decreasing over time, every time that someone does a deposit, they get the current interest rate in the smart contract. And, we want to try and incentivize early depositors, depositors, so yeah. So, if I do a very small deposit, very early on, and then later I do a very large deposit, and then I send, using a second, using a second wallet, then I can send my new massive deposit, from my second wallet to the first wallet, and retain the higher interest rate, which is now applied to my entire two deposits, the early one and the later one. The second design flaw is in the way that we calculate the interest. So, when you call balanceOf, you obviously times by the accumulated interest, which is like one plus any interest that has accrued, and then you times that by the balance. Now, obviously, the super.balanceOf is going to be any minted tokens. Now, if the user comes along and they interact with the protocol, let's say, they call burn, wherever burn is, let's say, they call burn. Then, we are going to mint them the accrued interest which will mean that their principal balance of, like, their number of actual tokens that have been minted will increase. Therefore, this balanceOf function is going to a higher rate of increase because this is going to return a higher number. The same, if they send tokens to someone else, maybe they only send like 0.000000 tokens, but now they have accumulated the interest, which means that the interest is compounding, because we now are applying this interest rate on not just their initial deposit, but, any interest that has accrued. Now, this isn't, is not a critical issue. Obviously, it means that, you know, if someone is spamming burn or transfer, then, they could, you know, let their, the interest is going to diverge away from linear and converge or tend towards a compound interest style contract. And, that's okay, and you know, maybe this is just something that we accept, and we incentivize people to interact with the protocol more. Or, we could set a minimum amount to transfer or burn, and this minimum amount could be based on your current principal balance or something like that. Um, but, I'm going to leave it as is. You could also do something like have a deposited struct where you keep track of the interest rate and the deposit time for an individual deposit of tokens. Um, however, this is going If I did implement that, that would make the cross-chain aspect very, very challenging. Don't worry if none of that makes sense to you. I just wanted to highlight those two issues just to say that this is a demo project. This is not something that you should be using in production. This is not production ready code. It absolutely has not been audited. It is purely for demonstrative purposes to show you what a rebased token is, and what it looks like. Usually, the interest is not going to be linear, it's going to be compound, and in order to do that we would have to use things like Taylor expansions and binomial expansions, which are very confusing and difficult, um, to grasp. So, initially, we are just implementing a rebased token that uses linear interest for simplicity. And, then, the other thing that we get to learn is how to do cross-chain transfers, and how to make our tokens available for CCIP, so we can use the cross what's called the cross-chain token standard by Chainlink to enable our tokens for CCIP without having to wait for Chainlink to sign on the line and be like yep, we approve this. There's no central control. You can do it completely permissionlessly whilst keeping control of your pool contract and your token contract. So, with that said, before we get started with actually implementing the contracts and all of the scripts, and everything like that needed to make our token work cross-chain, I am going to give you a very brief introduction to what bridging is. I know I've mentioned this term a few times throughout this section so far. So, what does that actually mean? And, what does it mean to send your tokens cross-chain? And, basically just everything you need to know about cross-chain. And, then, also, the second thing we will learn is a little bit about CCIP. What is CCIP? What is Chainlink CCIP? What can it be used for? Why is it so amazing? And, how to use it very briefly. And then the third thing is the cross-chain token standard, which is the standard, which helps you build cross-chain tokens, using CCIP, in a completely permissionless way. So, passing over to Kira to have some slightly more fun videos to explain those concepts now. 
