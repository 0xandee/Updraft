The final thing that we need to do is we need to configure the token pools before we mint tokens and then transfer them cross-chain. So to configure the token pool, we need to call applyChainUpdates and this is a function that is inside the token pool which we are inheriting by the re-base token pool. And this takes two constructor arguments U int 256, which is the remote chain selectors to remove. So if you've previously added any chains, then you would need to populate this with the chain selectors that you want to remove and then a chain updates array which is the configuration for any chains that you want to enable. And enabling a chain basically means I am allowing tokens to be received and also sent to this chain from this chain from the chain that I am currently working on. So for instance, from my Sepolia pool, I could enable ZkSync, or I could enable Arbitrum. And I would enable to be able to receive tokens from that chain and also send tokens to that chain, by adding that chain to this chain updates array. So we need to call applyChainUpdates on our token pools. So to do that, we are going to create a little function called configureTokenPool. And we are going to make this so that it can be called to configure the pool for either Sepolia or Arbitrum, which means that we need to define some new terminology which is local and remote. And local just means we are talking about the chain that we are currently on. So if I'm on Sepolia and I am going to enable Arbitrum, then the local is referring to Sepolia and remote is referring to Arbitrum. If I am working from the Arbitrum pool, then Arbitrum would be the local, and then Sepolia would become remote. So the first thing that we need to do is make sure that we are working on the correct fork by using vm.selectFork cheat code. And then we need to pass in a fork and because we are not hard coding this, we do need to pass it in as a an argument to the function. And then, the second thing we need to do is we need to prank that we are the owner using start prank cheat code. Actually, we can we can just use vm.prank to prank the next line because we are only we are only going to be calling one function. Then, we need to pass in the local pool. So we can pass it as an address local pool because we want to be calling local pool local pool.applyChainUpdates like this. And to be able to call applyChainUpdates, we need to make sure this is of type token pool. So, we need to import TokenPool from ccip contracts src v0.8 ccip pools TokenPool. So import TokenPool from ccip contracts src v0.8 ccip pools TokenPool.  So, remember, the first argument is a U int 256 array of the chains that we want to be removing, which is not going to be anything. So new U int 64 sorry array, and we want no elements in it. So, that's fine. And then, we need the second argument to be this chain to add. So, we need to make this and this needs to be of type chain update which we are going to need to get from the token pool. So we need to create that array. So, we've got TokenPool.chain chain update and this is going to be an array which we are going to set in memory chains to add equals new TokenPool.chain update with one element. And then, we can have the first element chains to add to add zero equals TokenPool. chain update which is the struct chain update. And then, we can use the curly braces and we are going to do named named members of the struct. So let's go into the struct. And then we will just copy this over to this this. And if we highlight this then, let's just comment that out by selecting all and then do using command / and then we can see that the first element is U int 64 remote chain selector. This is the chain selector for the chain that we want to enable. So, we are going to pass in as an argument to the function U int 64 remote chain selector. And then, let's pass that through to the struct. So, remote chain selector is colon remote chain selector. The second argument is remote pool addresses, which is a bytes array. So, this means we need to ABI encode the remote pool address and then add it to a bytes array. So let's make that little bytes array now. So, bytes array in memory remote pool addresses equals new bytes with one element in. And then, we are going to set the first element to be remote pool remote pool addresses and the first element at index zero is equal to ABI.encode. And then, we are going to need to encode the remote pool. So we need to pass it here. address remote pool. And then, we can pass this remote pool addresses in to our struct. Remote pool addresses remote pool addresses. Then, we need the remote token address, so let's pass that in as an argument. Address token remote token address. So, then we need to ABI encode it, remember. So remote token remote token address colon ABI.encode remote token address. Then, we've got these two structs inside of our struct. Outbound rate limiter config and inbound rate limiter config which is in defined inside the library rate limiter. So we need to import that library from ccip. So import rate limiter from ccip contracts src v0.8 ccip libraries rate limiter. And let's go inside here. And you'll see we have this config struct which is what the type is going to be. And it's got this bool is enabled, and this is defining whether we are enabling rate limiting, which we are not going to, so this is going to be false. And then we have the capacity which is like, as we were saying in the video before the the complete bucket, how many in total tokens are able to be sent cross-chain. And then, the refill rate. So, how many tokens per second is this capacity filled back up. So going back inside of our test, we can then create these config objects, so rate limiter.config, and again, some parentheses curly braces, and then we have is enabled we are going to set to false. And then, we've got capacity zero rate zero because we are not allowing rate limiting. Awesome. So, now we've created this function that enables us to configure our token pool. Now, before we stop this prank of the owner, we need to and after we have deployed all of the tokens, both tokens and both token pools we need to configure both of the token pools, because remember we are going to be using those remote pools and the remote pool addresses. So, we need to make sure all of them have already been deployed. So, we can call configure configureTokenPool the fork initially, we are going to use the Sepolia fork. And remember, we are already doing I'm going to check correctly select fork down here. So we don't need to worry about what fork we're on. The local pool is going to be the Sepolia pool. The remote chain selector is going to be the Arbitrum Sepolia network details. chain selector. Then the remote pool is going to be the arbSepolia pool. And we need to make sure we cast this to an address. And we also need to do that to the Sepolia pool, because the pools are of type rebaseTokenPool. And then, the re-base token the remote token address is going to be the arbSepolia token which again we need to cast to an address. Then, we need to do that whole thing again but the other way around. So, we need arbSepolia and then everywhere that we have and then here we need the arbSepolia pool. arbSepolia pool. Then here we need Sepolia Sepolia Sepolia. And we have successfully configured our pools. Let's just check that this all builds nicely. So, run forge build. And, it ran successfully. Now, let's create a function to send a cross-chain message before we start actually creating our tests. 