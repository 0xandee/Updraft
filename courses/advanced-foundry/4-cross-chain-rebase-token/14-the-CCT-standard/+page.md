## The CCT Standard

CCIP v1.5 introduces the cross-chain token standard or CCT standard. In this video, we are going to dive into CCIP v1.5 and what this means for you developers out there and how you can use it. In the world of blockchain technology, the ability to transfer assets and tokens cross-chain has become a crucial capability. And as DeFi is maturing, there is an increasing need for interoperability and sharing of liquidity across chains. CCIP offers a decentralized solution. And the CCT standard, or cross-chain token standard, enables developers to seamlessly and easily integrate their tokens with CCIP in a permissionless manner. Allowing them to keep complete custody and control of their tokens and their token pools. There are two main reasons the CCT standard was developed. The first being liquidity fragmentation where assets were siloed to certain blockchains making it difficult for users and liquidity providers to access that liquidity across different ecosystems. Token developers had to make a decision. Do you deploy your token on the blockchain with the most liquidity where there are the most people, or do you deploy your token on the newest chain? Each decision had positives and negatives. By using CCIP and due to the CCT standard, you can now deploy your tokens on both chains and share liquidity cross-chain. The second reason is greater autonomy for the token developers. Usually, there is a need for third-party support in order to have your token integrated cross-chain. You'd have to collaborate with CCIP or another cross-chain interoperability protocol like Wormhole to get your token added. However, now the developer has complete control. They can integrate their token with CCIP without having permission from a third party. Due to the fact that the CCT standard allows you to integrate with Chainlink CCIP, it means that you are using the Chainlink decentralized oracle network to send your messages and tokens and data cross-chain. And Chainlink CCIP has defense in depth security where details of this security benefit are detailed in the Chainlink docs for you to read at your own leisure and include things like a risk management network, configurable transfer rate limits. With the CCT standard, it also enables you to set your own custom rate limits on the source and destination chain for each chain. For instance, if I am on Ethereum, I can enable different rate limits from zkSync or Arbitrum or Polygon, et cetera. And all this amounts to increase security for your cross-chain needs. The CCT standard also enables programmable token transfers, allowing you to specify certain actions to be performed when token transfers occur. This means that you can do a simultaneous token transfer and a message in a single transaction. This enables complex use cases such as rebased tokens or fee-on-transfer tokens to be enabled for cross-chain. The CCT standard does not require fragmented liquidity pools to be provided on all chains. Instead, the token pools on either side require a locking or burning mechanism on one side and an unlocking or minting mechanism on the other side. Existing ERC20s can also be extended to have cross-chain functionality using the CCT standard. To give you a quick architectural overview of how this works. You simply need to have a token contract deployed on every chain that you want to enable. You also need to have a token pool for each of these token contracts. So on every single chain, you have both a token contract and a token pool contract. The token contract has all of your ERC20 functionality logic inside as usual. In the token pool contract, there is all of the logic for sending cross-chain. So whatever mechanism you are using either lock and unlock or mint and burn or a combination of the two. This is where that logic is stored. And it needs to inherit from the Chainlink token pool contract. These token pool contracts are responsible for executing the cross-chain token transfers. Handling the logic of burning, minting, locking, unlocking. And Chainlink provides a set of standard token pool contracts such as Burn/Mint Token Pool, Lock/Release Token Pool, which can be deployed by yourselves, the token developers. Secondly, there is the token admin registry. This contract is like a central registry allowing you to self-register your token and associated with its token pool. And finally, the registry module owner custom which assigns the token administrators meaning that the token deployer or whoever you want as your token admin can be authorized to manage these cross-chain operations. Let's do a very quick demo of how to create your own cross-chain token and register it for CCIP using the cross-chain token standard. Let's do it now! Let's very quickly show you how to enable a token for CCIP using the cross-chain token standard. So if we head over to the Chainlink documentation and then down to guides and then cross-chain token standard you'll see an in-depth tutorial of how to enable your token for cross-chain transfers. So we are going to head to register from an EOA and then we are going to select foundry burn and mint because we are going to create a burn and mint token pool. Now the contracts for this are all written by Chainlink themselves. They have written the ERC20 token, and they have also written the burn and mint token pool. And they are actually ready for you to use. They have created a burn/mint ERC677 token. And we are going to be deploying this token on Sepolia and Arbitrum Sepolia. And then we are going to be deploying token pools on Sepolia and Arbitrum Sepolia. Then we are going to be doing the CCIP setup, which is detailed in this guide. If you would like to come back to it and understand a bit more about what we are doing, I am going to run through things quite quickly. So let's get started. Now the first thing we are going to do is clone this repo which is in the Cyfrin organization, called CCIP CCT starter. And this is adapted from the Chainlink examples repo which is inside of the smart contract examples repo /CCIP/CCT/foundry. But I have gone ahead and just simplified it a little bit and changed some of the commands so that we are using the keystore rather than ENV and I have modified the README so that you know what the steps are that we are going to be taking. So let's clone this repo. We can run ```bash
git clone
``` And then paste in at the Github URL. Let's navigate inside this repo and then open it up in our code editor. Now, the majority of the code that we are going to be working with is in this scripts folder, which has all of the scripts in order to do all of the things that we need to do such as setting CCIP admins deploying the tokens deploying the pools setting limits, minting tokens, and transferring them cross-chain. Now, I just want to very quickly show you this Burn/Mint ERC677 with CCIP Admin contract. Now we have the option to set this CCIP Admin because when we are enabling tokens with a CCT standard, we need a CCIP Admin. And there are two ways to do this. You can implement this set CCIP Admin and get CCIP Admin functions, so that you are compatible with this I GetCCIP Admin interface, or you can use an Ownable function and make your contract Ownable. For instance using OpenZeppelin's Ownable smart contract. The way that we are going to be doing it is with the Ownable version. So, whatever address deploys the smart contract is going to be the owner, which we are going to set as the CCIP Admin. Now, the first thing we need to do is run ```bash
forge install
``` to install the dependencies. Now, we can run ```bash
forge build
``` to check that everything compiles correctly. Now, we are going to clear, so we can start with the tutorial. So, the first thing is we have this config file, which has all of the settings for your cross-chain token. So you can have a name, a symbol of whatever you choose, you can have custom token decimals, custom maximum supply, CCIP admin address which we have set to the zero address, which is fine, because we are going to be using the Ownable version. As we have set this to false, we've got the amount to mint and the amount to transfer, the fee type, which is LINK. And then, here we have the remote chains, which is saying that on this chain with this chain ID, we are allowing this chain And, on this chain with this ID we are allowing cross-chain transfers from this chain. So, in this instance, on the Sepolia pool we are enabling Arbitrum Sepolia. And on the Arbitrum Sepolia pool, we are enabling Sepolia. There is a description of all of these options, which you can modify. And then the final bit of setup we need to do is setup our environment variables. So in this .env.example rename this to just .env. And then add in a Sepolia RPC URL, and Arbitrum Sepolia RPC URL, which you can get from a provider such as Alchemy. You can also add in your Etherscan API key and Arbiscan API key if you want to have your contracts verified, which I recommend you do so. But, for simplicity, I am not going to be doing this. Once you have added in those environment variables, you need to run ```bash
source .env
``` to load the variables into your environment. And then, we can continue with the tutorial. So, the first thing we need to do is deploy the token contracts, first on Sepolia and then on Arbitrum Sepolia. In this script, we deploy the token pool and then we grant the mint and burn role for the token pool, on the token to allow them to mint and burn those tokens. So we can copy this command, paste it into our terminal. You'll need to add in your sender address and your keystore name. So we have now deployed our token on Sepolia by running the deploy token script. This script also saves the address to an output file in order to be able to read it. As you can see here, we've got the address which we deployed the token to. We granted the mint and burn role to ourselves, and we wrote the token address to the file /scripts/output/deployedToken in Ethereum Sepolia. So then when we deploy our token pool, it knows what the address is on Sepolia as well. So, let's do that again, but now on Arbitrum Sepolia. So, we can copy this command and then put in our address again and then the name of our account. We are going to be doing this a lot. I am not going to say this every time I modify it, but every single command, I am going to be modifying the account and then the sender address. So, we've now deployed our tokens on both Arbitrum and Sepolia. Let's deploy our Burn and Mint token pools, first on Sepolia And then, on Arbitrum Sepolia. Now, we need to claim the CCIP admin role. To claim the admin role, we are using Ownable as we have this owner function. So, we need to call the registry contract, which is the RegistryModuleOwnerCustom contract and call register admin via owner. If we had a CCIP Admin instead, we'd be calling register admin via get CCIP Admin and then in both instances, we pass the token address. Let's run the command to run this script, first on Sepolia and then on Arbitrum Sepolia. Then, we need to accept the CCIP admin role. In the accept admin role script, we call the token admin registry and the function we call is accept admin role, which again takes the token address. Let's run the command to run this script first on Sepolia and then on Arbitrum Sepolia. Then, we need to link the token pools with the associated token. In this set pool contract, we again call the token admin registry and we call the function set pool, which takes the token address and the pool address to link the token with the pool. First on Sepolia And then, on Arbitrum Sepolia. Then, we need to add the remote chain to the token pool to enable us to be able to send a cross-chain transfer. In this apply chain updates script, we first create a chain updates object, which is of type pool.chainUpdate, which takes the remote chain selector, the remote pool address, the remote token address, an outbound rate limit config for you to be able to set the capacity and rate for the outbound lane. And then an inbound rate limit config for the inbound lane. We then call the pool contract, and the function is apply chain updates, with any chain selectors that we want to remove which if we're adding chains will be just an empty array and then the chain updates object. So let's add the remote chain by running the apply chain updates script on Sepolia. Of course. Then on Arbitrum Sepolia. Then, we need to mint ourselves some tokens. This mint tokens script, purely just calls mint, on the token contract. Let's run the mint script on Sepolia. Then, we need to send our tokens from Sepolia to Arbitrum. This transfer tokens scripts sends a cross-chain message. It does this by creating this Client.EM2AnyMessage struct, called message, which has the receiver, any data you want to send cross-chains, the token and token amounts, the fee token that you would like to use either LINK or native and any extra arguments like a custom gas fee. We then approve the router to be able to spend our tokens. We also approve the router to be able to spend the fees. And then we call CCIP send on the router contract, by passing the destination chain selector and our message struct. So, let's run this transfer tokens script to send our tokens cross-chain. Then, we can grab the transaction hash, and head over to the CCIP explorer. Paste it in the explorer, then we see have an overview of our cross-chain transfer. We can see the source transaction hash, the status which is waiting for finality, the source chain which is Sepolia, and the destination, which is Arbitrum Sepolia. So, we'll have to wait for our cross-chain transfer to happen, while we wait for finality. But, we can also see the origin, who is it from, who is it going to and the amount of tokens. And as you can see, it has now succeeded. So we have successfully bridged our tokens or cross-chain transferred our tokens from Sepolia to Arbitrum Sepolia. Which means that we have also successfully created a cross-chain token enabled for CCIP using the CCT standard, which is super cool. And, as you can see it's really easy to do. So I encourage you to go and build your own tokens, and enable them for CCIP. And that's exactly how you can make your own token cross-chain! Amazing! Thank you so much for watching and I'll see you in the next one. Goodbye! 
