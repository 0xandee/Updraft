## Running Scripts on Testnet

We can go to the Chainlink faucet and head over to the Link tab on the right-hand side. Then we can select Ethereum Sepolia and zkSync Sepolia. Click Continue, then Get Tokens to get our testnet tokens.

Now we can run our script. Let's go ahead and deploy on a testnet. Given that we've done fork tests, we can be pretty certain things will work as intended, especially if we integrated our scripts into our tests. However, as of recording, scripts do not work on zkSync for the same reason we can't really do fork tests on zkSync very well. That's because cheat codes don't work very well and there aren't actually that many cheat codes for foundry zkSync. There is a limited number, and `vm.broadcast` is one of those that doesn't really work.

So, what I've done is I've created this `bridge-to-zkSync` script. What you'll need to do is modify this to add in a variable called `zkSyncSepoliaRPCURL`, and then you'll need another one called `SepoliaRPCURL`. We can just copy this file over, then in the root of our projects we can create a new file called `bridge-to-zkSync.sh`. `.sh` is the file extension for a bash script. So what we need to do is make sure that this file is running `source.env`. It is, so we can now put in a `.env` file, and in here remember we are not placing our private keys. Please don't do that because we're going to be using instead an imported wallet, a key store to send all of our transactions and deploy all of our contracts. But instead, we need a `zkSyncSepoliaRPCURL` equals colon quote quote, and then we also need a `SepoliaURL` equals. Then I'm going to copy those over. By the way, the one from Alchemy isn't working correctly for some reason whenever I get an RPCURL from Alchemy, it doesn't work. This is the one that zkSync themselves provide, so I recommend you use exactly this one. Then I'm going to go paste in my `SepoliaRPCURL`.

So, in here after you have made your `.env`, let's just walk through very quickly what's going to happen. So we've got `source.env`, which just loads in our environment variables. We've got `forge build --zkSync` to make sure that everything is built ready to deploy on zkSync. We then have some echo lines just to make sure that when we're in the terminal we know what is happening, and then we deploy our rebase token on zkSync using a `forge create` command. Here, we also use the `--legacy` and `--zkSync` flags because that's what you need to do when you're deploying to zkSync. Then, we deploy our zkSync pool address. We then set our permissions for the pool address, which is granting them a mint and burn role, and we do that using `cast send`, and then, we can call `grantMintAndBurnRole` and pass through that zkSync pool address. Then, we set the CCIP admin roles and set the pool by using `cast send` again, and then just passing through those function signatures with the parameters that aren't required. Then, we go over to Sepolia and we can use our script using `forge script` now to deploy the token and pool. Now, because I was having some issues with transaction ordering, I split things up a little bit more granularly. So, after we've deployed the token and the pool, we run two more scripts, which is those set permissions scripts. One of them is `setAdmin`, and then, the other function is `grantRole` to grant the role for the mint and burn role for the pool, and then, also to grant the admin role and set the pool for CCIP. Then, we deploy the vault on Sepolia. We then configure the pool on Sepolia because remember in our tests we need to configure the pool to be able to send cross-chain to zkSync. We then deposit some funds into the vault on Sepolia, and we'll be able to see our balance of rebase tokens increase on our Metamask. However, because we're sending a very, very tiny amount, it actually won't be very visible on Metamask. Then, we configure the pool on zkSync because now we have the pool and the rebase contract on Sepolia. Then, finally, we bridge to zkSync. We get our balance before bridging. We then use the script by running `forge script` to bridge the tokens over to zkSync, and as you can see, this is a very long command, like the `cast send` to apply the chain updates. It's very, very long, um so I wasn't going to put you through the pain of writing those commands. Then, afterwards, we check our Sepolia balance after, and then, we're actually going to use the CCIP block scanner to see our CCIP message go through. Now, I can open up my terminal. Let's just clear that. Oops, run `clear`. 

Let's make our file executable by running:
```bash
chmod +x ./bridge-to-zkSync.sh
```

Then we can run it with:
```bash
./bridge-to-zkSync.sh
```

Before I run that, actually, I just wanted to say that in here I have used `--account updraft` to use the key store with the account name updraft. In this updraft account, I've stored a private key, so you will need to do your `cast wallet import --interactive` and give your key store a name and all of that that we've done previously, or have done previously with Patrick in another lesson, and you will need to save one inside updraft. Or, you will need to go through this script and manually change all everywhere I said updraft to the name of your key store. The first thing I need to do, and I could actually just put this in the script, which would be `foundry up --zkSync`. Now, because if you've run this a couple of times you probably don't want to be doing that, but even still I'm probably going to add that in right now just to make sure that we are on the zkSync version of foundry because we're going to need the `--zkSync` to make sure that we can build for zkSync as you'll see here, `--zkSync`, and also whenever we are deploying to zkSync remember we need this `--legacy` flag. At the moment of recording, again, as Patrick said, if you're doing this at a different time you might not need the `--legacy` flag. I would just check the zkSync documentation to see whether you still need that. So it's now compiling with zkSolc and zkSyncSolc v0.8.24 because it installed foundry zkSync. Now, we've got this warning which was the same warning as before. It doesn't matter because that's just in our test. Compiling and deploying the rebase token on zkSync, okay, and then, I need to type in my password. There's going to be a lot of typing in the password, so I'm not going to say that every single time, but every time I send a transaction or deploy a contract or anything, I'm going to have to type in my password. So we have now deployed the rebase token to this address, and I'm actually going to copy that address. 

Anyway, so now we need to deploy the pool contract on zkSync. Now we need to set those permissions on zkSync. So there's going to be a couple of times to type in your password here because we need to give them the roles. So, we can see that that transaction went through, and then, we need to set the CCIP admin, and then, we need to accept the CCIP admin after we set it. And then, finally, we need to set the pool contract associated with the token contract. Then, we're going to deploy the contracts on Sepolia. So, first of all, the token and the pool because we're going to be using the script. Now, I have actually got this error a couple of times where it says `server returned an error response error code blah, blah, blah future transaction tries to replace pending`, and I was under the impression it was because the fees were very, very high. Now, if I just check very quickly what are the current fees? It's 15 gwei. So don't think it's because of that. So, instead, what I'm going to do is inside `deployer`, if we just close out this quickly, what I'm going to do is I'm going to move out these function calls into a new contract, into a new script. So I'm going to make `contractSetPermissions`, or something like this, a script, like this. Then I'm going to make a function `run`. I don't know what it's going to need yet, but it's certainly going to need the `token`, which is going to be public, and then, also we're going to need the CCIP local simulator fork so we can get the network details. Again, this just means that we're splitting up deploying and then, um, configuring the configuration. We're going to need that `vm.startbroadcast`. I'm also going to do that after I do the CCIP local simulator fork stuff. So before we do the token configuration, then we need that `vm.stopbroadcast`. Then, please format for me, which it's not, which is really annoying, uh, and then we need `vm.stopbroadcast vm.startbroadcast`. We need the `token`. So, this is going to be uh an address token and then, we also need an address pool. Then we need that's it, I think, because we do the vault deployment and configuration separately. So, in my `bridge-to-zkSync` script, I will have modified this already, um, to account for the fact that we changed that in the script. So, inside your `bridge-to-zkSync`, that will already be a separate step, so don't worry. And also, remember I just remember this. We need to cast the token to the `IRebaseToken` so that we can access this function, `grantMintAndBurnRole`. So, I'm going to run this script again, and get to the same point that we were just at, where we were just deploying the token on Sepolia. So, actually, I've split this up a tiny bit more granularly. I just put `grantRole` into its own function, then, made that `run` function into a `setAdmin`. Sorry, that's a little bit confusing, using but I'm just trying to make sure that we don't run into that problem where Sepolia is running a bit slow, so we get that problem where some transactions are trying to be broadcast before others. So, if you have that problem, just try and split up your script into two separate small functions. It's still better to do this, because at least you've written it in, rather than writing um a command in your command line, which you are subject to errors, and you can test your scripts. So, I've made a `grantRole` function, which is public, takes the `token`, and the `pool`, and just calls on the `IRebaseToken grantMintAndBurnRole`. And, I've just done a broadcast, because I didn't need the CCIP local simulator fork in, at that instance, but I did need it to set the admin and set the pool. So, that is what our contract, or script, is going to look like, for setting permissions, rather than putting it inside this token and pool deployer script. 

Okay. It's running the scripts to deploy the contracts on Sepolia now. So, now we can send the permissions and the CCIP admin on Sepolia. So, this will be two transactions, one to grant the CCIP admin, and then, the other to grant the burn and mint role. If I had them all together, for some reason it would just throw an error. I don't know if this is a Sepolia thing, but it was saying that the transactions were being replaced. I don't even know. So, I just made it a little bit more granular in the script, as we did just a second ago. So now we can deploy the vault on Sepolia. Transactions are taking a while to go through on Sepolia, at the moment, so I think that that could be why. Then, if we look inside of our script, after we've deployed, then we are configuring the pool on Sepolia, as it says here. Then, we need to deposit funds to the vault on Sepolia in order to be able to bridge them cross-chain. And actually, if we scroll up back to when we deployed the token and pool contracts, if we import our token, we paste in the contract address, it'll see that we've got this. It's recognized that the symbol is RBT for Rebase Token. It's 18 decimals. We can click Next, and you can see that we have a very, very tiny balance of rebase tokens now. So we can import that. It'll say zero in your Metamask, just because we've got such a tiny tiny tiny amount of it. If you have more then you would actually be able to see your balance slowly slowly increase over time. 

But what we need to do now is configure our pool on zkSync so that we can send our tokens cross-chain. And the reason we had to wait to do this, rather than doing it before we did all the deployments, is because we actually needed the pool and token addresses on Sepolia to be able to enable Sepolia on zkSync. Then, finally, we can bridge the funds using our bridging script to zkSync. So, first of all, we'll get our initial balance, which you can see we have now got a balance of Rebase tokens. And, we've actually accrued a little bit of interest because some time has passed. Now, we need to run the script to bridge our tokens to zkSync, and we need to put our password in again because we actually need the receiver address. This is going to be the same address on zkSync. You need to make sure that you have the same address on Sepolia and zkSync. And, if you want to send to a different address then you'll need to modify this script. So, here we'll say `forge script`. Then, in here rather than having for this first argument `cast wallet address --account updraft`, you'll have `--account` whatever account address you have on zkSync. So, now what we want to do, now that we've sent that transaction to send our tokens cross-chain, we need to copy this Sepolia transaction hash, hash, this bottom one. Then, what we're going to do is we're going to head over to the CCIP Explorer. You can find that at `ccip.chain.link`. You can just paste in that CCIP Explorer address and you can see that we've now initiated this CCIP cross-chain transfer, and we need to wait for finality. This will take approximately 20 minutes to bridge from zkSync to Sepolia. So you can see we have in fact bridged across almost a half a balance of Rebase tokens, um, but because we've accrued a little bit of interest we will actually have still a little bit of Rebase tokens on Sepolia. And you can see these fees, we actually spent a little bit of Link to be able to bridge our tokens cross-chain. And I will come back right after I have waited for finality to see if this cross-chain transfer did in fact succeed. 
