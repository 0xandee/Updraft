## Building a Rebase Token: Project Setup and Core Design

This lesson guides you through the initial setup and conceptual design of a rebase token smart contract. While the ultimate goal might be a cross-chain token using Chainlink CCIP, we'll start by focusing on building the core logic on a single chain using the Foundry development framework. This approach simplifies the learning process, allowing us to tackle the rebase mechanics first before introducing cross-chain complexities. We'll set up our development environment and meticulously plan the token's behavior within our project's `README.md`.

## Setting Up Your Foundry Project

First, we need to prepare our development environment using Foundry and VS Code.

1.  **Create Project Directory:** Open your terminal and create a new directory for the project:
    ```bash
    mkdir ccip-rebase-token
    ```
2.  **Navigate into Directory:** Change into the newly created directory:
    ```bash
    cd ccip-rebase-token
    ```
3.  **Initialize Foundry Project:** Initialize a new Foundry project. This command sets up the standard project structure (`lib`, `script`, `src`, `test`, `foundry.toml`, `.gitignore`, `README.md`) and installs the necessary `forge-std` library.
    ```bash
    forge init
    ```
4.  **Open in VS Code:** Open the project folder in your code editor:
    ```bash
    code .
    ```
5.  **Clean Up Default Files:** To start with a clean slate, delete the example files generated by `forge init`:
    *   `src/Counter.sol`
    *   `script/Counter.s.sol`
    *   `test/Counter.t.sol`
6.  **Clear README:** Open the `README.md` file and clear its default content. We will use this file to outline our contract design.

With the basic Foundry project structure in place and cleaned up, we can now focus on designing the core mechanics of our rebase token.

## Designing the Rebase Token Mechanics

We'll outline the design within our `README.md` file. This serves as our specification before writing any Solidity code.

**1. Protocol Overview**

The system will consist of two main components:

*   **`Vault` Contract:** Users will deposit an underlying asset (e.g., ETH or an ERC20 token like WETH) into this contract.
*   **`Rebase Token` Contract:** In return for depositing assets into the Vault, users will receive an equivalent amount of Rebase Tokens. These tokens represent the user's proportional share of the total underlying assets held within the Vault.

**2. Rebase Token Mechanics**

The core functionality revolves around how the token balance changes over time due to accrued interest.

*   **Dynamic `balanceOf` Function:** The standard `balanceOf(address user)` function will not simply return a stored numerical balance. Instead, it will dynamically calculate the user's current token balance on the fly. This calculation will factor in their initial deposit (or current base balance) and the interest that has accrued linearly over time according to their specific interest rate.

*   **Lazy Minting / State Synchronization:**
    *   **The Challenge:** Since `balanceOf` is a `view` function (read-only), it cannot modify the blockchain's state. This means it cannot mint new tokens to represent accrued interest when someone simply checks their balance. Reading balances should remain a gas-free off-chain operation.
    *   **The Solution:** We'll implement a "lazy minting" mechanism. The actual minting of tokens corresponding to the accrued interest will be deferred. The contract's internal state (the user's stored token balance) will only be updated when the user initiates a transaction that *already* requires modifying the state.
    *   **Triggering Actions:** State synchronization (minting accrued interest) will occur immediately *before* executing actions such as:
        *   Minting more tokens (depositing more underlying assets).
        *   Burning tokens (withdrawing underlying assets).
        *   Transferring tokens to another address.
        *   Bridging tokens (relevant for future cross-chain functionality).
    *   **The Process:** When a user triggers one of these actions, the contract will first calculate the interest accrued since their last state-changing interaction. It will then mint these accrued tokens, updating the user's stored balance. *Only then* will the originally requested action (mint, burn, transfer, etc.) proceed using the newly updated balance.
    *   **The Outcome:** This ensures that the `balanceOf` function *always* returns the theoretically correct, up-to-date balance (including unminted accrued interest), while the computationally and gas-expensive state update (minting) only happens when necessary during other transactions.

**3. Interest Rate Model: Rewarding Early Adopters**

To incentivize early participation, we'll implement a specific interest rate model:

*   **`globalInterestRate`:** The Rebase Token contract will store a global interest rate. This rate can be set and managed by an authorized `owner` address.
*   **`userInterestRate`:** When a user makes their initial deposit (or any subsequent deposit), the contract records the *current* `globalInterestRate` and locks it in as that specific user's `userInterestRate`.
*   **Decreasing Global Rate:** The contract `owner` has the ability to update the `globalInterestRate`, but crucially, they can *only decrease* it. Increases are not permitted.
*   **Incentive Mechanism:** Because the `globalInterestRate` can only decrease over time, users who deposit earlier lock in a higher `userInterestRate` for the lifetime of that deposit portion. Later depositors might receive a lower rate if the owner has decreased the global rate in the meantime. This directly rewards early adopters with a higher rate of return.
    *   *Note:* If a user deposits multiple times, each deposit might lock in a different rate based on the `globalInterestRate` at the time of each deposit. The overall interest calculation would need to account for this (though for simplicity, initial implementations might update the user's *entire* rate upon a new deposit to the current global rate).
*   **Source of Interest (Simplification):** In a real-world scenario, the "interest" might be generated from underlying yield strategies (like staking, lending). However, for this initial implementation, the interest accrual primarily serves as a tokenomic mechanism to drive adoption and reward early users, rather than reflecting external yield generation.

## Understanding the Interest Rate Lock-In

Let's walk through an example scenario to clarify how the interest rate model rewards early participants:

1.  **Initial State:** The `globalInterestRate` in the Rebase Token contract is set to `0.05` (representing 5%).
2.  **User 1 Deposit:** Alice deposits ETH into the Vault. The Vault instructs the Rebase Token contract to mint tokens for Alice. At this moment, Alice's `userInterestRate` is set and locked to `0.05`. Her balance will now start accruing interest at this 5% rate.
3.  **Rate Decrease:** The contract `owner` decides to reduce the incentive and calls a function on the Rebase Token contract to decrease the `globalInterestRate` to `0.04` (4%).
4.  **User 2 Deposit:** Bob deposits ETH into the Vault. The Vault interacts with the Rebase Token contract. At this moment, the *current* `globalInterestRate` is `0.04`. Bob's `userInterestRate` is set and locked to `0.04`. His balance will accrue interest at this 4% rate.
5.  **Outcome:** Alice continues to accrue interest at her locked-in rate of `0.05`, while Bob accrues interest at his locked-in rate of `0.04`. If the owner later decreases the `globalInterestRate` further (e.g., to 0.02), both Alice's and Bob's rates remain unchanged at 0.05 and 0.04, respectively. This demonstrates how the system inherently rewards earlier depositors.

## Next Steps

With the project environment set up and the core design principles for our rebase token, vault interaction, lazy minting, and interest rate model clearly defined, the next logical step is to begin implementing the `Rebase Token` smart contract in Solidity based on this plan.