##  Minting Interest and Burn Functions

Okay, before we go on and create our burn and transfer functions, let's finish _mintAccruedInterest_ which is the internal function that we were creating that mints any interest that has accrued since the last time they performed some action, like minting, burning, bridging, later or transferring. Which when they do that is actually going to mint them the tokens, and this is the function that is going to be called. Any interest that has accrued since the last time that their actual balance, their principle balance of minted tokens was updated is going to be minted in this function. We walked through how we were going to do that. We are first going to find their principle balance, how many tokens have actually been minted to them. Then, we were going to calculate their current balance, so how many tokens do they actually have, including any interest that has accrued since this principle balance was last updated, the last time this internal function was called. Then, we are going to calculate the number of tokens that are left that need to be minted, which is going to be the difference between these two. The amount of tokens that are currently minted, the total amount of tokens that they need, minus the amount that they currently have, will be the number of tokens that need to be minted. Then, we will call the internal _mint_ function to mint those extra tokens to the user, and set the user's last updated time stamp. So, first thing we need to do is find the principle balance, which is going to be the same as before, so we've got _uint256_ previous principle balance. So, before they call this function, what is their balance? And, it's going to be, thanks copilot, Super, so the implementation on the contract that we are inheriting, ERC20 from open Zeppelin . _balanceOf_. So, how many tokens have actually been minted to them in the balances mapping that we were looking at earlier. Then, we need to calculate their current balance, which is going to be a _uint256_ again, their current balance, and then we are going to use the _balanceOf_ function that we implemented earlier on this smart contract of the user, which is going to account for any interest that has accumulated. Then, we can calculate the interest that has been accrued, or the amount that their principle balance, the actual number of tokens, needs to increase by. So, _uint256_ balance increase, because it's not the total amount of interest that is accrued since the time of depositing into the protocol, it's just the amount that has accrued since the last time they performed an action. So, that could include redeeming / burning, transferring or transferring cross-chain, like we were saying. That is going to be equal to the difference between the two, so current balance - previous balance. Then, we update the user's last updated time stamp to the current time because this is when their balance was last updated. Oh, this needs to be _previousPrincipleBalance_. Like that. And then, find Oh, we actually want to do this after we set their last updated time stamp because we want to do any checks effects, and then our interactions, so effectively We haven't really got any checks, but this is our effects, and then we've got the interactions which is going to be _mint_ and we are going to mint to the user the amount that their balance has increased since the last time they did something. Since the last time they properly sent a transaction to interact with the protocol. Amazing. Now, _mintAccruedInterest_ has been implemented, and where have we used it currently? We have used it in our _mint_ function to check whether they currently, before we mint them any tokens, have any interest that has accumulated on any existing deposits. We can mint that to them so that then we can set their interest rate again. So, if there were, was any deposit that was in here, then, we will use their previous interest rate in here, and then we will set their interest rate afterwards, because they are doing another deposit, and that is the only time this will be called, and then we mint them the tokens. Now, you will notice here that if they already had an interest rate from a previous deposit, and since interest rate in the smart contract is what's being set here, if this is decreased, which is the only thing it can do, it can only decrease, then, if you deposit again and this _mint_ is called then, the interest rate of the user is going to decrease. This is fine, and the expected behavior, because effectively, we want to avoid people depositing a very very tiny amount to get the highest interest rate and then, later doing a massive deposit at a much later date and reaping the rewards of their first initial, tiny, tiny deposit. We want to incentivize people to deposit as much as possible, as early as possible. The next function that we want to create I'm just going to double check we didn't add a comment here. So, we're going to add some _natspec_ in here. Oops. At notice. _mint_ the accrued interest to the user, since the last time they interacted with the protocol (e.g. burn, mint, transfer). It takes one parameter which is the user, to _mint_ the accrued interest to, and it doesn't return anything, so we can just leave it as is. Now, the only other thing we might want to do is add an event here. However, inside _mint_ is an event that was emitted anyway when we _mint_ the tokens, an event is emitted inside _mint_. So, it's all good. We are already missing events, so this function is now done. Amazing. So, let's move on and create our _burn_ function, so let's create a function _burn_, and this function is going to be called when we transfer tokens cross-chain, because we're going to be creating a burn and mint token mechanism for bridging our tokens. However, let's assume this _burn_ function is only going to be called when a user is redeeming their rewards, and their deposit. They are pulling out of the protocol. So, they would go into some vault, they would call redeem with an amount, and then _burn_ would be called by that vault. So, we've got an _address_ to make it consistent, we're going to make this _from_, then we've got a _uint256_ and it needs to take the amount that they want to _burn_. We can make this external. Again, we will add the access modifiers later, and we want to do the same as what we did in _mint_, we want to _mint_ them any accrued interest, and the address is called _from_, and then we want to call the internal _mint_ function implemented on the ERC20 contract that we are inheriting. Let's add in a little bit of _natspec_. At notice, burn the user tokens when they withdraw from the vault. _param_ _from_ The user to burn the tokens from. _param_ _amount_ The amount of tokens to burn. There's something a little bit interesting going on here. So, because in the real world, there's going to be some kind of latency, see, so from the time that you send the transaction, maybe it takes a little bit of a long time to go through, and there's a wait for finality and things like that, we could accrue some interest in that time. So, because of this from the time of initiating the transaction and the time of the transaction being executed is a wait while we wait for our transaction to be brought to the top and be added into the blockchain, we need to account for what we call dust, which is this leftover interest that has accumulated when someone is trying to withdraw and therefore burn their entire balance. So, they might do something like, calculate their current balance and then pass that into redeem to redeem all of their tokens. And so, they intended to redeem all of their tokens, but they in fact, don't, so we're going to add a way for them to redeem all of their tokens without having to go and call _balanceOf_ and then pass that through. So, we're going to use the maximum value of a _uint256_. If they pass in the maximum value of a _uint256_ to this function, well, they'll pass it into redeem, which calls burn, and so the value of _amount_ is the maximum value of a _uint256_, then, we withdraw their entire balance, and therefore burn their entire balance. 
```javascript
function burn(address from, uint256 amount) external {
    if (amount == type(uint256).max) {
        amount = balanceOf(from);
    }
    _burn(from, amount);
}
```
We can also add some _natspec_ here: At notice Burn the user tokens when they withdraw from the vault. _param_ _from_ The user to burn the tokens from. _param_ _amount_ The amount of tokens to burn. So, because in the real world, there's going to be some kind of latency, see, so from the time that you send the transaction, maybe it takes a little bit of a long time to go through, and there's a wait for finality and things like that, we could accrue some interest in that time. So, because of this from the time of initiating the transaction and the time of the transaction being executed is a wait while we wait for our transaction to be brought to the top and be added into the blockchain, we need to account for what we call dust, which is this leftover interest that has accumulated when someone is trying to withdraw and therefore burn their entire balance. So, they might do something like, calculate their current balance and then pass that into redeem to redeem all of their tokens. And so, they intended to redeem all of their tokens, but they in fact, don't, so we're going to add a way for them to redeem all of their tokens without having to go and call _balanceOf_ and then pass that through. So, we're going to use the maximum value of a _uint256_. If they pass in the maximum value of a _uint256_ to this function, well, they'll pass it into redeem, which calls burn, and so the value of _amount_ is the maximum value of a _uint256_, then, we withdraw their entire balance, and therefore burn their entire balance.  So, this is how we can add in a check so that, if a user calls burn, they can also just burn their entire balance. And, this is how we mitigate against dust and make our protocol more robust. Amazing. 
