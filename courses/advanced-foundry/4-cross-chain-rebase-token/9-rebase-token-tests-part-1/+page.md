This is the last little section before we take a well-earned break. I mean, if you need to take a break now, then go ahead, but let�s try and get through this last little section before we move on to making our token cross-chain. So, as I said earlier, we need to start making our tests. We need to check the functionality of the vault and the rebased token to make sure it�s all working as expected. So, let�s create a new file, and we can call this `RebaseToken.t.sol`.  `SPDX-License-Identifier: MIT`. `pragma solidity ^0.8.24;`. Then, we need to import `Test` from `forge-std/Test.sol`.  I�m actually also just going to import `console` so that we can print some lines. Then, we�re also going to import our rebased token so that we can test it. `... /src/RebaseToken.sol;`. And then, we�re also going to import the vault.  Now, remember, we�re also going to in the vault, need to pass through our rebased token and make sure that it is of the type IRebaseToken or has the interface IRebaseToken. So, we are probably also going to need the interface. So, let�s just import that quickly. Oh, and Copilot knows exactly what I want to do, which is amazing. I really do recommend if you aren�t using Copilot, actually, you know, if you�re very new to this, maybe start writing things from scratch, but it is helpful if you struggle with syntax, like I do. I am not so bad with logic, like logic, I enjoy, but syntax, I often forget the keywords and things like that, and it just means that you can get started with writing your contracts a lot quicker. Anyway, so we�ve got `contract RebaseTokenTest is Test {`.  RebaseToken private rebaseToken; Vault private vault;  function setup() public {  rebaseToken = new RebaseToken();  vault = new Vault(IRebaseToken(address(rebaseToken))); }.  We�ve got `contract RebaseToken is ERC20, Ownable, AccessControl {`.  `error Vault__RedeemFailed();`. And then, what do we need to do? We need to deploy our rebased token. We need to deploy our vault, and then we need to set the permissions for the vault. So, up here, we need to have a storage variable for the rebased token. We need to have a storage variable for the vault. Deploy the rebased token and the vault. So, `RebaseToken`.  It doesn�t take any constructor parameters, and then we can initialize the vault with the new keyword to deploy it. `Vault`. And then, wrap the rebased token in the interface. Now, let�s just quickly build everything, and you can see that we have got an issue. So, explicit type conversion not allowed from contract RebaseToken to contract IRebaseToken, because the problem is you can�t you can�t cast it directly. And instead, we need to do an intermediate cast to address. So, that will fix that issue, and then we can build again. And we�ve got a problem with one of our comments. Return. And this isn�t named, so it�s called linear interest. So, we can fix that there. Amazing. Now, the other thing is, remember that our rebased token, whoever deploys this contract, hang on, let�s just, oops, get rid of the terminal just so we can see what�s going on. In our constructor, whoever deploys this contract is the owner. Let�s just make sure that we have access directly to the owner, and then also a user that is going to be interacting with the protocol. So, let�s just make some nice little addresses here. So, `address public owner = makeAddr("owner");`.  `address public user = makeAddr("user");`.  And then, we can use `prank` VM.startPrank to make it seem like these calls are coming from the owner deploying the contracts. And then, we also need to grant the vault the mint and burn role. And the way we do that is, we call `rebaseToken`, and we call the meth- the function `grantMintAndBurnRole`, and then we can pass through the vault.  And now, this is obviously of type vault, so we�ve got an error here. Invalid type for argument in function call. Invalid implicit conversion from contract Vault to address requested. So, we need to cast this to an address. And then, we need to make sure that we stop the prank, `stopPrank`, and that�s it. We�ve done our setup. Now, the other thing that we also want to do is just make sure that we are adding some rewards to the vault because then, when we�re testing redeeming and things like that, we don�t have errors where there aren�t enough rewards to withdraw. So, let�s also just after we `grantMintAndBurnRole`, just add some funds to the vault. So, we can call the vault with a low level call. call, and we can specify the value. Let�s just do one whole ETH. So, then, we don�t need any data. And then, we also need to cast this to an address so that we can form a low-level call on it. And then, also, because we�re sending ETH, we need to make it payable like this. So, we now have added in some rewards to our vault. And then, we�ve also got this error here. Return value of low-level calls not used. So, we should add in the bool success. But, we don�t really need to do anything with success. We�ve got a little squiggle here because we haven�t used it, but we don�t really need to check that it was successful because if it�s not successful, our tests will fail. Um, obviously, if this was in a smart contract, we�d want to be doing something with success and making sure that if it�s not successful, we revert, but we don�t need to do that because it�s a test. Now, remember, this is a little contrived. We�re obviously going to be making sure that we have enough rewards in the vault. And, this is probably going to come from some kind of interest where users have borrowed tokens or something like that. So, the rewards are automatically going to be in there, and then the interest rate is going to be adjusting based on the amount of rewards, and you�ve got clever mechanisms like that, but we�re going to sort of gloss over that for simplicity in this section, and that�s because we�re just purely learning what a rebased token is, and then how to do cross-chain transfers. And I want to make sure that we get to the cross-chain element of this course as quickly as we possibly can. So, just keep that in mind because you might be thinking here, �Hey, that�s a little bit sketchy. What if I have tons of users and they have massive deposits? And how am I going to make sure that I add enough rewards to the vault?� Yes, you�re totally right, and, and, I�m excited to see how you implement this in your projects. Let�s start our tests. Now, the first test that I want to create is I actually want to check the interest is in fact linear. And the way we�re going to do that is, we�re going to create a deposit. Then, we�re going to wait some time or, we�re going to check the amount of rebased tokens has increased. We�re then going to wait another period, and then check our balance for a third time. Then, we�re going to check the difference between the third one and the second one, and then the second one and the first one, and check that the difference is the same. Because if the interest is linear, if the time interval between two checks of our balance is constant, then the amount of interest that accrued should also be constant. Let�s create a little function. function testDepositLinear. We�re going to make this public. Oh, there�s something else I wanted to say. So, these tests we are going to write are, we�re going to write a mixture of normal and then also some fuzz tests because it�s good practice to do fuzz tests to make sure you find any inputs which are a little bit break some assumptions of our smart contracts. As Pat always says, we should be using unit tests, we should be then doing some integration tests of our scripts and things like that, but for the purposes of efficiency, I am going to not test the scripts, which is not good practice, but we obviously haven�t written those yet because the scripts are going to be cross-chain based. And also, I�m also going to be doing my fuzz tests in with my unit tests. If you�re being very thorough, which you should be, then you should be doing unit tests, fuzz tests, and integration tests all separately, and I�m excited to see all your projects in which you are doing this. And I just wanted to call that out here to make sure that we are still abiding by the best practices of development. Right, so in this function, first thing we need to do is deposit.  The second thing we need to do is check our rebased token balance. Third, we need to warp the time and check the balance again. And then, thirdly, fourthly, oops, we need to warp the time again by the same amount, and check the balance again. So, we need to create a prank to make sure that we are using the user. So, VM.startPrank.  We�re going to prank the user. And then, the other thing that we�re going to do right at the end is VM.stopPrank to make sure that we don�t forget.  Then, we need to make sure that this user has some ETH to be able to use, and we can use VM.deal to give them some ETH.  So, we need to send it to the user. Um, we need to give them some amount, and then we�re also going to fuzz this amount. So, we can pass in here uint256 amount. And we also need to make sure that this amount is enough to be able to see some linear interest in a certain amount of time. So, we can use bound in order to restrict amount. And now, you might be thinking you can use VM.assume that amount is greater than something like 1 ETH, but instead we are actually going to use bound. So, what we can write is `amount = bound(1e18, 1e18 * 5, type(uint256).max)`. This is obviously a massive deposit. People aren�t going to, you know, 2 to the power of 96 is a humongous number, and people aren�t going to be depositing that amount, so this is fine to bound it to this amount because this is for 1,000 way, which is tiny. Actually, let�s make this 5, even because that is very, very tiny. We want to see, make sure that we have a little bit of growth in our linear growth. 
