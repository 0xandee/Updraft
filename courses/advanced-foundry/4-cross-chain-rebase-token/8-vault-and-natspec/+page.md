Okay, very quickly, before we move on, I noticed that our comments didn't have these nice pretty colors and I was like, "Oh, that's not very helpful." So, I realised that I forgot to add the second star. So hang on, that's automatically created at the end. But, yeah, if you do slash star star, it will do nice colors for your NatSpec. So, we can go through and add this to all of the comments, the NatSpec comments, on our functions. So, the next thing we need to do is, like we were saying earlier, we just close out this lib. We need to create the vault, and this is just going to be the place where our users come to deposit, to deposit their ETH, and then withdraw their ETH. It's also going to be the place where rewards are going to be sent. So, it's just basically a place to lock up all of the ETH in one place. So, we're going to create a new file, called vault.sol. And then, we need to add SPDX license identifier MIT, pragma solidity ^0.8.24, contract Vault. Like this. We are going to need to, as I was saying earlier, we need to We need to pass the token address to the constructor so that we can call mint and burn. We need to create a deposit function that mints tokens to the user and sends the underlying tokens to the contract create a redeem function that burns tokens from the user and sends the user ETH create a way to add rewards to the vault. Cool. So, the first thing we need to do is, we need to create a constructor. So, constructor and then we're going to be able to pass in address which is going to be our rebase token, and then we can set this in storage, and we are going to make this immutable. So, i_ because we don't want to be changing this later, so then we can put our little storage variable up here. So, address i_ rebaseToken, and we are going to make this immutable. And, we want to also find a way to return the address of the rebase token, so we're going to make create a little getter. function getRebaseTokenAddress and this is going to be external view returns address, and we're going to return i_ rebaseToken. And, this is of type address. So, it's all good. So, now people can come along and they can deposit well they can't yet, but they will deposit to the vault, and we've given them a way to see the address of the tokens that they have received. So, if they wanted to add them to their Metamask, or something like that, and they didn't want to have to visit our documentation, I don't know. Different people have different workflows. Right. So, the next thing that we need to do is I'm actually going to go bottom up. Well, sort of, I'm going to create the way to add rewards to the vault. So, with Patrick, you have learnt about fallback functions. Woohoo! So, we're actually going to implement a little receive function, and the way that the rewards are added to the vault, there could be a number of different mechanisms, um it could be from fees, from lending and borrowing or lots of other different methods, but we are going to implement a receive fallback function, just to create a way for our protocol owner to send ETH to this contract so that there are a pool of rewards, um for users to be able to withdraw. So, remember, we don't need the function keywords because this is a fallback function, and it's called receive, although I think I've spelt that incorrectly. I have receive Oh, not receiver, and it needs to be external payable. Exactly like that. And, that's it. Now we have a way to send rewards to the vault. This receive function, obviously, this is a little bit trivial because in real in the real world, this is going to be rewards that are unlocked linearly based on some mechanism, like staking or lending and borrowing. But, we are just doing it discretely. We probably should set a limit on the amount of ETH we allow people to to deposit. We're not going to do that, but we probably should so that we can make sure that the amount of rewards in the contract are enough to distribute to our users. However, this is just an example, it You know, not as I said this is going to be using some kind of other mechanism, um in order to accrue rewards for our users, but we need a way to send these rewards to this contract and to do that we have a receive function. Now, let's create our deposit function. So, we've got function deposit, which is not going to take any arguments. We need it to be external so that people can call it, and we also need to make it payable so that they can send ETH. And, then we need to get So, the first thing is we need to use the amount of ETH the user has sent to mint tokens to the user. And then, we need to emit an event. So actually that's the only thing we need to do. So, what we're going to do to do this is, we are going to call the rebase token. And, we're going to call the mint function that we created, and this takes an address and an amount. So, how do we get the amount of ETH that the user message sender has sent along with this transaction? And, the way we do that, as Copilot is helpfully telling us is using msg.value, which I'm pretty sure you've looked at with Patrick, and then we also then need to emit an event. Obviously, mint will also emit an event, but because there is a second way which we're going to be using mint, and that is with bridging our tokens. We're actually also going to emit an event here, and we're going to call it deposit. And, we also want to add in the address of the sender and the amount that they deposited. So, let's go ahead and create that little event. event Deposit, let's call this deposited. Nope, you know what, let's not. So, you can see here, this little squiggly line member mint not found or not visible after argument dependent lookup in address. So, the the the member mint is not defined on an address. We need to create an interface so that we can say that this interface has these functions on, and therefore it is good to call this address with this function selector. So, in our source, we're going to create a folder, we're going to call this interfaces. And then, in here we're going to create a new file, and we're going to prepend it with i_rebaseToken.sol. And then, in here we're going to create our interface for our rebase token. So, the usual thing is SPDX license identifier MIT, pragma solidity ^0.8.24, and then we write interface i_rebaseToken, and in here we are going to need a function, mint, and the function signature is address to, uint256 amount, and the functions on an interface need to be external. We also need to add burn because we are obviously going to be using that when we go when we implement redeem. So, burn address from uint256 amount, I'm going to make this external. And, there we have it. So, now we can call mint and burn on anything with the type i_rebaseToken with that interface. So, in our So, in our vault, we now need to make sure that this address has does conform to the i_rebaseToken interface. And so, what we can do is, we can actually make sure this is just making being a little bit extra a little extra precaution because we could What we could do here is, we could import the interface, and then we could wrap this in the interface, i_rebaseToken, and then put some parentheses around here like this, and that would work absolutely fine. But, it's actually good practice to make the type in here i_rebaseToken. We're going to change this to be an i_rebaseToken interface, that's the type. And, now it knows that it has mint on it. And, we're also going to cast this now to an address to make sure that we return the address. So, the final thing that we need to do is add our redeem function. function redeem, and we are going to allow them to specify the amount that they want to redeem, so if in case they want to not only redeem some of their balance If we're also going to make this external, callable by anyone. So, the first thing we need to do is, we need to because checks effects interactions. We need to burn the tokens from the user, and then number two, we need to send the user ETH. Okay. So, the first thing is we get i_rebaseToken.burn, message.sender, amount, Thanks Copilot. And, then we need to send them some ETH. So, we can cast We can then cast our address the message.sender to be payable, and then all payable addresses have the method transfer on them. And, then we can transfer them the amount. Now, this is actually not the best practice. Instead, we're going to do a low-level call. So again we can cast message.sender to be payable, and then we can call the method call, which is a low-level call, and then with that low-level call, we specify the value, or the ETH amount, that we want to send with this low-level call, and then we would specify the data. So, like the function selector of the function that we want to call. But, we don't want to call any functions on this address. We don't want to send any data at all. So, I've got a little squiggly line here, so it's saying Unknown call option "value". Valid options are "salt" and "value". Return value of low-level calls not used. So, what we need to do is this low-level call will return a boolean, which we are going to name success. And then, it also returns a second argument which we are not actually going to be using. And this would be the return data, but obviously, we are not sending any data along. No functions are being called, so there is no return data. So, instead, we can just use this success boolean to check that the ETH was actually sent to the message sender. Just in case there was some problem, and the address was not able to receive. So, we can write if not success i it is false. It did not pass then we can revert, and as always we're going to use a custom error, not a string because it's better for gas. We need the name of the contract which is Vault_ _ redeem failed. And, then we need to add this up the top. error Vault RedeemFailed. And, again, we're going to make the user indexed because we might want to see all of the times that they have redeemed. Amazing! We have now written our Vault contract. I'm just going to add in a few NatSpec comments. So, deposit slash star star, and this is going to at notice allows users to deposit ETH into the vault and mint rebase tokens in return deposit ETH into the vault and mint rebase tokens in return. And, then it doesn't take any parameters and doesn't return anything. Then for redeem, allows the users to redeem their rebase tokens for ETH, and the amount is the amount of rebase tokens to redeem, and it doesn't return anything. And, then this little function here slash star star the address of the rebase token I'm going to say at return the address of the rebase token. So, we've added in our nice little bit of NatSpec there. Lovely! So, the next thing that we need to do is write some tests to check that the vault and the rebase token are working as expected. So right, let's do that now. 
