The next step is going to be to do a cross-chain transfer, and we are going to create a little function to do that cross-chain transfer. So, that we can reuse it to send tokens cross-chain. So, let�s learn how to do a CCIP token transfer. So, in the documentation we've gone to guides, then transfer tokens. And, if we scroll down, then this documentation, it could be a little bit confusing. But, if we scroll down into this contract, you will see this transfer tokens, pay LINK, function. And, in here we build an EVM to any message, and this is the structure that we need to create to create a message. So, the first thing we need to do is create a message. We need to approve the fees. So, we need to get the fees from the router, after we've created the message, as it is dependent on the message. To do that, we will call the getFees function. We then need to approve on the LINK token, the router to be able to spend the fees. We need to approve for the token that we want to send cross-chain to the router, of the value amount. And, then we need to call CCIP send on the router. And, as arguments, we provide the destination chain selector, which from before we can get from the network details. And, the any the EVM to any message which is the message that we want to send, containing things like the token amount, the token send, the receiver things like that. We're going to go through this any to EVM EVM to any message structure in a second. So, we need to import this client library. We also need to import the interface which has this getFees function, and CCIP send function, so we can wrap so we can cast the router address to that interface, to be able to call these functions. So, let�s create our little function, so I�m going to remove Oops that, and also get rid of the little sidebar, to give us as much room as possible, because I keep forgetting to do that. So, apologies. And then, I�m going to create a function of not a function, a function and I�m going to call it bridge tokens. And, I�m also going to make this so that we can send tokens from Sepolia to Arbitrum, and from Arbitrum to Sepolia. So, we can do it back and forth. Where did it disappear to? That was weird. Ah, it�s because of that, really unhelpful. So, we are going to pass in the things that we need as constructor arguments, so that we can make it, so that we can go bi-directionally. So, we're going to need the uint 256 amount, to bridge, or transfer cross-chain. We're going to need the uint 256, and we�re going to use the terminology local and remote, to mean the chain the chain we are bridging from, is the local, and the chain we are bridging to to be the remote. So, we�ve got the local fork, because we're going to want to be able to move to that fork. Uint 256, remote fork. We�re probably also going to need the network details on both sides. So, register register. Sorry dot network details, and because this is a structure, we need to store in memory local network details, and then register network details, remote network details. And, then, we're probably also going to need the tokens on both sides because we�re going to need to call functions, such as balance off on both sides. So, rebase token, local token, we need a space there, and then we can remote token. Now, we might also need things like the pool addresses and things like that. I don�t know right now whether we are going to need those things, so we�re going to leave it as is, for now. And, if we need to add anything else, as an argument to the function, then we can do so. So, the first thing we need to do is we need to set select the fork that we are working on and we are going to be working on, initially, the local fork. This is the fork that we are bridging from. And then, we also need to do a prank vm . startPrank, because remember we also need to do those approvals. And, this is going to be that user who is going to be doing the cross-chain transfer. Then, we need to create our message. So, we�ve got client . EVM to any message. Store it in memory. And then, we�re going to call it message equals client . EVM to any message { remoteChainSelector: remoteNetworkDetails. chainSelector, remoteContractAddress: remoteTokenAddress, remoteFunctionSignature: abi . encode(remoteTokenAddress), remoteFunctionArguments: abi . encode(user, amountToBridge, 0), remoteFunctionCallValue: 0; }; vm . startPrank(user); So, we need to import the client, so import client from @ ccip contracts / src / v0 . 8 / ccip / libraries / Client . sol; We also need to import the interface, which has this getFees function, and CCIP send function. So, we can wrap so we can cast the router address to that interface, to be able to call these functions. So, let�s create our little function, so I�m going to remove Oops that, and also get rid of the little sidebar, to give us as much room as possible, because I keep forgetting to do that. So, apologies. And then, I�m going to create a function of not a function, a function and I�m going to call it bridge tokens. And, I�m also going to make this so that we can send tokens from Sepolia to Arbitrum, and from Arbitrum to Sepolia. So, we can do it back and forth. Where did it disappear to? That was weird. Ah, it�s because of that, really unhelpful. So, we are going to pass in the things that we need as constructor arguments, so that we can make it, so that we can go bi-directionally. So, we're going to need the uint 256 amount, to bridge, or transfer cross-chain. We're going to need the uint 256, and we�re going to use the terminology local and remote, to mean the chain the chain we are bridging from, is the local, and the chain we are bridging to to be the remote. So, we�ve got the local fork, because we're going to want to be able to move to that fork. Uint 256, remote fork. We�re probably also going to need the network details on both sides. So, register register. Sorry dot network details, and because this is a structure, we need to store in memory local network details, and then register network details, remote network details. And, then, we're probably also going to need the tokens on both sides because we�re going to need to call functions, such as balance off on both sides. So, rebase token, local token, we need a space there, and then we can remote token. Now, we might also need things like the pool addresses and things like that. I don�t know right now whether we are going to need those things, so we�re going to leave it as is, for now. And, if we need to add anything else, as an argument to the function, then we can do so. So, the first thing we need to do is we need to set select the fork that we are working on and we are going to be working on, initially, the local fork. This is the fork that we are bridging from. And then, we also need to do a prank vm . startPrank, because remember we also need to do those approvals. And, this is going to be that user who is going to be doing the cross-chain transfer. Then, we need to create our message. So, we�ve got client . EVM to any message. Store it in memory. And then, we�re going to call it message equals client . EVM to any message { remoteChainSelector: remoteNetworkDetails. chainSelector, remoteContractAddress: remoteTokenAddress, remoteFunctionSignature: abi . encode(remoteTokenAddress), remoteFunctionArguments: abi . encode(user, amountToBridge, 0), remoteFunctionCallValue: 0; }; vm . startPrank(user); So, we need to import the client, so import client from @ ccip contracts / src / v0 . 8 / ccip / libraries / Client . sol; 
```javascript
import Client from "@ccip/contracts/src/v0.8/ccip/libraries/Client.sol";
```
We also need to import the interface, which has this getFees function, and CCIP send function. So, we can wrap so we can cast the router address to that interface, to be able to call these functions. 
```javascript
import IRouterClient from "@ccip/contracts/src/v0.8/ccip/interfaces/IRouterClient.sol";
```
So, let�s create our little function, so I�m going to remove Oops that, and also get rid of the little sidebar, to give us as much room as possible, because I keep forgetting to do that. So, apologies. And then, I�m going to create a function of not a function, a function and I�m going to call it bridge tokens. And, I�m also going to make this so that we can send tokens from Sepolia to Arbitrum, and from Arbitrum to Sepolia. So, we can do it back and forth. Where did it disappear to? That was weird. Ah, it�s because of that, really unhelpful. So, we are going to pass in the things that we need as constructor arguments, so that we can make it, so that we can go bi-directionally. So, we're going to need the uint 256 amount, to bridge, or transfer cross-chain. We're going to need the uint 256, and we�re going to use the terminology local and remote, to mean the chain the chain we are bridging from, is the local, and the chain we are bridging to to be the remote. So, we�ve got the local fork, because we're going to want to be able to move to that fork. Uint 256, remote fork. We�re probably also going to need the network details on both sides. So, register register. Sorry dot network details, and because this is a structure, we need to store in memory local network details, and then register network details, remote network details. And, then, we're probably also going to need the tokens on both sides because we�re going to need to call functions, such as balance off on both sides. So, rebase token, local token, we need a space there, and then we can remote token. Now, we might also need things like the pool addresses and things like that. I don�t know right now whether we are going to need those things, so we�re going to leave it as is, for now. And, if we need to add anything else, as an argument to the function, then we can do so. So, the first thing we need to do is we need to set select the fork that we are working on and we are going to be working on, initially, the local fork. This is the fork that we are bridging from. And then, we also need to do a prank vm . startPrank, because remember we also need to do those approvals. And, this is going to be that user who is going to be doing the cross-chain transfer. Then, we need to create our message. So, we�ve got client . EVM to any message. Store it in memory. And then, we�re going to call it message equals client . EVM to any message { remoteChainSelector: remoteNetworkDetails. chainSelector, remoteContractAddress: remoteTokenAddress, remoteFunctionSignature: abi . encode(remoteTokenAddress), remoteFunctionArguments: abi . encode(user, amountToBridge, 0), remoteFunctionCallValue: 0; }; vm . startPrank(user); 
```javascript
function bridgeTokens(uint256 amountToBridge, uint256 localFork, uint256 remoteFork, Register . NetworkDetails memory localNetworkDetails, Register . NetworkDetails memory remoteNetworkDetails, RebaseToken localToken, RebaseToken remoteToken) public {
    vm . selectFork(localFork);
    vm . startPrank(user);

    Client . EVM to any Message memory message = Client . EVM to any Message({
        receiver: abi . encode(user),
        data: "",
        tokenAmounts: new Client . EVMTokenAmount[](1){
            token: address(localToken),
            amount: amountToBridge
        },
        feeToken: localNetworkDetails . linkAddress,
        extraArgs: Client . argsToBytes(Client . EVMExtraArgsV1({ gasLimit: 0 }))
    });

    uint256 fee = IRouterClient(localNetworkDetails . routerAddress) . getFee(remoteNetworkDetails . chainSelector, message);
    IERC20(localToken . address) . approve(localNetworkDetails . routerAddress, fee);
    IERC20(localToken . address) . approve(localNetworkDetails . routerAddress, amountToBridge);
    vm . prank(user);
    uint256 localBalanceBefore = localToken . balanceOf(user);
    vm . prank(user);
    IRouterClient(localNetworkDetails . routerAddress) . ccipSend(remoteNetworkDetails . chainSelector, message);
    vm . prank(user);
    uint256 localBalanceAfter = localToken . balanceOf(user);
    assertEq(localBalanceAfter, localBalanceBefore - amountToBridge);
    vm . selectFork(remoteFork);
    vm . warp(block . timestamp + 20 minutes);
    uint256 remoteBalanceBefore = remoteToken . balanceOf(user);
    ccipLocalSimulatorFork . switchChainAndRouteMessage(remoteFork);
    uint256 remoteBalanceAfter = remoteToken . balanceOf(user);
    assertEq(remoteBalanceAfter, remoteBalanceBefore + amountToBridge);
    uint256 localUserInterestRate = localToken . getUserInterestRate(user);
    assertEq(remoteUserInterestRate, localUserInterestRate);
}
```
We didn�t actually need to do that. I'll just close the sidebar again. Um so, we need to pass through the fork, which is going to be the remote fork. So, technically speaking, didn�t need to do this select fork. However, because we wanted to pretend that it took some time, and we also wanted to get the remote balance before let�s actually rename that to before, then we already wanted to select the fork. But this does it for us anyway, as well. Which if you do it twice, and you�re already on that fork, it doesn�t actually matter. So now, this will propagate the message and send it cross-chain. Now, we can get the balance after.  uint 256 remote balance after equals remote token . balance of the user. Now, we can do some assertions again. We can assert equal the remote balance after is equal to the balance before minus the amount to bridge. Now, let�s propagate the message cross cross-chain. So, we can select the fork, the other fork. Select fork remote fork. Go onto the other chain. Remote Oops What am I doing? Remote fork, like that. Then, let�s also do a little vm . roll. Just because, sorry a vm . warp. to warp the timestamp by like one by about let�s say, 20 minutes. Normally, it takes a little bit of time for these messages to propagate, and we just want to check that nothing funky happens if the message takes a little while to bridge cross-chain. Now, let�s get the initial balance on the remote block on the remote fork. So, remote balance is equal to remote token . balance of the user. Then, let�s get the message cross-chain, so that we can get the balance after the cross-chain message. So, the way we do that is, we call the CCIP local simulator fork again. simulator fork and then, we call switch chain and route message. Switch chain and route message. So, switch chain and route message, actually does already select the fork that you want to work on, so we didn�t actually need to do that. I�ll just close the sidebar again, and so, we need to pass through the fork, which is going to be the remote fork. So, technically speaking, didn�t need to do this select fork. However, because we wanted to pretend that it took some time, and we also wanted to get the remote balance before let�s actually rename that to before, then we already wanted to select the fork. But this does it for us anyway, as well. Which if you do it twice, and you�re already on that fork, it doesn�t actually matter. So now, this will propagate the message and send it cross-chain. Now, we can get the balance after.  uint 256 remote balance after equals remote token . balance of the user. Now, we can do some assertions again. We can assert equal the remote balance after is equal to the balance before minus the amount to bridge. Now, let�s propagate the message cross cross-chain. So, we can select the fork, the other fork. Select fork remote fork. Go onto the other chain. Remote Oops What am I doing? Remote fork, like that. Then, let�s also do a little vm . roll. Just because, sorry a vm . warp. to warp the timestamp by like one by about let�s say, 20 minutes. Normally, it takes a little bit of time for these messages to propagate, and we just want to check that nothing funky happens if the message takes a little while to bridge cross-chain. Now, let�s get the initial balance on the remote block on the remote fork. So, remote balance is equal to remote token . balance of the user. Then, let�s get the message cross-chain, so that we can get the balance after the cross-chain message. So, the way we do that is, we call the CCIP local simulator fork again. simulator fork and then, we call switch chain and route message. Switch chain and route message. So, switch chain and route message, actually does already select the fork that you want to work on, so we didn�t actually need to do that. I�ll just close the sidebar again, and so, we need to pass through the fork, which is going to be the remote fork. So, technically speaking, didn�t need to do this select fork. However, because we wanted to pretend that it took some time, and we also wanted to get the remote balance before let�s actually rename that to before, then we already wanted to select the fork. But this does it for us anyway, as well. Which if you do it twice, and you�re already on that fork, it doesn�t actually matter. So now, this will propagate the message and send it cross-chain. Now, we can get the balance after.  uint 256 remote balance after equals remote token . balance of the user. Now, we can do some assertions again. We can assert equal the remote balance after is equal to the balance before minus the amount to bridge. Now, let�s propagate the message cross cross-chain. So, we can select the fork, the other fork. Select fork remote fork. Go onto the other chain. Remote Oops What am I doing? Remote fork, like that. Then, let�s also do a little vm . roll. Just because, sorry a vm . warp. to warp the timestamp by like one by about let�s say, 20 minutes. Normally, it takes a little bit of time for these messages to propagate, and we just want to check that nothing funky happens if the message takes a little while to bridge cross-chain. Now, let�s get the initial balance on the remote block on the remote fork. So, remote balance is equal to remote token . balance of the user. Then, let�s get the message cross-chain, so that we can get the balance after the cross-chain message. So, the way we do that is, we call the CCIP local simulator fork again. simulator fork and then, we call switch chain and route message. Switch chain and route message. So, switch chain and route message, actually does already select the fork that you want to work on, so we didn�t actually need to do that. I�ll just close the sidebar again, and so, we need to pass through the fork, which is going to be the remote fork. So, technically speaking, didn�t need to do this select fork. However, because we wanted to pretend that it took some time, and we also wanted to get the remote balance before let�s actually rename that to before, then we already wanted to select the fork. But this does it for us anyway, as well. Which if you do it twice, and you�re already on that fork, it doesn�t actually matter. So now, this will propagate the message and send it cross-chain. Now, we can get the balance after.  uint 256 remote balance after equals remote token . balance of the user. Now, we can do some assertions again. We can assert equal the remote balance after is equal to the balance before minus the amount to bridge. Now, let�s propagate the message cross cross-chain. So, we can select the fork, the other fork. Select fork remote fork. Go onto the other chain. Remote Oops What am I doing? Remote fork, like that. Then, let�s also do a little vm . roll. Just because, sorry a vm . warp. to warp the timestamp by like one by about let�s say, 20 minutes. Normally, it takes a little bit of time for these messages to propagate, and we just want to check that nothing funky happens if the message takes a little while to bridge cross-chain. Now, let�s get the initial balance on the remote block on the remote fork. So, remote balance is equal to remote token . balance of the user. Then, let�s get the message cross-chain, so that we can get the balance after the cross-chain message. So, the way we do that is, we call the CCIP local simulator fork again. simulator fork and then, we call switch chain and route message. Switch chain and route message. So, switch chain and route message, actually does already select the fork that you want to work on, so we didn�t actually need to do that. I�ll just close the sidebar again, and so, we need to pass through the fork, which is going to be the remote fork. So, technically speaking, didn�t need to do this select fork. However, because we wanted to pretend that it took some time, and we also wanted to get the remote balance before let�s actually rename that to before, then we already wanted to select the fork. But this does it for us anyway, as well. Which if you do it twice, and you�re already on that fork, it doesn�t actually matter. So now, this will propagate the message and send it cross-chain. Now, we can get the balance after.  uint 256 remote balance after equals remote token . balance of the user. Now, we can do some assertions again. We can assert equal the remote balance after is equal to the balance before minus the amount to bridge. Now, let�s propagate the message cross cross-chain. So, we can select the fork, the other fork. Select fork remote fork. Go onto the other chain. Remote Oops What am I doing? Remote fork, like that. Then, let�s also do a little vm . roll. Just because, sorry a vm . warp. to warp the timestamp by like one by about let�s say, 20 minutes. Normally, it takes a little bit of time for these messages to propagate, and we just want to check that nothing funky happens if the message takes a little while to bridge cross-chain. Now, let�s get the initial balance on the remote block on the remote fork. So, remote balance is equal to remote token . balance of the user. Then, let�s get the message cross-chain, so that we can get the balance after the cross-chain message. So, the way we do that is, we call the CCIP local simulator fork again. simulator fork and then, we call switch chain and route message. Switch chain and route message. So, switch chain and route message, actually does already select the fork that you want to work on, so we didn�t actually need to do that. I�ll just close the sidebar again, and so, we need to pass through the fork, which is going to be the remote fork. So, technically speaking, didn�t need to do this select fork. However, because we wanted to pretend that it took some time, and we also wanted to get the remote balance before let�s actually rename that to before, then we already wanted to select the fork. But this does it for us anyway, as well. Which if you do it twice, and you�re already on that fork, it doesn�t actually matter. So now, this will propagate the message and send it cross-chain. Now, we can get the balance after.  uint 256 remote balance after equals remote token . balance of the user. Now, we can do some assertions again. We can assert equal the remote balance after is equal to the balance before minus the amount to bridge. Now, let�s propagate the message cross cross-chain. So, we can select the fork, the other fork. Select fork remote fork. Go onto the other chain. Remote Oops What am I doing? Remote fork, like that. Then, let�s also do a little vm . roll. Just because, sorry a vm . warp. to warp the timestamp by like one by about let�s say, 20 minutes. Normally, it takes a little bit of time for these messages to propagate, and we just want to check that nothing funky happens if the message takes a little while to bridge cross-chain. Now, let�s get the initial balance on the remote block on the remote fork. So, remote balance is equal to remote token . balance of the user. Then, let�s get the message cross-chain, so that we can get the balance after the cross-chain message. So, the way we do that is, we call the CCIP local simulator fork again. simulator fork and then, we call switch chain and route message. Switch chain and route message. So, switch chain and route message, actually does already select the fork that you want to work on, so we didn�t actually need to do that. I�ll just close the sidebar again, and so, we need to pass through the fork, which is going to be the remote fork. So, technically speaking, didn�t need to do this select fork. However, because we wanted to pretend that it took some time, and we also wanted to get the remote balance before let�s actually rename that to before, then we already wanted to select the fork. But this does it for us anyway, as well. Which if you do it twice, and you�re already on that fork, it doesn�t actually matter. So now, this will propagate the message and send it cross-chain. Now, we can get the balance after.  uint 256 remote balance after equals remote token . balance of the user. Now, we can do some assertions again. We can assert equal the remote balance after is equal to the balance before minus the amount to bridge. Now, let�s propagate the message cross cross-chain. So, we can select the fork, the other fork. Select fork remote fork. Go onto the other chain. Remote Oops What am I doing? Remote fork, like that. Then, let�s also do a little vm . roll. Just because, sorry a vm . warp. to warp the timestamp by like one by about let�s say, 20 minutes. Normally, it takes a little bit of time for these messages to propagate, and we just want to check that nothing funky happens if the message takes a little while to bridge cross-chain. Now, let�s get the initial balance on the remote block on the remote fork. So, remote balance is equal to remote token . balance of the user. Then, let�s get the message cross-chain, so that we can get the balance after the cross-chain message. So, the way we do that is, we call the CCIP local simulator fork again. simulator fork and then, we call switch chain and route message. Switch chain and route message. So, switch chain and route message, actually does already select the fork that you want to work on, so we didn�t actually need to do that. I�ll just close the sidebar again, and so, we need to pass through the fork, which is going to be the remote fork. So, technically speaking, didn�t need to do this select fork. However, because we wanted to pretend that it took some time, and we also wanted to get the remote balance before let�s actually rename that to before, then we already wanted to select the fork. But this does it for us anyway, as well. Which if you do it twice, and you�re already on that fork, it doesn�t actually matter. So now, this will propagate the message and send it cross-chain. Now, we can get the balance after.  uint 256 remote balance after equals remote token . balance of the user. Now, we can do some assertions again. We can assert equal the remote balance after is equal to the balance before minus the amount to bridge. Now, let�s propagate the message cross cross-chain. So, we can select the fork, the other fork. Select fork remote fork. Go onto the other chain. Remote Oops What am I doing? Remote fork, like that. Then, let�s also do a little vm . roll. Just because, sorry a vm . warp. to warp the timestamp by like one by about let�s say, 20 minutes. Normally, it takes a little bit of time for these messages to propagate, and we just want to check that nothing funky happens if the message takes a little while to bridge cross-chain. Now, let�s get the initial balance on the remote block on the remote fork. So, remote balance is equal to remote token . balance of the user. Then, let�s get the message cross-chain, so that we can get the balance after the cross-chain message. So, the way we do that is, we call the CCIP local simulator fork again. simulator fork and then, we call switch chain and route message. Switch chain and route message. So, switch chain and route message, actually does already select the fork that you want to work on, so we didn�t actually need to do that. I�ll just close the sidebar again, and so, we need to pass through the fork, which is going to be the remote fork. So, technically speaking, didn�t need to do this select fork. However, because we wanted to pretend that it took some time, and we also wanted to get the remote balance before let�s actually rename that to before, then we already wanted to select the fork. But this does it for us anyway, as well. Which if you do it twice, and you�re already on that fork, it doesn�t actually matter. So now, this will propagate the message and send it cross-chain. Now, we can get the balance after.  uint 256 remote balance after equals remote token . balance of the user. Now, we can do some assertions again. We can assert equal the remote balance after is equal to the balance before minus the amount to bridge. Now, let�s propagate the message cross cross-chain. So, we can select the fork, the other fork. Select fork remote fork. Go onto the other chain. Remote Oops What am I doing? Remote fork, like that. Then, let�s also do a little vm . roll. Just because, sorry a vm . warp. to warp the timestamp by like one by about let�s say, 20 minutes. Normally, it takes a little bit of time for these messages to propagate, and we just want to check that nothing funky happens if the message takes a little while to bridge cross-chain. Now, let�s get the initial balance on the remote block on the remote fork. So, remote balance is equal to remote token . balance of the user. Then, let�s get the message cross-chain, so that we can get the balance after the cross-chain message. So, the way we do that is, we call the CCIP local simulator fork again. simulator fork and then, we call switch chain and route message. Switch chain and route message. So, switch chain and route message, actually does already select the fork that you want to work on, so we didn�t actually need to do that. I�ll just close the sidebar again, and so, we need to pass through the fork, which is going to be the remote fork. So, technically speaking, didn�t need to do this select fork. However, because we wanted to pretend that it took some time, and we also wanted to get the remote balance before let�s actually rename that to before, then we already wanted to select the fork. But this does it for us anyway, as well. Which if you do it twice, and you�re already on that fork, it doesn�t actually matter. So now, this will propagate the message and send it cross-chain. Now, we can get the balance after.  uint 256 remote balance after equals remote token . balance of the user. Now, we can do some assertions again. We can assert equal the remote balance after is equal to the balance before minus the amount to bridge. Now, let�s propagate the message cross cross-chain. So, we can select the fork, the other fork. Select fork remote fork. Go onto the other chain. Remote Oops What am I doing? Remote fork, like that. Then, let�s also do a little vm . roll. Just because, sorry a vm . warp. to warp the timestamp by like one by about let�s say, 20 minutes. Normally, it takes a little bit of time for these messages to propagate, and we just want to check that nothing funky happens if the message takes a little while to bridge cross-chain. Now, let�s get the initial balance on the remote block on the remote fork. So, remote balance is equal to remote token . balance of the user. Then, let�s get the message cross-chain, so that we can get the balance after the cross-chain message. So, the way we do that is, we call the CCIP local simulator fork again. simulator fork and then, we call switch chain and route message. Switch chain and route message. So, switch chain and route message, actually does already select the fork that you want to work on, so we didn�t actually need to do that. I�ll just close the sidebar again, and so, we need to pass through the fork, which is going to be the remote fork. So, technically speaking, didn�t need to do this select fork. However, because we wanted to pretend that it took some time, and we also wanted to get the remote balance before let�s actually rename that to before, then we already wanted to select the fork. But this does it for us anyway, as well. Which if you do it twice, and you�re already on that fork, it doesn�t actually matter. So now, this will propagate the message and send it cross-chain. Now, we can get the balance after.  uint 256 remote balance after equals remote token . balance of the user. Now, we can do some assertions again. We can assert equal the remote balance after is equal to the balance before minus the amount to bridge. Now, let�s propagate the message cross cross-chain. So, we can select the fork, the other fork. Select fork remote fork. Go onto the other chain. Remote Oops What am I doing? Remote fork, like that. Then, let�s also do a little vm . roll. Just because, sorry a vm . warp. to warp the timestamp by like one by about let�s say, 20 minutes. Normally, it takes a little bit of time for these messages to propagate, and we just want to check that nothing funky happens if the message takes a little while to bridge cross-chain. Now, let�s get the initial balance on the remote block on the remote fork. So, remote balance is equal to remote token . balance of the user. Then, let�s get the message cross-chain, so that we can get the balance after the cross-chain message. So, the way we do that is, we call the CCIP local simulator fork again. simulator fork and then, we call switch chain and route message. Switch chain and route message. So, switch chain and route message, actually does already select the fork that you want to work on, so we didn�t actually need to do that. I�ll just close the sidebar again, and so, we need to pass through the fork, which is going to be the remote fork. So, technically speaking, didn�t need to do this select fork. However, because we wanted to pretend that it took some time, and we also wanted to get the remote balance before let�s actually rename that to before, then we already wanted to select the fork. But this does it for us anyway, as well.