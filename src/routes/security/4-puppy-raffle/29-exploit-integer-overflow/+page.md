---
title: Exploit - Integer Overflow
---

_Follow along with this video:_

## <iframe width="560" height="315" src="VIDEO_LINK" title="vimeo" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

---

# Smart Contract Debugging: Dissecting "Select Winner" Function

Hi there! Today we're diving once again into the depths of smart contract bugs, and we've stumbled on another one we think you might find interesting. We're dissecting the notorious "select winner" function and unsurprisingly, there's a lot more to be uncovered here than we originally thought.

So, grab a cup of coffee, put on your favorite debugging playlist, and let's get started!

## The Peculiar Case of 'Bad Randomness'

In the function, we start with faulty randomness - a classic coding issue where the output isn't as random as you'd think or want it to be. We managed to change that by implementing a `chainlink fear F`.

```python
# Function that retrieves a random numberrandom_number = chainlink.fearF()
```

The function above calls a random number, replacing the unpredictable nature of our code. However, it often gets more complicated in the future when we call any method to `get_the_winner()`.

## Total Amount Collected: Why not Balance?

The following piece of the code confused us:

```python
# Computes the total amount collectedtotal_amount_collected = len(players) * entrance_fee
```

We wondered, why not simply use `address.balance` instead? It seems like a more straightforward method to compute the total amount collected. Could there be an underlying reason for this approach? This is definitely a conversation for the team handling the project.

## Deciphering the Prize Pool

![](https://cdn.videotap.com/1eblPhxnIULZz5ABPoxP-135.7.png)Moving on, we interpreted an interesting metric â€“ the prize pool. The code below illustrates how it's computed:

```python
# Computes the prize poolprize_pool = total_amount_collected * 80 / 100
```

The computation suggests the prize pool is set to be 80% of the total money, while the final 20% appears to be a fee. The question here is, "Is the 80% allocation right?" We couldn't find this in any documentation,so it's possible that there might be some arithmetic error we're yet to spot. We briefly checked if there could be a loss of precision. But we'll revisit that later.

## The Enigma of Total Fees

Next, we noticed some peculiar operations regarding total fees:

```python
# Update total feestotal_fees += fee.cast()
```

Where `fee.cast()` is computed as a fixed portion (UN 56) of some percentage amount. When we examined `total_fees`, we found it to be a UN 64 variable that gets updated in `withdrawal fees()`. This implies that `total_fees` is the total amount the owner should be able to collect. But, there was a warning flag for us due to a strange casting operation happening here. The casting operation gave us an intuition of the possibility of an `audit overflow`, a classic error that doesn't surface in modern versions of the framework due to its built-in protection mechanisms.

## Into the Abyss: Understanding Overflow Functionality

Armed with our suspicion, we journeyed into the Smart Contract Exploits Repository to understand more about this overflow. The repository contains numerous arithmetic errors, including overflow, underflow, and precision loss.

![](https://cdn.videotap.com/4IhOT3WnizauykVujmDa-262.93.png)Using some sandboxed sample contracts, we devised methods to illustrate these errors in practicality. The `increment function` showed that adding anything to a variable that has reached its maximum value will cause the value to wrap back to the start, which results in an overflow issue.

This is a big deal in contract development and can be resolved to a large degree by removing the unchecked wrappers around your incrementing function calls. Consequently, we're able to limit the value to the maximum, preventing any overflow.

Here's a quick illustration:

```python
# Initial function that causes an overflowfunction increment() public {count++;}
```

Updating the function to avoid overflow:

```python
// Corrected functionfunction increment() public {require(count < max, "Maximum limit reached");count++;}
```

Similar issues can be detected with `underflow` and `precision loss`. It's worth noting that the impact of precision loss has to be carefully evaluated. Sometimes, the loss is insignificant and won't affect the functioning of the smart contract. However, in certain use-cases, even the slightest precision loss can lead to significant deviations.

## Proof Of Code: Making It Real

It's crucial to not only understand the bugs and possible errors but also to replicate these issues with a proof of code. Although we won't provide a complete walkthrough for writing a proof of code for the overflow issue (it's pretty straightforward), we encourage you to pause your reading here and take a moment to write one yourself.

Once you've done that, head to our repository and switch to the `audit data` section. There you'll find a ready-made proof of code (`proof_of_codes_t.sol`) with which you can compare your own.

# Finding Bugs: Are We Done?

As we continue to dig through the smart contract, we're fascinated by the array of bugs we're finding. However, it's pretty exciting! It's evident that there is a lot left to explore and debug, so let's keep delving deeper! And remember, while we may be finding lots of bugs now, our ultimate goal is to create code that is clean, robust, and secure against potential exploits.

And that's it for today's bug hunt! Watch out for our next blog post where we delve into more detailed examinations and interesting discoveries. Happy debugging!
