# foundry-full-REAL-p1

Welcome to the Ultimate Solidity Smart Contract Web three blockchain Developer course Foundry edition. Previously, we've done two other massive courses in tutorials like this. One of them with JavaScript and one of them with Python, and then now one in P Pure Solidity. And combined those two videos have over 5 million views making them the most watched blockchain developer educational material on the planet.

And we're looking to do it all over again. We've learned a ton for making those first two courses, and we've taken all of those learnings from those two courses wrapped them up into this one to make this one the best one. Yet, if you're more interested in full stack development and working with JavaScript, the Hard Hat one is still a phenomenal resource for you to get started.

However, this one has a ton of advancements in it, making it the most cutting edge web three developer course period. Having done one of these videos every year for the past three years, I've been reached out to by countless developers who are now full-time developers in the Web three space, making a living, doing well, and contributing to Web three.

And there are thousands that I have not met who have left comments or left me notes, and I know we're gonna do it again with this video. If you're looking to become a Web three Solidity smart contract or blockchain developer, or any of those terms, this is the course for you. And this course is for anybody and everybody, no matter your blockchain or developer experience level.

And additionally, we're gonna be using artificial intelligence to accelerate our learning progress. And I'm gonna teach you not only how to become a blockchain developer, but how to work with AI tools to make you a 10 x developer. If you have a little bit of developer experience before this, this course will be even easier to get through.

But again, don't worry if you've never coded before. And for those of you who are already familiar with blockchain and smart contract development, feel free to jump around the different modules in different sections and grab the learnings that you want. I promise there's a lot of cutting edge information in here, and maybe you need to brush up.

So no matter if you're brand new to coding, brand new to blockchain, or you're an experienced smart contract engineer, you're in the right place. Welcome to the edge of the Rabbit hole. Let's get froggy. For those of you who don't know me, my name is Patrick Collins. I'm a smart contract engineer, security researcher, and just lover of all things Web three.

I'm one of the co-founders of the smart contract auditing firm, Cron average smart contract YouTuber, co-creator of Web three education.dev, and I live and breathe smart contract development. I absolutely love Web three, blockchain and smart contracts, and I love the power and the tools that they enable us to use.

But not only that, I love taking blockchain developers like yourself watching this video right now. On the journey to becoming a successful, smart contract developer. I think the key to web three, to blockchain, to cryptocurrencies being successful is having a phenomenal foundation of developers. So I'm incredibly excited that you are here with me.

And for those of who don't wanna become blockchain developers, the first two lessons of this course, lesson zero and lesson one, are foundational pieces of conceptual information for you just to understand how to get into this web three thing. So if you don't wanna become a developer, just stop once we get to the coding where my Python ista here, I'm working on an addition of this course purely in Python and Viper, stay tuned for that as well.

In any case, I'm incredibly excited for your journey. This is a data dump passion project of all the knowledge that I've collected over the past few years of working in this industry and being a smart contract developer myself. And at this point, I have the track record show that I am 100% confident that if you follow along, if you code along with us, if you follow me on this journey, you'll come out the other side armed with the knowledge to be a positive force.

The cryptocurrency and blockchain industry, smart contract and solidity developers are massively in demand with an average salary being around $145,000 a year. And with AI coming in place, it's becoming even easier to get up to speed quickly, but only those that understand the technology truly will be able to take advantage of all these advancements.

AI get stuff wrong a lot, so we especially need the knowledge to fact check whenever AI get things wrong. Being here, you have the opportunity to be a pioneer ushering in the age of web three of cryptocurrency blazing the trail of where this phenomenal industry has yet to go. Like I said, this isn't the first time we've done this.

We've already helped so many developers get into space, and we're gonna give you the cutting edge most modern tools for industries like Defi, NFTs, DAOs, tokens of upgradeable, smart contracts, blockchains, and everything else that you can think of. Once you finish this course, it will be abundantly clear what you want your next steps to be, and you'll have a ton of economic opportunity at your fingertips and opportunities to make a huge difference in this amazing industry.

However, I can't just give it to you, you have to come with me on this journey. You have to take the step despite what you might think. You know, cryptocurrencies and smart contracts enable a more accountable world, a more transparent world, a more collaborative world, a world where promises can't be broken, and that's a world that I wanna live in.

We'll learn more about the purpose of smart contracts and the purpose of blockchain technology in less than one of this course, and then of course we'll teach you how to build it. So before we even get started, I wanna give you a huge thank you for even being here on this video and listening and being interested in engaging in this phenomenal technology.

So thank you for being here and welcome to the Rabbit Hole cuz we're about to drop down. With that being said, let's get froggy.

So let's begin our journey by talking about some best practices. That way you can get the absolute most out of this course and be as effective as possible. Now, there are two links in the description that I want you to pause a video right now. Go into the description and click on and open up. The first one is web three education.dev, and the second one is a GitHub link to a repo, also known as a repository with all the code and all the lessons and everything we're gonna be covering in this video.

Web three education.dev site is an education site that we're working on to have all of this video, anding else and all the cutting edge learnings of blockchain developers in this course, in this site. So if you enjoy written context as well, be sure to subscribe to sign up for that so that you can be one of the first people to know when it launches.

And the second site is this GitHub link. This is going to be your Bible for the duration of watching this video. It has everything that we're gonna go over. It has all the code, context, text, et cetera, that you're gonna need to be successful in this video. And I'm going to be referring to it pretty often as we go through the course.

Additionally, in this GitHub, there's a discussions tab right here that you can click on. And in here is where you can ask questions, discuss with other people taking the course in, interact with members, helping out, and it's where you can discuss anything that you're having trouble with. And an important note, sometimes you'll see this as the Chain Excel org, Foundry Folk course.

We recently renamed it to the Cipher Foundry Folk course, so this is the correct link. But if you see chain excel org, that's fine as well. That being said, as we go through this course, we're also gonna teach you some best practices on working with artificial intelligence. How to best prompt these AI so that they can give you the best results.

Just keep in mind, they sometimes get things wrong, and it's a good idea if you are gonna use an AI to fact check it with a human or another resource. So be sure to say hi to the discussions and maybe meet some like-minded peers. And additionally, once we do get to the coding portion of this course, it's a good idea to code along with me as I'm explaining things.

So having the video up as well as your coding screen is a good idea, so you can follow along with me as I'm explaining it. Now, this space moves incredibly quickly, so whenever I open some documentation or some code base or something, I highly recommend that you open it as well in your browser. Just so that you can know immediately right away that the code that I'm working with in the video is gonna be the same that the code that you're working with locally.

Now we're gonna be keeping all of the code in here up to date, but sometimes things change and something that I do in the video might not be the most up-to-date best practice. So we're gonna have this file called Chronological Updates md, where you can go in and check to make sure that you're working on the most up-to-date edition.

So if you go into that file, each lesson will have a section, and if there's some update that we made to the lesson, you can find it in there. Additionally, if you think you found something that is different or doesn't quite work. Be sure to make a discussion for it in that GitHub repo. Like I said, it's gonna be your Bible, but yes, if you run into an issue, make sure that file is one of the first places that you check just to make sure that all the code that you're working with is the most up to date.

All of this is to say if you run into an issue, jump to that GitHub repo and make a discussion. We will also be giving you some tips very soon about how to best make a discussion. Yes, asking questions to other human beings is a skill, and we're gonna try to teach you to be the most effective. Cuz asking well formatted questions is not only the secret to being a fantastic AI prompt engineer, but also becoming an incredibly successful developer.

We're gonna learn how to ask well formatted questions, and whenever we post on discussions or forums or whatever we're going to work on formatting them as best as possible. Take breaks. I cannot tell you how many people have tried to rush through these courses and be like, oh, I'm gonna finish in a single weekend.

Your brain doesn't work like that. Your brain needs time to absorb the information, so take breaks maybe every 25 minutes to a half hour. Take a five minute break, or maybe you like working in longer chunks. Maybe take a whole hour and then take a 15, 20 minute break. Don't try to rush to the whole video in a day.

You're not going to retain the information. Go outside, go for a walk. Grab some ice cream, get some coffee. Go to the gym. Your brain needs time to have the information settled. Maybe every two hours, just step away. Maybe be done for the day work at whatever pace makes sense for you. Everyone's going to have a different learning pace.

There is no right speed for this course. I've had people take my courses in two weeks, in three months, in six months. It doesn't matter. Pick a pace that you can do and stick to it. Not only work at your pace, make sure that I'm talking at a pace that makes sense for you. There's a little gear icon in the YouTube video here where you can change the speed of how I'm talking and how fast the video's going.

So if I'm talking way too fast for you, then you can slow me down. But if I'm talking too slow, then you can speed me up. So make the adjustments you need to make me go the speed you want me to go. Now, a giant video like this can be kind of hard to triage where you left off, so using the GitHub repo with the timestamps in there is a good way to say, ah, okay, I was on lesson one.

Let's click the link there to jump right to the timestamp. If you pause video in YouTube, you can actually right click and say copy at current time, and maybe drop that into a notes folder somewhere so that you can always just. Pick right back up where you left off. Or like I said, you can use some of the timestamps in the GitHub repo associated with this course.

Or depending on when you watch this, the web three education.dev site might also be up. Be sure to check that out as well. And of course, this course is modular so you can bounce around topic to topic and go to where you want to go. If you don't wanna do any full stack stuff, then skip that section. If you want to go right to the advanced stuff, do that.

Like I said, go the pace and take the learnings that you want to do. And after every lesson, it might be a good idea to go back and reflect on each lesson, to really make sure the knowledge gets ingrained. Repetition is the mother of skill, and we're going to be repeating a lot of smart contract development.

Now, additionally, at the end of every lesson, you'll see a little QR code that looks something like this. And there will be a link in the GitHub repo pointing to the same place that this QR code is pointing to. These are optional challenges that you can do to try to make sure that you actually learned what was meant to be learned here.

And if you do solve them, you get a very cool N F T along with it. Dunno what an NFT is, don't worry. We'll teach you later. Blockchain development and open source development world is incredibly collaborative, so be sure to use tools like of course, the GitHub discussions tab, theum stack exchange, the decentralized q and a forum, purana issues on different GitHubs, artificial intelligence and more.

And like I said, we'll give you more tips on how to most effectively use these sites in the future. And the reason I'm putting so much emphasis on this and that I will continue to put so much emphasis on this is being a successful smart contract developer is more than just knowing how solidity works.

Knowing where to go for information and how to collaborate with people is often more important than your smart contract knowledge because oftentimes you're gonna run into issues you don't know how to solve. So we're gonna teach you to unblock yourself on this. And really anything in life plus syncing with other people in the space makes it way more fun.

Now, before we can actually get to coding, we need to understand how the blockchain even works, what the purpose of these smart contracts even are. And this is essential to becoming a successful smart contract developer because a technology is really just a solution. And a solution is only as good as the problem is.

So we need to make sure we understand the problem really well, so we know how to attack it with this smart contract technology. And the better you understand the smart contract technology, the better you'll be able to architect your smart contracts in the future and make really intelligent, really powerful systems that further this amazing industry.

But if you already know the basics of blockchain, feel free to jump into lesson two and skip over lesson one. So those are some of the best practices to be really successful with this course. But with that knowledge, you're now standing at the edge of the rabbit hole. And if you're like me, once you jump in, you'll just want to keep going deeper and deeper.

I'm so excited for you to embark on this journey with us, and I'm looking forward to seeing you on the other side, just like the thousands of other developers who have taken these courses and have emerged the other side triumphant. So it all starts with blockchain basics. Let's get froggy.

<!-- L1-1 -->

Now since you're here, you've probably heard of Bitcoin before. Bitcoin was one of the first protocols to use this revolutionary technology called blockchain. Bitcoin White paper was created by the pseudo anonymous Satoshi Nakamoto, and it outlined how Bitcoin can make peer-to-peer transactions in a decentralized network.

This network was powered by cryptography and decentrally and allowed people to engage in censorship resistant finance in a decentralized manner due to its features, which we'll talk about in a little bit. People took to this as a superior digital store of value, a better store of value over something like gold, for example.

And that's why you'll also hear people commonly refer to it as a digital gold. Similar to gold, there's a scarce amount or a set amount of Bitcoin available on the planet, only so much that you can buy and sell. You can read more about the original vision in the white paper. We have a link to the white paper in the GitHub repo associated with this course.

Now, this was an insane breakthrough in a little bit. We're gonna learn exactly how this is all possible and how this actually works under the hood. Some people though, saw this technology and wanted to take it a little bit farther and do even more with this blockchain technology. And a few years later, a man named Vitalic Buterin released a white paper for a new protocol named Ethereum, which used this same blockchain infrastructure with an additional feature.

And in 2015, him and a number of other co-founders released the project Ethereum, where people could not only make decentralized transactions, but decentralized agreements, decentralized organizations, and all these other ways to interact with each other without a centralized intermediary or centralized governing force.

Basically, their idea was to take this thing that made Bitcoin so great and add decentralized agreements to it, or smart contracts and fact. Technically, these smart contracts weren't even really a new idea. Back in 1994, a man named Nick Zao had actually originally come up with the idea. Smart contracts are a set of instructions executed in a decentralized, autonomous way without the need for a third party or centralized body to run them.

And they come to life on these blockchains or these smart contract platforms like Ethereum. And it's these smart contracts that are gonna be the core thing that we're gonna be working on in this course and that we're gonna be developing. You can think of smart contracts in the same way you think of traditional contracts or traditional agreements.

They're just a set of instructions between parties. Except instead of written on pen and paper or typed up in Microsoft Word, they are written in code and embodied on these decentralized blockchain platforms, and that's also where they're executed. Instead of being executed by the two parties or three parties or however many parties that are involved, this removes this centralized issue that we'll talk about more in a bit.

This is one of the main differentiators between the Ethereum protocol and the Bitcoin protocol. It's these smart contracts. Now, technically, Bitcoin does have smart contracts, but they're intentionally Turing incomplete, which means they don't have all the functionality that a programming language would give them.

This was an intentional move by Bitcoin developers. Bitcoin developers viewed Bitcoin as a store of value versus Ethereum. Developers viewed Ethereum as both a store of value and a utility to facilitate these decentralized agreements. Now, these smart contracts on blockchains alone are absolutely incredible.

However, they do come with a huge issue. If we want these digital agreements to replace the agreements in our everyday lives, they probably are gonna need data from the real world. Blockchains by themselves actually can't interact with and can't read or listen to data from the real world. This is what's known as the Oracle problem.

These blockchains are deterministic systems and they're deterministic on purpose, and we'll learn about more about how that works in the sessions to come. So everything that happens with them happens in their little world, but if they're gonna be these agreements, they need external data and they need external computation.

And this is where Oracle's come into play. Oracle's are any device that delivers data to these decentralized blockchain or runs external computation. However, if we want our applications to stay truly decentralized, we can't work with a single Oracle or a single data provider or a single source that's running these external computations.

So we need a decentralized Oracle network similar to our decentralized blockchain network. Your on chain logic will be decentralized, but you also need your off-chain data and computation to be decentralized. Combining this on chain decentralized logic with this off-chain, decentralized data and decentralized computation gives rise to something called hybrid smart contracts.

And most of the biggest protocols that we interact with today are some type of hybrid smart contract or interact with hybrid smart contracts to some extent. This is where the protocol chain link comes into play. It is a modular, decentralized oracle network that can both bring external data and external computation into our smart contracts to make sure they're decentralized end-to-end, while giving them the feature richness that we need for our agreements.

Chainlink allows for us to get data, do upkeep, get random numbers, or really customize our smart contracts in any meaningful way. Now throughout the course, we're gonna use the terminology smart contract. However, whenever we say smart contract, we're often using it a little interchangeably with hybrid smart contracts, but just know that when we say hybrid smart contract, We're talking specifically about smart contracts that have some type of off-chain component.

Now, since Ethereum's release, a number of different blockchains or smart contract platforms have come to light, such as avalanche, polygon, phantom harmony, and more. For the majority of this course, we're gonna be assuming that we're gonna be deploying to the Ethereum network. However, everything that we learn here is gonna be applicable to the vast majority of the blockchains out there, like Polygon, avalanche, phantom harmony, et cetera.

And understanding everything from Ethereum fundamentals will give you the skills that you need to switch chains very easily with literally one line of code. So don't worry about learning a specific tool or with a specific chain, because most of them work together seamlessly. Now, there are a couple of smart contract platforms that don't use solidity, but still learning the fundamentals here will make you much better at those as well.

And Ethereum, by far has the most value locked and is the most used blockchain and smart contract platform out there. You'll also hear those two terms used a little bit interchangeably as well. Sometimes I'll say smart contract platform. Sometimes I'll say blockchain, they kind of mean the same thing.

Obviously blockchains could mean store of value and smart contract platform, but you get the idea. Similarly, chainlink is the most popular and powerful, decentralized Oracle network is the one that we're gonna be focusing on for this course as well. Chainlink is also blockchain agnostic, so it'll work on Ethereum, avalanche, polygon, Solana, or really any other blockchain out there.

Now, additionally, over the last year, a new term has come to light called an L two or a layer two. This solves an issue that most blockchain see where they don't scale very well or they don't grow big very well. We'll be talking about L two s a little bit more in the future, but the basic concept of is that.

Blockchains can really only get so big. So what they do if, if this is Ethereum, you can actually have blockchains hook into them to essentially make them bigger. If that doesn't really make too much sense, don't worry about it. For right now, layer twos solve this scalability issues, and at the moment there are two different types of true layer twos, optimistic rollups and zero knowledge rollups, optimistic Rollups like Arbitra and optimism or zero knowledge rollups like ZK Sync or Polygon, Z K E V M.

Yes, there's a polygon chain, but there's also a Polygon Z K V M L two. The two of them are very different. Don't worry about them for now. And in fact, it's this Arbitra layer two where our challenge contracts are going to be deployed on this roll-up. But like I said, once we learn how blockchains work from a basic level under the hood, then we'll explain more about how these L two s actually work.

Now throughout this course, you'll hear the term DAP or decentralized protocol or smart contract protocol or decentralized application, and they all kind of mean the same thing. A decentralized application is usually the combination of many smart contracts, and when we get into solidity, you'll see what a singular smart contract really looks like.

And like I said, learning all these core fundamentals will make you a better solidity and a better smart contract developer. You'll also hear the term web three a lot in this video and in the industry. Web three is the idea that blockchains and smart contracts are the next iteration of the web, web. One being this permissionless open source world with static content, web two being the permissioned web with dynamic content, but all the agreements and logic runs off of centralized servers where they control your information.

And then web three comes back to the permissionless web. But once again, with dynamic content, and instead of centralized servers running your logic, decentralized networks run the logic, creating these censorship resistant agreements that these smart contracts enable. It is also generally accompanied by the idea that the users own the protocols that they work with, and it's an ownership economy.

You'll see what I mean later in this course. Now, we've talked a lot about the history and about the high level of these protocols and of these smart contracts and what they can do, but what do these smart contracts really mean? What is it when I say trust, minimize agreements or unbreakable promises?

What is the real value add of these smart contracts before we look under the hood and take a peek at how this all works from a technical standpoint. Let's learn what all the value of this is. What is the purpose of us building all these technologies of you taking this course? What problem does this technology solve?

In my mind, a technology is really only as good as the problem that it solves. If it doesn't solve a problem, a then why bother mark contracts, blockchain, web three, cryptocurrencies, those are all just different words that encapsulate the idea of what we're doing in such a unique paradigm. I think the easiest way to sum up what these smart contracts do is that they create trust minimized agreements.

And if you might be scratching your head to that, a much easier way to think about it is just they give rise to unbreakable promises. Yes, you heard that, right? Unbreakable agreements and promises. Additionally, they give rise to speed, efficiency and transparency and a number of other things. I made a video pretty recently about exactly this, so let's dive in and take a listen to the purpose, the undeniable value of smart contracts.

<!-- L1-2 -->

Cryptocurrencies fundamentally re landscape markets and agreements as we know them. Unfortunately, you've probably only been bombarded with people screaming about MFTs and money. Now, some of the memes are fun, but let's forget the bullshit and get down to the essence of this space. If you're already in web three, this is the video to send to your friends to explain why you're so excited about this space and explain why we're here.

And then if you're not into crypto, you've come to the right place. And yes, there are fun memes and markets, and there's some money stuff, and there are all these things. But outside of all that, the purpose of blockchains relates to the age old elementary school, unbreakable promise, the pinky swear. Let's get froggy.

Nearly everything you do in life is the result of an agreement or a contract. Your chair was the result of an agreement to buy and sell lumber, to assemble and sell the chair to a retailer on Amazon. Then you made an agreement to buy the chair for $40. The lights in your house are powered by electricity, which is an agreement from you and the electric company.

You agree to pay them in return. They'll keep the lights on. The electricity that they generate is agreements between them and engineers who built turbine to generate the electricity. With insurance, you agree to pay some amount of money to them every month, and in return, they will do nothing. Or I mean I'll, they'll cover your medical bills.

Almost everything you do in everything you interact with is the result of some form of agreement or contract in some aspect. Now, agreements and contracts can feel kind of abstract and boring to really grasp onto. So to simplify, we can also refer to them as promises. When you get an oil change, they're promising that they will faithfully change your oil in exchange for money.

When you put money in the bank, they promise to keep it safe in exchange for them to use your money to give out loans. When you buy a lottery ticket, the lottery promises to give you a fair chance at winning a ton of money in exchange for you buying the ticket. Whenever you make one of these agreements, in a way, you're asking them to pinky swear to not screw you over and to treat you fairly.

But this doesn't always happen. Let's look at a real world example of someone breaking the pinky square. Back in the eighties and nineties, McDonald's ran a promotion for people to win money by collecting McDonald's Monopoly game cards. The idea was simple. You buy McDonald's and a return, you get a chance to win $1 million.

You can imagine McDonald's literally going, Hey everybody, I promise if you buy our mc food and McNuggets, we'll give you a fair chance of winning this money. Woo. But they ended up breaking this promise instead of having a fair chance of winning. Your chance was in fact. Zero. In the mid nineties, between 13 and 24 million went into the pockets of not people playing the game, honestly, but a group of corrupt insiders who had rigged the game.

Meaning that when you played the McDonald's monopoly game, you are buying into a set of lies and promises that were 100% always going to be broken. And the thing is, it doesn't really matter if this was McDonald's fault or not. They were the ones making the promises that they ultimately could not keep.

Another way you could think about it is that that's 24 million that they essentially stole from you and I. Now, if this system was deployed on a blockchain with something called a smart contract, it would've been impossible to defraud this 24 million due to smart contracts being immutable, decentralized, and transparent.

But I'll get back to that in a minute. In all the agreements and contracts we make, imagine making a pinky square with a 10 year old and imagining how that agreement would hold up. Hey buddy, could you, could you please keep my money safe? You can play with it if you like, but just, just please have it when I come back immediately.

You might get that worrying feeling in your chest that something might go wrong. This 10 year old might lose your money. You might be thinking, how could I trust them? Will they break their promise? And this feeling of I can't breathe because of untrustworthy situations happens once all the time. Can I trust this used card salesperson to give me a good car?

Can I trust this tag that says machine washable? Or will it make my shirt shrink? Will my insurance provider break their promise of covering my medical bills when I get hit by a bus? When Patrick promises he'll go on a hike with me? Will he actually, yes. I, I, I actually will. The issue with our current agreements and contracts is we have to trust the people who are making them to do the right thing.

However, often they're actually incentivized to not do the right thing. Insurance doesn't want to pay out money. Sometimes salespeople just want to get the shit off the shelves. And with my girlfriend, I promised to go on a hike, but I hate hikes. Where else has this happened? Now you might be thinking, okay, Patrick, this seems cool, but like, where has this actually affected me?

Well, the McDonald's lottery that we just spoke about above. During the Great Depression with the run of the banks, banks promised to keep our money safe. And that when we went back to go get it, they would actually have the money there. And well and behold, there were times that they didn't have the money there.

Just last year, Robin Hood painted this amazing picture. Come use our application. We will give you access to the markets. We promise we will give you a retail investor, a fair chance of interacting with the world of finance. Psych, but not this asset, this asset, this asset or this asset. The 2008 financial crisis.

Remember that shady deals behind closed doors combined with lies about financial product, brought the world to its economic needs. How are you? US hyperinflation in Zimbabwe, hyperinflation in Brazil? Theranos history is a relentless lesson of trustworthy entities, being notorious promise breakers, and we finally have a way to fix it with smart contracts.

Now, before I jump into smart contracts, a lot of people might be thinking, Hey, cool and all. However, we have systems in place to protect against a lot of these things, which is true and which is great, and that is a very helpful step forward. But these systems often break. Ones in 2008, definitely didn't work.

The ones with the Robinhood crisis definitely didn't work. And even if these systems apply and you go to court to try to work 'em out, maybe you're in court for years before you actually see a resolution. And by that time, what you needed the money for is long gone. So what is this technology? What is this tool that can fix this fundamental problem in our agreements today?

This tool is smart contracts and this tool is what the blockchain was built for. Now I'm gonna give you a quick overview of what a smart contract is, how I'm leaving some links in the description for more explanations. But the basics of them is a smart contract is an agreement, a contract or a set of instructions deployed on a decentralized blockchain.

And once the contract or set of instructions is deployed, it cannot be altered, it automatically executes and everyone can see the terms of the agreement. The real basics of it is that the code is executed by a decentralized collective, like a group of people, but a group of people running a certain software.

This means that no one person or entity can actually alter any of these agreements or change the terms of the arrangement in these traditional agreements. Whoever owns the contract, whoever owns the execution of the contract, can flip a switch and say, eh, we're not gonna do that anymore. In's smart contracts in web three in blockchain, you no longer can do that.

Typically, these smart contracts are in a decentralized blockchain and used in combination with a decentralized Oracle network. To get the real world assets and information. And if these words sound like I'm conjuring up a magic spell, well again, check the links in the description if you wanna learn more about the technical implications.

If you're not a technical person and you're not interested in getting to the nitty gritty, you can kind of think of it like https. I bet the vast majority of you don't even know what HTTPS stands for, and yet you use it every single day whenever you log onto the internet. So how does this fix the McDonald's monopoly issue?

In its traditional form, the lottery was executed behind closed doors. Somebody operated and owned the code and the contracts and the agreements that ran the lottery, and they had the power to alter it. And nobody other than the people internal on the lottery could audit this altering happening. Now, if the code for this lottery was deployed onto a blockchain, every time a hacker attempted to alter it, everyone would be notified.

Not only that, but you couldn't even alter it because the terms of a smart contract cannot be altered. Once deployed, combine that smart contract with a chain link, V R F Oracle to get a verifiably random number, and presto, you now have a perfectly decentralized unalterable agreement that is impossible to hack, commit fraud, or manipulate.

We have just saved the public between 13,000,020 4 million just by fixing the issue of trust. How does this fix Robinhood? Well, the problem with Robinhood is already fixed, right? Again, the problem is that there's a centralized body that can flip a switch at any time and say, yeah, you can't access these markets anymore.

We're breaking our promise of actually giving you access to the markets. This is already fixed with something called decentralized exchanges, and these exist today. One of these exchanges is one called Unis Swap. You can swap ERC 20 tokens, which are kind of the equivalent of stocks, but some aren't. Some aren't.

It's a little confusing. I won't get into that here either. But it doesn't have that centralized body that can flip a switch and ruin access to the markets. And had these investors been on a decentralized exchange, it would've saved them hundreds of millions of dollars and it would've prevented fraudulent market manipulation.

How does it fix run of the banks? With transparency built in and automated solvency checks, you can build the bank light smart contract that has insolvency checks built in that make it impossible to get there. Insolvent means broke is any agreement or any history lesson where there was a trust assumption that was broken.

Smart contracts can be applied to and should be applied to, especially in a time where big money runs, owns and controls everything. We desperately need to move to a world where some self-interested centralized entity can't flip a switch and ruin people's access to the services that they need. We can move away from a world that is brand based to a world that is math based right now.

If you interact with a service that you don't like or that they break their promise, the only thing you can do is walk down the street to the next service that's gonna make the same set of promises, and you have to hope and pray that they're actually gonna keep it. We can move from that to a world where we can just look at the math and say, oh, okay, one plus one equals two.

This is what this agreement is going to do for me every single time. Guaranteed, because it's a decentralized, autonomous agent, has no incentive to be evil and everything is transparent and out in the open. If I'm a big company and if it was better for me for one plus one to equal three, maybe I would go behind some closed doors and fudge some numbers and come back out and be like, Hey, one plus one equals three.

But with smart contracts, that's impossible. Doing the right thing is infrastructural. Now, given the choice between two agreements, one where you have to trust a single centralized entity that they're gonna do the right thing for you versus a decentralized untamperable collective, which one are you gonna choose?

I'm picking the one that can't screw me over every single time for every agreement I can apply it to. Now, this technology is relatively new, but we have already seen it re-landscaped entire markets and continue to do so. The traditional financial world is already getting get lunch eaten by defi or decentralized finance.

There's already over 200 billion of people's money in these protocols to help have a more fair, more accountable, more transparent financial system. This defi movement is one of the main reasons I got into this space because we desperately need to move away from where we are right now and end people's chances for wealth being sucked up by some group that's bending the rules in their favor, and smart contracts are a ticket to that better world.

More and more industries are also coming over to smart contracts and blockchain, because of all the innovations, is because of all the advantages that it has. As we grow and as we get better, we get closer to this vision of having this concept fulfilled. Trust minimized agreements. These smart contracts are minimizing the trust that we need to give other people in order for these agreements to be executed.

If trust minimized agreements is too confusing for you, just say unbreakable promises. Now, I gotta be honest with you guys. Blockchains and smart contracts and cryptocurrencies can actually do more than just trust, minimize agreements. What have security benefits, uptime benefits, execution, speed benefits, and a whole lot more.

But it's a lot easier to just learn about one and learn the other ones later, right? It's kinda like sprinkles on top. So this is why we are here. This is why we're building this future, and this is why we are so excited about it. Last year, 2022, there were a lot of issues with a couple different companies, like for example, S bfs FTX platform.

The thing to me that's most frustrating about that situation is that FTX platform wasn't anything that I just talked about. It wasn't decentralized, it wasn't trustless, it wasn't transparent. It was purely a traditional web two company pretending to be web three and just using the cryptocurrency part of Web three, but not actually using the smart contracts.

And we're doing a much better job as a community, getting rid of the bad actors. And this is something that's incredibly important for you when working with protocols and when building protocols. I want you to be incredibly successful here, but I want you to be incredibly successful because you're making a ton of value.

A lot of these platforms that we saw collapsing last year were not creating value. They were stealing value. They were siphoning value, they were faking having value. And as you learn and as you build smart contracts yourself, it'll start to become innately aware of what protocols and what companies are centralized and are not the ethos of Web three and the ones that are.

We are building verifiable trust, minimized agreements, unbreakable promises, and if you can't verify those promises, then it's not trust minimized. It's not Web three, it's not what this industry is for. That's what I want you to do as you finish this course, is be a force for good. Unfortunately, because a lot of people haven't taken my course, not everybody understands the difference between a legitimate project and a token that's just meant to pump somebody's bags.

As this space continues to grow, and as people like yourself take courses like this, we will get to continue to push real, legitimate projects forward and wash out the products that aren't actually contributing to Web three. Whew. Even in just this introduction part, we've learned a ton. So let's do a quick summary of what we've learned so far.

Bitcoin was the first protocol to take this blockchain technology into the limelight and take these cryptocurrencies into the mainstream. Bitcoin is a sort of digital gold or a store of value able to make transactions between users in a decentralized manner. Ethereum and other smart contract platforms take this blockchain technology one step further, enabling people to make smart contracts and decentralized trust minimized agreements.

These smart contracts and decentralized applications can access and interact with the real world using something called decentralized Oracle networks. Chainlink is a decentralized network that allows us to build these hybrid smart contracts, which combines our on chain logic with our off-chain decentralized data and decentralized computation, giving rise to our logic being completely decentralized, and our data and external computation being completely decentralized, giving us all the features that traditional agreements and traditional contracts have.

Now, these digital currencies like Ethereum and Bitcoin have value. Even without the smart contract part, having a censorship resistant decentralized store of value is measurably powerful in its own right. We have some links in the GitHub repository that'll teach you how this decentralized store of value flips traditional finance on its head, and it's another one of the great reasons for building smart contracts.

<!-- L1-3 -->


But again, the easiest way to boil it down is trust minimized agreements or unbreakable promises. But let's also go into some of these other features that smart contracts have over our traditional environment. The first feature, of course, is that they're decentralized and they have no centralized intermediary.

The different individuals that run one of these blockchains are known as node operators, and it's the combination of all these thousands of node operators running the same software, running these algorithms, running these smart contracts that make the network decentralized. We'll dive deeper into how that works later.

The next feature is transparency and flexibility in these decentralized networks. Since all these individual node operators run this software, everybody can see everything that's happening on chain, meaning there's no shady deals, there's no weird things happening, anything that's gonna be unfair, people will be able to see and just not use.

Everybody has perfect information and has to play by the same rules. Now, additionally, this doesn't mean that there's no privacy. The blockchain is pseudo anonymous, meaning that you aren't necessarily tied to an identity in real life. They also have the feature of speed and efficiency. For those of you who have ever tried to do a bank transfer or send money across seas, you know what?

Sometimes can take two to three weeks when in fact all these banks are really doing is basic math. They're subtracting money from your balance and adding it to some other balance. Why does it take so long in the blockchain? All of these transactions happen instantly. Another instance for those in the financial world today know that clearinghouses and settlement days can take a long time in the blockchain.

There's no need for any of that because they happen instantly. This obviously is much quicker, but it also makes for much more efficient interactions with each other. Security and immutability, again, immutable means that it can't be changed once a smart contract is deployed. That's it. Whatever's in the code is going to be in the code forever.

They cannot be altered or tampered with in any way. This means that the security is much easier, whereas in a centralized world, somebody can hack into the server, jump into the database and change some numbers. You can't do that in the blockchain world, and since it's decentralized. In order to hack the blockchain, you'd have to take over half of the nodes as opposed to in the centralized world where you only have to take over one.

In the regular world, if your computer and your backup computer go down, all of your data is gone. In the blockchain world, if your computer and your backup computer go down, all your data is safe because it's being run on all these other decentralized notes. And even if a few hundred nodes or if a few thousand nodes go down, it doesn't matter because as long as one node has a copy of the blockchain, You're good to go.

Hacking a blockchain is nearly impossible and leaps and bounds more difficult than hacking a centralized server. Not only that, but this is safer in the asset sense as well. All you need to access your credentials and your information and your assets is your private key, which is basically your password for all of this.

And as we've discussed in the video, these smart contracts remove this counterparty risk, remove this centralized intermediary, remove these trust gateways that we have to do in web two. When we engage with users and individuals, they don't always have our best interests at heart. Smart contracts remove this counterparty risk because once one of these contracts is created, they can't go in and they can't alter it, and they can't let greed or ego or anything else get the better of them and alter the terms of the deal.

And as we said, this gives rise to these trust minimized agreements or these programmatic unbreakable promises. We move away from brand based agreements to math based agreements where we can look at the cryptography, we can look right at the code and see exactly what something is gonna do and how it's gonna execute versus having to rely on a human being doing the right thing with smart contracts and decentralized hybrid smart contracts.

Doing the right thing is infrastructural. All these pieces boiled down to us having the freedom to interact the way we want to interact without having to be afraid that interacting like that is gonna screw us over this trust minimized piece. These unbreakable promises make interactions so much better.

In the purely web two world, were constantly bombarded with messages of projects and protocols pushing us to move or act in the direction that makes them more profitable. Versus in the smart contract space, we can see everything transparently, and we can even engage and interact and be partially owners of the protocols and the interactions that we decide that we wanna be a part of.

So smart contracts have been around for a few years now, and what have they generated for what industries have come about due to these smart contract platforms being around? Well, you've probably heard of some of these and some of these we've already mentioned, but let's give you a quick refresher. Defi.

DEFI stands for Decentralized Finance, and it gives users the ability to engage with finance and markets without having to go through a centralized intermediary. For example, like we said with Robinhood, you no longer have to trust that Robinhood would continue to give you access to the markets. You instead would be able to see in the smart contract.

Yes, I have access to the markets, or in the 2008 financial crisis. You never have to trust that these groups and institutions are giving you the correct things on the backend. You can see everything transparently right on the blockchain. You can engage with things like money markets and sophisticated financial products, easy, effectively, and securely.

If you're really excited about defi, we have a ton of defi examples showing you how to build and interact with these protocols in coming lessons. Dows or decentralized autonomous organizations are another group that we've already mentioned. Dows are groups that are governed completely decentralized by a set of instructions or smart contracts on chain.

There are some massive benefits here where engagement's much easier. The rules are black and white, and you can see everything directly on chain voting and governance. Technology is completely decentralized, and the blockchain space is one of the big ones. Pushing how we can evolve politics and how we can evolve governance to make it more efficient, fair, and reasonable, and you better know it.

We have some examples of how to build dows and how to work with Dows in coming lessons. So be sure to watch those NFTs for non fungible tokens and can really be kind of described as digital art or just a unique asset. They can do so much more, but we'll keep it high level for now. Projects like bored apes and crypto punks have revolutionized the way that people get paid for their work, show off their creativity status and so much more.

And yes, of course, we have lessons showing you how to create and interact with NFTs as well. So many other groups and so many other industries are being created as a result of this insane technology. And maybe after finishing the journey with us here, you go out and you'll be the one to pioneer the next industry or the next billion dollar idea.

You've learned so much already, but now that we've learned a lot of this high level information, let's finally jump in and let's make your first transaction and let's get you set up to interact with this new world. In this next section, we're gonna get you a wallet and we're gonna show you a exactly what a transaction looks like and feels like.

Let's dive in.

<!-- L1-4 -->

This is the Ethereum website, ethereum.org. We are going to make a transaction on a test Ethereum blockchain. I'll explain what that means in a little bit. This is gonna be our first ever transaction that's made on the blockchain, and this process of making a transaction is gonna work the exact same across all E VM compatible blockchains and layer twos like arbitra, Ethereum, ZK Sync, and et cetera.

I'll explain what E V M means in the future for now. Just follow along and have fun running your first transaction. Now, in order for us to send a transaction on any of these E V M chains, the first thing that we need to do is set up a wallet. So I'm gonna go to meta mass because it's one of the most popular wallets and one of the easiest wallets to use.

I'm using the Brave Browser, but it works for Chrome or Firefox or really any other popular browsers out there, and it's just gonna be an extension in the top right hand of our browser. It's gonna make it very easy to see anything to do with our wallets and our transactions very easily, and it's gonna store all of our VM based currencies and VM based transactions.

So I'm gonna go ahead and hit Add to Brave Add Extension, although Brave does also come jam-packed with its own wallet. So now we come to the Get Started page, and I'm gonna go ahead and select Create a New Wallet. Sure, we'll agree to help out Minim Mask. Now we're gonna create our password. Make sure it's really secure for the purpose of this demo, mine's gonna be kind of mediocre.

Now I'm gonna preface this, this wallet that you're making right now as you follow along with me. This is gonna be your development wallet. So if you want to make the password a little bit weak, just so that you can test things out very quickly, go for it. Just know we're never ever gonna put real money into this wallet.

It's good if you treat this as if it is a real wallet. That way you'll get used to, and you'll get familiar with Good Wallet Safety. You'll then get a video like this, which will teach you about the secret recovery phrase, which we saw a little bit earlier when we were creating our wallet. Let's watch this video.

Meta Mask is a new way to connect to sites and applications on traditional websites. A central database or bank is responsible for controlling and or recovering your accounts. But on Meta Mask, all of the power belongs to the holder of a master key. Whoever holds the key controls the accounts, your secret recovery phrase is your master key.

It's a series of 12 words that are generated when you first set up meta mask, which allow you to recover your wallet and funds. If you ever lose access, it's important that you secure your wallet by keeping your secret recovery phrase very safe and very secret. If anyone gets access to it, they will have the master key to your wallet and can freely access and take all of your funds.

To secure your Meta Mask wallet, you'll want to safely save your secret recovery phrase. You can write it down, hide it somewhere, put it in a safe deposit box, or use a secure password manager. Some users even engrave their phrase onto a metal plate. Nobody, not even the team at Meta Mask can help you recover your wallet if you lose your secret recovery phrase.

If you haven't written down your secret recovery phrase and stored it somewhere safe, do it now. We'll wait and remember, never share your secret recovery phrase with anyone, not even us. If anyone ever asks you for it, they're trying to scan you. That's it. Now you know what a secret recovery phrase is and how to keep your wallet safe and secure.

Awesome. So that was a great introduction to keeping your wallet safe. We'll talk a little bit more about safety with our wallets in the future. Let's go ahead and and select Secure My Wallet. Now, this is where we need to write down our secret recovery phrase and save it in a very secure place. It gives us some tips here, like a password manager, a safety deposit box, or split it up and keep it in multiple secret places.

For the purposes of this video, I'm going to be showing you the secret recovery phrase, because I'm not gonna put any real money into this, but you should never, ever do this. Additionally, you'll sometimes hear pneumonic as a synonym for secret recovery phrase. The main takeaway from all this is you should never share any of this.

This is for you only if you show this secret phrase to anybody else. They will have access to not just one account, but every account that you make in Meta Mask. So be absolutely certain to not share this with anybody. So, again, I know I'm belaboring the point a little bit, but everything that we're gonna do in this tutorial we're gonna do with fake money and fake assets and never put actual money into this account that we're making here.

Once you get familiar with using Meta Mask and working with the tools and staying secure, then you can go ahead and create a separate meta mask that will have real funds in it. If you wanna put real money into different meta mask, a lot of browsers have a profile option and maybe you can make a new profile install Meta Mask on that different profile.

Call that Profile Real Money Profile or something, and that's where you will store your money. But for this video, for this tutorial, the metas that you are using is going to be specifically for testing things out and you will never store real money to it. I'm going to harp on that a lot more in this course.

So we, even if you're coming here and you have a wallet, I highly recommend still making a brand new one for this tutorial, just in case you don't accidentally code something or do something autonomous and give away your funds. If this is your first wallet, then great. But again, when you're working with Real Money, if you lose access to the secret phrase, you will lose access to all your money.

So be sure to write this down. Promise me that you won't use real money for this course. Great. I'm gonna hit copy to Clipboard for now, and we're gonna go ahead and hit next. Now we need to confirm by adding our seed phrase back in, we can go ahead and hit confirm, and we now have created our wallet.

Let's go ahead and click. Got it. Awesome. Now we can see the interface of our meta mask full screen, and depending on your browser, what you can normally do is hit this little puzzle piece on your browser and select this pin button. So now we can pin our meta mask into the top of our browser and we can click it like so, and we can see it give a little dropdown like this.

And we could see the same information in this little dropdown as there is on the full screen. Now, even if you lose access to that page, now that this is bookmarked in your browser, you can select your meta mask, select these three dots and hit expand view to reach this tab. Now additionally, what we can do in here is we can actually go up to our accounts and we can actually create multiple accounts by hitting Create account.

And if you wanted to, you could give it a name. Here, I'm just gonna leave it as default for account two. And now we have two separate accounts. We have an account, zero with an address and an account two with an address as well. Both of these accounts actually share that same secret phrase, so anybody with access to the secret phrase can actually have access to both accounts.

However, they have different private keys and that's what makes them different. We'll talk a little bit more about that in the future. If somebody gets access to a private key, they'll get access to a single account. If they get access to the secret phrase, they'll get access to all the accounts that you make.

Even, you know, if you made a third one, they'd get access to this one as well. Now, if you look up in the top right of the screen here, you'll see this section that says Ethereum main net. This is our Nets tab, and if you click it, you can see all the different networks that our meta mask has access to.

Ethereum main net is the main network of Ethereum, and this is where real money is spent and used For this course. We're not gonna be working with Ethereum main net. We're instead gonna be working with something called a Testnet. For both engineers and non-engineers, we often need a place to test or simulate our transactions.

And for the developers here throughout this course, we are going to teach you another technique for testing out your transactions on a local network. And a local network is actually going to be the preferred way we do our testing and our simulations. However, it's still really important to see end-to-end what a real transaction looks like, and that's what a test net will do for us.

It simulates exactly what a main net or a live money network would look like. However, there's no real money at stake and we don't actually have to spend any money to see some of the test nets that come default with Meta Mask, we can hit the show slash hide button, which will bring us to the settings page of Meta Mask.

We can turn on show test networks, and if we scroll back up. Now, if we hit our Networks tab, actually let's go ahead close outta settings. Now if we hit the dropdown, we can see Go Test Network, Napoleon Test Network, and Linear Goli Test Network. These networks are test networks that resemble Ethereum or Polygon.

Or linear or arbitra or optimism or ZK sync or any other E V M compatible chain that we wanna work with. And again, we'll define E V M in the future and then we can actually switch the network that we're working on simply by clicking another network. So let's switch to selio. We can see our network changed up here, and now we can see we have zero seli eth.

So on ETH main net, this new account has zero Ethereum. And on the seia test Network we also have zero seia eth, which makes sense because this is a brand new wallet and we haven't put any money into this brand new account yet. So of course we have zero at the time of recording, SEIA is one of the most popular test networks out there, so we're gonna be working mainly with seia throughout this course.

However, testnet often change because again, they're run outta the goodness of people's hearts and sometimes people stop running them. You should absolutely have either the Web three dev.education site up or the GitHub repository associated with this course. And an important note, sometimes you'll see this as the Chain Excel org foundry fill course.

We recently renamed it to the Cipher Foundry fill course, so this is the correct link. But if you see chain excel org, that's fine as well. And you should scroll down to the recommended testnet section to make sure you're on the most up-to-date Testnet at the time of recording. Like I said, we're working with Selio throughout this course.

We are gonna show you how to work with different testnet and different networks as well because it's incredibly important to do so. The blockchain world is moving into a multi chain world, and especially with the popularity of L two s, which help Ethereum scale. Learning the differences between different chains and different L two s is incredibly important.

Now, same as Ethereum. What we can do is we can actually go to seia Ether scan. So we'll go to seia dot ether scan.io and we can grab our address from Meta by clicking and copying the address here, tasting it into the seia Explorer, and same as theum. We can see our account balance. We have zero eth, there are no transactions, no token transfers, nothing because obviously it's a brand new wallet.

Now I'm showing you this because pretty soon we're going to send our first ever blockchain transaction. If you've never sent a blockchain transaction before, we're gonna do it on this testnet to give you some confidence as what a transaction actually looks like when you do move over to a main net. And I'm showing you this site now because you're gonna see when we send a transaction, a lot of this information is going to get updated.

Now just remember, like I said earlier, a testnet is run under the goodness of people's hearts. So please use the transactions sparingly. Once you send your first transaction here. Try not to send too many more as one is good enough for you to see what's going on anyways, and in order for us to simulate one of these transactions, we're gonna go to a faucet for a testnet.

Testnet have this thing called faucets, which allow us to get some free seia ETH so that we can test out sending transactions and receiving transactions. If you go to the GitHub associated with this course or Web three Dev education, we can scroll down to this Testnet faucets section and select one of the links to go to one of these Testnet faucets.

Right now, the recommended faucet that we're working with is faucets chain link, but be sure to use the GitHub repo or web three dev education to be most up to date. What this is gonna do is we're gonna ask this faucet site to send us Testnet Ethereum, and this is why this TESTNET Ethereum isn't worth any real money since we can get it for free anytime that we want.

These obviously don't exist on main net. You can't get free main net Ethereum via a faucet. Now what we can do is we can actually connect our wallet to this site and we can get some free Testnet seia eth. This will make it so that in our balance here, we'll actually have some seia ETH to play with. So to do this, what we're gonna do is we're gonna go ahead and hit Connect Wallet, except the Chain Link terms of service.

I've already read them. Our meta mask is gonna pop up to connect it to this website. Now, get familiar with this interface because this is how websites will interact with our wallet and interact with the blockchain. Connecting our account to the site will first select the specific account that we want to connect.

We're just gonna choose account one. We'll hit next, and then we'll go ahead and hit Connect. And now we can see our wallet address in the top right, and we can see that we're connected on the Ethereum seia testnet. If we go up to our wallet and we actually switch to Ethereum main net, you can see that the website has actually changed this little dropdown to Ethereum main net.

And if we go in here, we can actually switch to Ethereum seia, and our meta mass will pop up with this Switch Network button, which will help us switch the network for us. So now we're back on seia Test Network. Connecting to these websites is how we give these websites a way to interact and connect with our wallets.

We can go ahead and select this, hit these three dots and hit disconnect this account. But don't worry, anytime we want to send a transaction, the website has to ask us if we want to send a transaction. So just by connecting to the site, it won't actually send a bunch of transactions for us. And if we scroll down, we can see our wallet address is placed right here, and we can see we can request Test link, and we can also request test eth.

For now, we don't need any test link, so we're gonna leave that off. But in the future, we will come back to the site to get some test link. For now, we're just gonna get 0.1 test Ethereum, and if all goes well, we should hopefully see it in our Seia Ether. In order for us to get this test, Ethereum, we do have to log in via Twitter.

If you don't have a Twitter, you can use any of the other faucets in the Testnet faucets area of the GitHub, such as the Alchemy seia Faucet, or the seia Proof of Work Faucet. But if you are on Twitter, now's a great time to gimme a follow. Maybe gimme a shout out and maybe say, Hey, sending my first transaction.

Thanks Patrick Alpha C, or not, whatever you want to do, just some light shilling of my own Twitter account. Anyways, we can log on via Twitter. We can authorize this app, verify that we're human. Give our AI overlords the prompt here. Oh, make sure we don't select the link. And let's go ahead and send the request.

Now what's gonna happen is it's gonna give us this transaction hash on Selio, and after a delay, we'll see it go from initiating to waiting for a confirmation to token transferred. And we'll see a transaction hash. And if we click the transaction hash, we'll see a transaction that was sent to our address.

So this will be the first transaction that we get to see. And there's a ton of information here, but the most important piece is if we open up our meta mask. Now we can see we now have 0.1 SEIA ETH in our account. And if we copied the address again, we paste it into here, we can see now we have a 0.1 ETH balance.

You might have to wait several minutes for the transaction to finish going through. And if you accidentally refresh your browser again, we can go ahead and just select our meta mask, copy our address, and paste it into Ether scan, or just view it right in our meta mask here. And if you miss that piece about the transaction data, if we go back to Ether scan with our address, remember we're on seia Ether scan and we scroll down, we can see this most recent transaction hash that just occurred.

And we can click the link here and we can see that detail about the transaction again here. Now importantly, remember though, this is on seia. If we switch back to main net Ethereum, you'll see we have zero ETH on main net Ethereum. If we switch to goli test Network, you'll see we have zero goli ETH on that network.

If we switch to linear, goli, ETH, or any other network other than seia, you'll see that seia is the only one that has the 0.1 pulia eth. If you want to practice working with a different testnet, feel free to scroll up back to the faucet, select a different testnet, and try to get testnet in one of these different test nets.

Just be sure to take a look at what Testnet your meta mass comes with. Since some of the networks this faucet is compatible with, don't come built into our meta mask. But again, like I said, in the future, I'll teach you how to add these different networks to our meta mask in the future. But huge congratulations.

You received your first transaction because again, this faucet is us asking them to send us money. It's not us sending money, it's them sending money to us. And if this is the first transaction that you've ever sent, you should be proud of yourself already. Give yourself a big pat on the back. And here's a picture of me holding a cat with that cat's face all over my pajamas, as a congratulations.

Now once more, let's grab our address, paste it into Ether, scan here and scroll down. And we're gonna learn a little bit more about what actually went down, what actually happened in this transaction. You can see on ETH scan, it gives us some basic details. It says from and two from is gonna be another address, a different address, an address controlled by the faucet.

And two is obviously going to be our address. And if we select this transaction hash, we can see even more details in here. Understanding all these different fields is essential to becoming a smart contract developer and even just a web three or Ethereum or blockchain user. So let's learn a bit of the basics of what's actually going down in this transaction.

The first field on this page is the transaction hash. You can even see a little question mark here, which tells you a little bit more about it. It's a unique identifier for this specific transaction on this network. So this specific transaction hash, we can even copy and paste this into the address bar and we'll get the exact same transaction back.

This is the only transaction in the entire blockchain that will have this transaction hash. It's the unique identifier. It identifies the transaction of sending 0.1 ETH from the faucet address to our address. We can see the status of this was successful. We can see the block number and the number of block confirmations, which we will explain in the future.

We can see the timestamp, which of course is when this transaction occurred. We can see the from and to who initialized the transaction and who it was sent to. If we select this from and open this in a new tab, we can see some details about who actually sent us this test E. And if we go back to the transaction detail and keep going, we can see the value here, which again, if we roll over, it's the value of Ether or Testnet Ether.

And then in parentheses, the fiat value or the dollar value, which of course, since this is a test net, it's always going to be zero. The value of this transaction was 0.1 eth.

<!-- L1-5 -->

 Now what's underneath this value thing, this transaction fee and this gas price thing. What are these? If we zoom in a lot more to these pieces here and we roll over transaction fee, we can see it says it's the amount paid to the block producer for processing the transaction.

And then gas price is going to be the cost per unit of gas specified for the transaction in Ether or G gu. The higher the gas price, the higher the chance of getting included in a block. I'm gonna explain that in a little bit, but if we scroll down even more, let's zoom back out and we click Click to show more.

We can see even more details about this transaction. For now, we're just gonna click to show less and just focus on the details that are here. So let's talk about just the concept of transaction fees and gas for a second, because they're important concepts for you to understand. Remember how I said that these blockchains are actually run by a group of different nodes?

Well, the question is, what's their economic incentive to keep running these blockchains? Are they running them outta the goodness of their heart? Well, on a real network, these nodes actually get paid a little bit of ether for processing transactions. Whenever you send a transaction, there is a node sometimes referred to as a minor or a validator, depending on the network you're on, who gets paid a little bit of the native currency of the blockchain to process that transaction.

For Ethereum, they obviously get paid in Ethereum or for test Ethereum. They get paid in test Ethereum, which again, the test Ethereum is worth nothing, which is why I said they're running them outta the goodness of their heart. If you're sending a transaction on the Polygon network, they're gonna get paid in madic, the native token of Polygon.

If you send a transaction on an L two like arbitrage or optimism, you're gonna get paid in eth, which is the native token of those L two s. This payment is obviously to incentivize people to continue to run notes, and they get paid more the more gas you use. So what is gas? Gas is a unit of computational measurement.

The more complex your transaction is, the more gas you have to pay. For example, if we hit more details, just really quickly, and I zoom in a little bit more, we can see this section here, gas limit and usage by transaction. This means that when we sent this transaction, we limited it to a maximum of 60,000 gas, but in total, we only used 21,000 gas.

This 21,000 gas represents how complex this transaction was. It was 21,000 gas units worth of complexity. Now, for simple things like sending ether, the units of gas are usually pretty small. For example, 21,000 units of gas is actually a really small amount of gas being sent. But maybe for more complex transactions like minting, an N F T, depositing some funds into a defi protocol or deploying a smart contract, those are typically gonna be more expensive transactions because they're more complicated, they have to do more stuff.

In the future, we'll introduce you to this concept of VM codes or OP codes, and if you break down a transaction to the lowest level, this assembly op code stuff, you can actually see exactly how much each op code costs in terms of gas. Don't worry about this at all right now. Just know that these transactions are broken down into many, many, many, many very, very small instructions, and each instruction has a specific amount of gas.

The more instructions usually means more gas. Like I said, we'll explain this much later in the course. Don't worry about this too much here, but just know that we use 21,000 gas. Now if you take this gas used and multiply it by the gas price in ETH instead of G Gray, so we'll take 21,000 and multiply it by this gas price in eth, not in G Gray, and hit enter.

Will see the total transaction fee of the transaction, and you can see that this number does indeed match the transaction fee. For you to understand how much ETH you're going to pay for your transaction. You multiply the gas price times the gas used transaction fee equals gas, price times gas used. So this means that whoever sent us this 0.1 ETH also paid 0.0 0 0 0 5 2 5, blah blah blah eth to a blockchain node to a validator on the seia Ethereum testnet.

Now each blockchain has their own unique way of calculating how much transaction fee someone's actually going to pay for most E V M chains. This is the simple algorithm. It's going to be gas used times gas price. After we understand how the blockchain works more in depth, I'll explain to you what the rest of these values stand for.

For now, just know that anytime you make a transaction on chain, you have to pay the validators or the blockchain nodes a little bit of gas or a little bit of the native token of the blockchain, which in our case is eth. So you have to pay a little bit of ETH to the blockchain nodes providing or sending the transaction.

Sometimes I'll refer to this just as transaction gas. Let's look at an example of this ourselves. If we pull up our meta mask, we go ahead and hit expand view. As we know, we have two different accounts in here. We have account one and account two. Count one has 0.1, seia ETH account two has zero seia eth.

If I send 0.05 from account one to account two, how much do you think I'll have left in account one? Let's go ahead and do this, and this is going to be the first transaction that you send on the blockchain, which is incredibly exciting as well. Let's go ahead and hit this send button in our meta mask.

We'll hit send, we'll hit transfer between my accounts, we'll select account two and we'll say 0.05 SEIA eth. So we started with 0.1 ETH and we're gonna send 0.05 to account two. We'll scroll down, we'll hit next. We can see some information here about what's actually going on. We can see some gas information, which mem mask automatically prompted for us, and it even gives us the total amount that we're going to be paying in eth.

It's adding this 0.05 ETH to the estimated amount of gas that we actually have to spend, so that at the bottom it says the amount plus the gas fee is the two of those combined, the value that we're sending plus the gas fee. And additionally in meta mask. If you select this here, you can get some more information about editing our gas fees, the amount of gas that you choose to spend can be different depending on how many people are making transactions at the blockchain.

The more people are sending transactions at the same time, the more expensive gas costs are going to be. So if a lot of other people are also sending transactions right now, The gas price is going to be higher. If a lot of people are sending transactions, that means there's not gonna be enough space for everyone's transaction to get through.

So in order to throttle that, they increase the gas price. That's a bit of an oversimplification of what's happening. But if you take that understanding, that'll pretty much work. If you want to specify exactly how much gas you wanna spend, you can collect the advanced tab. If you select zero gas, there's a high likelihood that your transaction will never go through.

So we're just gonna go with a default, which is usually a good idea. So let's go ahead and confirm. We now see a send transaction in our queue in the activity tab of our meta mask, which shows us that we have a transaction currently sending. And if we click on it and click view on Block Explorer, it'll actually open us up on Ether Scan and we'll see.

Well, mine was a little bit quick, but normally we'll see a little indexing tab and we won't see this having gone through. We'll see it as like indexing or sending or something like that. But after a little bit, it'll actually finish sending, you might have to wait a minute or so for this to actually finish going through, but it looks like mine was really quick and same as our last transaction.

This has a lot of the same information. And if we scroll down, we'll see that. Of course, we send a different amount of ETH 0.05, and we have a different transaction fee. Now if we pull up our meta mask, what do you think that we're gonna see? We're gonna go ahead and click Expand View again, and we see account one says 0.05, and account two also says 0.05.

Hmm, that's kind of odd. I thought we spent some gas. Well, if we click on the big accounts button, you can see exactly how much E is in each account. You can see we have 0.0499 in account one and 0.05 in account two. And we can see in our activity history, our account one recently sent 0.05 E, and account two recently received 0.05 seia eth.

Now, here's the best part of all this. Even if you don't wanna become a developer, you just learned the basics of sending a transaction and interacting with sites using your meta mask. Congratulations. Now, here's something that's incredibly exciting with just this little bit of information. You now know how to interact with blockchains and interact with the Ethereum protocol.

So if you don't wanna learn how to code anything, you can go and you can start interacting with Ethereum and interacting with protocols with just this much information. However, I know most of you guys are here to learn how to code. So let's look under the hood of Ethereum and what is actually going on with these transactions and with these gas and with these blockchains and what's really going on.

Let's learn all the fundamentals of a blockchain. Now, if you wanna just go ahead and jump into the coding, go ahead and grab a timestamp from the description. However, learning exactly how the blockchain works is gonna make you an incredibly powerful developer. So let's take a look at that first. So we're gonna be going through this blockchain demo on this site right here.

Now, the creator of the site has a fantastic video and a fantastic walkthrough. Blockchain 1 0 1. It is right on their site. So if you're looking for another explanation, definitely check out his video. It is absolutely fantastic. But the first thing that we really need to do in order to understand blockchain, in order to sound really anything and everything that's going on here, we first really need to understand this SHA 2 56 hash or hashing, just kind of in general.

Let's first understand what a hash is. A hash is a unique fixed length string meant to identify any piece of data they are created by putting some piece of data into a hash function. In this example, uh, the hashing algorithm used is s Shah 2 56. Now Ethereum actually uses, uh, this, uh, this right here for its hashing algorithm, which isn't quite, um, s Shah 2 56, but is in kind of this s Shah family.

But it's, it's really just another way to hash things and, uh, the specific hash algorithm doesn't matter, uh, so much. So, uh, this example uses shot 2 56, but you can imagine it's the same as the Ethereum hash. They're just gonna, you know, result in a different hash. So what's gonna happen in this application here is whatever data or whatever information we put into this data section here, as you can see below this hash changes.

So what's happening is this data is running through this SHA 2 56 hash algorithm and it's outputting this unique hash. So this hash is a unique fixed length string that's going to identify like a blank data piece here, right? So if I put in, you know, my name, like, you know Patrick Collins, this is the hash that's going to represent Patrick Collins, right?

And you can see even when I put, you know, tons and tons of data in here, the length of the string doesn't change, right? So it's always gonna be the same amount. We can put almost any amount of data in here. There is an upper limit on the max size of the data, but for all intents and purposes, we can pretty much put any length in here.

And you'll see too that, you know, every time I type in Patrick Collins, this hash is always gonna be this seven E five B, right? I'm gonna delete it. I'm gonna do Patrick Collins again, you know, seven E five B. It's always this, this unique hash is always going to be unique, right? It's always gonna be this fixed length string here.

So now we can take this idea, right, of putting this data in here and we can move on to, uh, this concept of a block. So with this block concept, we're gonna take the exact same thing with this hash this, this data section, right? But instead of having everything just be in this, this singular data area right here, we're gonna split this data up into block nuns and data.

So all, so what we're gonna do is we're actually gonna hash all three of these to get, to get this hash right. We're gonna put all three of these. We're gonna say all three of these are combined, uh, together. We're gonna put every, all three of them into this hashing algorithm, uh, to figure it out. So if I type a bunch of stuff here, We can see that block one with nuns, you know, this nuns and this data.

We're gonna get this hash, and as you can see, actually the screen turns red. This block turned red. Now what happens when I hit this mind button, when I hit this mind button, it's actually gonna take some time. It's gonna think for a little bit. And we can see that the nuns here actually changed, right? The nuns is different from what it was before.

And this hash now starts with four zeros, okay? And then it, the, the back turned green. When, when we're talking about mining, we're talking about miners solving some type of very difficult problem that takes a lot of time to do. Now, in this example here, the problem that, uh, the miners had to solve was they had to find ANU or, or a value in this nun section that went hashed with at block number one with this data, it would start with four zeros.

So the problem here the miners had to solve was to start with four zeros. And the only way for them to really do that is kinda this brute force, you know, trying stuff. So they tried one, okay, one didn't work. Okay, two, nope, two didn't work. Three, no, four or five. Six. Okay, five. Well, that started with one zero, but that's not four.

And they have to keep trying all these numbers until they, uh, get to this one where, you know, let's hit mine again where it has four zeros at the top at the start. Now this specific problem changes blockchain to blockchain, right? Ethereum has a, a different problem for minors to solve. Um, Bitcoin has different problems for minors solve, but this concept is gonna be the same.

And since Ethereum is proof of stake, now nodes actually take turns solving these problems. Again, we're not gonna go too deep into that right now though. So they have to take, um, one block is gonna be this, this, uh, this concept is gonna be all this data. It's gonna be the block number and it's gonna be this nuts, right?

And so this nuts is the solution, um, is, is gonna be the, the number that they use to get like the solution to the problem, right? So if I go to one here, you know, and I do this again, I'm gonna hit mine and the nuns has changed, right? It went from one to 33,128 cuz this is the nuns that allowed this hash to start with four zeros.

And so that's what's happening when, uh, blockchain miners are mining. They're going through this process, this very computationally intensive process of trying to find ANU that fulfills whatever the problem is. So that's really it actually. So that's a block and, and that's really what's happening when miners are mining.

They're just looking, there's trial and error, brute force trying to find this nut. So, so now that we know what a block is, let's go to the next step and figure out, okay, well. What's a blockchain? So here we have an example of what a blockchain is gonna look like, right? We have a combination, you know, we have back here in the block section, we have one, what one block looks like.

Now here we have multiple different blocks, right? Each one of these represents a different block, but we have an additional column here or we have additional, uh, variable here. So like before, you know, we have block nuns and data, right? We have block nuns data, but we also have this thing called previous, right?

And so this is actually gonna be pointing to the previous hash of the last block. So for example, if we go to the, the last block in this blockchain, it says previous is zero zero a e eight. And if we look at the hash of block number four, it's 0 0 0 0 a e eight. And then we look at its previous, it's uh, four zeros B nine, we have four zeros, B nine, and so on, all the way back to our first block, which has previous of just all zeros, right?

And so the block with the previous of all zeros is going to be known as the genesis block. So you've probably heard that before the Genesis block. It's the first block in the blockchain where the previous hash points to a hash that, uh, doesn't actually exist. Now, as you can imagine, kinda the same as how this block worked, how the block nuts and dated all go through the hashing algorithm in the blockchain.

The block nuns data and previous hash all go through this hashing algorithm to figure out, you know, what the hash is. Okay? So if we go to over here, you know, for example, if I type in, you know, Patrick, obviously this is now no longer valid, right? Because this nuns, uh, combined with the block, the data in the previous hash aren't gonna solve, you know, our problem of having four zeros at the, at the start, right?

So I'm gonna go ahead and fix that and, and that's, that's kind of an easy way to, to see it being broken. But h but let's take a look. If I break this block right here, what happens if I, if I break the data in here, if I do like Patrick in here, you can see that both of these are now read, both of these are now invalid, right?

Because the block hash with the nuns hash with the new data, which is my name, Patrick Hash, with the pre hashed with the previous block, is now a brand new hash, right? And this block is still pointing to this previous hash right here, right? Is pointing to this previous block and now it is wrong and it is messed up.

And now, um, and now it's nuns with this previous hash is also wrong, right? And this is where when we talk about, uh, blockchains being immutable, this is exactly how it's immutable, right? Because if I go back and I change anything, you know, if I just typed a right here, the entire blockchain is now invalidated because none of these are going to have, uh, nuns that solve this equation anymore.

So this is why blockchains are immutable is because anytime you change one thing, you ruin the rest of the blockchain, okay? So however though, you know, if, if an A was here originally, we can go ahead and mine these. We can mine all these. But as you can see, you know, this is going to start getting very.

Computationally expensive cuz I have to go redo, uh, basically the entire blockchain. Uh, and the farther and farther down the line you get the harder and harder it becomes to, you know, rehash and, and redo all these different blockchains here. Now this makes a lot of sense, right? So we have this blockchain, it's really hard to change something in the past, but if we do, we can just go ahead and remind it.

Now, if I'm the one who controls the blockchain, right? If I'm the one who controls this, you know, and, and I wanna change something in the past, well, okay, great. All I gotta do is change this data here and then, you know, mine, each one of these, you know, obviously it's gonna be very computationally expensive, but it's something that I can do, right?

If I'm the one who owns the blockchain. Now, here's where the decentralized nature or the distributed nature really, uh, makes it incredibly powerful. So we're gonna go to the distributed tab here, which uh, I also refer to as the decentralized tab here. Uh, and it's going to show us what a blockchain looks like, uh, in a decentralized manner.

So we have this exact same, uh, initial setup here. We have distributed blockchain, we have, you know, the, our first blockchain, which is kind of exactly as the one from here, but we also have more than once we have peer A, peer B, and peer C. And when people are talking about peer-to-peer, peer-to-peer transactions, they're really talking.

Uh, this is kind of that concept that they're talking about, right? So we have a number of different peers who are running this blockchain technology. They're all weighted equally, right? Each one of these peers or each one of these nodes, each one of these entities running a blockchain has the exact same power as anybody else, right?

So the way that we can tell very easily which blockchain is correct or which ones are correct, are by looking at this end hash here, right? Are by looking at where we are, uh, in the blockchain. Cuz again, remember because again, remember this, this hash that this, this in this last block here is going to encompass all of the blocks from before, right?

Cuz this last hash is gonna have the previous hash here, which includes the previous hash here, which this hash includes the previous hash here, and which, so this last hash is encompasses everything in here, right? And we can look, we can look at the hash of p c, which is four zeros, and then E four B we can look at the latest hash of p b, which is four zeros E four B, and then peer A, which is four zeros E four B.

So all of these peers, all of these nodes, all of these decentralized, you know, these independent, um, all these independent users running this blockchain software, they're all matched up. It's very easy for their nodes to look at each other and say, Hey, great, we are all matched up. Now what, let's say that a decides that, you know, something happened on the blockchain that they didn't like and they wanted to go back and change something, right?

So let's say they change here, you know, obviously, uh, the rest of their blockchain is invalidated and they have to spend a lot of computational power to catch up to speed. So let's go ahead and humor it. Let's say that they, they did, they ended up catching up, uh, they ended up catching up, you know, they ended up mining everything.

And now they have a valid blockchain, right? It solves the equation. Awesome. However, in block number three, there's something new, right? This is here and it shouldn't have been here. This is something that peer A put in by themselves. All that happens now is we look at all the blockchains that are running the software, and we're looking at all the hashes at hash at block number five.

So p a has this new hash now 0, 0, 0 9 bc but p B has a different hash 0 0 0 E four B, right? So who's right? Is it? Is it pure A with their new stuff or is it peer B? Well, that's where the decentralizing comes in cuz then we can look at peer C and peer C also has E four B. So peer B and peer C both say, Hey, peer A, you're wrong.

Get out. Right? And peer A will stop being able to participate in the mining rewards because they have essentially forked, uh, the blockchain and started their own little blockchain, right? With their own history, because they're the only ones with this, this piece of data in block three. Whereas peer B and peer C have nothing in there.

So that really shows why, uh, in these blockchain worlds, in this decentralized world, there really is no centralized entity. You know, peer A, you know, might have been maliciously motivated to change. You know, this, this block number three, however, democracy rules, right? The majority rules in the blockchain, peer B and peer PC both say, Hey, you know that that's cute and all pure A, but you're wrong, right?

That that's not right. Now it might be a little abstract that should just look at data and, you know, us typing kind of random stuff in here and think, okay, yeah, that's, that's data, right? That makes sense. You know, just kind of random strings in here doesn't really do anything for us. So if we actually go over to the token section here, this is where everything really starts to make a lot of sense.

So we have the exact same setup here, uh, with peer A, peer B, peer C, except the difference is instead of having kind of this, this data section, we have this, uh, tx, this transaction section, right? And this represents all the transactions that are happening in this block, right? So we're, we're sending $25 from Darcy to bingo or to Bingley, uh, four, uh, $4 and 27 cents here, uh, 1922, right?

And it's the exact same thing. So this, all these transactions are gonna get hashed in the exact same way, uh, that the data is gonna get hashed. And, and this is why it's so powerful, because again, you know, if I want to be malicious, right? If, uh, if I wanted to say, Hey, I, I really wanted to give Jane a lot more money from Elizabeth, so I'm puree and I go back and I change it to a hundred, well, now, you know, not only do I does my whole blockchain, uh, get invalidated because that was so far, uh, so long ago, but I'm not gonna match any of these other chains, right?

And so my blockchain is gonna be excluded from the overall blockchain. So, and let's, let's go ahead and fix this. And it's the same thing if down here if I, I become malicious and I wanna send, you know, I want, uh, Miss Audrey to have less money. Maybe I wanna send a dollar and I go ahead and mine it. The same thing here, this hash.

Now this two A one is not gonna match tier B's, your B'S hash of BBA, and it's not gonna match P c's hash of BBA as well. So the two of them are gonna say, Hey, this, your blockchain is invalid. It's not matching the majority, you know, you're out, right? So that's really how, uh, these blockchains work at a low level.

And it all goes back to this, this understanding, this hash idea and using it in this very sophisticated manner, uh, to kind of cryptographically prove, um, you know, where, where stuff lies. Now the way the blockchain works is you, instead of random stuff put in this data section, it's actually gonna be solidity code in here.

Defining ways to interact with different blocks and different protocols that are on chain, or as we've said before, different smart contracts. Now, the next question that you might be asking is, okay, well how do I know? How can I be sure that I'm the one, uh, you know, let's say this is, let's say I'm Darcy, right?

How can I be sure that I was, that Darcy was the one to actually send this money here? How do we know that Darcy sent $25 to, uh, Bingley? Well, this is where we get into, uh, private keys and public keys, and that's what we're gonna go into. Now, let's just do a quick recap of what we've learned in this section so far.

Right? We've learned that Ethereum actually runs on this catch check 2 56, but you know, we used shot vid six for this demo. It doesn't really matter. We're just talking about a hashing algorithms. So again, a hash is a unique fixed length string meant to identify any piece of data. A hash algorithm or a hash function is a function or algorithm that computes any type of data into a unique hash mining is gonna be the process of finding the solution to the blockchain problem.

In our example, the problem was finding a hash that starts with four zeros. Nodes get paid for mining different blocks, and the problem is gonna be different. Blockchain to blockchain. A block in a blockchain is basically a combination of a block nuns transaction and a previous hash to create this unique hash for this block.

And again, depending on the blockchain implementation, this might have a couple other fields or might have different fields, but this is essentially what's going on. Blockchains are decentralized and distributed because many independent users are gonna run this blockchain software and it will check and they'll compare against each other to see which blockchains are acting honestly and which ones are acting maliciously in the blockchain world, majority rules the nuns.

Here is the answer used or the number used to get this hash. Now, nuns is kind of an overloaded term. It's actually used for a number of different reasons. In this case, we're using it to solve this problem of getting, you know, four or five zeros at the stop or the hash. However, in Ethereum, it'll also all be often used as the number of transactions from a given address.

So now we're gonna talk a little bit about signing these transactions and, and private keys and, and some other cryptography pieces, right? Because in this blockchain demo here, we can see we have all these, these fantastic transactions, right? All these things went through. But how do we know that it was Darcy who was the one to send $25, uh, to Bingley, right?

How do we know that actually happened? And this is where all those pieces that we just learned about, uh, in our, our testnet in our meta mask account are really gonna start to, to come to life here a little bit here. So here we have an example of public and private keys, okay? At the top we have this private key, right?

That was, that was randomly generated. Uh, a private key is, is, you know, as it kinda states is a key that you really wanna keep secret because you're gonna be using this, uh, as kind of your, your secret password for all your transactions, right? I can really pick, you know, any, any, any private key, anything that I want.

And with it, uh, this algorithm, uh, they're gonna use an algorithm, you know, for Ethereum and Bitcoin, they both use this elliptic curve digital signature, uh, algorithm. It's, it's a variant of just, uh, a digital signature algorithm and it's gonna create this, this public key, right? I'm really not gonna go at all into kind of this digital signature algorithm, but just know it does use some of these, uh, some of the hash, uh, knowledge that we just learned combined with some other pieces, uh, to kind of get this, this public key here.

So I'm not gonna go too deep into it, but we have this private key that we create and we get this public key. Now, this public key, we want everybody to have access to, right? This is, yeah, whole world can see this, this private key. We really want it to be, uh, private. We don't want people to see this. We're going to use this private key as like a password to quote unquote digitally sign transactions.

And then people can verify them with this public key. So let's, let's see what this actually looks like. Let's pick a, a random key, a more secure key, right? Cuz the longer it is, the, the more secure it's gonna be. And if we go to signatures now, right? Um, let's say we have this, uh, this message that we want, right?

Let's say high world, right? We want this to be the message. What's gonna happen is this private key that we've created we can use to sign this data, right? Remember how in the blockchain demo, you know, we were kind of, we were hashing stuff, right? We were, we're using this, uh, SHA 2 56 hash to, to get this hash.

Well, we're doing something similar, but instead of hashing, we're, we're using this digital signature algorithm to create this message signature. Now, what's really powerful about how this, uh, this algorithm works is that you can create this message signature with your private key, but somebody else can't derive your private key from the message signature.

And that's what makes this really, really powerful. However, if we go to verify using this public key, right? Uh, and so this is the. This is that oh 4 0 3, this is that same public key using this, uh, using this public key. Anybody can verify, oh, let's go ahead and sign it again. Anybody can verify that this signature is yours, right?

So you have a pub, a private key just for you, so you can sign things and a public key that anybody can verify something, right? So anybody can verify this. And let's say somebody tries to fake a transaction from you. They say, Hey, you know, this is, this is, this is their transaction. Um, all they have to do is verify that this signature against your, uh, public key, and very easily this whole thing turns red because, uh, it isn't verified, right?

The, the algorithm says, Hey, Uhuh, that's wrong. So we can go ahead and take that into transactions in this exact same way. So if I wanna send money, you know, if I wanna send $400 from, you know, my address to another address using my private key, I can sign that transaction and anybody else in the world can then verify this transaction, right?

And this is why when people say, hide your keys, you know, protect your keys. This is what we're talking about in our accounts here, right? If we go to, uh, settings, and again, the only reason that I'm showing you guys my pneumonic and my private key is because this is a, uh, this is a, a dumpster account. I'm gonna throw this away at the end of this video, or I'm just not gonna put any real money in it.

Um, but when we look at our, our, our meta mask here, we have this pneumonic phrase, which allows us to easily get these different private keys, right? So, uh, pneumonic phrase combined, uh, with, you know, uh, whatever account number will get us a private key. So pneumonic phrase, combined with one, we're gonna get this private key, and this is when we look at account details, export private key

password, confirm this is gonna be the private key that we're gonna use to sign our transactions, right? This, if anybody else gets access to this private key, they then can sign transactions for us and they can send transactions for us. And that's why we want to keep these private. So, uh, they, it works the exact same way, right?

And so this is why it's so important to hide your private keys and hide your pneumonics. Now your Ethereum address is actually, uh, a piece, uh, is actually a piece of your public key. Now to get our address in Ethereum, all we have to do is take this public key that we've created with our private key, hash it using that same Ethereum hashing algorithm, and then take the last 20 bytes.

And that's how we'll actually derive to our, um, to our address here. Now knowing the exact methodology of how to get the address doesn't really matter cuz it could change blockchain to blockchain and could even change in need two. Um, but just know that that is essentially how kinda these addresses are derived, right?

There's some derivative of the public key, right? Because the public key is public and you know, uh, using the public key in kind of any public way is, is totally fine. Um, but not the private key. So that is how we sign our transactions. Note though, this isn't how we send the transactions, so, so this is just gonna sign it, create a transaction for us to send, uh, we'll learn later on how to send these transactions.

Whew. So that was a lot of information there too. Let's do a quick recap. Your public key is derived by using a digital signature algorithm on your private key, right? And you wanna keep your private key private at all times because you're gonna use your private key to sign transactions, signing transactions with your private key.

You are the only one who can actually do this because you can't get the private key from a message signature. However, using your public key, you can, anybody can very easily verify that a signature that's signed by you is in fact signed by you in our meta mask. Our private keys are located in this account details section.

You just hit, uh, show private keys and type in your password and it'll get your, your private key here. And the address of your account is derived from this private key. Uh, and it's derived from this public key. So if you think about it, your private key creates your public key, which then can create your address.

And there's a little barrier or big barrier here cuz your private key, you wanna keep private and your public key and your address can all be public information. Now remember how in our meta mask we were able to actually create new accounts. Mine says account six cuz I've created actually a few. But how was it actually creating those accounts?

Well, now that we know all this, if we go back to our blockchain demo here, what our meta mask is doing is essentially taking our pneumonic or, or that multi word secret phrase and then just hashing it with some number. So secret phrase plus zero gets this and it'll set this as your private key. And for our account, one that'll be the private key or maybe it's plus one the exact algorithm that it's using doesn't matter.

But if you want to create a new private key where you just hit this create account button, the way it actually picks this account is by taking this secret phrase and then just changing this number. So if I go, if I'm on my meta mask, I do create account this, right now I'm on account six. Cuz like I said, I'm, I made a whole bunch if I make account six, right?

It's as if we just did the secret phrase plus six and created this new hash or this new private key and created this new hash. And it uses this to make a private key. And this is why in your meta mask, if you share that secret phrase, if you share that pneumonic device, they will have access to all the accounts that you ever created.

However, if you share your private key, it will just give them access to that single account. Secret phrase has access to all the accounts created in your meta mask or your wallet. Your private key is access to that single account and the public key or address anybody can have access to. And it's cool for anybody to have access to.

So when I'm thinking about the security of my meta mask or my wallet, this is kind of the order that I think of it in the seed phrase or pneumonic or secret phrase is incredibly important. Protect this at all costs because if somebody else gets access to this, they will have access to all of your accounts.

The second most important is the private key, because if somebody gets access to that, they will get access to a single account. And then your public key, your address, which whatever, it's public.

Now that we know a little bit more about what's going on underneath the hood of these blockchains, let's go back at our transactions and look at this gas thing again and we'll look to see what's actually happening here. Gas in particular can be a little bit tricky to wrap your head around. So if you don't get it right away, don't worry.

As we go through examples, it'll start to make more sense. So before I was saying let's just look at this transaction feed bit, which is the cost of associated with running this transaction. If I scroll over this on Ether scan, I can see this thing that says block base fee per gas, plus max priority fee per gas times the gas use, which might be a little bit confusing here.

Let's actually break down what's going on on Ethereum with e i p 1559 in place. And again, this is gonna be specific to Ethereum as every blockchain might do it a little bit differently. But if we click to see more, we can see a number of useful values. Here we can see gas limit is 21,000 and usage is 21,000.

So this transaction used 21,000 gas and we sent 21,000 gas along with it. Sometimes when sending a transaction, depending on when it's sent, and depending on what the specific instructions are, it might actually use way more gas than what you want it to use. So with your transactions, you can actually set a limit.

Hey, I don't want to use more than X amount of gas. I don't wanna do more than X computational units. And in fact, if we go to our meta mask and we click send to transfer between accounts again and we pick, you know, 0.01 ETH or something next, can actually hit this little button here, go to advanced, and we can actually edit some specifics of this transaction.

One of them is gonna be the gas limit. We can change this gas limit to maybe 2200, 2300 or more or even less since sending Ethereum takes exactly 21,000 gas meta mass just defaults to setting into that. But we also see these other interesting things. We see a priority fee and a max base fee. Let's reject this transaction and let's look back at Ether scan to talk about these.

So currently in Ethereum, according to E E I P 1 5 59, every transaction on Ethereum comes with something called the base fee. This is the minimum gas price you need to set to include your transaction. And you'll notice that these are priced in something called gu. So what is a gu? If we come to the site, econ converter.com, and again, there's a link to this in the GitHub repository.

We scroll down, we can see Wewe and Ether. If I put one ether in here, I can see how much one Ether is in terms of Gwe. And in terms of way, one ether is equal to 1, 2, 3, 4, 5, 6, 7, 8, 9, 9, 0. So that's, that's 1 billion. Gwe is gonna be one ether, and then 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, and then 18 zeros is away.

These are just easier ways of referring to really, really small amounts of Ethereum. So if we look at our gas fees, we see that the base fee is 0.0 0 0 0 0 0 0 4 away. And this obviously would be an even smaller number if this was in units of way. So if we take this number and we put it into our calculator, we can see that this is equal to 40 way or 0.0 0 0, 0 0, a whole bunch of zeros for Ether.

The max fee here refers to the maximum gas fee that we're willing to pay for this transaction. And you can actually see that our max fee is a little bit higher than what we actually ended up paying. Our max fee was 2.2 1, 3 2 something, something, and the gas price we actually paid was up here. Now your transaction might of course be a little bit different.

Then additionally, we have a max priority fee. This is gonna be the max gas fee that we're willing to pay, plus the max tip that we're willing to give to miners. Now, currently in Ethereum, this base fee ends up getting burnt and we can see on Ether scan it exactly how much is getting burnt here. And if we pull our calculator again, we can grab this gas fee, multiply it by the amount of gas we used, and we can see that this is indeed how much Ethereum we actually end up burning.

We go back to Ethereum converter, paste it in. We can see that these two numbers are indeed equal. This means whenever you send a transaction, a little bit of Ethereum is removed from circulation forever, or it's considered burnt. So currently in Ethereum, part of your Ethereum, part of your transaction fee actually gets burnt, and then the other part goes directly to minors.

So to figure out exactly how much went to minors, we could do this. Number minus. The burnt amount, and this is how much Ethereum was paid to an Ethereum minor for this transaction. You'll see down here transaction type two e i P 1559. This is the e I P 1559 version of these transactions. Like I said, every blockchain is gonna have a different fee burning and fee and gas process, and they're all gonna be a little bit different.

But the sum of it is blockchains have limited block space for transactions. The gas price that costs for your transaction to be included in one of these blocks changes based off how much demand there is. The base gas fee for Ethereum will go up and down depending on how many people are sending transactions and how many people want to be included in a block.

If a ton of people want to be included in a block, that means a ton of gas is obviously gonna get burnt. We've left a link to a video in the GitHub repository with this section from this YouTuber who does an amazing job breaking down this e i P 1559 and more about how this gas model AC actually works.

I highly recommend you pause this video and watch that video to understand more. The base fee gets programmatically, algorithmically adjusted to try to target for all the blocks to be 50% full. If they're more than 50% full, this base fee automatically goes up. If they're less than 50% full, this base fee goes down.

Now, this is a lot of the basics of how this transaction works, and it can be a little confusing, so let's do a quick refresher of everything in here. There's a unique transaction hash that uniquely identifies this transaction on this blockchain. We can see the status, we can see the block number that it's confirmed on.

One other thing we wanna look at, if we scroll up, we see block number and block confirmations. This is how many blocks have been mined since this block was included, like we saw with our blockchain demo. The longer the blockchain gets, the harder it is to tamper with and the more secure it is. Typically, you'll see some processes say they'll only do something after 20 block confirmations, 30 block confirmations, or, or et cetera.

The reason that they wait for these block confirmations is because they want to make sure that that transaction is actually included, and we can actually see the block that our transaction was included in and all the other transactions with it, different details about how much gas was used, the gas limit, et cetera.

Timestamp is when the transaction happened. We can see from, and two, we can see the value and then we can see the transaction fee. Which we see right here is block base fee per gas, plus the max priority fee per gas times the gas used, and we see all the details of the gas down here. Gas price is the cost of one unit of gas.

Gas limit is the max amount of units of gas that were willing to pay in this transaction. The usage is how many actually got used. The base fee is gonna be the base network fee per gas, so 40 way per one gas used. The max gas is the max gas price we're willing to pay, and max priority is gonna be the max gas price per the tip that we give to miners, and then we can see how much is burnt.

And then we see transaction savings, which which is the difference between how much was actually used or paid for and then returned. So for example, in this transaction, the gas price we ended up picking was a little less than our max gas price here. So the gas price we ended up using was a little less than our max priority fee here, so we had some savings compared to that.

We can also see that this was an EIP 1559 transaction. We can see our nuns here, which was nuns zero because the transaction that I'm showing is our first nuns. And then of course, we can see the input data for transactions that are just sending Ethereum. The input data is gonna be blank, but you'll see that when we get to smart contracts, the input data is not gonna be blank and it's gonna be one of the most important features of these transactions.

You'll also notice that there's a state tab. This is an advanced tab, and it shows the different states that are changed based off of this transaction. We're gonna ignore this one for now. Now that we know how the blockchain itself works under the hood, let's talk about some blockchain fundamentals and we actually covered all these topics in a previous free code camp video.

So let's go to that. If the first time you listened to this, some of these concepts seem a little bit hard to grasp, don't worry about it. As we continue and as we move on with this course, they'll start to make more sense when you see them used in real examples. I definitely would recommend going back and rewatching and re-listening to the parts that you don't quite get and asking quite questions in the discussions tab of the GitHub repository.

Awesome. So now that we know all the cryptography pieces and all the little nitty gritties of how the blockchain actually works and how our signatures work and how everything sticks together, let's talk a little bit about how this works. In actuality and what's really going on now for a lot of this, each different blockchain has slightly different algorithms and slightly different metrics and criteria for doing a lot of this stuff.

So when we're talking about these specific implementations, keep in mind the exact algorithm might be a little bit different, but the concepts are all still gonna be exactly the same. Hashing and a hash function is gonna be the same no matter where you look. A decentralized blockchain is gonna be the same no matter where you look.

How it's actually implemented is gonna be a little bit different. Now, traditionally, when you run an application, you know, be it a website or something that connects to some server, you are interacting with a centralized entity. And unlike how we saw with the blockchain with multiple different peers, it's going to be run by a single centralized group.

Now, it still could be run on many different servers, but all those servers are still gonna be controlled by the same centralized group. Blockchains, as we saw, run on a network of different independent nodes. When we saw peer A, peer B, peer C, those were different examples of different independent users running the blockchain technology on their own node.

Now, when I use the term node, I'm usually referring to a single instance of a decentralized system. So when I say a single node, when I'm talking about a blockchain, I'm talking about one of those pure a's pure B's, peer Cs, running that blockchain software. I'm talking about one server running this technology, and again, it's this network, it's this combination of these nodes interacting with each other that creates this entire blockchain.

What makes these so potent too is that anybody can join the network, and that's why there's decentralized. The barrier to entry is a little bit of hardware requirements. You're getting the correct materials to run the software, and then you running the software. Anybody can join these networks and participate, and that's what makes it truly decentralized.

In fact, you can go to GitHub right now and run your own Ethereum node in a few seconds. Now, in the traditional world, applications are run by centralized entities, and if that entity goes down or is maliciously bribed or decides that they wanna shut off, they just can't because they're the ones that control everything.

Blockchains by contrast, don't have this problem. If one node or one entity that runs several nodes goes down, since there are so many other independent nodes running that it doesn't matter, the blockchain and the system will persist so long as there is at least one node always running. And luckily for us, most of the most popular chains like Bitcoin and Ethereum have thousands and thousands of nodes.

And as we showed in our demo, if one note acts maliciously. All the other nodes will ignore that node and kick that out or, or even punish it in some systems because they can easily check everybody else's node and see, Hmm, okay, this one is out of sync with the majority. And yes, majority rules when it comes to the blockchain.

Each blockchain keeps a full list of every transaction and interaction that's happened on that blockchain. And we saw if FA node tries to act maliciously, then all their hashes are gonna be way out of whack and they're not gonna match everybody else. This gives blockchains this incredibly potent immutability trait where nothing can be changed or corrupted.

So in essence, we can think of a blockchain as a decentralized database, and with Ethereum it has an extra additional feature where it also can do computation in a decentralized manner. Now let's talk consensus, proof of work and proof of stake, because you've probably heard these before and they're really important to how these blockchains actually work.

When we went through that blockchain example and we did that mining feature, this is what's known as proof of work. Proof of work, and proof of stake fall under this umbrella of consensus. And consensus is a really important topic when it comes to blockchains. Consensus is defined as the mechanism used to reach an agreement on the state or a single value on the blockchain, especially in a decentralized system.

I briefly alluded to this consensus mechanism in our blockchain example when I said, if one changes something and the other two don't, then majority will rule and kick that one out. This is part of that consensus mechanism. Now, very roughly, a consensus protocol in a blockchain or decentralized system can be broken down into two pieces.

A chain selection algorithm and a civil resistance mechanism. That mining piece that we were doing or or the proof of work algorithm is what's known as a civil resistance mechanism, and this is what Ethereum and Bitcoin currently use. Please note that depending on when you're watching this, if ETH two is out, then it's no longer proof of work.

Now, proof of work is known as a civil resistance mechanism because it defines a way to figure out who is the block author, which node is gonna be the node who did the work to find that mine and be the author of that block so all the other nodes can verify that it's accurate. Civil resistance is a blockchain's ability to defend against users, creating a large number of pseudo anonymous identities to gain a disproportionately advantageous influence over said system.

And in layman's terms, it's basically a way for a blockchain to defend against somebody making a bunch of fake blockchains so that they can get more and more rewards. Now, there are two types of civil resistance mechanisms that we're gonna talk about here, namely proof of work and proof of stake. Let's talk about proof of work a little bit more in depth.

First in proof of work, this is civil resistant because a single note has to go through a very computationally expensive, uh, process called mining, which we demonstrated earlier to figure out the answer to the blockchain's riddle of finding that correct nuts or, or whatever the blockchain system has in place.

And proof of work. This works because. No matter how many pseudo anonymous accounts you make, each one still has to undergo this very computationally expensive activity of finding the answer to the proof of work problem or the proof of work riddle, which again, in our demonstration, it was finding Anu with that first four zeros.

But again, each blockchain might change the riddle or, or change the problem to be a little bit different. In fact, some of these blockchains make this riddle intentionally hard or intentionally easy to change what's called the block time. The block time is how long it takes between blocks being published, and it's proportional to how hard these algorithms are.

So these problems actually can change depending on how long they want the block time to be. If a system wants the block time to be very, very long, they just make the problem very, very hard. If they want it to be very short, they make the problem a lot easier. We'll talk about civil attacks in a little bit and how they can affect the system, but with proof of work, it's a verifiable way to figure out who the block author is and be civil resistant.

Now, you need to combine this with a chain selection rule, create this consensus. Now, there's some consensus protocols that have more features, but very, very roughly. These are the two pieces that we're gonna look at. The second piece is gonna be a chain selection rule. How do we know which blockchain is actually the real blockchain and the true blockchain?

Now, on Bitcoin and Ethereum, they both use a form of consensus called Nakamoto consensus, and this is a combination of proof of work and longest chain rule. The decentralized network decides that whichever blockchain has the longest chain or the most number of blocks on it is going to be the chain that they use.

This makes a lot of sense because every additional block that a chain is behind, it's gonna take more and more computation for it to come up. That's why when we saw in our transaction, we actually saw confirmations. The number of confirmations is the number of additional blocks added on after our transaction went through in a block.

So if we see confirmations is two, it means that the block that our transaction was in has two blocks ahead of it in the longest chain. Now, I do wanna point out that a lot of people use proof of work as a consensus protocol, and I do want to say that this is a little bit inaccurate, but sometimes people use it interchangeably.

Proof of work is a piece of the overall consensus protocol, which in Bitcoin and Ethereum, one's current case, is Nakamoto consensus. Nakamoto consensus is a combination of proof of work and its longest chain rule, both equally and very, very important. Now, proof of work also tells us where these transaction fees and these block rewards go.

To remember how when we made this transaction. We had to talk about gas and a transaction fee. So who's getting paid? Who is getting this transaction? And this transaction fee is going to the miners or the validators in a proof of work network. They're called miners. And in the proof of stake network, they're called validators.

There are a little bit different, and we'll get into that when we talk about proof of stake in this proof of work system, all these nodes are competing against each other to find the answer to the blockchain riddle. Remember in our example it was to find hash that has four zeros at the start. And again, depending on the blockchain implementation, that riddle is gonna be a little bit different.

But all the nodes are trying as many as possible to try to get this answer first. Why? Because the first node to figure out the answer to the blockchain real is gonna get that transaction fee. They're gonna get paid from that. Now, when a node gets paid, they actually get paid in two different ways. One is gonna be with a transaction fee, and another piece is gonna be the block reward.

Remember how we talked about alternating the gas price or the gray on our transaction? Well, that's the transaction fee that we're gonna pay to these blockchain nodes for including our transaction. The block reward is given to these nodes from the protocol, from the blockchain itself. You've probably heard of the Bitcoin having before.

The having is referring to this block reward getting cut in half, and it's supposed to be cut in half, roughly every four years. This block reward increases the circulating amount of whatever cryptocurrency that is being rewarded. For example, on Ethereum, the block reward is giving out Ethereum and on Bitcoin, the block reward is giving out Bitcoin.

So these nodes are competing against each other to be the first one to find this transaction, to be the first one to find the answer to this problem so that they can be the ones to win both this block reward and your transaction fee. Some blockchains, like Bitcoin for example, have a set time when they're no longer going to give out block rewards and the miners or the nodes are only gonna get paid from transaction fees.

Now this gas fee, again, is paid by whoever initialized the transaction. When we got our funds from the faucet, there was some server and somebody else was paying the transaction fee for us. However, when we sent Ether from one account to another, our first account actually paid some transaction fee to send that ether in proof of stake.

There's also a gas fee, but it's paid out to validators instead of minors, and we'll talk about that in a little bit. Now let's talk about two types of attacks that can happen in these blockchain worlds. Let's talk about the first one being the Sybil attack. The Sybil attack is when a user creates a whole bunch of pseudo anonymous accounts to try to influence a network.

Now, obviously on Bitcoin and Ethereum, this is really, really difficult cuz the user needs to do all this work in proof of work or have a ton of collateral in proof of stake, which again, we'll talk about in a bit. The other more prevalent attack is what's known as a 51% attack. Now, as we saw, as part of our consensus protocol, these blockchains are going to agree that the longest chain is the one that they're going to go with so long as it matches up with 51% of the rest of the network.

This means that if you have the longest chain and you have more than 51% of the rest of the network, you can do what's called a fork in the network and bring the network onto your now longest chain. Now, civil attacks obviously are when a single node or a single entity tries to affect the decentrally of the network by pretending to be multiple different people, although they're just the same person or entity.

And like I said, it's really difficult to do in proof of work and proof of stake. So you can see now that blockchains are very democratic. Whichever blockchain has the most buy-in and is the longest is the blockchain that the whole system is going to corroborate. When nodes produce a new block and add to the longest chain, the other nodes will follow this longest chain that the rest of the network is agreeing with.

Add those blocks to their chain and follow up. So very small reorganizations are actually pretty common when a blockchain picks a block from a different longest chain, puts it on and then has to swap it out for another block and and continue with a different blockchain. However, if a group of nodes had enough nodes or enough power, they could essentially be 51% of the network and influence the network in whatever direction that they wanted.

This is what's known as a 51% attack and it's happened on blockchains like Ethereum Classic, which is not Ethereum. This is why the bigger a blockchain is, the more decentralized and the more secure it becomes. So after you watch this video and you become a blockchain engineering expert, I definitely recommend you run a node as well because you are going to increase the security of the network as a whole by running a node.

So proof of work is fantastic cuz it allows us to very easily protect against these civil attacks and keep our blockchains decentralized and secure. However, it has some drawbacks as well. Proof of work costs a lot of electricity because every single note is running as fast as they can to win this race to get the rewards.

This leads to obviously an environmental impact. Now, since proof of work in Nakamoto Consensus, a lot of other protocols have taken this idea and gone in a different direction with a different civil resistance protocol. A lot of them with the intention to be a lot more environmentally friendly. And the most popular one right now is proof of steak.

There are some chains that are already using this proof of steak protocol and that are live and thriving. Some of them are like avalanche, solana polygon, polka dot. So let's talk about proof of steak. Now again, this is a different civil resistance mechanism. Instead of solving this difficult problem, proof of stake nodes put up some collateral that they're going to behave honestly, aka, they stake in the example of Ethereum, two nodes put up some Ethereum as a stake that they're going to behave honestly in the network.

If they misbehaved in the network, they're going to be slashed or removed some of their steak. Obviously this is a very good civil resistance mechanism because if you try to create a whole bunch of anonymous accounts, then each one of those accounts you have to put up some stake, and if you misbehave, you're gonna run the risk of losing all the money that you put up as collateral.

In this system, miners are actually called validators because they're no longer binding anything, they're actually just validating other nodes. Now, unlike proof of work, which every node is racing to be the first one to find, the block and proof of stake nodes are actually randomly chosen to propose the new block, and then the rest of the validators will validate if that node has proposed the block.

Honestly, as we saw with our cryptography lesson, it's usually very easy for other nodes to verify if a proposal or a transaction is honest. Now, proof of stake obviously has some pros and cons as well. Pros are that, again, it is a great civil resistance mechanism and a great way to figure out who the author of a block should be.

The other pros are that it's way less computationally expensive to figure out the new block because instead of every single node on the network trying to do this, only one node needs to do this, and then the rest of the nodes just need to validate it. The cons are that it's usually considered a slightly less decentralized network due to the upfront staking costs it costs to participate.

Now this gets into a little bit of a philosophical battle on how decentralized is decentralized enough, and I think that's up to the community to decide, and as we progress, I think we'll learn more and more about how decentralized is decentralized enough. The general consensus amongst blockchain engineers though is that proof of stake is very, very decentralized and very secure.

Now, there's another term that you might be the first time you heard it, a layer one. We're gonna talk about layer ones and layer twos in terms of scalability really quickly as well. A layer one refers to any base layer blockchain implementation. Bitcoin's a layer one Ethereum's a layer one avalanche is a layer one.

These are the base layer blockchain solutions. A layer two is any application that is added on top of a layer, one added on top of a blockchain. Some examples of layer twos are gonna be chain link arbitron or optimism. Arbitron and optimism are very interesting because they are layer twos that also look to solve this scalability issue.

Arbitron and optimism are what's known as rollups, and they roll up their transactions into a layer one like Ethereum. We're not gonna go too deep into Rollups and how they actually work, but all you really need to know is that they solve some of the scalability issues by being another blockchain that people can make transactions on.

Still on kind of this base Ethereum layer. Now they're different from side chains because side chains derive their security from their own protocols. Rollups. Derive their security from the base layers. So arbitra and optimism, for example, is gonna be just about as secure as Ethereum. There's some fantastic guides in there that go a little bit deeper into roll-ups, and I've left a link in the description for you.

All right, so we just talked about a lot of stuff, so let's do a quick recap before moving on. Sybil attacks are prevented due to protocols like proof of work and proof of stake. 51% attacks grow increasingly harder with the size of blockchain, so you should run a node. Consensus is the mechanism that allows a blockchain to agree upon what the state of the blockchain is.

Sharding and roll-ups are solutions to scalability issues. On Layer ones. A layer One is any base blockchain implementation like Bitcoin or Ethereum, A blockchain scalability problem is that there's not always enough block space for the amount of transactions that want to get in them. This leads to very high gas prices, and again, gas prices are how much it costs to interact with a blockchain.

Whew. So that's it for the blockchain basics and the blockchain explainers. With just this information, you now can go off into the world and start working with blockchains and interacting with blockchains, with at least some level of knowledge as to what's going on. You should be incredibly proud of yourself for just making it this far.

Definitely be sure to give yourself a pat on the back and a round of applause. Now that we've gotten a lot of the basics and the fundamentals out of the way, let's start jumping into the coding aspect. This is where you're gonna learn how to actually build these smart contracts, how to build these trust minimized agreements in these blockchains and in these smart contract platforms.

This next section, this Solidity Basics. The Solidity fundamental section will give you all the skills to start actually coding solidity and understanding how these smart contracts work underneath the hood. So at this point, absolutely give yourself a high five, maybe say hi in the GitHub discussions, maybe say hi in the community, on Twitter, on Reddit, et cetera, and be proud of just making it this far.

The journey has really only just begun, but you've already learned so much. Let's begin the next section, and let's jump into the code.

Now that we're getting to the coding part, I need to stress to absolutely use the GitHub repository or Web three Dev education associated with this course. If you're on the GitHub repo right now, and you scroll down to lesson two, and this is gonna look a little bit different when you come to it, you can click on the GitHub repo associated with this lesson.

This will have all the code that we're actually gonna be working with for this section, as well as a read me section, which is gonna have a lot of notes on how to actually work with the code. And instead of making issues and discussions on this repository here, if you have an issue, please use the discussions tab of the Foundry full course here, or use any of the areas that we've laid out.

In the questions section, we're gonna teach you how to ask questions so that they have the highest probability of being answered by either somebody else in the community, by an AI, or by a forum. Additionally, please be sure to check out web three dev. Do education for more information as well. I highly recommend that you pause the video right now and make accounts for first of all, GitHub, and then at least Stack Exchange Ethereum.

Additionally, chat JBT is a great resource to make an account for. Just remember that it will often get things wrong and isn't quite up to date find you don't need to make an account for, but it often gets things wrong sometimes as well. Typically, for each coding section, I'll give you a brief rundown of what we're actually gonna be building.

And in this lesson we're gonna be building this exact smart contract and we're gonna be building your first smart contract ever and we're gonna deploy it to a blockchain. At the end of this section, you are going to have deployed your first smart contract ever. So be sure to get to the end so you can deploy your first smart contract.

We're gonna be using something called an I D E called remix to deploy and interact and work with this smart contract, which is going to be very exciting. It's highly recommended to get the best experience outta. This is for you to follow along and you to code with me. You can change my speed on the YouTube video if I'm coding too fast or I'm coding too slow.

But you taking the time to write out the code as I code along with you is gonna ingrain the knowledge into your brain. Repetition is the mother of skill and I wanna make sure you come out the other side with skill. So actually code this. We're gonna be using a tool called Remix. You can either Google search it or you can just come to the GitHub repo or Web three Dev education and click this link to remix, which will pop open the remix web id.

So let's go ahead. Let's jump in and let's learn to deploy our first smart contract. At the end of this lesson, you will have deployed your first smart contract. You'll have written your first bit of Solidity, and we are very excited to get through this part.

Welcome to the remix I D E or the Integrated Development Environment. This is where we're gonna learn to write a lot of our code in the beginning. If you want, you can go ahead and accept to help out remix here. And if you've never been to the remix website before, it'll give you a tutorial walkthrough of some of the features that Remix has to offer.

For example, it has a Solidity, compiler Solidity is the programming language that we're gonna be using in this course to code our smart contracts where, and we need to compile them when we've written the solidity. We'll learn about that in a little bit. We have a tab here where we can actually deploy our contracts to a blockchain, and we have all these different folders and scripts since we can actually write.

JavaScript and TypeScript in remix as well. But don't worry about those too much for now because I'm gonna be explaining everything that we're going to do. Remix is an incredibly powerful tool because it has a lot of features that allow us to really see and visualize what our smart s do. Eventually we're going to move off of remix to a local development environment.

However, remix is a tool still used by some of the top auditors and smart contract developers in the space when they want to quickly check something out. And additionally, it's fantastic for learning the fundamentals of Solidity. The left hand side is where we're actually going to start interacting with Remix.

If we bring our mouse up to the top, this little file explorer is where we're gonna have all of our files and where we're gonna write our solidity or our smart contract code. If you want, you can leave all these folders in here, but I'm actually gonna go ahead and delete everything so that there's less for me to work with or or deal with.

So I'm just gonna go ahead and write, click and delete everything in here just so I can start completely from scratch. Again, if you want to leave all of these in here, feel free to do so. Doesn't matter, I just think it's cluttering up my mental space a little bit. Now we have a blank remix project, and the first thing that we're gonna want to do is create our first file to start writing and deploying our Solidity Smart contract.

We're gonna go ahead and click the create new file right here and type in Simple Storage. So, so tells our compiler that this is going to be a Solidity contract, a Solidity file, and we're going to be writing Solidity inside of this file, which again, solidity is the most popular smart contract programming language.

And you'll see we actually get popped up, a simple storage sole on the right hand side, which we can type in and actually write our Solidity code. Now, right below the File Explorer button is a little search icon, which allows us to search for different code in all of our contracts. So for example, if I type in Hello in here, and I copy that, paste that into the search bar and enter, we can see that it found this line.

Hello, in our Simple Storage Soul, let's go ahead and delete that. Right below that search icon is this Solidity compiler, and you'll see a bunch of different stuff pop up, which tells us about our compiler configuration, and we can see even more advanced configuration if we hit the dropdown. We're not gonna hit that for now.

Let's go ahead and double click the Solidity compiler over here so we can just see the simple storage sole. I'm also gonna click this high terminal button so that we just see our simple storage do sole. Now, the first thing that we want to do in all of our Solidity and smart contracts is write the Solidity version that we're gonna be working with.

Solidity is a constantly changing language, and we wanna be very specific about what version we're gonna be using to write our smart contract as each version does different things. To write your version, you're gonna do Pragma Solidity, and then type your version. For most of this course, we're gonna be using zero point.

Eight point point 19 as that's the most current edition of Solidity. However, getting used to working with different versions of Solidity is really good for you as you're going to be working with different versions of solidity. No matter where you go. Certain versions of Solidity are considered more stable than other versions right now.

There's a popular tool called Slither, which recommends using 0.8 0.18. So if you want to default to 0.8 0.18 for this course, feel free to do so. We're gonna be using a couple different versions as we code. So this line says we're stating our version. Now these two slashes here stand for what's called a comment in solidity, and this allows you to write anything after the two slashes.

And when we compile or run our code, it will just ignore what's in here. So we could type blah, blah, blah, whatever we want. Cats are cool and it doesn't matter. You can write anything in here. I highly recommend as we're going along, you should write comments in your own code as well for you to refer to later on.

And additionally, feel free to copy all the code that you write and paste it locally so that just in case your browser cash refreshes or something, you won't lose all the work you've done so. So before you lock off for the day, copy, paste this into a text file so that you can have it for later. But a good comment for here might be this is the version.

Now writing our version like this in Solidity tells the solidity compiler that we're only allowed to use 0.8 0.18 when compiling this. However, maybe a new version comes out and we're okay to use anything newer than this version to tell the compiler that we add this little hat, this little carrot, which says, this contract only works with 0.8 0.18 or anything greater than that.

This means 0.8 0.19 would work when 0.8 0.2 comes out, that one would work. However, 0.8 point 17 would not work if we were working with 0.8 0.18 or above. If we don't have the carrot, this tells the compiler that only 0.8 0.18 will work with this code. If we want to use solidity versions within a range, we could do something like this.

We could say we want our version to be greater than or equal to 0.8 0.18, but less than 0.9 0.0. This would tell the compiler that any version between these two is a valid version. For example, 0.9 0.1 would not work, neither would 0.9 0.0 because these are not strictly less than 0.9 0.0. Great, so now we know how to do compiler versions.

Now the next thing every smart contract needs to start with is something called the S P D X license identifier. Now, this actually isn't required by the compiler. It'll actually throw a warning if we compile and it won't error. It's fine if you don't have this. However, it's highly recommended. This is a way to make licensing and sharing code and IP.

Of your contracts a lot easier from a legal perspective, I have a link to more about how licenses work in the GitHub repo. Associated with this section of the course, m i t is known as one of the most permissive licenses. It basically means anybody can use this code and pretty much do whatever they want with it.

I wouldn't worry too much about the licenses right now, but let's actually go back to 0.8 0.19 and on the left hand side, let's scroll down to this compiler button and open this back up. Even right now, now that we don't even have any code, we can actually go ahead and compile this contract. Now you might see a red squiggly and you might see a warning here, but don't worry about that for now.

To choose our compiler version, we scroll up to this section and we can choose the compiler version that we wanna work with. Most of the time though, if you just hit Compile Simple Storage Sole, or you hit this big compile button, it'll automatically choose the version for you. For example, if I scroll down or to hit Compile, it'll automatically flip up to 0.8 0.19, and we were able to go ahead.

We were able to successfully compile this code. Now it says no contract compiled yet, because we haven't put a contract in here yet. We just put the version of Solidity that we're working with. Compiling our code means taking our human readable code and transforming it into computer readable code, which is essentially a bunch of zeros and ones, or it's bite code.

Computer code is very specific instructions for the computer to use, or in our case, the blockchain to use for our contract. We'll learn later about machine level code and OP codes and E V M codes in a much later section of this course. Additionally, you can hit command S or control S, which will also save and compile.

You'll see I kind of have a trigger finger and I will out of habit hit command S all the time because as somebody who codes a lot, I need to make sure I save all the time. Otherwise, things might not work as intended. As you saw, if we use a different version of Solidity and we hit the compile button, it'll automatically flip back.

But for example, let's say I, I wanted to use 0.8 0.7, anything greater than that, and we're on compiler, 0.8 0.19, and we hit Compile. It won't change. However, if I use something less than 0.8 0.7 and we hit Compile, it'll change because it wants to automatically select a Solidity version that is appropriate for the version that you chose.

Again, I want to use 0.8 point 18 and I'm gonna hit Compile and we're good to go. Yep. We're gonna go ahead and start writing our contract and to get the full screen view again, we just go ahead, click the Solidity compiler so that we can just see our code here. To start writing our contract, we're gonna use a keyword in Solidity called Contract.

This tells Solidity that the next piece of code is going to be the name for our contract that we're gonna create. You can think of a contract very similar to a class if you're familiar with JavaScript or Python or Java, or really any object-oriented programming, and we're gonna go ahead and give our contract a name here.

We're gonna call ours Simple Storage. And then we add this little open and closed curly braces or curly brackets. Everything inside of these curly brackets is gonna be considered part of this contract. Simple storage. Now if we hit enter, we go back to the compiler and hit compile. We can see once again this little green check mark popup.

This means our compilation has been successful. If we were to remove, for example, this curly brace and hit compile, we would see, we would get this error compilation failed with one error. And if we scroll to the bottom, it'll tell us where the error actually is and we'll get a little red popup saying what line the error is actually on.

We'll learn about debugging these errors in a little bit, but let's add the curly brace back. Go ahead, back to the compiler, compile, and we're good to go.

Hypothetically, we could deploy this smart contract right now. This is a valid contract, although it doesn't do anything, but congratulations technically with just this little piece of code. You've written your first smart contract, I spelled version, so we're gonna correct that. Solidity has many different types of things that you can build in these smart contracts.

Many different data types or just types. If you go to the solidity documentation@docs.soliditylang.org, again, link this in the GitHub, we can select the types section on the side to learn more about solidity types. If you want to get a holistic view of all the different types, you can go ahead and read this documentation.

Some of the basic types are going to be Boolean, Boolean, uin, and an address And bytes. Bytes is a lower level type, which we'll talk about in a little bit. A Boolean is some type of true false value. A UIN is going to be an unsigned integer, A K a a positive whole number, meaning no decimals, no fractions.

A integer is going to be a signed whole number, meaning it could be positive or negative, but again, is a whole number. And then we have an address which is going to be, well, an address. It's very similar to if we open up our meta mask and we click this account here, it's gonna be something like this.

There's some other types as well, and ways to create your own custom types, but we'll learn more about that later on. We can use these different types to define different variables. Variables are essentially holders for different values, and these values can have one of these types. For example, we could create a variable called has favorite number, which would represent if somebody has a favorite number.

This has favorite number, could be true or false. Either they do have a favorite number or they don't to tell solidity that this has favorite number is a true false or a bullion. We would add this bull keyword before has favorite number. So this has favorite number is gonna be either true or false. And to set its value, we're gonna give it this little equal sign and say True.

So now has favorite number is a variable that represents true. We could also say has favorite number is false, meaning that somebody doesn't have a favorite number. For a uin, which again is an unsigned integer, we could say UIN favorite number equals 88. This means that this variable favorite number is going to be 88 a uin and INT are actually special in that we can actually specify how many bits or bytes that we want to use.

For example, we could say N 2 56, U N 2 56 specifies this variable. Favorite number has 256 bits. We're not gonna go over bits and bytes in depth right now, but if you want to get a quick refresher, we've left a link in in the GitHub repo associated with this course to give you an overview of bits versus bytes and how they work.

An easier way to think about this is really just how big can it get? The bigger the number over here, the bigger this favorite number can be. The maximum size is a UANT 2 56, and if you don't specify the UANT 2 56, it defaults to being a UANT 2 56. So this and this are the same thing. This this same thing.

You could also have eight bits, 16 bits, 64 bits, et cetera. Oftentimes it's better when we're writing our code for a readability standpoint to be as explicit as possible. So you'll see me pretty much always writing you in 2 56 because I want to be very explicit with how many bits I'm using for you. UUA 2 56, even though they mean the same thing instead of a UUA 2 56, we could also have this be an INT 2 56 and actually let's add that Boolean back up here.

Now an INT can actually be positive or negative, so we could have our favorite number be negative 88 if we wanted to. We can also have strings or text variables, which I didn't name up here, but I'll say why in just a minute. We could say string favor it number in text equals 88, and let's actually make this positive 88.

Even though an inch could be positive or negative, I'll put this little semicolon here. You'll notice that at the end of every one of these lines, I'm adding this semicolon. This semicolon is how you can tell solidity that a statement has completed. So this semicolon is saying the end of this line is right here.

If we wanted to, we could put all of our code on the same line like this and this would compile fine. It just looks really ugly. So we always want to put our code on a new line after the semicolon. A string in solidity is basically text that represents well words. So I could say 88 instead of having 88 in here.

To tell solidity that something is a string, you have to put it in between quotes. I could put really any combination of characters in here, even like hello or follow Patrick on Twitter. And let's actually do you in 2 56 here, favorite number, and we'll do an in 2 56 favorite int equals negative 88. This way we'll just have an example of all these different types on screen.

We can also do an address. So we can say, address my address equals, and we can go into our meta mask, copy the address, and paste it right into remix and add that semicolon. And now we have our address type in remix. And then finally down here we're gonna say a Bytes 32 object, RI bytes 32 equals cat. And we're gonna put it in quotes just like we did the string up here.

And what's interesting about the string object is that strings are actually secretly just bytes objects specifically for text. So a string can actually get converted to a bites object really easily because under the hood they're essentially the same thing. Bites typically look like something like Xerox and a whole bunch of random numbers and letters that represent the hacks of whatever the bites is and can often be represented as strings like cats.

We'll talk about bites more in the future. Similar to you went 2 56 and in 2 56. You can have different size bites like bites, two bites, bites, four bites, eight, et cetera, all the way up to 32. You can also have just straight up bites and not have a number after, but that's a slightly different type. And we'll go over that later as well.

A uant like this and a U 2 56 are the same thing, but a bites 32 and a bites with nothing are actually different. So keep that in mind for now. The largest bytes, like I was saying, is actually 32. So for example, we can't do eight bytes, 64, and if we type that in here, remix actually goes, Hey, there's an issue here.

And if we try to compile this and we scroll down, we'll again, see this little error code here and this little error pop up. It even gives us an output declaration, error identifier not found or not unique. It gives us the line and we can say, ah, whoops Daisy, this should be a bytes 32. And we can go back and compile this for our simple storage contract.

Let's say that we only want to store a favorite number. This contract is gonna be a contract that allows us to store our favorite number and some different people's favorite numbers as well. So we're gonna go ahead and delete everything except for the unit 2 56 favorite number. So we're gonna go ahead and delete everything and boom.

And we'll pick a smaller favorite number just to make it a little mentally easier. Now, these variables actually have default values. So for example, if I don't set my favorite number to anything, and I have a line that looks like this, you'll see that this actually compiles fine favorite number will actually get defaulted to zero.

And all of these types have a different default value U 2 56 is zero, bullions is false, et cetera. So saying U 2 56, favorite number and not having an equal sign after here is the same as doing U in 2 56. Favorite number equals zero. So for now, let's not initialize it to anything. So that favorite number starts off as zero.

And remember, as you're coding along here and typing along with me, if you get confused, make sure to write your own comments. For example, we can say favor it number gets in this, she lies to zero. If no value is given.

Now let's go ahead and learn to make our first function. Basic solidity function. Section functions or methods. Functions or methods are a subsection of code that when called will execute a very specific small piece of our entire code base. If you're familiar with JavaScript or Python or any other programming language functions and solidity are exactly the same.

Functions are identified by the keyword function. Let's create a function and name it store, and we're gonna have this function be responsible for actually updating our favorite number. We're going to store a new favorite number. So you first write the function keyword, the name of the function, and then you add these two parentheses.

Whatever is in between these two parentheses represents what we're going to pass or send to our function or the parameters that we're gonna send to our function. For example, we need to tell our store function what value it should use to update favorite number. So we're gonna tell our store function.

It should take a unit 2 56 and this variable that we're gonna pass to it, we're gonna call underscore give orit number. It's important that we give it a different name than favorite number up here, and we'll talk about that in a little bit. Then we're gonna say, this is going to be a public function, and we'll explain that soon too.

We wanna put these little curly brackets in here as well, and we're just gonna say, favor it number equals underscore, favor it number. And without going too deep into what this is doing, we're saying, I'm not gonna explain public yet, but we will in a minute. But what we're saying is whenever you call this store function, you're going to set our favorite number variable to whatever variable that we passed.

I'll explain why we do this underscore here as well in a little bit. And with just this, we can actually start to simulate what this smart contract will do and if our store function will actually work correctly. So what we can do with just this code right here is come over back to the compile tab and hit compile.

Make sure that we get this green check mark and that everything looks good. And then we can go down to this deploy and run transactions tab. Our deploy and run transactions tab has a ton of different parameters in here on how to actually deploy and run with our transactions. We're gonna deploy this contract to a simulated virtual environment.

So we're gonna deploy it basically to a fake environment. We're not gonna be deploying it to a testnet, we're gonna deploy it basically in kind of an imaginary world. In order for us to do this first, make sure we're on this remix vm, and for us, we're gonna just use the default, which is the merge.

Doesn't really matter which one you're on just so long as it's the remix vm. This remix VM is a fake local blockchain where we don't have to wait for transactions to complete, and we don't have to deal with any of the oddities on deploying our code to a real testnet or a real main net. And don't worry about the rest of these for now.

We also get an account here when we run on our fake remix vm. We get automatically given an account with a different amount of Ethereum for each account. You can think of each one of these accounts similar to our meta mask accounts. In meta mask, except for these are fake imaginary accounts that remix just gives to us for our transactions, including deploying contracts.

We're given a gas limit values that we can send, and we'd also choose our contract depending on which one we've compiled. Since we only have one contract in here, we only have one to choose from. So on the left hand side, to deploy our contract to this fake remix VM and environment, we're gonna go ahead and click the deploy button if we scroll all the way down to the bottom.

Now under this deployed contracts, we can see we actually deployed a contract here, simple Storage. You can see the balance of zero, and we see this big orange button that says store and then U to six underscore favorite number on our local blockchain. This at blah, blah, blah. Here. This is gonna be the address of our contract, similar to our wallets, how they have different addresses.

Every single contract has a unique address as well. And if we hit this little copy button and we close this and we put it as a comment here and we paste it, we can see this looks exactly similar to an address such as what's in our meta mask. And then let's go ahead and open the deploy back up. And we see that deployed contract is still there.

Additionally, if you hit this little show terminal button and you pull this up, we can actually see, we have this little comment here, creation of simple storage pending, and we have this green check mark here. This is notating that we actually sent a transaction to deploy this contract. Similar to sending ETH back and forth.

In order for us to deploy a contract, we actually have to send a transaction. Since we're doing this on the remix M, this is a simulated transaction, a pretend transaction inside of our remix environment. You can even hit the little dropdown and see even more information about this transaction. You'll see a lot of familiar keywords like status transaction, hash from to gas, et cetera.

Deploying a contract uses the exact same process as sending a transaction for just eth. The main difference is we populate this data or input field with a ton of that bite code. And if you copy this input field or this data field, and go ahead and make a comment in here, you'll see it's a massive line and this massive line notates all the data associated with this smart contract, all the machine readable code.

Remember, anytime we do anything that modifies any value on the blockchain, we actually do that by sending a transaction. Deploying a contract is modifying the blockchain. So we do it in a transaction, which means yes, we spend gas. Now this big orange button over here actually resembles our function store in our smart contract.

And if we add some numbers in here and we call it again, if we pull the terminal up, we can see transact to simple storage pending. And we see we sent a transaction, which called this store. If we do this again with a different number, we call it. We can see our terminals say, oh, you sent another transaction to update the state of the blockchain.

And if we scroll all the way up to our account, you'll see that we have a little less ether in our account cuz we had to spend the gas associated with, well, a, deploying this contract. And then B, calling these functions. And then for example, if I add this, if I add five in here and hit store, we'll send a transaction to store five on the blockchain.

Now you might be thinking, okay Patrick, that's pretty cool, but what is the value of favorite number? You're telling me that this function store is updating favorite number, but I can't really see it. How do I know that favorite number has actually been updated to five? Well, the reason we can't see it is that the visibility of our favorite number is actually defaulted to internal.

So us not having anything here or right internal are actually meaning the same thing. And we'll talk about visibility and default visibilities in a minute. But in order for us to actually see the value of our favorite number, we'll go ahead and add the public keyword to this. This changes the visibility of favorite number to public.

And like I said, we'll talk about visibility in a minute, but let's go ahead and compile this. Let's go ahead and delete this contract by hitting this X here and let's redeploy this contract with this new public keyword. So let's go ahead and hit deploy. And now if we scroll down and we open up our simple storage, we actually now see a blue button labeled favorite number.

And if we click it now, we can see it returns zero, which makes sense because we know that U 2 56 is default to zero. Now if I go ahead and add five into here and hit the store button, I pull up the terminal, we'll see that we went ahead and executed that store function. Call that transaction. That's going to take input this five as favorite number and set it to our favorite number.

Now if I hit favorite number, you can see it does indeed return five showing that we actually updated our favorite number with this function call. And remember though, I'm gonna go ahead and do this again and remember when I hit X here, this is just removing it from this window here. If you actually deploy a smart contract to the blockchain, hitting X from this window doesn't do anything because once you deploy your contract, it's immutable, it's out there it, you can't just delete it by clicking X and remix functions and variables can have one of four different visibility specifiers in solidity, public, private, external, and internal.

If you don't give one of these keywords to your variables, it'll get defaulted to internal public functions mean that they're visible externally and internally. And you'll see here it says it creates a getter function for storage slash state variables. This means that other people can call this function or call this variable.

When we didn't have a visibility for favorite number, it defaulted to internal, which is why we didn't see this blue number pop up. Because in internal it means that other contracts and people aren't allowed to call on this favorite number. We have a little bit more here. It says it actually creates a getter function for storage slash state variables.

When we add this public keyword here, it's actually equivalent to us making a getter for this favorite number variable, a getter function. And I'll show you exactly what the function will look like in a little bit. Now keep in mind though, everything on chain is technically public. So setting a function or variable to private isn't a good way to hide what the value actually is there.

And we'll talk a little bit more about storage and visibility and, and that much later. Just remember everything on these E V M chains is actually public data. This public variable just means any other contract can call this favorite number and and see the value of what's in favorite number. And private means only the current contract can.

External functions mean they're only visible externally, and this is only for functions, not for variables. And it means another function inside. This contract couldn't call an external function and internal means only the current contract and its child contracts can call the function. We'll talk about child contracts and inheritance in a later section, so let's just keep it public for now.

The reason that we have this underscore here in this parameter is because we need to tell users that this variable in here is different than favor number. And there's a couple different conventions on naming local variables versus these what's known as state variables or variables outside of functions.

And we'll go over those later in the course. Now here's something that's really interesting as well. Remember how I told you earlier that sending ether is a relatively simple transaction, right? Well, let's see what happens when we call this store function and we update favor number to five. Let's actually call it one more time and we hit the little dropdown here.

Let's go to gas. And we'll see. Gas actually costs 27,000 gas, which is a lot more than the 21,000 gas it costs to just send ether between accounts. Remember, every time you update the state of the blockchain, it's going to cost gas. Now, what do you think will happen if we do more in inside of this store function?

For example, we say pay over it number equals itself plus one. Let's go ahead and compile this. Let's delete our old simple storage. Let's deploy this new one. Remember the last one? Cost 27 gas. Let's pull up the terminal and remix actually gives us a little tool tip and it's saying an infinite gas, which we know is actually wrong, but let's go ahead and add 1, 2, 3 in here and we'll hit store.

We'll see this transaction, we'll scroll down. We'll see. Gas is actually a lot more, it's way more gas. It's 50,000 gas, which just adding this line here. Now technically I'm not telling the full story here because there are some other gas costs associated with the first time you run a function, but it's still more right?

And that's what's important here, so, so let's go ahead and delete that line and go back to our old function here. Now let's talk about something called Scope for a second. So if I create a variable in here called you went 2 56, test VAR equals five, and I create a new function called something, make it public.

Could I access the test VAR and then maybe change it to six or seven? What about the favorite number? Var? What about the favorite number variable? Could I access that to seven? Well, let's go ahead and see what happens if we try to compile this. We try to compile, we actually go ahead and get an error in our compilation, undeclared identifier.

Whenever you create a variable, it can only be viewed in the scope of where it is. If that's confusing, just look for the curly brackets. The reason that our something function can read the tevar is because this tevar isn't inside of the curly brackets of something. The reason it can't read the tevar is because tevar was created way up here inside of these curly brackets outside of something.

But favorite number wasn't created inside of these curly brackets. So how come it knows what favorite number is? Well, something is inside of these curly brackets, and favorite number was created inside of all of these curly brackets. If favorite number was created inside of here, it wouldn't be able to access favorite number because again, favorite number is inside of this scope and not this scope.

If you create a variable like test var inside of store, you can only access this test var inside of this store function and not anywhere else. The easy way to know what the scope of a variable is is just look for the curly brackets. So let's go ahead and delete this something variable and let's delete this test file and let's recompile.

Now, like we were saying earlier, when we add this public keyword to favorite number, it's the exact same as if we created a getter function to return this favorite number. So let's actually write a function similar to what this public keyword is creating. So we're gonna say function, retrieve, make this a public view function and we'll talk about that in just a second.

And we'll say it returns a uant 2 56 and we'll add the curly braces here and we'll say return avari number. And oftentimes when these auto suggestions come up like this, you can just hit enter and they will automatically do it. So if we do favo R, and then I just hit enter, boom, automatically like that.

Now I'm gonna hit command S, which is equivalent to me going the compile tab and hit and compile. Now if I go to the deploy tab, let's deploy this contract. Now we scroll down, we now see we still have that store function. We have our favorite number function, and we have a new blue button called retrieve.

Right now they both start off at zero, and then obviously if we update this to five by calling store. Yep, I called store. These are now both return five since favorite number is the actual variable, and retrieve is just returning whatever favorite number is. Now, as you can see here, these two functions are blue, but this one is orange.

What's the difference? Why are the colors different? Well, the key is actually with this view keyword here. Solidity has a special keyword which notates functions that don't actually have to run or don't actually have to send a transaction for you to call them. And those two keywords are going to be view and pure.

A function marked view means we're just going to read state from the blockchain. For example, in our retrieve function, we're just going to read what the favorite number variable is. Our store function isn't reading, it's updating something so it, it's changing the state of the blockchain. So we have to send a transaction since our retrieve function doesn't have anything inside here that updates anything, it just returns favorite number.

We don't need to send a transaction. So if you add this view function in here, it disallows any modification of state. For example, I couldn't add favor. Rate number equals favor rate number plus one. If we go ahead and try to compile this, we'll get an error function cannot be declared as view because this expression potentially modify state.

So we'd have to remove this line or we'd have to remove the view keyword. So view functions, disallow, updating state your functions, disallow, updating state, and they disallow even reading from state or storage. This favorite number here is what's known as a storage variable cuz it's stored in a place called storage.

We'll talk about that in a later section, but if this was labeled pure, we'd see we get a little red underscore here because favorite number is reading from state. Instead of returning favorite number, we would return something like seven. So this would be an example of a pure function. This would be ex an example of a view function because we're reading from state, again, we'll explain the difference a little bit later.

And like I was saying before, if we call a view or a pure function, we actually don't need to spend gas since we're not modifying the state. That's why these buttons over here are blue. They're representing view or pure functions. Functions that we can call without having to send a transaction. For example, if I pull up the terminal here and I pull this up and our call retrieve, we do get another function, but it's just a call and it looks different than if I hit the store, which has this little check mark.

The different, because the store is obviously sending a transaction and the retrieve is actually just making a call and not sending a transaction. However, something weird's going on here. If I hit retrieve and I go into the details of this call, I could see, oh what's, what's this? Why is there an execution cost?

It says cost only applies when called by a contract. What's going on there? The reason for that is because if another function that does update state that does require a transaction calls retrieve that transaction, does need to pay the gas of reading and calling this retrieve function. So calling a view or pure function actually does cost gas only when a gas cost transaction is calling it.

So we can go ahead and call these as much as we want. It costs nothing. But if another function that does cost gas calls it, it's gonna cost something. For example, if our functions store here then went ahead and called retrieve. Like this. Since store costs gas, you're telling this function. Hey, also call this retrieve function, which is more work for it to do, and since it's more work, it's gonna cost more gas.

So for example, if we delete this contract over here, let's go ahead and compile this. Let's go ahead and deploy this with this retrieve in here. So let's go ahead and look at these. These are now zero. We'll store five in here. We'll select the dropdown. We can see how much gas we actually sent. 50,000 gas.

Go ahead and drop this. Now, close this out. Let's remove the retrieve line. Let's compile. We'll hit deploy. Simple storage. These are both zero, we'll add five. It's store. Pull up the terminal, hit the dropdown. Look at gas. It's still 50,000, but it's actually a little bit less than before, although I'm pointing at gas.

We really should be looking at transaction cost because gas is really just actually how much we're sending, whereas transaction cost is how much gas the transaction actually cost. But in any case, it was a little bit less without the retrieve function. Now, I've kind of been glossing over this a little bit, but this returns keyword specifies what this function is going to give us when we call it.

So when we have this returns keyword in our retrieve function here, we're saying, whatever we call this retrieve function, we wanna get returned or we wanna be given this favorite number of type U N 2 56. We wanna return a u n 2 56 from this function.

Now our contract as is, is pretty good. It does one thing pretty well. It's a, it allows us to store our favorite number, update that favorite number, and then view that favorite number. And in fact, let's go ahead and make this an internal variable, and we'll have the retrieve function be the way to get this.

We can have this public, but for now, we're gonna set it up like this and I'll tell you why we're gonna set it up like that in the future. But what if we wanted to be able to store not just our favorite number, but other people's favorite numbers as well? Well, what we could do is we could create something called an array or a list of favorite numbers.

What we could do is we could say, instead of just one U 2 56, we could have a list of U 2 56 called list of favorite numbers. This bracket syntax here identifies that we have a list of u n 2 56 or a list of numbers or an array of numbers. An array of numbers is gonna look something like this. It's gonna have, maybe the first element is gonna be zero, maybe the second favorite number is gonna be 78.

The third favorite number is gonna be 90. Now, arrays are very common in computer science and programming. And an array in solidity is exactly the same as an array in any other programming language. If you're unfamiliar with arrays, arrays or lists are actually zero indexed. So the zero here is actually at index zero.

So we refer to this object here as the zero width object, right? This could be 77 and this would be the zero width object. This 78 is going to be the first element, the 90 is gonna be the second element, and so on and so forth. It's very common in computer science to actually start counting from the number zero and arrays start counting from the number zero.

We'll learn to play around with arrays more in just a minute. So this list of favorite numbers is great, but how do we know whose favorite number each section is? This is our list of favorite numbers. How do we know who zero is, who 78 is, who 90 is, et cetera. Well, maybe what we would do, instead of just having a raw list like this, let's go ahead and comment this line out.

Maybe we could create a new type called a person. In solidity, you can actually create your own types using the struct keyword. So we're gonna say struc person and do little curly brackets like this. Inside of these curly brackets, we can define what this struc person custom type is comprised of. And we're gonna say for every person, they're gonna have a U 2 56, they written number and a string name.

Now something important to note is, oh, whoops, we have two favorite numbers here. Remember what we learned about scope, since this favorite number is inside of these curly brackets, these would clash a little bit. So what we're gonna do instead is we're gonna rename favorite number up here to my favorite number, and we're gonna copy paste that down here as well.

So we're, we're renaming this state variable, this storage variable to my favorite number, and just keeping it down here. That way we can have favorite number in inside of this struct. In any case, we created this new type of type person, which is a combination of each person has a favorite number, and each person also has a name.

Now, similar to how we can have a U at 2 56, a Boolean, a string in 2 56, et cetera. We now have a type of person, and this is similar to each one of these. Oh, and we're also gonna have to update the retrieve down here with my favorite number instead of favorite number. Now since we have our own new type, we could actually create a variable of type person the exact same way we created a variable of type.

My favorite number. So we could say person visibility will be public, my friend equals, and we'll put Parson here and put some parentheses here. Because when you're working with custom types, you have to define both on the left side and on the right side what type it is. And in here we would assign a favorite number and a name.

So we could say seven and patch like that. So now Pat is going to be a person with a favorite number of seven and a name of pat. See, the first parameter goes to the first. Item in the person's struct and the second primer goes to the second item. I like being a little bit more explicit when working with Structs.

And actually what you can do is you can put little brackets here instead and you can say exactly what value you're gonna assign to what section. So I can say favorite number is gonna be seven and name is gonna be Pat, and we hit hit command S, or just go straight to compile to see if it worked correctly.

Get that little green check mark. Now, by doing this, we've created our own type person and we've created a variable named Pat with a favorite number of seven and a name of pat. Now, if we were to go ahead, let's delete this old simple storage and let's deploy our new simple storage and we scroll down, we now have a new blue button, since this is a public variable called Pat, and if we click the button, if we call this variable, we'll see favorite number of seven and string name pat.

You can also see this zero in this one, which shows the index of each one of these variables or parameters. Zero is for favorite. Number one is for name. If we added another one, maybe Bull is cool. Bull is cool, would be at index two. Whenever you create a custom type like this, solidity will automatically index them similar to the way that we index our lists or our arrays.

Favorite number, zero name one, whatever's next would be two, et cetera. Now, this is great for one friend, but what if you have a lot of friends, which I know a lot of you do, because you're taking this course, which automatically means you're cool. Maybe what if you have your friend, Mariah, that you would like to add to our smart contract like this, and her favorite number is 16, or maybe your friend John, you'd have to copy paste the line, add John in here.

His favorite number is going to be 12, so on and so forth. It might get very tedious to have to write variables for all of these people. For all of these friends, this obviously isn't a great way for us to create lists of people or lists of our friends. So instead of this, we can actually use this array syntax that we just learned and create an array of person or a list of persons.

So I'm gonna comment all these out for now, and a quick tip here, if you're on a Mac and you highlight a couple, if you're on a Mac and you hit command back slash or command question mark, it'll automatically comment or uncon those lines. If you're on a Windows, I believe it is control slash, but you might be able to Google what the actual keyboard shortcut is.

This is a keyboard shortcut I use all the time. So what we're gonna do now is we're gonna create a list or an array of persons. So exact same as we did up here. We'll say our type first is gonna be type person array, so we're a type person array. Then we'll state our visibility. Which is gonna be public.

Then we'll get our variable name, which is going to be list of people like this. So we've created a person array with visibility, public and the name list of people, and we'll just leave it blank for now, so it'll get defaulted to being an empty list, which would look like this. Now, if I were to go ahead and deploy this, let's delete the last one.

Let's compile deploy. We scroll down, we select this, we now see we have our retrieved blue button, and we also have this blue button for list of people. When you create a arrays with a public keyword, instead of being able to see the whole array with this list of people button, you actually have to put in the index of the elements you wanna work with.

And you get to see that exact element. It wants to take a U in 2 56 as an input parameter. However, obviously our array is blank. So if we say what is the person at the zero width index, it'll say, well, nothing because you have a blank array. Well, what about the first index? Well, nothing. What about the second one?

Well, nothing, no matter what you put in the box right now, it's going to return nothing. We'll show you how to add to this array in just a second. This kind of array is known as a dynamic array because the size of the array can actually grow and shrink in solidity. A dynamic array is signified by what's inside of these little brackets here.

If we added a three in here, this would be a static array. We're saying this list of people can only have a maximum size of three, so we can only put three persons in this array. Dynamic array, static array can have any size, can only go up to three, any size up to three, any size, up to four. Hopefully you get the picture.

We're gonna work with a dynamic array because we're gonna want to add a arbitrary number of people to this person array. So let's create a function that will allow us to actually add people and update this array. And let's delete this comment. So below our retrieve function, we'll create a function add person.

And this is gonna take two variables as input. It's gonna take the name of the person that we're gonna add. It's gonna take the favorite number of the person that we're gonna add, as well as the name. So we'll say string memory name, and I'll explain this memory keyword in a little bit. And we'll do you 2 56 underscore favorite number.

And let's do, and let's do underscore name. And we'll make this a public function. And what we're gonna do inside of this add person function is we're gonna take this list of people object and call the push function on it. Arrays come built in with a function called push, which allows us to add elements or add person to our list of people array.

So what we're gonna do is we're gonna say, list of people push and we'll add these little parentheses here. And we're going to push a new person onto this array. Now what we could do now, let's comment this out for now. Now what we could do is we could create a new person. Person, new person equals person name, favorite number like we did above.

Oops, excuse me. These are backwards person, memory, new person, which we're gonna ignore that for now. And then just do list of people. Dot push new person. We could do this. This is valid syntax, and I'll explain this memory keyword in a little bit. This is gonna create a new person and we push to the list, or we could just add this person right into this push piece here.

So we could delete this line. Instead of creating a new person on its own line, we could say list of people, do push person and then we'll add in here. Favorite number name, since we're calling this person, favorite number name. Inside of this push object, solidity is smart enough to execute this line of code first, create a new person and then execute this line to push our person into this list of people object.

So this function should allow us to push new people into our list of people all array. So what we can do now is let's compile this, let's deploy this. Let's delete the old one. We'll hit deploy. Now we see, if we call our list of people at zero, we'll get nothing back because it starts off as a blank array.

But now we have this new ad person function where we can, you can kind of see very faintly. It takes a string name and a U in 2 56. A favorite number. So we can add Patrick seven. We'll hit add person, which if you have your terminal, you'll see we made a transaction and now if we hit list of people at zero, we see we have a deed added a person to the zero with index.

Patrick has a favorite number of seven and his name is Patrick. Obviously if we hit one, we'll get nothing back and this will just stay up. But if we add another person, maybe John 16, add person. Now at list of people index one, we now see John 16, so zero, it's gonna be Patrick seven, one John 16, two is nothing.

So nothing happens.

Now we've talked about this a little bit already, but if we go ahead for example, and maybe delete this semicolon, and we go to try to compile and we scroll down, you'll see we get this error, partial error expected semicolon, but got bracket instead. And it gives us this little red exclamation mark in the line that it's having an issue with.

All these red errors mean that your code isn't compiling and you can't actually deploy this to the blockchain because Solidity doesn't know how to turn this human readable code into a machine readable code. So we need to add this semicolon here, recompile, so we get no errors. Now interestingly though, if we go to the top, and let's say we delete this P X license identifier, and now we compile, we scroll down, we get a yellow box and it says warning instead of error, it says, warning spdx, license identifier not provided, source file, blah, blah, blah.

Interestingly though, if we compile this, we actually let's delete our last simple storage. We can deploy this. So if something important to note is warnings are just that, they're just warnings, they won't prevent you from deploying or compiling your code. Errors will prevent you from deploying or compiling your code.

Now, even with that being said, though, it is good to try to remove all of the warnings because the warnings are generally there for a reason. They're warning you that you might be doing something bad. And sometimes if you have a bug in your code, simply just listening to the warnings would've solved it.

So it's best to listen to the warnings here. So to summarize, if it's red, it's broken, if it's yellow, if you might want to check it out. And additionally, when it comes to these errors and these warnings, this is where using our AI and Google searching skills can really come in handy. Let's say for example, I ran our code.

I get this error, I read the error, and I don't really understand what's going on. What we can do is we could maybe copy this error and use any of these search features that we talked about. Resources for this course. We can use chat G B T or find GitHub discussions, stack Exchange Ethereum and Piana. And I'll explain what each one of these is good for later in the course.

But for example, let's go and try out Find. Find is an AI search ended for developers. What it does is it first does a Google search and then it reads all those links and based off the links it reads, it tries to give you an answer. So what we could do is we could say, I am getting this compiler error in Solidity.

How do I fix it? We hit this little dropdown, put any code or context here, we will paste our error. This is the error like this, and we'll go ahead and hit search.

We get a pretty verbose response on what's going on with our code. We could actually take this a step farther and we could copy our entire code base and we could paste it under here. We say code usually put three back ticks before and after any code that I use, and I'll teach you why in the future.

Well, let's go ahead and hit enter and research and actually is able to read our code and say, One way to fix the air is to simply add a semicolon at the end of the line where you push the new person to the dynamic array list of people, and we could see if we do indeed get a way to just copy our ad person function and we can scroll down and just paste it on top with it being fixed.

And we could also say concise, because it's being a little too verbose for us. We'll hit enter again, and it wasn't that concise, but a lot of these AI tools, like I said, are still in beta, but this was a good example of how using an AI tool like this can actually help you detect bugs. Like I said, oftentimes they will still get things wrong, which is why it's important for you to know about GitHub discussions, stack Exchange, piana, et cetera.

Later in the course, I'll explain more about how to ask good questions, how to do good AI prompting, how to format your questions and how to search and learn more. One of the key pieces of being a really good software engineer or a good prompt engineer is less about actually knowing the information and more about knowing where to find the information.

So throughout this course, I want you to practice using these resources because they're gonna help you be a much stronger developer, much stronger prompt engineer, and just be better at everything that we're gonna go over in this course. If find or chat topi t gives you a poor answer, be sure to use the GitHub discussions.

If you have a question specific to this course, be sure to use the GitHub discussions. Or if you have a more general question about solidity, about Foundry or anything like that, you can use one of these resources. Again, I'll go over this more later, but great job. You've done your first bit of prompt engineering.

Congratulations.

You don't have to understand this section fully. Now, one thing that we didn't really go over and we kind of glossed over was this memory keyword. And you'll notice if we actually delete this keyword and you try to compile, we'll get an error data location must be memory or call data for parameter in function, but none was given.

Now there are actually six places you can store data in solidity. You have the stack memory storage call, data code, and logs. We're not gonna go over all of these areas right now, but we are gonna go over some of the big ones, which are call data, memory, and storage. And this is gonna be a little bit advanced here, so if you don't understand this section the first time, don't worry about it.

Just keep pushing through. It'll make more sense as you go later on in the course. Call. Data and memory both mean that this variable is only going to exist temporarily. It's only going to exist for the duration of the function. Call any call anytime we call ad person with a different name. We can only access this name variable that one time that we call this function.

If I call ad name Patrick seven, now I try to list of people at zero. Obviously we see Patrick at favorite number seven. We can actually never access that Patrick variable ever again because it existed in memory. It existed for a very short period of time just for that single call. We could also have call data here and we'll go ahead, remove this, deploy the dropdown into the same thing.

We'll add Patrick. And actually you don't even need the quotes. Patrick will do 88 add person. We'll see if it's in there. Sure is all data and memory both mean temporary variables inside of functions. Most variables automatically default to memory variables. Strings are a special type in solidity, so you have to specify memory or call data and it has to do with the way arrays work in memory.

But we'll talk about that much later in the course. Now the question obviously then follows. Okay, well if call data and memory are both temporary variables, why have two? What's the difference between these two? Well, let's try something. Let's have this be a memory variable and in here we will say name equals cat.

So we're gonna reassign whatever people put in here to cat. Let's compile this. Looks like it compiles fine. Now let's do call data and try to compile. Ah, we get an error type. Error type. Literal string cat is not implicitly convertible to expected type string call data. The difference between memory and call data is that a memory variable can be changed.

It can be manipulated. If we pass a memory variable to a function, we can go ahead memory and I hit and I hit command S to compile. This is valid solidity. This is not, if you pass a call data variable, you cannot modify it. Call data is temporary variables that cannot be modified. Memory is temporary variables that can be modified and storage is permanent variables that can be modified.

My favorite number was actually implicitly converted to a storage variable since it's added in this state context outside of a function, if you create a variable that's outside of any function inside of a contract, it'll automatically be a storage variable. And let's delete this line. Let's compile, let's deploy again, delete this, deploy.

We know it's a permanent variable because we can hit retrieve and we can always access what is in favorite number. So if we store 1, 2, 3, we hit store, we can hit retrieve and we can access 1, 2, 3. So this variable, 1, 2, 3, exists outside of function calls. Now, even though I said there are more places like stack code, log return, et cetera, we can only make these variables call data memory or storage.

And like I said, we'll explain that later in the course. So let's go ahead, let's add this back to memory cuz that's normally what you'll see. Now the next question that logically falls is, oh, okay Patrick, well why do we need to put memory here? But we don't need to put memory over here. In fact, if we try to put memory there, We had an error data location can only be specified for array struct or mapping types.

But memory was given, like I was saying earlier, arrays, structs, or mapping are considered special types in solidity. And the way that memory management works under the hood makes it so that we have to put this memory keyword. U N 2 56 is known as a primitive type, and solidity is smart enough to know where to put this favorite number.

Always under the hood, like we were saying earlier, a string is actually an array of bites. And so, so as we just saw with the air, we need to put the memory keyword for arrays. So then the next question is, okay, well what about the storage variable? Can I put that here? No, you can't put that here either.

Since this is a function, solidity is smart enough to at least know that, ah, okay, this is a temporary variable that you're working with. It's gotta be memory or call data. It's not gonna be storage since this name is only gonna exist for a short duration. So you gotta pick one of these other two. So the summary of this section is that struc mappings and arrays need to be given this memory.

Keyword string is an array of bytes, so it needs this memory or call data keyword.

So this code is starting to shape up. It has a lot of functionality here. We can store variables, we can add people, but it has a bit of an issue if we have this contract and we wanna say, oh, what was Kelly's favorite number? Let's say we have four people on the array. Let's have Pat seven, John eight, Mariah 10, and Chelsea 22 or 232.

And we ask the question, ah, what was Chelsea's favorite number? Well, the way we would do it is we'd have to actually loop through this list of people to find Chelsea. So we'd say, okay, what's at zero? Ah, okay, that's Pat. That's not Chelsea. What's at two? Ah, that's John. What's at three? Ah, that's Mariah. Or excuse me, what's at three?

Ah, that's Chelsea favorite number. 2 32. Okay, perfect. I found Chelsea. But obviously if we had a thousand people in this array, that would be a very tedious process and that would take a long time for us to find the person that we wanted. So the question then is, is there a better data structure than a list or an array to use that makes it much easier to access and find the information about the people that we want?

And the answer to this is using a mapping. You can think of a mapping as a dictionary. It's a set of keys with each key returning a special set of information about that key. So it's similar to a dictionary. If you look up the word the the word, the will have a whole bunch of tax associated only with the word the, so let's create a mapping type and you'll see how it works in practice.

So we're gonna create a mapping like this with this mapping keyword, and we'll say the key is going to be a string and it'll point to a U into 2 56. So this is going to be our type, obviously what comes after the type our visibility. So let's just go ahead and do public for this as well. And I like to be very explicit with my naming.

So I'm gonna say name to number, signifying that this map maps someone's name to their favorite number. And now with this we have essentially a dictionary where every single name or every single string is gonna map to one number. So for example, if we looked up Chelsea, we'd automatically get returned, the 2 32 that we're looking for instead of having to iterate through this list.

So let's add some capabilities to our ad person function here so that we can update our mapping. So we have this list of people push, which adds someone to the array. Let's also update this. So it will also add somebody to our mapping to do that. We'll say name to pay over it number. And we put these little brackets in here to specify what the key is, and we'll say underscore name, and we'll assign that to underscore favorite number.

What this line is doing is now it's saying, all right, in our mapping up here in our name to favorite number mapping, anytime you look for that person's name, you'll automatically get their favorite number back. And now you have a much quicker way to access people's favorite numbers just by knowing their name.

So let's go ahead. Let's compile this. Let's deploy this. Let's delete our old one. We'll deploy this. Now we have this new name to favorite number, blue button. And so let's go through the same problem. So let's say we have Pat seven, John 16, Mariah 32, Chelsea, 2 32. Now same thing. List of people, zero returns, pat list of people, one, John, so on and so forth.

Or we could just go down here and let's say, let's look up Chelsea. And we automatically get 2 32. We get Chelsea's favorite number back automatically. Same thing. If we look up Pat, we get seven. If we look up John, we get Mariah. And if we look up cheesecake, we get nothing back. In a mapping, the default value for all the keys is zero.

So if you look up a key or a word that we haven't added in the mapping yet, it defaults to the default value of whatever that type is. Since ours is a string to U at 2 56, U at 2 56, default type is zero. If we look for a key that we haven't added, we get zero back.

So now that we've added all this functionality, we're looking pretty good. We really like the way that our contract is set up. We have our, my favorite number. Which is a internal variable, but we have a way to read it with retrieve. We have our new typing person, we have a public list of people array.

We've got a public name to favorite number. Got a way to update the favorite number, retrieve the favorite number, and add people to both our list and our mapping. Now, in the future, you'll hear me say that you should never do this before you write any tests, before you get it audited. But for now, this is just a dummy contract that we're gonna deploy on a testnet.

So we don't really care. But let's go ahead and learn how to actually deploy this to a real testnet. This is going to simulate what deploying to a real network with real money is gonna look like. Are you ready? You should be. This is gonna be incredibly exciting. After you do this successfully, you should 100% tweet about it on Twitter, on LinkedIn, on lens protocol, on whatever social media you want.

It's important to celebrate your small wins. Surprisingly, it'll help motivate you moving forward. So first off, let's make sure this actually compiles. Okay, cool. We've got a green check mark. There's no warnings. There's no errors. Fantastic. Now let's go back to the deploy tab and we'll delete this down here and we'll scroll up and we're gonna change the environment.

We're in this remix VM and we're actually gonna move to injected provider meta mask. Remember this remix VM is kind of this fake world that remix gives to us. Injected provider meta mask means that we're going to literally inject our meta mask into this remix. We're going to inject our meta mask into this website.

We're gonna allow this website to interact with our meta mask. We'll first get prompted by meta mask to pick the account we want to use. I'm gonna use account one and hit next. And we're gonna go ahead and hit connect. Similar to the way we connected to the faucet, if we scroll up to our meta mask, we now see, oh, it says your account is not connected.

That's because I'm currently on account two. Let's flip to account one. And we do indeed see that account one is connected. And now before where we saw kind of this fake account with fake ether, we see our actual account with the actual amount of seia E that we have. Make sure that, again, be sure to use whatever recommended Testnet we have in the GitHub repo for us.

We're using Selio. Don't worry about the rest of these for now. So make sure you're on the correct testnet. To deploy to a testnet, you're gonna need some Seia eth. So if you haven't been to the faucet, be sure to head over to the faucet to get some seia eth. Remember, you can find those in the GitHub or Web three Dev Education.

Now in remix, what we're gonna do, we're gonna do the exact same process we use to deploy to the virtual remix environment. We're gonna do that to deploy to the test set environment. So we're gonna go ahead and hit the deploy button. And meta mask is actually gonna go ahead and pop up. This is similar to what we saw with the blockchain example with signing transactions.

We're actually going to sign and send a transaction on the test set. It's similar again to us sending Ether to ourselves. The difference here is though that our data section has a ton of information here. All this data is associated with sending this transaction, but this one has all of this contract information encoded in machine readable code or our compiled code in details.

We can see all the pavement information associated with this transaction. We can see exactly how much gas it's gonna cost to deploy this contract on chain. But again, we're on the Pulia test network, so this is fake money. Anyways, to actually deploy this, we're gonna go ahead and hit the confirm button, and now we're gonna have sent our function.

If you have the terminal up, you can see we have this call created and it says Creation of simple storage pending with this view on Ether scan button. If you click the view on Ether scan button, you'll get brought to this Ether Scan page. With this transaction going through on seia, you'll see it's currently being indexed by Ether Scan, but there's a good chance it already went through and back in remix.

It actually goes ahead and gives us this green check mark saying that we did indeed deploy this contract. You might have to wait a few minutes for this to complete, because again, we're sending a transaction to a testnet blockchain, and the blockchain needs to actually produce the block with our transaction in it.

But if we wait a few minutes on Ether scan, we'll eventually see a success status with block confirmations on this block section here. And exactly the same as what we saw with sending ETH to ourselves. We see all this information about the transaction transaction, hash status block time from two, blah blah, et cetera.

But if we scroll down, this input data field is much bigger than anything we've seen before because again, this is all the data associated with creating this contract. And of course, we see more gas fee information because again, deploying a smart contract to the chain is modifying the blockchain. So we have to spend gas.

Now, if we come back to our remix and scroll down, we're able to see our simple storage contract and we're able to copy the address that it's at. So if we copy this address, we go back to Ether Scan. We can even paste this into the bar here, and we can see this contract that we went ahead and deployed.

Ether Scan is smart enough to know that this transaction created a new contract. Remember, this has to be on the seia Ether scan, not the main net Ether scan because we sent this on the seia Testnet. So now that we have this contra created, we have all the exact same functions that we had in our virtual environment, but these functions are actually on a testnet with a contract that we actually deployed.

Now we can do all the exact same things we were doing on our fake remix environment on this test environment. For example, we can call retrieve, which doesn't send a transaction, it just reads off the blockchain and we get zero. Same as what we got before. If we look up a name like Pat in named a favorite number, we get nothing back cuz we haven't updated anything.

If we add zero in here for list of people, we get nothing back as well. Meta mask didn't pop up here because these blue buttons are view, functions, view and pure functions. Like we said, don't send transactions. Now let's go ahead and actually send a transaction. Let's update the blockchain. Let's update our contract by storing a new favorite number.

So let's do 7, 8, 7 8 and we'll hit store and we'll press this orange button. You'll see you'll get prompted with meta mask actually popping up saying, okay, let's update the blockchain. Let's send this transaction. And if we go ahead and hit confirm the exact same thing happens, we'll get this transact to Simple Storage.

Storage transact to Simple storage.store pending view on Ether scan's, a little check mark. If we view it, we can see the transaction indexing on Ether scan. And after you wait for a little bit, the transaction will go through. And now if we hit the retrieve button, we can see we have now stored 7 8 7 8 on chain.

If we copy the contract address again, we paste it into Selio Ether scan, we scroll down. After a few minutes, we'll actually see a second transaction come through. We see two transactions associated with this contract. The first transaction obviously is the contract creation transaction and the second transaction is us actually calling the store method.

Ether Scan is smart enough to know that this is the store method. It's not always smart enough to know that, but for this one, it's smart enough to know and we see that we actually updated our contract. And remember, in the future, please use these testnet sparingly. We're just starting out and we're just learning.

So it's okay for us to send these transactions here though, but let's go ahead and let's keep going because named a favorite number of Pat still returns nothing. List of people, zero still returns nothing. So let's go to ad person. We'll do Pat 16. We'll hit ad person Meta Aask pops up obviously because we're updating the state of our contract.

We'll hit confirm. We see transact to Simple storage.ad. Person is pending. It looks like it has succeeded. So now if we do named a favorite number of Pat, we see 16 get returned. And if we do list of people at zero, we see we get Pat whose favorite number is 16. And guess what? At this point, you've successfully deployed a smart contract to a real test net.

Congratulations. You should be incredibly excited for yourself. Be sure to give yourself a pat on the back, maybe go for a walk, maybe have an extra cup of coffee or an ice cream because additionally, you've also interacted with that contract, with these buttons and remakes that allow us to send transactions to update the state of our contracts.

Congratulations, you're a Solidity developer, but we've got a lot more to go and like I said, make sure to celebrate these little wins. Celebrating little wins will motivate you and excite you to continue to move forward, so be sure to take the time to pat yourself in the back. Congratulations if you've got this far.

There's a ton more for us to learn, but just you getting here is a fantastic achievement in itself. Now here, if we wanted to deploy to a different testnet, all we would have to do in our meta mask is switch to a different testnet, like linear gorilla. Since we don't have any linear gorilla, we actually can't deploy this to a testnet, but if we used a faucet to get more linear gorilla eth, that's how we would deploy it.

Additionally, we could do the same methodology for deploying to Ethereum main net or any other main net that you wanna work with throughout this course. The difference here is obviously you just need to buy some Ethereum to actually deploy. This smart contract remix will automatically update to what whatever network you're working with.

For example, right here it says, ah, you're working on the main network, but if we were to switch to Gore, it would say, ah, you're working on Gore. But if we were to switch again, it would say, ah, you're working on Leia. In the future, we'll learn to add different networks so you can learn how to deploy to any other E V M compatible network that you want to.

Now, I've mentioned this a couple of times, but whenever we compile this code, it compiles it down to something called the E V M or the Ethereum Virtual Machine. Don't worry too much about exactly what this means, but essentially the E V M is a standard for how to compile and how to deploy smart contracts to a blockchain.

Any blockchain that is VM compatible, you should be able to deploy Solidity code Two, some examples of VM compatible blockchains and layer twos, which again, we're gonna go over working with layer twos. More in the future are going to be Ethereum, polygon, Arbitron optimism, ZK sync, and more. Just note that it's important to double check the blockchain before you launch to it.

For example, zk sync is E V M compatible, but a couple of keywords don't actually work with ZK syn. Now let's do a quick recap of everything we learned in this lesson, and then after we do this, be absolutely be certain to take a break, maybe go get some ice cream, go get that extra coffee, or whatever you like to do.

The first thing you want to do in any smart contract or solidity code that you write, be sure to write the version that you wanna work with and above the version, be sure to add the S P D X license identifier. If you're not sure what version to use for now, just default to M I T. Then you have to create your contract object and name your contract.

A contract is similar to a class in other programming languages. Anything inside of the curly brackets for the contract is part of that contract. There are many different types in solidity like you at 2 56 string bullion int, et cetera. If we wanna create our own type in solidity, we can use what's called a struct.

You can create arrays or list in solidity. You can create mappings or dictionaries or hash tables in solidity. Where if you give it a key, it'll spit out the variable associated with that specific key. We can create functions in solidity that modify the state of the blockchain. We can also create functions in solidity that don't modify the state of the blockchain view and peer functions.

Don't modify the state of the blockchain. We can also specify different data locations in our parameters of our functions, but we can only do that for special types like strings, STRs, and arrays. Call data and memory mean that that variable is only temporary and will only exist for the duration of the function.

Call storage variables are permanent and stay in the contract forever. Function parameters can't be storage variables since they're only gonna exist for the duration of the function call. Whenever we hit compile in our smart contracts, it actually compiles our solidity code down to E V M compatible bite code or machine readable code.

We'll learn more about those specifications later. And last but not least, congratulations on your first contract here.

All right, let's get started now with our lesson three. Remember, everything is in the GitHub repository or the Web three Dev education. If we scroll down, once again, we can scroll to lesson three. And again, a lot of this is undone, but it'll be done for the actual video. Scroll down to lesson three, and we have lesson three Remix Storage Factory.

All the code that we're gonna be working with is in this remix Storage Factory, F 23 GitHub repository, all of the GitHub repos associated with this course. End with F 23, which stands for Foundry 2023. I'm gonna first do a brief walkthrough of what we're gonna be coding for this lesson. So for now, just sit back and relax and enjoy.

For this lesson, we're gonna be working with three new contracts. Our original simple storage sole, which we're gonna do a slate modification to a new five storage sole, or add five storage.so, and a storage factory sole. Our storage factory, so is actually gonna be responsible for deploying new simple storage contracts.

Yes, other contracts can deploy contracts. Not only is this going to be able to deploy other contracts, but it's gonna be able to interact with other contracts as well. What we could do is we could deploy this to a remix vm Deploy. We'll compile all of our code, go to a remix vm. Scroll down. To select the contract, we're gonna select Storage Factory, not Simple Storage.

Deploy this. See that contract that we just deployed down at the bottom? And you'll see our top function is this function called Crate Simple Storage Contract, where if we pull up our terminal and we click Create Simple Storage Contract, you'll see we get a new transaction at the bottom. And this transaction is the transaction that we deployed a simple storage contract from our storage factory contract.

Now we can actually go ahead and interact with our simple storage contract. Remember, in simple storage, we have a function called store, which takes a favorite number. We can actually call this store function on our simple storage contract from our storage factory contract using this F store function.

So we'll add the index of our civil storage contract, which since we only deployed one so far, it'll be at index zero. And we'll say our new favorite number is 1 23. And we'll hit F Store and we'll click SF Store at 0 1 23 SF Store sends for a storage factory store. So we're gonna store the number 1, 2, 3 on index zero.

And again, don't worry about this making too much sense yet. We're gonna explain this all in a minute. Now, if we hit SF get of zero, we'll go ahead and get back. 1, 2, 3. We're saying let's get the value of the simple storage contract stored at index zero, and we do indeed get 1, 2, 3. Additionally, we have this list of simple storage contracts, array or list, and it's only size one right now, but if we type in zero here, we get back the address of that original simple storage contract that we deployed.

Additionally, in this lesson we're gonna learn about a ton of incredibly important solidity features, such as imports and inheritance. Without further ado, let's get froggy.

And one more time. Of course, remember, all the code is available in the Foundry, full course, F 23 of the chain excel org, or on the Web three Dev education site. Once it's up. So here we are back in remix with our simple storage. So if you skipped over the last section and want to get that contract, just come to the full repository, go down to lesson two.

Go over to the code in the GitHub repo associated with this course, the remix, simple storage F 23, and just copy and paste everything into remix yourself. Make sure you've done it correctly. Be sure to hit compile. We have our simple storage contract that we created in our last lesson, which is great. It allows us to store our favorite number, and it allows us to store a list of people who have different favorite numbers, also on mapping and some other different functionality with interacting with people's favorite number.

But we wanna go even further with this. We want another contract to actually deploy this civil storage contract for us and interact with it. Contracts interacting with each other seamlessly. And Permissionlessly is a feature of smart contracts and blockchain development. That's absolutely essential and crucial.

And one of the reasons why blockchain development is so powerful. The ability for contracts to interact with each other seamlessly is something known as composability. Smart contracts are composable because they can easily interact with each other. This becomes even more important when we get to topics such as Defi, where we can have incredibly complicated financial products and instruments interact with each other seamlessly because they're all using the same smart contract interface.

So we're gonna keep our simple storage sole the exact same way it was from the last lesson, and we'll update it in a little bit. But let's go ahead and create a new contract called Storage Factory dot Soul. So let's go ahead and get this contract set up. Now. We're gonna be doing this a lot, and when we work with AI pair Programmer, now we're gonna be doing this a lot.

And when we work with AI pair programming, this is gonna be a lot easier for us to do. But for now, repetition is the mother's skill. So let's keep going. First thing we need to do is what, if you wanna pause the video and add the first two things you should put at the top of every Solidity Smart contract right now, go ahead.

But for those of you who didn't pause, let's go ahead and do S SP D X license identifier, mit, and then let's do Pragma Solidity, 0.8 0.18 or 19 or whatever you wanna do. You know what? Let's do 19. What do we do in Simple Storage? We did 18. Let's do 18, and then we'll do contract. So this will be the third thing, actually, contract storage factory like this.

And I hit Command S, but you can also go and compile like so, and I'm also just gonna add the carrot here, meaning we're gonna use 0.8 0.18, but any version greater than that also works as well. Awesome. Now, this Storage Factory contract is gonna be deploying a simple storage contract. So let's create a function that can actually deploy or create a simple storage contract.

So we'll say function, create simple storage contract, and we'll make this a public function and we're gonna have this create simple storage contract function, deploy a contract, and then save it to a state variable or a storage variable. But the question is, okay, well how does the storage factory know what the simple storage contract even looks like?

How does this contract know about this contract? How does this contract know that this contract even exists? The first way that we could do this is we could actually go to our Simple Storage. So contract and start highlighting from the contract word and scroll all the way down to the end of the contract.

Copy it, command C, or right click copy, go back over to Storage Factory and below Pragma Solidity, but above Contract Storage Factory. Paste it in here. If we go ahead and command S or compile this, you'll see that this actually goes ahead and compiles successfully. Huh? So this is to show you that yes.

Right now in our storage factory, so we have Contract Simple Storage, which ends here, and we also have Contract Storage Factory down here.

You're allowed to have multiple contracts in the same file. Now this isn't a best practice because we really don't wanna be having multiple contracts in the same file when we could separate them out into their own files. As your projects get bigger and bigger, if you just add all of your contracts into the same file and can get really, really confusing and really difficult to jump around the code and find the places where you wanted to add stuff.

So normally it's best practice to keep them separated like we did above, but we'll learn a little bit more about how to keep them separate in just a minute. If you go down to the Deploy tab and you stay on the remix VM and scroll down, you actually have this section to choose your contract. We can choose either one of these contracts right now and if on the right side you have Storage Factory.

So in this contract section you can actually choose either one Simple Storage or Storage Factory and you can see they're both in Storage Factory. So if on the right hand side we go to Simple Storage and we go back to this contract section, we can only choose Simple Storage cuz the Simple Storage contract only has one contract in it.

The Storage Factory has both Simple Storage and Storage Factory. So that can get a little confusing as well if you have multiple contracts in the same file. But let's stick with this methodology for now in our storage factory and let's even close out Simple Storage dot. So at the top, just so we don't get confused in our storage factory dot.

So let's scroll back down to Storage Factory because now that we have our simple storage in this file, we can actually deploy the simple storage contract.

So this function is going to deploy a simple storage contract, but we're gonna save it to a storage or state variable and we're gonna do it the exact same way we've been saving any variable. First thing, remember like remember how we did u n 2 56 public favorite number. This was in the format type visibility name.

We're gonna do the exact same thing. The type of a simple storage contract is gonna be simple storage, and the reason that Solidity is gonna be able to identify this keyword is because it's the same name as contract in the same sense that our struc keyword allows us to create a person type. The contract keyword allows you to create a new type of, well, a type of simple storage contract.

So simple storage for now, we'll just give it a visibility of public and we'll give it a variable name, simple storage. Now this is going to be a syntax. You're gonna see a lot, and it might be a little bit confusing the first couple times you read it. The difference between these two is very subtle. The difference between simple storage on the left and simple storage on the right is very subtle.

It's simply that the S is lowercased over here and the S is capitalized over here. Solidity is case sensitive, so these are actually different word simple storage. Here is referring to the contract. Simple storage here is referring to the variable. You'll often see people use the syntax when working with contracts where they name the variable, the exact same as the contract itself.

If this is confusing to you, you can do my simple storage instead of simple storage with lowercase. So either one of these works, it's good to get used to this as such, but if that's confusing, you can do my simple storage. Now in our Create Simple Storage contract function, we're gonna say simple storage equals new simple storage.

Like this. This new keyword is how Solidity knows to deploy a contract. So with just code alone, if we go to the compile tab, we compile this, this does indeed compile, we can go to deploy. We need to make sure we're on the storage factory dot. So on the right hand side, we'll scroll down to the contract. We can actually deploy our storage factory like so hitting the deploy button.

And remember, you can see the transaction in the terminal here and we can scroll down to the contract right now. There's two buttons. We have our blue view function, simple storage, because again, the public keyword automatically gives the variable name a getter function or a view function. And of course we have our Crate Simple Storage contract orange button, because it is actually a transaction right now.

Simple storage returns, nothing. The zero, the default value for an address, which is the zero address. And if we call create simple storage contract, we get see a green check mark, meaning that transaction went through. Now if we call the simple storage Blue View function, we see we indeed get an address here.

We have deployed our simple storage contract from another contract. Oh my goodness. So congratulations. Now you know how a contract can deploy another contract. Awesome job.

But the thing is, like I was saying, if we just add all of our contracts into the same file and we have these massive contracts, all interweave between each other can get very cluttered and very confusing. So is there a better way we can actually arrange and organize our code? Other than this, and this is actually even a little bit redundant since we already have our simple storage dot sole.

If I change something in here, then I would also have to go and change it in here. And that's too much work for me. As an engineer, I will work incredibly hard to be incredibly lazy. So instead of doing this, we can use what's called an import. If we go ahead and delete our contract, simple Storage in our storage factory here, so that now we just have the Storage Factory contract, we can go ahead and use the import keyword to import Simple Storage dot Sole.

So we can do import, do slash Simple storage Sole and a little semicolon here. This import slash Simple storage sole is the exact same as if we had this giant simple storage in here. So this Import Simple Storage dot Sole is a shorthand version of Copy pasting that Simple Storage. So into this contract.

And now we're able to have Simple Storage Sole in its own file and storage factory, just import it from simple storage, making our lives much easier. It takes our path package or GitHub, which will explain it a little bit. And I, and copy paste whatever in that file at the top of our file. Literally solidity for us is copy pasting everything in here and sticking it up here so we can go ahead, run this again.

Let's compile lead old contract run Remix vm. Let's be sure we're on Storage Factory. We'll go to Storage Factory, we'll deploy it. Scroll down, click here. Simple Storage starts up is nothing. Create Simple Storage. Oh my goodness. Look, we deployed a contract, hazah Great work. So now that we're starting to work with different files, there's a number of things we want to consider.

The first one is actually the Solidity version. So right now we're using 0.8 0.8 with no Carrot and in Storage factory we're using 0.8 0.8 with a carrot. If I were to, for example, move the solidity version of this down to 0.8 point 16 and go to compile this with a different version, remix is actually gonna remix, is actually gonna automatically bump this up to 0.8 point 19.

Or actually remix is actually gonna automatically bump this up to 0.8 0.1 18 if I'm on the simple storage because 0.8 point 18 is the version that works for Simple Storage and it still is compatible with Storage Factory. However, if I were to take Storage Factory and move it to 0.7 0.6 and try to compile, it's gonna try to compile this with 0.7 0.6 and our simple storage with 0.7 0.6 and it's not gonna be able to do it for both.

And so we're gonna get a compilation error. So when working with multiple files, it's important to keep the version of Solidity in mind cuz you wanna make sure that all of your contracts can actually compile together. So this is great and all but right from the get-go, I wanna teach you the more advanced import that you should always use.

So this is good, but we actually never want to default to this. We want to default to something called Named Imports. Let's say our Simple Storage. So Contract had a ton of other contracts like Contract Simple Storage Two, simple Storage Three, simple Storage Four. And these were all massive, massive contracts.

As we have this right now, import Simple Storage, so would import everything from here. Simple Storage, simple Storage Two, simple Storage three, simple Storage Four. And if these files were incredibly big when we deploy our storage factory, it would have to calculate all this extra computation, making the deployment of our storage factory more expensive.

If that's confusing to you, don't worry about it right now. Additionally, in the future, these can import from weird places that aren't compatible with Storage Factory. Again, that's not gonna make sense quite yet, and that's okay. But in any case, there's a way for us to not import this whole file, but only a very specific contract or a specific section of our simple storage.

So, so instead what we can do is in our import statement, we can specify the exact contract that we want to import from this file. So in our Simple Storage dot, so let's say we do have these other contracts in here, we could say we only want to import Simple Storage, not Simple Storage. Two, not not Simple Storage three, not simple storage.

Four, by saying import these little brackets here. Simple storage from simple storage. So, and this goes ahead and compiles correctly, we could also import multiple contracts from our simple storage. For example, we could do import simple storage, simple storage to from simple storage dot. So this way we only import the exact specific contracts that we want from these other files.

And I promise you in the future, always referring to named imports instead of this type of imports will save you a lot of headache in the future. So always default to this, never default to this, just by learning this, you are already better than 80% of the current Solidity developers. So congratulations.

But alright, fantastic. So we've learned about imports. We're able to import our simple storage from Simple Storage dot Soul. We're importing it in the more advanced way. Congratulations. Now,

already here you might actually start running into some questions, right? And we're gonna get more and more advanced with this course, and you're gonna have questions, which is a good thing. If you don't understand stuff, that means you're thinking critically and you're approaching the subject matter the right way.

So this is where we're gonna jump into, again, doing a little bit of an AI chat example. So for example, on this line, let's say you're a little bit confused and you go, what's the difference between simple storage here and simple storage Here? I don't understand. So let's learn how to work with chat BT or any AI buddy to ask them to help clarify.

So we're gonna go ahead, I'm gonna hit command A, or you can just highlight everything. Command C to copy or right click copy. We'll go over to chat vt. And in here we're going to ask the question, hi, I'm having a hard time. And let's zoom in, understanding the difference between these simple storages on this line.

And here's where we want to be very specific when we're talking with ais. So I'm gonna hit shift enter so that it doesn't actually send the question to Chatt bt, but I'm gonna put three bag ticks, shift enter again. And actually I said we're gonna copy the whole thing, but let's just copy this single line and paste it in here.

Shift enter, again, three back ticks again. Adding this delimiter tells Chachi VT that this is a block of code and it makes it easier for Chachi VT to be able to understand that this is a block of code. Then it'll hit shift, enter twice. And if you have a lot of code, you're not gonna be able to copy your whole contract because a lot of these ais can only understand so much in a question.

But this is small enough that we can actually just go ahead and copy the whole thing, bring it back over to chat with T and say, here is my full code. And then we'll do again, shift enter three back ticks, shift, enter, paste, shift, enter three back ticks. So now we have a little AI prompt here that we can ask in chat, should bet.

And, and I don't have this in here yet, but in the GitHub repo associated with this lesson, I will add this AI prompt in here. So let's go to the bottom. And I was saying you needed to use shift enter, but I guess you could just use enter. That's fine. Let's go ahead and click the send button and I'll send it the question.

So now it'll start outputting here and let's see what it says. And this is where we can already start to see the power of these AI buddies as learning buddies. We see in the given code, simple storage is a variable of type simple storage, which is a contract defined in simple storage. So tells us what the line is doing.

It clarifies the differences a little bit more. And a lot of this beginner basic stuff ais are really good at. Once we get more and more advanced, ais are gonna start breaking apart. But at least for the beginning of this course, AI are gonna be incredibly helpful and incredibly good at explaining a lot of these.

What we could do if we wanted to, is we could also go ahead and copy this prompt. We could go over to something like Bard, paste it in here and ask Bard the same thing. And here's already a good example of where an AI can get things wrong. If we scroll down, it's telling me you can use simple storage variable to interact with the new simple storage contract.

For example, you could call the set function to set the value on stored data variable, or you could call the get function to get the value of the stored date variable. Uh, there is no stored data variable, so I don't know where it's getting that from. So just remember, keep in mind that AI can get things wrong and that when they do, there are other forums that to use as well.

Like I said, we're gonna be learning about them as we go on like Stack Exchange, Ethereum, Piana, or like I said, of course, the discussions forum of this course. So if Bard or Chet VT or whatever AI buddy you're working with gives you something confusing, be sure to go to the GitHub discussions or ask on one of these forms.

Now, as you can see though, right now, every single time we call Create Simple Storage contract, we're gonna deploy a new Simple storage contract, but we're gonna override it in this simple storage, right? So if we go ahead and deploy this right now, we'll scroll down here, simple Storage at the Zero address Create.

Okay, now it's at a new address. Create again. Okay, now it's at a new address. We're not keeping track of all the different addresses that this simple storage contract is being deployed to. So let's actually create a running list of all the different simple storage contracts that we're deploying. So instead of having this variable be just a single simple storage contract, let's have it be an array or list of simple storage contracts and we'll, we'll change the name to list of simple storage contracts.

So now when we deploy it, instead of saving it like this, we're gonna do what we did before. In our last section, we'll say simple storage, new simple storage contract equals new simple storage. And then we'll push it onto our dynamic array. So we'll say list of simple storage contracts, push new simple storage contract.

So let's go ahead and compile this. Okay, looks good. Let's go ahead and deploy this. We'll delete our old one. We're on the remix vm. Great Storage Factory. And look at this. You can even see, make sure we're on Storage Factory. Okay, great. And we'll go ahead and deploy that. Awesome. We get list of simple storage contracts, which now has this U at 2 56 input, which allows us to choose the index of the variable.

We'll go ahead and create simple storage. Now, if we go check the zero width index, we have an address. If we check the first index, nothing happens. If we call create again, which, sorry, if I have the terminal up, I'll call Create again. Again. Now there is one at the first index, and since I called it twice, there's also one at the second.

There's nothing at the third. I'll hit create again. There's now one at the fourth. Oh, at the third. Excuse me. Awesome. So now we actually have a running list of all of our simple storage contracts. Now let's learn how to actually interact with other contracts from a contract. For now, we can think of our storage factory as a sort of manager for all these other contracts.

So let's learn how our storage factory contract can actually call the store function of the civil storage that it deploys. So let's create a function called SF store, which is gonna stand for storage factory store. And it's gonna take two variables, a U 2 56 underscore simple storage index, and a U 2 56 underscore new simple storage number.

I'll make this public like this. Now, in order to interact with a contract, you're always gonna need two things, and we're gonna refer to this a lot. You're gonna need an address and you're gonna need the A B I. Now, this is technically a lie. You really just need the function selector, but we're gonna learn that way, way later in the course.

For now, just think, okay, I always need the address and I always need the abi. The ABI stands for Application Binary interface. The ABI will tell our code exactly how it can interact with another contract. We'll go deeper into the ABI later on in this course. But for now, if you go to the compile tab, you compile and you scroll down, there's this little button at the bottom that says Copy ABI to clipboard.

Or you could also go to compilation details. You can see a ton of information about the compilation details such as the bike code with the op codes, the metadata, the name, but also the A B I, which tells us the ways we can interact with this contract. If we hit the dropdown for the zero, we say there's an input create simple storage contract, which is one of our functions.

You see state mutability, which we'll talk about later, but if we had another dropdown, we see list of simple storage contracts and the other dropdown we'll see SF Store. These, as you know, are the buttons that we can press when we deploy this contract, right? So if I redeploy this, we see those exact three buttons.

These are the three buttons that were inside of that abi. This is how Remix knows to put three buttons here cuz it looks at the ABI and sees that there's three buttons. So in our code here, our compiler knows what the ABI is. So in our code here, the compiler automatically knows what the ABI is because the compiler is the one that generates the abi and we know where the address is because we have a list of all of our addresses that we're keeping track of up here.

So the reason we have the ABI is because we're importing our simple storage contract. And actually let's delete this simple storage too. We don't really need the simple storage too. So when we compile simple storage, we automatically get the ABI for solidity. In the future, we'll learn other ways to get the Abi I.

So down here, let's get a simple storage contract to interact with from our list. And to do that, we'll say simple storage. My simple storage equals list of simple storage contracts at Index Simple Storage Index like this. Since this is an array of simple storage contracts, we can just automatically get the contract itself like this.

However, let's say that instead of this being an array of simple storage contracts, this was an array, an array of addresses, a list of simple storage addresses like this. You don't have to code along with me for this section. Just go ahead and follow along and watch if we had a list of addresses. And this would be to be a little bit different, but if we had a list of addresses instead we could say Simple storage, my simple storage equals list of simple storage addresses at the index.

And then do something called typecasting. And we'd wrap this in parentheses like, so let me zoom out a little bit. So this is something we'll learn about a little bit later. So basically what we're doing is this list of simple storage addresses, simple storage index. This line returns an address and we're wrapping that address in simple storage like so if this is a little confusing for you now, don't worry too much about it.

We will learn about it more later. Now that we have our simple storage contract, we can actually call the store function directly on this contract. So now we can say my Simple storage.store and we'll add the new simple storage number. And this is great. If we were to deploy this contract right now though, and call this SF store function, though, we wouldn't be able to read the new variable that we just updated our simple storage contract with.

So let's create a function that allows us to read from our simple storage contracts as well. So we'll create a function called S F Get, which will take a u N 2 56 underscore. Simple Storage index is an input parameter. We'll make this a public view function that will return. You went 2 56, you went 2 56.

And we'll say Simple storage. My simple storage equals, and we'll use this exact same syntax that we used above to get the simple storage index equals list of simple storage contracts at the Simple Storage index. And now we're gonna do Return My Simple Storage. And again, if you see these auto completes that come up, you can just hit Tab but retrieve.

So perfect. Now let's go ahead and compile. We'll go ahead and delete the old Deploy. We'll make sure we're on Storage Factory Sole. We'll hit Deploy and we see Storage Factory down here. Now let's go ahead, run through that exact same exercise. So we'll pull up the terminal just to see our transactions go through.

We'll hit Create Simple Storage. Let's see that it's actually there at the Zeroth index. Okay, cool. We see an address there. So now let's store a new variable at Index Zero. So at this address, so we'll say at index zero, we'll store the number 1, 2, 3. And actually before I hit this button, if we go down here, we hit zero, we get nothing back.

Right? But now if I hit SF store with Index zero, favorite number 1, 2, 3. Looks like the transaction did go through. Now if I hit sf, get we go ahead and get 1, 2, 3. So our storage factory contract was able to create its own simple storage contract, store a variable in that contract from the storage factory.

And we were able to read back the number 1, 2, 3, all from within our storage factory contract. Feel free to pause right now and play around with adding different values, creating different simple storage contracts so that you really understand what's going on. You can also feel free to hit the little dropdowns and read more information about these transactions.

Just as a recap, in our Storage Factory contract, we have a function called Create Simple Storage Contract, which creates new simple storage contracts from the storage factory contract. The reason it's able to do this is because we're importing from our simple storage dot Soul file using something called Named Imports.

We're only importing simple storage. We're not importing anything in these other contracts. Then we use SF Store to store a new number on one of those simple storage contracts using the index. In ra, it can do this because we have the address and the a b I, the list of simple storage contracts automatically compact with the address and the A B I.

And then finally, we can read back those simple storage values that we stored. Now we can make this SF get function even more condensed. Since this list of simple storage contracts, simple storage index returns, an object of type simple storage, we can actually delete this whole line, copy this, paste it here, and delete this line.

And this will work exactly the same as what we had before. Go ahead and save or compile. You'll go ahead and get that green check mark there. This dot retrieve is saying we're gonna call the retrieve function on whatever this is. This, whatever this is, is a type simple storage contract. You can actually do the same thing up here by deleting this part, copying this line, except for the semicolon and pasting it over the my simple storage and hitting save or compile.

Awesome. Great job so far.

Awesome. Now let's say you really like this simple storage contract. You love all the functionality except for one thing, you wish that the store function didn't just store the favorite number, you wished it added five. So for some reason you want a contract that does everything this contract does, but just adds five whenever you call a store, for some reason, you want everyone's favorite number to be five larger than what they think it is.

Well, one thing we could do is we could just copy paste this into a new file, but again, that's kind of too much work for me. I'm a lazy engineer. But let's go ahead and see how we can approach this problem. So let's create a new file. We'll call it add five storage. So, and same thing this, this is a new contract.

We're gonna follow the exact same tips. We're gonna do SP D X license identifier, mit. We're gonna do pragma solidity, 0.8 0.18. Let's even do the little carrot here and we'll do contract add five storage, like so look compile. Great. Looking good. Oh, I'm getting a warning. SP D X license. Spelled license wrongs.

Let's spell that right. Okay, cool. Looks good. So like I said, the first thing that we could do is we could copy paste everything in here and then just change the pieces that we don't like in our Ad five storage. This is a little bit redundant, a little bit too much work. And we are engineers. We want to work as hard as possible to be as lazy as possible.

So how can we do that? Well, this is where we can do something called inheritance. We can have our AD five storage contract be something called a child contract of our simple storage contract. And we can have our AD five storage inherit all of the functionality, all of the functionality of our simple storage contract.

So first, of course, in order for our Ad five storage to know about our simple storage contract, we're gonna go ahead and have to import it. So we're gonna do imports and we're gonna do once again, the named imports, because we're advanced Solidity engineers. So we're gonna say Import Simple Storage, just the simple storage contract from slash Simple Storage.

So now if this dot slash is confusing to you, don't worry. We'll learn about directory structures later on in the course. Then we'll say our contract at Five Storage is Simple Storage. Now our at Five Storage is gonna do what's called inherit everything from civil storage and our AD five storage is gonna have all the same functionality ass storage.

We can actually see this directly. If we go to compile, let's go ahead and delete our previously deployed contracts. We're on the remix vm. Let's make sure we're, we've selected Add five storage. Add five storage. So let's go ahead and deploy it. And if we scroll down, we can actually see, oh my goodness, it's got all the same buttons as simple storage.

Even though the contract itself doesn't have anything to find, that's because we inherited all of the buttons. We inherited all of the functionality of simple storage into ad five storage. If you want a contract to inherit the functionality of another contract, you just import it in and then say your contract is that other contract.

Now we can keep going though and add our own custom functionality into ad five storage. That's not in simple storage. So for example, we could say function, say hello, it's gonna be a public and it returns a string memory. And again, you need the memory keyword because strings are special in solidity. And we can just say return.

Hello, think. So. This will be a public cure. It's not a view because we're not reading from storage. And again, if that distortion is a little confusing to you, don't worry too much about it now. But if we go to deploy it, let's delete our old one. We'll deploy this one. We see we have all the functionality of simple storage plus this say hello function.

Great, but let's delete that for now. Let's say instead of wanting to add additional customization, you actually love every function in here except for one. Remember, the reason we wanted this ad five storage, so is because we actually want to change these store function to have it added additional five to people's favorite numbers.

Maybe you're mischievous and you want people's favorite numbers to be five greater than they are. Well, to add this AD five customization to that store function, we can do something called overrides to do overrides. There are two keywords that we need to be aware of. Those are virtual and override. If I were to try to create a store function for our AD five storage right now, what do you think will happen?

Well, let's try it out. So let's say function store u n 2 56, underscore new number public. If you try to compile this right now, we'll actually get an error even if there's nothing in this store function. We roll over, we say from solidity type error, overriding function is missing override specifier. And remember, if you get lost or confused, an error like this is something perfect for you to ask chat tube tea.

Or maybe even find, we could say, I am trying to compile my Solidity code, but I'm getting this error. We can copy this whole error here based it in here. And then in additional context, we'll just add the code like this. We'll hit search, see what it gives us. We'll say, and it looks like Find was able to find the answer.

The error message indicates the function of the store in the AD five storage contract is missing the override specifier, which is required because it overrides a virtual function from the simple storage contract. Thanks. I'll explain what Find is giving us in just a minute. It's right. We need to tell Solidity that it needs to override the store function in civil storage.

We wanna be very explicit and say, Hey, do this store function and not what's in civil storage dot sold. So let's go ahead and add that keyword override. Now though, if we just add that keyword, we go ahead and try to compile. We still get an error trying to override a non-virtual function. Did you forget to add virtual?

In order for a function to be override a bowl, you need to add this virtual keyword in the base class or the parent class. So in simple storage we need to add virtual to store. This virtual keyword means that this function is over rideable. Any function that doesn't have this keyword you can't override.

Now our store function is override a bowl and we've specified that we are indeed going to override the store function. Now if we go ahead and compile, we'll see everything compiles successfully. Alright, great. So now let's just add the functionality to store. Remember, since AD five storage inherits everything from simple storage, this means that we even have access to my favorite number.

So what we can do is we can say, my favorite number equals underscore new number plus five. We'll compile this and now let's try it out. We're on remix vm. We wanna make sure we're with add five storage. We'll delete the other ones. We'll deploy. Scroll down, hit the dropdown. Retrieve. Currently return zero.

Now if we store two, we'll pull up the terminal to make sure we're actually sending transactions. We'll hit store. And now if we hit retrieve, we see we indeed get seven back cuz two plus five is seven. We add five, we hit store retrieve now returns 10. So this is how we do inheritance and override functions.

And that's it for this section. You've learned a ton of incredibly powerful features and solidity. So let's do a quick recap of what we learned. This section, we learned that with the new keyword, we can actually deploy contracts from other contracts. We learned that we can actually import other contracts, which is essentially the same as copy pasting the code into this file.

We also learned this thing called named imports, which is gonna make you look even better than most of the solidity devs out there. We learned that we can interact with other contracts so long as we have the address and the abi, the simple storage type automatically comes with the address and the abi.

So we can just access it like this. We didn't learn too much about the abi, but we'll learn more about it later. We learned that if we wanna make a child contract and inherit the functionality of some other contract, we can just import that contract and then use the is keyword in the contract declaration.

To override a function, we need the override keyword and we need the base class or the parent class to have the virtual keyword on the function you want to override. And that is the end of this lesson. So be sure to give yourself a huge pat on the back. Take a break. Breaks are good for your brain. Go for a walk, grab a coffee, get some ice cream.

Go tell your friends, go post on Twitter. You're getting more and more advanced with solidity very quickly. So be sure to celebrate the little wins to keep being excited and keep that curiosity. Congratulations, you have completed this lesson.

All right everybody, welcome back. We are now headed into lesson four. This is going to be our remix FundMe, and once again, you can find all the code associated with this lesson in the GitHub repository associated with this course and also Web three Dev education. And let's do a quick walkthrough of these contracts before we actually start coding anything to see what we're gonna be doing, we're gonna be creating one contract FundMe.

So we're also gonna have another file called Price Converter. So, and we'll talk about that in a little bit. The FundMe contract is gonna be our main contract. This is going to be an example of a crowdsourcing application or a way to raise money. You can think of it as a web three decentralized Kickstarter.

We'll allow users to send Ethereum, polygon, avalanche, et cetera, or really any native blockchain cryptocurrency into this contract and allow the owner of the contract to actually withdraw all the funds for them to go spend on their new project. And we are going to actually deploy this contract to a testnet and remember, use the Testnet transaction sparingly.

But if we deploy this to a testnet, we scroll down, we actually see that we have a couple of buttons and a new color button, we'll actually get a new red button for our fund function. A red button indicates that a function is payable and we can send native Ethereum or poly polygon or Avalanche or whatever the native cryptocurrency of the blockchain we're working with is.

We additionally will indicate a minimum U S D amount to send to the contract, so funders have to spend at least $5 worth of Ethereum in order to call this fund contract. So if we go up to the value section, we can actually send some value with this transaction. And again, don't worry about this making sense yet, but if I wanna send 0.01 Ether, I'll grab that amount in way, paste it into the value section here.

I'll scroll down, I'll hit the fund button. Meta mouse will pop up. I'll confirm. We can see at the top, the current balance of the contract is zero, and we'll wait a little bit for the transaction to finish going through and after the transaction finishes going through, we can see an Ether scan. We have a balance of 0.01 eth and we can also see that after remix, after a slight delay, then we can allow the owner of the contract to withdraw those funds.

Right now the owner of the contract is also us, and after this transaction goes through, we'll see that balance removed from the contract and it'll go back into our wallet. And as you just saw there, if we held our meta mask up for long enough, eventually it would pop back into our meta mask. Are you excited?

We should be, because after you complete this section, you'll actually know most of the fundamentals of working with solidity. We're gonna be going over a lot of advanced features in this section, and I'll let you know the specific parts that you don't need to fully understand quite yet. There's gonna be a couple parts where if it doesn't totally make sense, just keep going with the course.

And as we get later into the course, you'll figure out why they make sense. But it might be a good idea to write down the questions that you have to ask either an AI on the GitHub discussions or Web three education dev. Make sure, of course, to use the discussion tab in the foundry, full course F 23 to ask questions and interact with other developers who are taking the same course or go to web three dev.education to learn more.

All right, let's get froggy.

So the first thing that we wanna do is let's once again delete everything in our remix so we can start from scratch. So I have the contracts that we're actually gonna be building in here. You might have the simple storage, the ad five extra, the storage factory, et cetera. Let's go ahead, right click and just delete everything.

We're gonna start completely from blank here, so let's go ahead and delete everything in here. All right, great. So let's go ahead and start creating our contract. We're gonna call it fun. So one thing that's really good when you actually start building any code at all is to first write down what you want it to do.

So what do we want ours to do? We want to get funds from users into this contract, withdraw funds to the owner of the contract or whoever has created this FundMe contract. And then we also want to set a minimum funding value in U S D. We don't want people to be able to donate just a penny. So let's go ahead and set this up.

S P D dx, license, identifier, identifier, MIT dup, pragma, solidity, carrot, 0.8 0.18. Contract Fund me. Let's go ahead and delete these comments. So before we embark on writing all of our functionality out, let's just write down the functions that we want to build. So we're probably gonna want a function fund, which is going to be the function they call to send money to our contract.

We're gonna want a function withdraw, which is going to be the function that the owner of the contract is going to use to withdraw the money that the funders send us. And those are gonna be the two main functions that our contract is going to need. We're gonna be implementing more functions than just this, but these are gonna be the main functions to interact with our protocol or interact with our FundMe contract.

Let's comment out withdrawal for now and just start focusing on fund.

We want anyone to be able to call this fund function. So we're gonna make this public and we want this function to do what? Well, we wanted to allow users to send money, and we want to have a minimum dollar amount that they have to send. So the first question we need to answer is, how do we send ETH to this contract?

How do we have it? When a user calls the fund function, ETH automatically gets sent into our contract. Whenever we send a transaction on the blockchain, there's actually always a value field that gets populated, and most of the time it gets sent with zero. Even before, when we called the send function between our accounts, we added an amount in our meta mask.

This amount value populated the value field of our transaction. This value field is the amount of native blockchain cryptocurrency that gets sent with every transaction. First thing that we need to do to allow a function in solidity to accept this native blockchain currency in the first place is to make the function payable.

It's this payable keyword that makes the function look red in the remix ui. Just like how wallets can hold funds, contracts can actually hold funds as well. So whenever you deploy a contract similar to a wallet address, it actually acts almost the same as wallet address. You can send money to it, you can interact with it, et cetera.

And like we did in the demo, you'll see this contract actually gain a balance just like a wallet, you can access this value amount of a transaction using one of the global's in solidity called message value. Solidity has a number of these globally available keywords and functions, and you can find these in these solidity documentation.

One of them is message out value, which is the number of way sent with the message. If we wanted users to be required to spend at least one whole ether with this fund function, we could use something called require to do so. In order to do that, we would add this line. Require message, do value is greater than one E 18.

And there's a couple of things to unpack here. One, E 18 is equal to one ether, which is equal to 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8. Or put another way, it's equal to one times 10. Raise two the 18th in solidity. A double asterisk or double multiply sign is how you do a power or an exponent. This value here is the value in way of one Ethereum in your smart contracts.

And at the lowest level, this is how they process numbers in this giant way format. So if we wanted people to be forced to send at least one whole ETH with this fund function, we would just say, require me do value is greater than one E 18. You can use something like econ converter.com to see, to convert one ether between Ether way and g.

GU is actually another value in between Ether and Way. And we saw G, we actually, when we saw gas costs, normally gas costs are shown in forms of G. This required keyword is a checker. It's basically saying, Hey, is message do value greater than one 18? If not, then revert this transaction. And if we want, we could add a little revert message.

We could say like, didn't send enough E, we can actually deploy this. We can actually compile and deploy this on a remix vm,

deploy. Scroll down. And if we hit fund, and if we pull up our terminal and we hit fund, we actually see we get this little X here, meaning our transaction didn't go through. And if we hit the dropdown call again, same thing. Same thing. We know that this error is because we have this required statement in here and our transaction is reverting or not going through.

So we know that with this transaction, we need to send at least one ETH or or one e 18 way worth of ETH in the value section of our transaction. So if we scroll up, we can actually just change the unit to ether. Put one in here, scroll down. And now if we hit fund, oh, it doesn't go through because we have strictly greater then.

So excuse me. Let's do, let's do two now. We'll scroll down. We'll hit fund. We see we get a green check mark, and we see the FundMe balance actually has improved to two. If we update the value to two again and we scroll down, we had fund again, we see our transaction went through and we have four. If we try to do less, like let's change this to way and we'll do you know, a thousand way scroll down, we had fund up.

It fails because 100 way is less than one e 18 way, right? Because one eight E 18 way is this much way. So obviously a thousand or however much it put in is much less. So this requires, says if this first section is false, then go ahead and revert with whatever this second section is.

Reverts can be a little bit confusing and a little bit tricky. So what is a revert? A revert undoes any actions that have been done previously and sends the remaining gas associated with that transaction back. So what does that actually mean? Well, let's say for example, in our FundMe contract, we have a U 2 56 public.

My value and let's have my value initialized to one. Now, in our fund function, let's say my value equals my value plus two. So every time this fund function successfully goes through, we add two to my value. However, if we get to a revert statement, even though we added two to my value previously, since our contract reverts, this would actually revert this action or reset it back to its initial state.

So if this transaction reverts my value would go back to one or whatever it was previously. If we compile FundMe, we delete our previous deploys, we're on the remix vm, we'll deploy FundMe, we'll scroll down. We have my value, which defaults to one. If we call fund right now without any value, if we pull up our terminal, we could see the transaction failed.

My value is still one. Even though this line technically executed, this line executed, but then this line hit and it reverted what was done here. So if we scroll back up though, we go to Ether. We'll put one in for now. Scroll back down. Now we'll hit fund. Oh, it needs to be more than once. Excuse me. We'll add two here.

Scroll back down. Now we'll hit fund. That transaction did go through, which means my value will now be equal to three. And again, if I set value to zero, we call fund, it reverts. So my value is still three. So then the question might be, oh, well, did we spend gas to do this if my transaction didn't even go through?

Well, unfortunately the answer here is yes. If you send a failed transaction, you will spend gas because computers executed this line and then they executed this line and just failed. So users can actually specify how much gas they send with every function. Let's say there was a ton of computation after this require line, we would need to send a ton of gas to operate and run our fund function.

However, once it gets to this require line and it reverts however much gas that we sent to execute, the rest of the computation would just get refunded to whoever initiated the transaction. Like I said, sometimes the refunds and some of that can be a little bit confusing. So again, for now, just know that if a transaction reverts, it undoes anything it does previously and you can consider the transaction failed.

However, if you send a reverted transaction, you will still spend gas. Okay, let's delete this value for now. Delete it from the global scope and delete some of these like that. In fact, every single transaction that we send will have these fields. It'll have ANU or the transaction count, the account, the gas price, the gas limit that we've seen on Ether Scan A two a K, a, the address that the transaction is sent to a value, which is gonna be this amount that we're talking about, will also have data, which is gonna be what we send if we make a function call or deploy a contract, and then it'll have this v r s components.

We're not really gonna go over these VR and s because this is that cryptographic magic that's happening when a transaction is signed, but just know that that's in there for sending value. We can populate some of these fields. The gas limit, for example, is populated to 21,000. Data is gonna be empty, and then that two is gonna be the outers of the transaction we want to send to for a function call.

We can also still populate the way that we want to send, so we can call a function and send a value at the same time in remix. It has a little dropdown here for way GU Finny in ether. We're gonna ignore Finney for now, but of course we have our way GU and Ether again, where one ether is worth this much GU and this much way.

So right now our contract is pretty minimal, right? We're requiring the message add value is greater than one whole ether, but we wanna actually require that it's less than some value. Like let's say we want to have users spend a minimum of $5 as opposed to one whole Ethereum. So let's first specify that $5.

We can do that at the top of our contract. We'll say you went to 2 56, minimum U S D equals five, and we'll make this public instead of internal. We'll update this minimum U SD in the future to make this more gas efficient. So what we wanna do is we wanna to require that our fund function requires that the message dod value is greater than, let's say, greater than or equal to minimum U S D.

However, minimum U S D is in terms of U S D or dollars and message. DOD value is in terms of ETH or way in terms of Ethereum. So how do we convert the amount of Ethereum to its price in dollar? This is where Oracles and Chainlink comes into play. The dollar price of an asset like Ethereum is something that we've assigned to Ethereum outside of the blockchain in the real world.

So in order to get this abstract concept of the price of the native cryptocurrency of the blockchain we're working with, so we need to use a decentralized Oracle network or something called an Oracle to get this price. So before we keep going, let's learn a little bit more about decentralized Oracles Chainlink and how they work so that we can understand how to get the price of Ethereum into our smart contracts.

As we've talked about, blockchains are deterministic systems, which means that they themselves can't actually interact with real world data and events. They don't know what the value of an Ethereum is. They don't know what random numbers are. They don't know if it's sunny outside, they don't know the temperature, they don't know who's president.

They don't know any of this information. These blockchains also can't do any external computation. Maybe you have some amazing artificial intelligence model that you want to integrate with a smart contract. Smart contracts by themselves can't do anything with that. As we've mentioned, this is because blockchains are deterministic by design.

This is so that all the nodes can reach consensus. If you start adding variable data or random data or values that return from an API call, different nodes could get different results and they would never be able to reach a consensus. This is known as the smart contract connectivity problem or the Oracle problem.

And this is bad news because we want our smart contracts to be able to replace traditional agreements, and traditional agreements need data and they need to interact with the real world. So this is where Chainlink and blockchain oracles come into place A blockchain. Oracle is gonna be any device that interacts with the off-chain world to provide external data or computation to smart contracts.

However, the whole story doesn't even end there. If we use a centralized Oracle, we are reintroducing a point of failure. We've done all this work to make our logic layer decentralized, but if we get our data through a centralized node or through a centralized a P I, or we decide we wanna make the a p I call ourselves, we are reintroducing these trust assumptions that we've worked so hard to get rid of.

We're essentially ruining the entire purpose of building a smart contract. So we don't wanna get our data or do external computation through centralized nodes. Those are bad news. Chainlink is the solution here. Chainlink is a decentralized Oracle network for bringing data and external computation into our smart contracts.

As we mentioned before, this gives rise to these hybrid smart contracts which combine on chain and off-chain to make incredibly feature rich, powerful applications. Chainlink is a modular, decentralized Oracle network that can be customized to deliver any data or do any external computation that you like.

So for example, a lot of people say, oh, I can just make an HTTPS call to some API I, and we'll be good to go. The blockchain nodes can't make these HTTPS calls because they wouldn't be able to reach consensus. If they called the node at different times or they did something else, all the consensus would be broken.

So instead, we need a decentralized network of chain link Oracles to do this, and then into transaction. This network of nodes will return the data to our smart contracts for us. Now Chain Link Networks can be completely customized to bring any data or any external computation that you want. However, doing the customization can be a little bit extra work.

There are a ton of chain link features that come outta the box, completely decentralized, ready to plug and play into your smart contract applications. What are those features? The first one is gonna be chain Link data feeds, and that's the one we're actually gonna be using for our application here.

Chainlink Data feeds currently at the time of recording, are powering over 50 billion. In the defi world. The way they work is a network of Chainlink nodes, gets data from different exchanges and data providers, and brings that data through a network of decentralized chain link nodes. The chain link nodes, use a median to figure out what the actual price of the asset is, and then deliver that in a single transaction to what's called a reference contract, a price feed contract, or a data contract on chain that other smart contracts can use.

And then those smart contracts use that, that pricing information to power their Defi application. We can see an example. We can see an example at Data Chain Link, and you can change networks, you can change price feeds. You can change a whole bunch of Informa information to see some of the most popular price feeds.

Let's look at E U S D, for example. On E U S D, we can see this whole network of independent chain link node operators that are each getting different answers for the price of Vet U S D. They're getting aggregated by the network and then delivered on chain. We can see how often they're updated. These ones are updated for a 0.5 deviation threshold or a few hour heartbeat, whichever one hits first.

We can see when the last update was. We can see the number of Oracle responses, et cetera. We can see the contract address directly on chain. We can even look at the contract on Ether scan. We can see some of the history. We can see all the responses of the different Oracles. And then at the bottom we can see the different users and sponsors keeping this network up.

Similar to transaction gas, whenever a node operator delivers data to a smart contract, the CHAINLINK node operators are paid a little bit of Oracle Gas. In the Chainlink token right now, these users of the protocol are sponsoring keeping these feeds up and are paying the Oracle gas associated with delivering this data on chain.

Here's an illustration of what the current model of these data feeds look like. A network of these chain link nodes. Each reaches out and gets the information about an asset and then signs the data with their own private key in a single transaction, then one node will deliver all the data with all the different signatures to a reference contract.

If that node doesn't deliver the data, another node will send it instead. Reputation is incredibly important when you're a Chain Link node operator. If you miss data updates, if you forget to send transactions, you'll probably be quickly kicked off these networks and have no chance of making any more money in the future.

These data feeds are used by some of the largest protocols in the space, such as synthetics, sushi, swap, compound, and Ave, with several billion dollars each. We can take a look at an example over at Docs Chain Link work with VM contracts. We're gonna hit VM chains. Scroll down to data feeds. We'll scroll down to the solidity section and we can see an example of an entire contract that uses and reads from one of these chain link price feeds.

We can even open up this up and remix

and work with it and remix. It looks like this example is reading from a price feed on Covin. The reason we're actually gonna use a testnet to see this work is that there's a set of chain link nodes monitoring the test network to S to show you exactly how this works out. Once we get deeper into the course, we'll show you how to actually run tests and work with chain link nodes without actually being on a testnet, which will make your development much faster.

But I highly recommend walking through this section along with me so that you can see firsthand how this actually works. So let's go ahead do faucets.chain.link/coven. We're gonna switch to the covin network and we're gonna get some coven eth. But remember, look at the network flag and use whatever network is in the documentation.

So to get some coven, we're gonna come to the faucet. We're gonna turn off Test link. We'll just stay with eth, I'm not a robot.

And then send request. Once our coven Ethereum has reached our wallet, we can go ahead and close and we can take a look in our wallet and see that we do indeed have 0.1 ETH on covin. Now let's go back to our remix. We'll compile this contract. We'll go and deploy this on Injected Web three. And again, the reason we're gonna use Injected Web three instead of JavaScript VM is that there's no network of chain link nodes watching our little fake JavaScript vm.

There are a network of Chain link nodes watching the test app. So we'll scroll down, we'll switch contract to the price Consumer v3, and we'll hit deploy. Meta mass will pop up and after a brief delay, we can see our price feed consumer down here and we can hit get the latest price, which shows us the latest price of Ethereum.

In terms of U S D, you may be wondering why the number looks so weird. That seems like a really large number for the price of Ethereum. In terms of U S D, and this is because decimals don't actually work so well in solidity, and we'll get to that in a little bit. There's a decimals flag associated with this price feed address that tells us how many decimals to include with this price.

It's also in the documentation. However, I know that this one has eight decimals, so this is saying the value of Ethereum right now is $3,262. It may of course be different when you go ahead and try this. Now, there's a number of things that happen in this contract that I'll explain in our FundMe example, but if you want to take a look now and see if you can figure out what's going on, I recommend you do so.

Price feeds are one of the most powerful out of the box decentralized features. You can use your smart contract to level them up, especially for decentralized finance. If you're looking for different addresses of different price feeds, you can check the contract addresses, section of the documentation, choose the network that you want, and then scroll down and then look some of the different addresses of the different price feeds.

For example, this address will give you the price of one inch token in terms of Ethereum. This address will give you the price of the Apple stock in terms of U s D and so on and so forth. The next decentralized application right outta the box is gonna be Chainlink, V R F or Chainlink, verifiable random dysfunction.

Once we do our lottery example a little bit later, we'll talk about how randomness can be manipulated in blockchain, blockchains are deterministic systems, which by definition means that they can't have randomness. If you can determine what a random number is, it's not really random anymore, is it? So we need a way to get a proably random number by looking outside of the blockchain, and Oracles are perfectly positioned to do exactly that.

Chain link verifiable randomness function is a way to get provably a random number into our smart contract to guarantee fairness and guarantee randomness of applications. Many protocols like Pull Together Axio Infinity, ether cards, avago cheeses, and more. Use Chain Link VF for lotteries, for randomizing NFTs, for gaming, and for more.

We're gonna do an example of chain link V R F in a later section once we get to the lottery section. If you wanna see if you can play with the randomness yourself right now, I recommend you going to Docs dot chain. Dot link EVM chains, and scroll down to get a random number. And this will teach you how to get a provably random number into your applications.

The next decentralized Outta the box feature of chainlink is Chainlink Keepers, which is decentralized event-driven execution. As you've seen, in order to kick off some type of transaction, somebody needs to spend the gas and somebody needs to sit down and hit the go button or hit the transact button or hit the send button.

This is obviously a centralized vector if you have a decentralized application that needs to run at specific times or after specific events are triggered. Chain link keepers are the solution to this chain. Link keepers are chain link nodes that listen to a registration contract for different events that you specify to fire.

Maybe you say every 10 minutes you wanna do something or once a week do something, or if the price of some asset hit some number, or maybe a liquidity pool is at a certain level, whatever event that you want to code, you absolutely can. The Chain Link nodes constantly listen for these triggers to happen and check the different contracts for these triggers.

Once a trigger returns true, the chain link nodes will then perform whatever action that you tell the chain link nodes to do. We're also not gonna go over the chain link keepers examples right now because we're gonna get to them in a later module. However, if you wanna try them out, go to docs.chain.link/ethereum going and go to making compatible contracts, and feel free to read the documentation and try it out yourself.

The last out of the box feature of chainlink is the most customizable, but also the hardest to get correct. End-to-end. Reliability is the ultimate promise of our smart contracts, and we want and need them to be able to do anything. We want to be able to take any input and get any output. Chainlink functions is the last decentralized out of the box tool, and it allows you to make any API call in a decentralized context through a network of chainlink node.

We're not gonna be going over that at all in this video, but be sure to check out the documentation if that's something that you're interested in. To me, Chainlink functions is gonna be the future of defiance of our contracts. And if you're looking to make something novel, and if you're looking to make something that's never been done before, I 100% recommend you check out chain link functions later on after this course, or whatever you wanna do as a filming.

It came out about a month or two ago, and people are just beginning to build amazing things with chain link functions. So be sure to check this out after or during the course. We're gonna be using the Chain Link automation in a later section in this course. Again, if you wanna try these out in remix on a real testnet, you can go to the documentation and play with them here.

Now, I know we haven't actually written that much code, but we've gone over a ton, so I wanna do a quick review. In order for a function to receive native blockchain token like Ethereum, you need to mark that function as payable. If you want to force a transaction to do something and you want it to fail.

If that wasn't done, you can use a required statement. A transaction that reverts means it undoes any work that it did previously and returns any gas to the user to get the value sent with a transaction. You can use the Solidity Global message Value Chainlink is a technology for getting external data and computation into our smart contracts, and most importantly, getting that data in a decentralized context.

In this example, we're gonna be using a Chainlink data feed or a Chainlink price feed, which is a decentralized way to get pricing information from real world assets into our smart contracts.

Now, in order for us to figure out if the amount of Ethereum sum with a transaction is greater than our equal to our minimum U s D of $5, we need to convert the amount of Ethereum into its value of dollars. So how are we gonna do that? Well, the first thing that we're gonna need to is we're gonna need to get the price of Ethereum or Avalanche or Polygon or whatever native blockchain token that we're working with.

So let's create a function to do that, create a function at price, and this function is just gonna get the price of Ethereum in terms of U S D. And then we're also gonna create a function called Get Conversion Rate Rate, which is going to convert a value to its converted value based off of the price.

Now we're gonna make them both public functions so we can play with them, test them, and do whatever we want with them to get the price of Ethereum. We're gonna use a chain link data feed, and we can go through the documentation to get that information. So in the documentation, I'm gonna scroll down using data feeds.

I've got an example here right in Solidity, and if you wanted to, like I said, you could easily open this up in remix. Now you can see this example on the documentation. What's actually going on when we're working with a chain link price feed. There's a contract out there at an address, and we're gonna call this latest round data function.

On that contract, gives us a whole bunch of data, but we really only care about the price, so we're gonna wanna do the same thing. We wanna reach out to that contract that's currently storing and having the price updated. So since we wanna reach out to and work with the contract, we're gonna need two things, right?

What are those two things? And we need the address and we need the abi. The address of the contract is gonna be really easy. We can get the address by going to the chain link documentation. And let's go to this price feed addresses section. We'll scroll down. We wanna be on Ethereum. Okay, great. Let's look for a set.

Polio. Looks like it's way down here and all right, awesome. E two S d. Great. There's an E two S D price feed. So now that we have the address, how do we get the abi? Well before with simple storage, we imported the entire contract from the top and we compiled and we got the ABI like that. We could do that here, but that's kind of a lot of code and we don't actually care about what the whole contract looks like.

We only really want to know what the functions are. So we can call that latest round data function. Remember if we're on remix and we go down to the compilation details. The ABI is really just this list of functions that we can call on a contract. The ABI itself doesn't actually need to include any of the logic.

It just needs to say, Hey, these are the functions you can interact with and here are their inputs and here's whether or not they're payable and here's whether or not their view functions, et cetera. Like I said, though, this kind of is a white lie. You can also use a functional selector or some other ways, but we're just gonna ignore that for now.

How can we get the abi? There's a concept in Solidity known as the interface. If we go to the chain link GitHub, we go to smart contract kit slash chainlink. We can see a lot of the different contracts in the Chainlink repository. We can go to contracts, src. This might look a little bit different based off of when you're looking at it, V 0.8 interfaces and we go to aggregator V3 interface.

If we scroll down, we can actually see a whole bunch of function declarations, but none of them are actually implemented. It's just function, the name of the function, some stuff, external view, blah blah blah, but then just the semicolon and nothing inside of them. This is what's known as an interface. If you compile this, this will actually give us that a B I because it defines all the different functions that you can call on a contract.

It just doesn't have any of the logic. Again, we don't really even need to know what the functions do. We just need to know how to interact with a contract. And if a contract is deployed, it'll have that logic in its deployment. So what we can do is we can copy this whole thing, scroll all the way to the bottom if the copy button and paste it on our remix.

Now hold on though. If you're following along, you don't have to copy paste it in here with me cuz I'm gonna teach you something in just a minute that makes this a little bit easier. This pasted code alert comes up. We're running solidity code, so this is gonna be okay. Since we're only working on Testnet here, we're gonna be okay that we don't have to worry about pasted code alert.

If you wanna take a second to read it, please do. Or we're gonna paste this code in here just like we did before with simple storage for now. You don't have to follow along. I'm about to show you an easier way. Just follow along and watch. Now that we have this interface, aggregator V3 interface, we can use this interface to make API calls because now we have the address and we have the api and we can even compile this and it'll compile fine.

So we can say aggregator V3 interface at address this and the combination of these two give us. Whatever code is at this address with all the functions from the aggregator V3 interface. And just to test this out, we could do something simple like DOT version since if we scroll up, it looks like there is indeed a version function.

Put a little semicolon at the end. So let's actually go ahead and actually copy this line. Give it its own function called Get version this. We'll have this public view returns. What is the version of your return? A U 2 56 over return a U into 2 56. Paste that line in here. Aggregator V3 interface at its address version, we'll say return.

All of that. Now I'm gonna go ahead and deploy this to the seia testnet just to show you what this would actually look like. However, I'm gonna recommend you don't do that for now. Just know that this will work this way. You won't have to wait forever for your transactions to go through on the testnet.

So to do this, I'm gonna go ahead, scroll up to the top, go to inject the meta mask, change the contract from Aggregator, V3 interface to fund me. Gonna go ahead and hit deploy. My meta mask is gonna pop up. I'm gonna go ahead and hit confirm. And we're gonna scroll down. And now we have a big blue button called Get version, which I'm gonna go ahead and click and we can see we get a four return because at this contract address on the blockchain, it has the functionality for get version returning four.

And for the rest of this lesson, I'm gonna be showing you guys and testing this on an actual testnet. However, I recommend that you don't test all of these as I go along. Just watch me do them. Because again, waiting for transactions on a testnet can be really annoying. Sometimes the testnet might be having issues because again, it's people running it and them outta the goodness of their heart.

So for this lesson, just follow along, write the code with me, and then maybe at the end, deploy everything. So this is a really easy way and a common way that people use to interact with other contracts outside of their projects. They get the interface of that contract using the interface keyword, they compile it, and the compiler actually gives us an abi.

And then you just wrap an address around with that interface keyword. And you can call any function at that address. And, and this is one of these things, as we work with more and more, it'll start to make more sense. In the beginning. It might be a little hard to grasp, but just bear with me for now. The more we do it, the better you'll get.

Don't get discouraged. Take a deep breath and exhale and less keep coding.

And if this is confusing to you, this is again where we can work with our AI friends or any of the forums that we're working with. Again, very soon. I'm about to show you how to ask really good questions and make really good prompts. But one we could ask here is, Hey, I'm confused. How does this solidity function return the value for when I didn't define any logic in aggregator V3 interface, and I just posted that code from GET version here.

Because a common issue that I see new developers run into is they go, oh, wait, wait. How does this version return for my aggregator? V3 interface doesn't have any code in it. Why? Why does putting an adders in here make it work? Like what's going on? And let's see if our AI is able to help us here. So this is chat, G B T version 3.5.

Again, I prefer version four, but this is the cheaper one. And it says in the code you provided, the GET version function is calling the version function of an instance of the aggregator V3 interface contract. It appears that the contract address here is being used to create an instance of aggregator V3 interface.

The aggregator V3 interface is an interface contract that defines a set of functions that must be implemented by another contract. It serves as a way to interact with the contract at the given address by providing a common interface. The version function being called in your code is likely defined in the actual contract that implements this.

Uh, and this is pretty much correct, right? And so it gives us some more context here. This is exactly correct. This address has a version function and us surrounding it with this aggregate of E three interface, like typecasting it in these parentheses, like this is just telling our solidity compiler, Hey, there's a version function at this address, or there's a, a latest round data function, or all the functions, all the functions in this aggregated V3 interface are at this address.

If this address doesn't have a version function, this would just break. And this is a good example of, again, where we can actually follow up with these ais. They're typically very good at keeping context. So we could even ask what would happen if that contract address didn't have that function. And we see if the implementation contract at the given address does not have a version function or if it has a different function, signature calling version on the contract would result in a compilation error or a runtime error.

So it wouldn't result on a compilation error, but the transaction would revert. So. So this is pretty helpful here, but again, we always wanna double check this. So this is where we'd probably go back to the discussions forum and follow up there.

So now that we actually have the interface, we can start calling these functions and calling these addresses. However, having a ton of these interfaces is really gonna clog up our contracts and clog up our files. That'd be really gross to work with. Is there a better way for us to do this? Well, when we worked with Simple Storage, yes there was, we just went ahead and used imports, right?

But that's when we had all the code in our locally, in our directory. We don't have all the code locally. We didn't create the aggregator V3 interface. We didn't create the price feed contracts. So can we do something like SIM import Simple storage, do so, but with a contract outside of our project? Well, again, we could copy paste it to its own file and import ator V3 aggregator V3 interface dot.

So, and of course we're gonna use this named import syntax because we're awesome developers. We could copy paste it like this and do exactly what we did before. We could create a new file called Aggregator V3 interface, paste the code in there, or we could actually import directly from GitHub. If we go back to the documentation associated with using data feeds, we scroll down to using data feeds here, scroll down.

We see at the top they do this import, like this import at chain link slash contracts, src, blah, blah, blah. This import actually has the same setup. As as the path of what's in the GitHub repository. So instead of us copy pasting from GitHub, we can actually import directly from GitHub or mpm. We can copy this line back in our remix.

We could paste it in like this. Remix is smart enough to know that this at Chain link slash contracts is referring to the what's known as an MPM package at chainlink slash contracts. At chainlink slash contracts is what's known as a package manager and it keeps different versions of combinations of code for us to download at chainlink slash contracts is created directly from Chainlink repository.

Remix downloads all this code from mpm, which is created from the GitHub, so it essentially downloads it from the GitHub. So us doing this import like this is the same as it's just copy pasting the entire interface at the top of our contract. Now we have this aggregator V3 interface that we wanna work with.

We can go ahead and compile and bot bing bottle. Boom.

So great. So now that we have the interface here, which we'll give a minimalistic ABI for us to interact with the contract, how do we actually get the pricing information? Well, again, if we go back to the docs, we can see right here, it gives us an example of the code we can use to get the latest price.

But let's write it ourselves just so that we know what's going on. We'll say Agra gato V3 interface and we'll actually create a new variable called price feed equals aggregator V3 interface contract at this address, which again, only works for seia. Now we can call this latest round data function on the price feed.

So we'll say price feed, not late round data. And if we look at the interface on GitHub, we can actually see latest round data doesn't just return one variable, it returns a whole bunch of different types of variables. And to return multiple types, we do some syntex that looks like this and we'll say you Wint 80 round id.

And you can even flip back and forth between the documentation. Make sure you have it right int price, which again, we know in INT default to an INT 2 56, you went 2 56, started at you, went 2 56 timestamp, and then you went 80 answered in round. There's a lot of code in here since this function returns so many variables, we have to set something up to capture them, but we don't care about any of this other stuff.

We just care about price. So what we can do is actually just remove them and leave the commas in there. So we're gonna remove started at remove timestamp, remove answered in round, and I hit Command S to compile. We're gonna get these yellow squiggly lines, which are warnings, but we're gonna fix them in a minute.

Now we have in price equals price feed, latest round data because we only care about getting the price from the return. The reason price isn't into 56 is because some price feeds could be negative. Now that we have the price, this price variable is gonna be representing the price of ETH in terms of U S D.

And it's gonna return a number that looks like this because again, solidity doesn't work with decimals. So we know that this price feed has eight decimals, but it'll get a return like this boom, like this. It'll return a value that looks like this if we want to double check how many decimals there are in a price feed.

It actually has a decimal function, which allows you to check that as well. Now, as we know, message value is gonna have 18 decimal places. How do we know that? Well, because we know that one ether is equal to this many way, and this many way has 18 zeros. 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8. So this massive number is equal to one Ethereum, right?

1.1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8. So right now message on value and price actually have different decimal places. Price has eight. Message on value is gonna have 18. So to get them to match up, we have to do return price times one E 10 or to add those additional 10 decimal places. And yes, I know we have a red line, I'll fix this in a minute.

Price as we know, is A in 2 56 and message value is gonna be a U 2 56. So the types are actually different. So we want to get the price in terms of U 2 56 instead of 2 56 to convert them. We can again do a thing called typecasting. There are a lot of different types that can be easily converted between each other.

Not all types can be typecasted, but an INT and a U 2 56 can be. So to make our price a U 2 56, we would just do uant 2 56 and wrap price like this. Or we could just wrap both of 'em like this. Now of course, since we're not modifying any state, but we are reading storage, we can make this a view function and then we'll say it returns a UIN 2 56 like so.

Now if we can compile, we get rid of all those errors and warnings. Now, math could be a little bit tricky in solidity, but the more you do it, the better you'll get. And the reason math can be tricky is because there aren't any decimal places. So you need to only work with whole numbers. The more you work with it, the better you'll get though.

Awesome. So now we have a get price function, which is going to return the value of Ethereum in terms of U S D as a UIN 2 56. Now all we have to do is convert our message value in terms of dollars using this get price function. To do that, we're gonna use our get conversion rate function. This get conversion rate function is gonna take a U 2 56 ETH amount as an input, and we're gonna convert this ETH amount to its value in dollars.

This will be a public view function that will return a U 2 56. So first we're gonna get the price of Ethereum by doing U 2 56 ETH price equals our get price function that we just defined. And then we're gonna do UIN 2 56 ETH mount in U S D equals ETH price times amount. And then we actually have to divide by one E 18.

The reason we divide by one E 18 is because both of these have 18 decimal places. And if we multiply 1, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, if we multiply these by each other where both of these are representing one, we're actually gonna get. A number that's absolutely massive with 38 decimal places.

So we need to divide by one 18 to produce it back down to what it should actually be. An important rule with working with math and solidity is you always want to multiply before you divide. The reason for this is since again only whole numbers work in solidity, you were to do one divided by two, you would end up getting zero.

So you always wanna multiply first. When we get to the foundry section of this course, testing all this math is gonna be a lot easier. If you're really struggling with some of the math bits right now, I wouldn't let that slow you down because one of the things that AI is really good at is doing a lot of these math conversions.

But in any case, this eth amount in U S D is the number that we're looking for. So we can say return eth amount in U S D and awesome. Now we have a get conversion rate function. Let's walk through this together just so that you can understand what's actually going on. Let's say we want to see how much one ETH is worth.

Well, we're gonna get the ETH price, which let's say it's $2,000, but it's gonna be $2,000 with 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 18 zeros. So eth price might look something like this. So that means we're gonna do this 2000 with 18 decimal places times one eth, which is gonna be 1, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 8, 9, 10.

We're gonna multiply those together and then since we're gonna get additional 36 zeros, then we just divide by one E 18 and that's how we would get $2,000 equals one eth. It's gonna be 2000 of course with 18 decimal places. One of the good reasons for using whole numbers in solidity is that it's not possible to have decimal places so we don't lose any precision, which is really good.

So normally we should test this function before continuing, but since we're doing all this on a testnet, and I promise you that I tested this all beforehand, we're just gonna go ahead and keep going. So now that we've done all this work, if we wanna make sure that our users are sending at least $5, we can do get conversion rate of message.

Dutch sender needs to be greater than minimum U S D cuz get conversion rate, takes an ETH amount as input, uses the pricing information to get the dollar value back and we're gonna check to see that the dollar value of the message do value is greater than the minimum U S D. However, since get conversion rate returns a value with 18 decimal places, we need to update our minimum U S D to say five times 10 raised to the 18th.

Or we could also do five E 18 or we could do five times one e 18.

I personally like this five E 18 syntax, but whatever works for you, I'm going to deploy this to a testnet just to demonstrate this working. But again, you do not have to. So we're gonna go ahead, delete our previous deployments, injected web three deploy meta mass pops up. Gonna go ahead and confirm after a long delay, we'll get our deployed contract here.

We have all this stuff we can call get price, and we can see the value of Ethereum. Right now is this. With 18 decimal places, which is awesome. So it's around $1,896. So if I were to try to fund this with maybe a hundred way, I know for a fact that a hundred way isn't gonna be enough. So if we call this fund function, we're actually going to get this gas estimation failed.

Gas estimation error failed with the following message, blah blah blah. Error execution. Reverted, didn't send enough eth, which is actually exactly the error message that we have here. It's exactly what our error message is here in our require didn't send enough eth. So if we try to fund it, we're gonna get, didn't send enough eth.

And this gas estimation failed is a pretty common error that you'll see in Remix and Solidity and E V M in general. It's kind of just the boiler plane answer for something went wrong. Luckily we got the actual error message here so we could debug. Here's what's actually going on. Now you see here, we could still send this transaction, like I said, we would actually spend gas to send a failed transaction.

And this isn't something that we want to do, so we're gonna go ahead and cancel. However, if we did send maybe 1, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 9. So if we go to Google, actually we can even see like an ETH to dollar conversion rate. So if we send 0.01, 0.01 ETH right now is worth $18. It might be different depending on when you actually do it.

So we send 0.01 ETH in our remix and we can do that by doing 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6. So that's one E 16. And we hit fund. Now we actually see meta mass pops up. We don't get that gas estimation error. We can go ahead and confirm and we can see that our function is working as expected, which is great.

It's reverting transactions that have less than $5 and it's letting transactions go through that have at least $5. Awesome. And if we select minimum use D, we can obviously see that here and we can see we have 0.01 eth year. Fantastic. And since we don't have a withdrawal function here, we actually can't pull it out, which is another reason why I say, hey, maybe don't test this right now, but great, we've confirmed our get conversion rate is working, so let's move on.

Fantastic.

So what's the next thing that we should do in this contract? Well, we probably wanna keep track of the users who send us money in this contract so we can keep an array of addresses called funders and keep updating that depending on who actually sends us money. So I'll at the top, we'll make an address array or an address list.

We'll make it public and we'll call it funders. And anytime somebody sends us money, we'll say funders dot push message sender like Message do. Value Message Sender is another global variable we can use in Solidity, which refers to whoever called this function, the sender of the transaction to this contract.

So if we're on seia and we initialize a transaction form our meta mask, the message sender is gonna be this account right here. And then maybe we want to even make a mapping of addresses to, to make it easier to look up how much money each funder has sent. So we'll make a mapping of an address two eight U two fifty six, we'll call it public address, two amount funded.

Now, something that's newer in solidity is you can actually name the types in your mapping. So you could say address funder mapped to U 2 56, amount funded. Usually this is what's known as a little syntactic sugar. It's just to make it easier to read what this mapping is, right, funder to amount funded.

And then our variable name is very explicit address to amount funded. Now if somebody funds our contract, we'll of course do address to amount funded, eat message dot senders. Address plus equals whatever they previously have funded plus S value, whatever they're additionally adding. All right, great. And now we have a way for us to keep track of funders sending money to our contract and have an easy way with a mapping to look up how much they've spent in total.

Now

I know we've gone over a lot of advanced validity here, so let's do a quick refresher of what we've learned so far. Whenever we interact with a contract, we always need the address and the ABI compiling. An interface allows us to get that ABI very easily for us to interact with another contract. When we combine the contract address with the interface, we can easily call the functions on that contract.

Chainlink price feeds are an easy way to get data, especially pricing data from the real world into our smart contracts. From working with Math and Solidity and the evm in general, decimals don't work, so we need to always make sure we're using the correct number of units whenever we interact with our contracts.

Message dot value and message dot sender are known as globally available units in Solidity and they refer to the sender of a message of the current call or the number of ways sent with a message or transaction. There's a whole bunch of these and you can view them all in the Solidity documentation.

Alright, great. So we've got a way to actually get this pricing information pretty easily. However, our code is getting a little bit cluttered with these get price and get conversion rate. You'd think that these are functions that would be reused pretty often anyways for anybody looking to work with channeling price feeds.

So is there an easier way for us to work with this pricing information? Maybe doing some math like this is pretty common and we'd want other contracts to be able to import this conversion functionality. And a way that we can do that is actually creating something called a library. There's a site out there called Solidity by example, which has great examples of using libraries and what they work with.

Libraries are similar to contracts, but you can't declare any state variables and you can't send Ether. A library is embedded into the contract if all library functions are internal. Otherwise the library must be deployed and then linked before the contract is deployed. That's a little bit confusing, don't worry too much about that.

Right now, using libraries can actually add functionality to different values. And what do I mean by that? Well, I mean, we can have our GET conversion rate function be a function of any value of type u2. 56 means we could take this, get conversion rate and do something like message value, get conversion rate.

So we can create our own custom function with any type we could work with. Get conversion rate, as if message, do value was a class or an object or a contract that we actually created to do this, let's go back to our files. Create a new one. Create a new one called price converter. So, and this is going to be a library, a price converter library.

So how do we create a library? And what is a library? Well, a library is gonna be very similar to a contract. We're gonna start of course, with spdx license identifier. We're gonna do Pragma solidity, and we'll give it a version of 0.8 0.18, the little carrot. And instead of typing contract, we're actually gonna type library for the name of the library and we're gonna call this library price converter.

So libraries can't have any state variables and all the functions have to be marked internal. So what we're gonna do is we're gonna go back to FundMe. So I'll zoom out a little bit. We're gonna grab, get price, get conversion rate, and get version, delete them. Well I hit copy first. Go back to price converter, paste them in here and work with them in here.

Of course, we're gonna need the Aggregator V3 interface. So we're gonna go back to our FundMe. We're gonna copy this named import from aggregator V3 interface, paste it in at the top here, hit Command S, and we're gonna go ahead and compile this successfully. FundMe is no longer gonna compile, but we're gonna fix that in a little bit.

Now the first thing that we're gonna need to do in here is make these all internal. So we're gonna say internal like this. We do internal get conversion rate and internal get version. Now that we have our price converter library, we can actually import it back in our FundMe and attach it to AU 2 56. And let's actually delete this aggregator V3 interface line for now, and we'll do import price converter from slash price converter.

So, and now to attach the functions in our price converter library to all unit 2 56 s, we'll say using price converter or you went 2 56. Of course, if we compile our FundMe, we're gonna get an issue because it doesn't really know what get conversion rate is. So for now, let's actually just comment out this line.

I'm gonna remove these comments up here as well. So what we can do now though is we can do message on value dot, get conversion rate, get conversion rate. And in your library, whenever you're working with the library, the first input variable for a library is going to be the type that you're using with the library.

So message on value is of type U 2 56. So this gets passed inside of get conversion rate as the first variable into U 2 56. Eat them out, even though we don't pass any variables inside of these parentheses here, get price and get version. We don't really care to have an input parameter at all. So it'll pass it in, but not do anything.

So now, instead of require, get conversion rate of message on value. We can actually do, let's uncommon this line now and let's delete this line. We can actually do message value dot get conversion rate, conversion rate. And now if we compile this, this is gonna compile successfully. This works because we're attaching the price converter library to all you two 50 sixes.

So now all U two 50 sixes have access to this get conversion rate function. And since message value is a U two fifty six, it can call get conversion rate and it'll pass itself. So that message value as the first input parameter to the function here. If we wanted another variable in here, like U two six, something else, that would be the first parameter inside these parentheses.

So maybe like 1, 2, 3, or something, right? This 1, 2, 3 would be the something else. But message value would still be the initial parameter, which in this example would be oun. So let's go ahead and undo that and undo that. But all right, great. We've moved a lot of the math into our own library.

Congratulations. Nice work.

One of the most common libraries that was used for a long time was this library called Safe Math dot Soul. And in your Solidity Journeys, you'll probably see it pop up from time to time. Now we're gonna go off on a little bit of a tangent here about safe math and the library safe math. And this is an excerpt from my course last year.

So you might see stuff like rink B and some other stuff, but just focus on the safe math stuff. Just know when we refer to the JavaScript virtual machine that's talking about the remix virtual machine, one of the most common libraries that was used for the longest time was this library called Safe Math.

So, and you'll probably see it a lot of different places. We're gonna go off on a quick little tangent here and teach you about safe math. So let's close FundMe and close price converter. And let's create a new file called Safe math tester dot sole. And let's start with some basic stuff in here. Safe math was all over the place before version 0.8 of Solidity, and now it's almost in no contracts.

What happened? Why is Safe Math no longer used as much? Well, let's create a sample contract. This is a section that you don't have to follow along if you don't want to code along with me, but if you want to, you absolutely still can. This is gonna be a contract we are gonna deploy on a JavaScript virtual machine.

Uh, we can use any version of solidity before version 0.8 of Solidity. So for example, we'll use Pragma current 0.6 0.0, and we'll create contract safe math tester. So now if I create a Unit eight, I set it to public big number, and I set this to 255. Oops, safe math tester. Let's go ahead and compile Safe Math tester with 0.6.

Point seven pragma Solidity. The maximum size of a uant eight is gonna be 255. This is gonna be the biggest number that we can fit in an UANT eight. And if I were to deploy this to a JavaScript VM or even a test network, save math tester, let's go ahead and deploy it. If I hit big number, we're gonna get 255.

But what happens if I create a function called Add that sets big number equal to big number plus one? Let's save that, delete that old contract and deploy. Well, right now big number is 255. What happens when we add one to big number when 255 is the max size? A Uant eight can be? Well, let's hit add now.

Let's check what big number is. Big number gets reset to zero. The so what's going on? Well, prior to version 0.8 of Solidity onside integers and integers ran on this concept of being unchecked, which means that if you passed the upper limit of a number, it would just wrap around and start back from the lowest number it could be.

So if I call add a whole bunch more times and hit big number, now it's eight. If I were to hit this ad button a ton more times and get it back to 255, it would then continue to wrap over to zero. So one of the most popular libraries that was out there was this safe math library, which would basically check to make sure that you weren't wrapping around unit 2 56 or an in 2 56.

Basically, it was a way to say, Hey, you've reached the max, this number can be, and now your transaction is gonna fail. If we switch this to 0.8 of solidity, delete the old contract, we'll go switch this to 0.8. We'll go ahead and compile it. And now we deploy this to a JavaScript vm. If I hit big number, we get 255, but if we hit add, it actually fails and we still get 255.

In version 0.8 solidity. They added this bit where it automatically checks to make sure if you're gonna do what's called overflow or underflow on a variable, we can actually revert back to the unchecked version by using an unchecked keyword. So if we wrap this big number equals big number plus one in this unchecked bracket, let's delete our old contract.

We'll compile, we'll redeploy, we hit big numbers. 2 55, we we hit add, we hit big number again, it reverted back to zero. So that's a little bit more about safe math checked and unchecked. So in version 0.76 and below, this code that you see in front of you is gonna be the exact same as this code in 0.8 and above with this unchecked keyword.

Now you might be thinking in newer versions of solidity, why would I use this unchecked keyword? Well, you'll find out later that this unchecked keyword. Makes your code a little bit more gas efficient. So if you're absolutely positive that your math is never gonna reach the top or bottom limits of a number, then it might make sense for you to use the unchecked keyword.

Let's head back over to our FundMe contract where we are now using the price converter library that we just created.

Awesome. We have a lot of the basics of the math that we need in our FundMe contract. So, all right, so this is great. People can actually send us money and we're gonna keep track of them as well, which is fantastic. So the next thing obviously that we're gonna wanna do is we're gonna want to be able to withdraw that money out.

So now let's go ahead and implement our withdraw function. When we withdraw the money, we're probably gonna want to reset all the mappings back down to zero to show that, hey, we've withdrawn all the money and there's nobody left to do this. We're gonna use something called a for loop. A for loop is a way to loop through a list of something or to do something in a repeated amount of time.

If you're familiar with other programming languages, it's the exact same concept. If we wanted to get all the elements in this list, for example, which where one is at the zero width index, two is at the first index, three is at the second index, and four is at the third index, which I know is a little bit confusing.

These are the different, these are the indexes and these are the elements. We would loop zero through three to get all the elements outta this array. To do this loop, we're gonna use the four keyword. We're gonna say four, but some parentheses. And in a for loop, we can add a a couple things. And by the way, this is a way to do comments inside of a line.

In solidity, you do a backslash star, star backslash, and now everything in here is a common, so in a for loop, you first need to give it the starting index, then you give it the ending index, and then you can give it the step amount. For example, let's say we wanna start on the zero width index. We want to go all the way up to the 10th index, and we want to go by up each time we would do 0, 1, 2, 3, 4, et cetera.

Well, let's say we wanna start with the third index. We want to go to the 12th index, and we wanna up by two every single time. Well, we would do 3, 5, 7, 9, et cetera. So our starting index is going to be a U two fifty six, and we'll call it under index. And we're gonna say we're gonna start with zero, and we're gonna end once the funder index is less than the funders length.

So I know I said up here, it's the ending index, but instead it's a Boolean. Once the funders index is greater than funders length, which is how you can get the length of an array, then we're gonna end. And then finally we're gonna say, every single time we do a loop, we're gonna say Funders index equals, funders index plus one.

Now, there's a shortcut you can do to do some variable equals itself plus one, and that's just plus. Plus This. Plus plus means every time we go through the loop, just add one, and we actually don't need that here. And then we put these curly braces to say, okay, execute everything inside of this loop here for the duration that we specified here.

And this final piece means that every time we run through all the code inside of these brackets, we're gonna add one to this funder index. That's how we go from zero to one to 3, 4, 5, 6, 7, et cetera. To access the zero width element of our Funders array, we're gonna say Funders of Funder index. And this is going to return an address since it's an array of addresses.

So we'll say address funder equals funders of funder index. And we want to use this to reset our mapping address to amount funded. So we can say, address to amount funded at the funder address is now equal to zero. So we're gonna reset whatever we added when they funded us down to zero because we're withdrawing all the money out.

And additionally, how there's a nice little shorthand like plus plus down here up here in the fund, another nice little shortcut. Whatever you want to add something to whatever you want to add something to something that already exists instead of doing something equals itself. Plus the new thing you can just do plus equals.

This means that we're gonna set address to amount funded of message sender equal to itself, plus message value. So let's walk through this for loop a little bit. We're gonna start with the zero width index. We're gonna get the funder at the zero width index in our funder array. We're gonna take that address, stick it into our mapping, and reset the amount that they've sent us to zero.

Then we're gonna do funder plus plus. We're gonna check to see that funder plus funder index plus plus is less than funders length. Obviously fund zero plus one is going to be one. So we're gonna check if one is less than the total amount of funders. And then we're gonna get the address of the funder at the first index, reset them to zero, get the address at the second index, reset them to zero third index, et cetera, et cetera, until we finally reach the index that is equal to or greater than the length.

So if we have 10 funders and we reach funder at next 10, the for loop will exit and be done.

But we still haven't done two things. We need to reset the array still, and then we also need to withdraw the funds. Since we've accumulated all this message value in the fund function. To reset the funders array, we could do the same thing we did with the mapping and reset each single address at each index, or we could just create a brand new funders array, which is what we're gonna do.

So to reset the array, we're now gonna say funders equals new address array. And to start off at a length of zero, previously we used the new keyword to deploy a different contract. Now we're using the new keyword to reset the funders array to a brand new blank address array. This part's a little confusing.

Don't let hold you back and later, later in the course why we make the choices here that we do so great, we've gone ahead and reset the array. So now how do we actually withdraw the funds? For this section, I'm gonna go ahead and again, refer to a previous course that it did because the content is exactly the same.

Just remember JavaScript VM is remix vm,

so great, we've gone ahead and reset the array, but how do we actually now withdraw funds from this contract? How do we send the funds back to whomever is calling this now to actually send Ether or send native blockchain currency? There are actually three different ways to do this. We're gonna look at all three and say what the difference is between the three of them are the three different ways are gonna be transfer, send, and call.

Let's go ahead and start with transfer. Since transfer is the simplest and at surface level makes the most sense to use. So if we want to transfer the funds to whomever is calling this withdrawal function, we would do, we would say message dot sender dot transfer. And then we'd get the balance of our contract here by saying, address this, the, this keyword refers to this whole contract balance and we can get the native blockchain currency or the Ethereum currency balance of this address like this.

And we can just do that. Only thing that we need to do is we need to cast, we need to typecast message sender from an address type to a payable address type. So message sender is of type address, whereas payable message sender is of type payable address. And in solidity, in order to send the native blockchain token like Ethereum, you can only work with payable addresses to do that.

So we just wrap it in this payable type caster. So this is the first way that we actually send Ethereum or send tokens from different contracts to each other. We wrap the address that we want to send it in, in this payable keyword we do dot transfer, and then we say exactly how much we want to transfer.

But there are some issues with transfer. Here we are on solidity by example for sending Ether, which again is a fantastic resource to refer to if you get lost. The method that we just looked at was this transfer method. Now we saw way earlier in the course that if I sent Ethereum from one address to another, it cost about 2100 gas or 2,100 gas.

Our transfer function is capped at 2300 gas, and if more gas is used, it throws an error. The next one that we're using is gonna be send, which is also capped at 2300 gas. And if it fails, it'll return a Boolean. So with transfer, if this line fails, it'll air and revert the transaction with send. It won't air, it'll return a Boolean of whether or not it was successful.

So using Send will do payable message sender send address this balance. But we don't wanna finish our call here. If this were to fail, the contract wouldn't revert the transaction and we just wouldn't get our money sent. So we wanna do bullion Send Success equals this whole bit here. And then we want to require send success.

And if this send fails, we'll throw an error saying send failed this way. If this fails, we will still revert by adding our required statement here. Transfer automatically reverts. If the transfer fails send, we'll only revert the transaction if we add this required statement here. So, great. What's the third way that we can actually send Theorum or native currency?

Well, it's with this call command. Now call is gonna be one of the first lower level commands that we actually use in our Solidity code because this call function is actually incredibly powerful and we can use it to call virtually any function in all of Ethereum without even having to have the abi.

We'll learn the advanced ways to use this call much later. For now, we're just gonna learn how to use it to send Ethereum or your native blockchain currency call is gonna look very similar to send, we're gonna do payable message.sender.call and this is where we'll put any function information or any information about the function we want to call on some other contract.

We actually don't want to call a function, so we're gonna leave this blank. We can show that we're leaving it blank by just putting in these two quotes here. We instead want to use this like a transaction. And as we saw in our deployment, there's always this message value bit. So we're gonna use this call function as if it's a regular transaction and we can add stuff like message value.

So in here we're gonna add these squiggly brackets and we're gonna say value address this balance, this call function returns actually two variables. And when a function returns two variables, we can show that by placing them into parentheses. On left hand side, the two variables it returns are gonna be a bullion that we're gonna call call success.

And also a bites object called data returned since call allows us to actually call different functions. If that function returns some data or returns value, we're gonna save that in the data returned variable. It also returns call success, where if the function was successfully called, this will be true.

If not, this will be false. And since bites, objects are arrays, data returns needs to be in memory. Now for our code here, we're actually not calling a function, so we don't really care about data returned. So similar to what we saw with the price contract, we can just go ahead and delete that and leave the comma to tell solidity.

Yeah, we know this function returns two variables, but we only care about one. And then similar to the send piece above, we're gonna do require call success, call failed, meaning that we're requiring call success is true, otherwise we'll revert with an error that says call failed. Now if learning the difference between these three is a little complicated for you right now, don't let that slow you down.

Feel free to come back to this after you've learned more about how some of these lower level functions work and a little bit more about how gas works. Solidity by example does a fantastic job though of saying what the difference is between all three are transfer has a maximum of 2300 gas and throws an error if it fails, send has a maximum of 2300 gas returns, a bullion if it fails, call forwards all gas, so doesn't have a capped gas.

And similar to send returns a Boolean if it is successful or if it fails. As of recording right now, using call is the recommended way to actually send and receive Ethereum or your blockchain native token for now. If this part's a little bit confusing for you, for now, just look at this and see, ah, that's how we send and transfer Ethereum or native blockchain currency tokens.

And I'm gonna delete this part for the video, but I'll keep those comments in the code repository associated with discourse.

All right, great. And actually the exact same code from that video we're gonna use for this as well. So we're gonna use this call, call success to work with sending a balance. However, there's a bit of an issue here right now. Anybody can call this withdraw function and take all the money out of this contract.

We don't want that. We want anyone to be able to fund the contract, but we don't want anyone to be able to withdraw money from the contract. We only want the owner of the contract to be able to withdraw. So how do we set this contract up so that the withdrawal function can only be called by the owner of this contract?

Well, we wanna set this contract up so that whenever we deploy it, whenever we create this contract, an owner gets assigned to this contract, we assign some address to being the owner, and then we add some parameters so that withdrawal can only be called by that address. So what we could do is we could set up some function.

Both call me right away and when we deploy this contract, we would just immediately call this, call me right away function, which will set us up as the owner. However, that would take two transactions. And remember, we're engineers. We wanna work incredibly hard to be incredibly lazy. So instead, solidity has something called a constructor.

And if you're familiar with other programming languages, a constructor is the exact same as really every other programming language. And the constructor is a keyword and a special function in solidity. So we can create a constructor function without the function keyword. We just call it structor, and we also don't even need the public keyword.

You'll see remix even highlights it pink. This is gonna be that function. It's gonna be a function that is immediately called whenever you deploy your contract. This function will be called in the exact same transaction that is used to deploy your contract. For example, if I were to take this minimum U S D added in our constructor and say minimum U S D equals two, this minimum U S D would immediately get updated to two right after this contract is deployed in that exact same transaction.

Since we want this withdrawal function to only to be able to be called by the owner of this contract in our constructor, we can set up an address right away to be the owner of this contract. So let's create a global variable called address public owner, and then right in our constructor, we'll say owner equals message dot sender.

Message dot sender. Of course, being the sender of the caller, which in this example is going to be the deployer of the contract. Dawn, we're gonna demo all of this very soon to show you everything that's going on. If you want to test all this right now, absolutely go for it. But just remember it's gonna take you a little bit longer on a testnet and I'm gonna show you how it all works.

Anyways. Now that we have our owner set up, we can actually modify our withdrawal function so that only the owner can call this function easily enough. We're already familiar with the require keyword. We could add a require the message sender of whoever calls this withdrawal function must be equal to, and this is how you do equals in solidity.

With this double equal sign, a single equal is set. A double equals means equals. So message sender must equal the owner. And if it's not the owner, we could revert with something like must be owner. Awesome. So now we have a quick way to require that whoever calls the withdrawal function is indeed the owner.

Awesome.

But let's say we have a lot of admin functions or only owner functions or functions that should only be called by the owner. Would we have to put this line on every single function? Remember, we wanna work incredibly hard to be incredibly lazy. We don't want to have to copy paste this line to every one of these functions.

And this is where something called modifiers come into play. So we're gonna go ahead and actually delete this line. And at the bottom we're gonna create our first modifier. A modifier is gonna allow us to create a keyword that we can put right in the function declaration to add some functionality very quickly and easily to any function.

To create a modifier, you use the modifier keyword and then you set it up very similarly to a function. So our modifier is gonna be called only owner. We don't give it a visibility like functions. And in here we can put our code. So again, we'll say require the message sender is equal to not set to, is equal to the owner.

And if it's not the owner, we're gonna say, sender is not owner. This. And then underneath we're gonna put this little underscore with the semicolon. What we can do is we can take this only owner keyword and stick it in the function declaration of our withdraw. And what's gonna happen now is it's going to execute what's in this modifier.

First, it's gonna execute this require and then this little underscore says, and then add whatever else you want to do in the function. So we're gonna execute this require then whatever else is in the function. And for our withdrawal function, it's gonna be everything else in here in our modifier. If we had the underscore above the require, this means that we would execute the code inside the function first and then the require.

So the order of your underscore matters. So now with this modifier keyword in the withdrawal function, whenever you call the withdrawal function, we first go, oh, there's a modifier I gotta drop down here. We'll execute this. Oh here's an underscore time to go back to the function. Let's do what's else is in the rest of the code.

And then it'll come back down to the only owner modifier and say, oh, is there anything else to do? Oh, there's nothing else. So I guess we're good.

So let's see this all go through. End-to-end. And remember, you don't actually have to deploy this to a testnet if you don't want to, but if you wanna follow along, feel free to do so. Of course, as well get started. Let's of course compile FundMe dot. So looks good. Let's delete any let contracts deployed previously.

Let's make sure we're on injected provider meta mask and let's make sure that we are on a testnet. We are indeed. Let's make sure we have a little bit of testnet eth in our wallet and we sure do. And let's go down to the contract and make sure we're on the right contract. If you try to deploy some, like an interface, you'll get an alert like this.

This contract might be abstract, blah, blah, blah. So we're not gonna do the interface. We're going to do the FundMe contract. Of course, we'll hit deploy. Meta mask will pop up. We'll go ahead and hit confirm on the meta mask. And then we're gonna have to wait a little bit for the contract to actually finish deploying.

If we pull up the terminal, we can see the contract go through and we can also see it in remix here. Now we've got a number of buttons in here. We've got our red fund button of course, which is because we have our fund function, which is payable, and this allows us to send ETH. With this function we have our withdraw function, which is just orange because it is not payable, although it is going to be withdrawing money out of the contract.

And then we have our typical blue view and pure functions. The owner of course, is gonna be our meta mask since we are the ones who deployed this contract, minimum U S D is going to be five. And these are of course going to be empty. We can call our fund function only if we send some value with it. If we try to call fund without any value, we're gonna get this gas estimation error failed and we'll even see didn't send enough ETH in the error log.

So let's go ahead and cancel this. Again, we could send this, but that would be a huge waste of gas, so we'll cancel it and let's get a value that's gonna be enough. So I believe 0.01 ETH should be enough. Let's say 0.01 eth. It looks like that's about $18. So back in remix, let's do 0.01 ETH in terms of way, which is this value here.

Paste that in and we'll scroll down. Now if we call fund, it does indeed go through and we can go ahead and hit confirm on this as well. And we see that transaction pop up on Ether scan and we might have to wait a little bit for this transaction to finish, finish going through finish indexing, et cetera.

So let's give it a couple minutes. Oh, looks like it's gone through. Fantastic. We can even see in the fund we contract the balance has gone up to 0.01 and we can see if we look at funders at Index zero, we can see our address. And if we copy our address and paste it into the mapping address to amount funded, we do indeed see an amount in here with this transaction fund being called.

Of course, on the Testnet Ether scan, we can see all the data and information associated with this and we can even scroll down and see the input data. We can see that this was calling the fund function. We'll learn more about the input data later. So now what we could do is we could do the reverse. We could go ahead and withdraw and that should reset the mapping and the array back down to zero.

For our modifier to work, we have to use withdraw on this account. If we switch to an account that isn't the owner of this contract and we go ahead and reconnect and we scroll down, we make sure value is zero and we scroll down and try to hit withdraw, we'll see. We get gas estimation failed and we'll even say sender is not the owner.

So we'll go ahead and cancel that. We'll switch back to account one. We'll make sure we're working with account one now we'll call withdraw. We'll see Meta mass does indeed pop up and we can go ahead and confirm. And in just a minute we'll see the balance reset. And if we call our funders and mapping, they should also have been reset.

So let's wait a little bit. Now if I try to call address to amount funded with that same address, we now get zero. And now if I look at funders at index zero, it actually airs and this isn't correct

following our more advanced load accounts. If you don't understand them the first time, don't let them stop you. They're not required to know to continue. The following is an excerpt from a slightly older edition of this course. You'll see that I don't use named imports like a new and a few other pieces of the code look slightly different.

But this next section we're gonna go over a lot of really advanced solidity pieces here that are gonna really advanced Solidity fundamentals. These are gonna be fantastic for saving gas, making your code look a lot cleaner and just better coding practices overall. For those of you who are looking to go super far with this, definitely be sure to pay attention to this section cuz this will make you look like a badass when you code later on.

Just remember when we say JavaScript vm, we just mean Remix vm. Additionally, whenever we deploy to the Rink Bee testnet, just know that you should be deploying to the swole Testnet or whatever the most up-to-date testnet is, or just don't deploy to the testnet and just follow along. We're gonna modify this contract to make it a little bit more professional.

It's not gonna be end-to-end amazing, but it's gonna be a little bit better and you'll see why in a minute. So the first thing that we're gonna do is we're looking, we're gonna look at some of these variables here. In particular, owner and minimum U S D owner gets set one time in our contract here and then it never changes again.

Minimum U S D gets set one time, even outside of the constructor. If we have variables that only get set one time, we can actually use some tools and solidity to make them more gas efficient. For now, let's compile our FundMe contract and then deploy it to a JavaScript virtual machine. Remember, we can go ahead and deploy it right now.

However, fund and withdrawing and doing any of the money stuff isn't gonna work because again, we don't have a chain like network on our JavaScript vm, so those aren't gonna work so well. But for what we're gonna do right now, we don't really care so much. Here's what we do care about. We do care about how much gas this costs to actually send.

We do care about how much gas this costs to create. Right now creating this contract costs about 859,000 gas and we're gonna add a couple of tricks right now to bring this number down. We're gonna add some stuff back in in a bit, which will bring it back up. But for now, we're gonna learn some tricks to bring this number down.

The two tricks that we're gonna learn are the constant keyword and the immutable keyword in their solidity. There are two keywords that make it so that your variables can't be changed and those keywords are constant and immutable. You can learn more about them in the solidity documentation if you assign a variable once outside of a function and then never change it.

So if if it's assigned at compile time, you can go ahead and add. This constant keyword we'll learn later about storage. But when you add a constant keyword, this minimum U S D no longer takes up a storage spot and is much easier to reto. So now if we recompile this and we deploy this new contract, let's see if we saved any gas.

We look in the transaction logs. Now we can grab the transaction cost of how much this cost to deploy and let's compare it to how much it was before. Wow, we saved almost 19,000 gas. That's almost as much gas as it cost to send Ethereum. Typically, constant variables have a different naming convention.

Typically, you'll wanna do them all caps like min Eum, underscore U S D, so all caps with underscores. So now let's just find minimum U S D and replace that with all caps as well. With this interaction, we know that this variable is a constant variable and it's much cheaper to read from. Now if we go ahead, compile this and redeploy in our fund contract, even though this is a view function, remember view functions do have gas costs when, when called by a contract as a constant variable, we can see the execution cost of this variable 21,415 gas.

So let's put a little note right underneath it. If we remove the constant variable, we delete this contract, we redeploy collect FundMe, and we hit minimum U S D. Again, we can now see how much gas this was cost. If it wasn't a constant variable, we can see the gas cost did indeed go up. Now a chains that are much cheaper, this gas difference probably won't make that much of a difference.

But on a more expensive chain like Ethereum, this is gonna make a big difference. For example, on Ethereum, we can actually see current gas prices on Ethereum. Here we see the current gas price of Ethereum is about 141 gu. So we'll go to our converter way to way, we'll copy the way price times this, we'll get the gas price of calling our minimum U S D, which is this number here, which if we put back in our Ethereum unit converter, we can see cost this much gas we, and if we times that by the approximate current price of Ethereum, which is around $3,000, calling minimum U S D as a constant is gonna cost $9.

Calling us at as at a non-constant is gonna cost almost an entire dollar more You, you can see how all these little gas optimization tricks are gonna make your life a lot better. So let's keep this constant keyword in here. We'll learn more about Constant and storage in later sections of this course.

Now, as you're just getting started with this course and with Solidity, do not struggle and do not worry about making your contracts as gas efficient as possible in the beginning, and especially right now, just write your contracts as best as you can. Once you get really good at gas and once you get much later on in the course and much more advanced with solidity, then you can start going back and working on gas optimizations.

But do not let gas optimizations hold you back, or if you start stressing over it, just let it go. Don't worry about it and just write your code as best you can. So long story short, do not stress about gas optimizations right now. Now, another variable we only set one time is gonna be our owner, variable owner equals message sender.

We set this one time in the constructor variables that we set one time, but outside of the same line that they're declared and we set them, for example, in the constructor, we can mark as immutable. Typically, a good convention for marking immutable variables is going to be doing, I underscore, so that we know that these are immutable variables.

They have very similar gas savings to the constant keyword Owner, of course, is a variable that we can't set on the line here because inside the global scope there's no function going on. However, inside functions, because inside the global scope there's gonna be no message sender. There's only gonna be a message sender when we're inside of a function.

So inside here we might say, I owner equals message sender. And then of course we'll scroll down and we'll change this require only owner now equals I owner. Now if we compile that and deploy it, we can see how much gas, we can see, how much gas calling I owner is gonna be by with the immutable nest. We get 21,508, which we'll go ahead and copy for now and we'll put right here.

We'll say immutable. Now, if we remove the immutable keyword, let's close this redeploy. Now if we scroll down to I owner scroll up the logs, we go down to the call, scroll down, see the execution cost was much more. So we'll do the backslash. Face that in here, gas non immutable. So you want to keep some of these tricks in mind when it comes to storing variables.

The reason that these two save gas is because instead of storing these variables inside of a storage slot, we actually stored them directly into the bike code of the contract. And like I said, don't worry too much about that for now. Later on in the course, we'll teach you more about storage and a lot of this low level stuff that it comes to these contracts.

But for now, just know that these exist and they're nice gas savers. If you're only setting your variables once. All right, great. So we've just made our contract a little bit more gas efficient, little gas efficiency improvements are gonna be concepts I sprinkle throughout this course. And when we get to the more advanced section, I'm gonna break down exactly what's going on and why all these gas efficiencies exist and what's going on behind the scenes for these gas efficiencies to occur.

It's a little bit in the weeds, which is why I'm gonna gloss over it right now. So if it's confusing, don't worry. I wouldn't let these gas efficiencies be the thing that slow you down. Awesome. So we have these two gas optimizations. How else can we make this contract a little bit more gas efficient? Well, one of the ways we can make this more gas efficient is by updating our requires.

Right now with our require statement, we actually have to store this sender is not an owner as a string array. Every single one of these characters in this error log needs to get stored individually. This, this string may not seem very big, but it's a lot bigger than the alternative with what we can do as of 0.8 0.4 of solidity, you can now actually do custom errors for our reverts.

We declare them at the top and then use ifs instead of require, and then just add our revert statements. This ends up saving a lot of gas since we just call the error code, as opposed to calling the entire string associated with the error. So for example, with our require down here and with actually with all of our requires, what we could do is instead of having this require, we could create a custom error.

So at the top, what we could do is we could say, error not owner. And you'll notice that this is actually outside of the contract here. Now what we can do is we can take this error, not owner, scroll down into our only owner. Instead of doing a require, we'll do an if statement, we'll say, if message dot sender is not I owner, then we're gonna go ahead and revert with a not owner error.

This ends up saving us a lot of gas since we don't have to store and emit this long string here. Now in a lot of code today, you'll still see require a lot of places because these, these custom errors are pretty new in solidity. So you'll wanna get used to writing in both ways. I wouldn't be surprised if in the future the syntax for some of these errors looks like this so that it's more readable.

But for now, if you wanna do a more gas efficient way than requires, you can use something like this. We could update all of our requires here for these custom errors, but for now I'm gonna leave both in just to show you the differences. This revert keyword does the exact same thing that required us without the conditional beforehand.

So you can actually go ahead and, and revert any transaction or any function. Call in the middle of the function call. Now let's look at one more way to improve this contract. Sometimes people will try to interact with the contract that takes Ethereum or the native blockchain token without actually going through the required function calls that that are needed.

For example, on a JavaScript E V M here, I could actually try to send this contract money without calling the fund function. However, if I were to do that, what would happen? Would our fund function get triggered? No, it wouldn't get triggered. We wouldn't keep track of that funder. We wouldn't have that person's information updated in this contract.

So if later on we went to give rewards or something, we wouldn't know about those funders and this wouldn't be great cuz people would send our contract money without us ever knowing and we, we wouldn't be able to give them any credit or anything. Additionally, maybe they called the wrong function by accident and they, they weren't using mad mask and they weren't using a tool to tell them, Hey, this transaction's likely gonna fail.

So what can we do in this case? What happens if someone sends this contract E without calling the fund function? Right now if we were to send this FundMe contract ETH, it would just go to the contract, right? And this contract just wouldn't keep track of those people. But there's actually a way for when people send money to this contract or people call a function that doesn't exist for us to still trigger some code.

And now there are two special functions in solidity. One is called receive and one is called the fallback. Now in solidity, they're actually a number of special functions. And two, these special functions are the receive special function and the fallback Special function. A contract can have at most one receive function declared using the receive external payable without the function keyword.

This function cannot have arguments, cannot return anything and must have external visibility. And a payable state mutability. What does that actually mean and or look like? Well, let's create a separate contract to go ahead and play with this. So in here we're gonna create a new file called Fallback example.

So, and in here we're gonna add our basic pieces, S px, slices, identifier, MIT pragma, solidity, 0.8 0.7. And we'll do contract fallback example like, so feel free to pause the video to catch up to this point. Once we create our fallback contract, let's create a variable to go ahead and try to test this function.

We'll create a u n 2 56 public result variable and let's create this receive function. So we'll say, receive, it's gonna be an external payable function. We don't add the function keyword for receive, since Solidity knows that receive is a special function whenever we send Ethereum or make a transaction to this contract.

Now, as long as there's no data associated with the transaction, This receive function will get triggered. What we can do in here now is we can say result equals one. So let's go ahead and test this out on the JavaScript virtual machine. We compile this, so we're gonna go ahead and compile this. We'll go deploy it on the JavaScript virtual machine.

We're gonna deploy our fallback example and we're gonna see what result is initialized to, since we haven't set anything for result. Result of course is initialized to zero. But what if we were to send this contract? Some Ethereum well receive would go ahead and be triggered here. We can actually send this contract some Ethereum directly by working with this low level interactions bit here.

Don't worry about what call data means for now. Just know that this area down here is a way we can send and work with different functions and we can add parameters to this transaction by going up here and adjusting the variables up here. If we keep call data blank, it'll be the same as if we were in meta mask and just hitting send and then choosing this contract address.

Again, we can't actually use meta mask since this is a virtual machine and not one of the networks that we're working with. So if I do, for example, I change this value to one way and I keep everything blank and I go ahead and hit this transaction button, which again is gonna be the same as hitting this send button, but only sending one way.

What do you think will happen? Well, let's try it. We can see in the log area that we did indeed send a transaction and if you look at the description here, you can even see it says from so-and-so to fallback example, receive it looks like it called our receive function, which should have updated our result to one.

So if we hit result, now we can indeed see that result has been updated to the value of one. Well, let's go ahead and delete this. Let's deploy this contract again and this time let's have value be zero. Does receive get triggered this time? So let's pull this down. Let's hit transact. Let's leave the call data blank.

We'll leave value at zero. So this will be the same as if we had sent zero Ethereum to this contract. Let's say transact looks like that went through. Do you think result is gonna be one or zero? You thought one, you were correct. A receive function gets triggered. Anytime we send a transaction to this contract now and we don't specify a function and we keep the call data blank when working with any other contract like FundMe for example, when we call one of these functions, we're actually just populating this call data bit with certain data that points.

To one of these functions up here. If we send a transaction and we add data to it, we could actually call one of these functions. Now let's try this again. Let's delete the contract again. We'll redeploy open this up. Result is currently zero. Receive, like I said, only is triggered if our call data to it is blank.

Now this time, if I add some call data to this transaction, you think receive will be triggered. This time, if we hit transact and remix, we actually get a popup saying, fallback function is not defined. This is because whenever data is sent with a transaction, solidity says, oh, well, since you're sending data, you're not looking for receive.

You're looking for some function. So let me look for that function for you. Hmm. I don't see any function that matches the zero x zero zero. So I'm gonna look for your fallback function. Remix is smart enough to know that we don't have a fallback function. The second special function in solidity is called the fallback function.

This is very similar to the receive function, except for the fact that can work even when data is sent along with transaction. So our fallback will look something like this. Fallback, external payable result equals two. Fallback is another one of these functions where we're not gonna put the function selector because Solidity is expecting this.

Actually, you're already familiar with one other special function. If we go back to our FundMe, our constructor, for example, is another type of special function. There's no function keyword. Solidity knows that this constructor is immediately called when we deploy this contract. So now we have our fallback function.

Let's go ahead and compile this. Let's delete our old contract. Let's go ahead and deploy this new contract. Let's click here. We hit result. We do indeed see it's set to zero. Now if I add this zero x, zero, zero, and I send this and I hit transact, this is equivalent to calling our contract here without a valid function.

So our contract goes, Hmm, I don't recognize what you're trying to tell me here. I'm gonna refer you to our fallback. Now if we hit result, we see that it's been updated to two. If we take this away, solidity will go, Hmm, it looks like you're trying to send some Ethereum or call this contract without specifying what you wanna do.

Well, I have a receive function, so I'm just gonna go ahead and forward you to that. So if we call transact, we hit result, we see it updates back to one, add some data, hit transact. We see it updates to two, no data updates to one Solidity by example. Dot org has a wonderful little chart that we can use to figure out whether or not receive is gonna get triggered, or fallback is gonna get triggered.

If it is empty and there's a receive function, it'll call the receive function. If it is data and there's no receive function, it'll just go to the fallback function. And if there's no fallback function, it might just, it might error out. So this is a lot of really fantastic information here. How can we apply this to our FundMe contract here?

Well, what we can do now in our FundMe is we can add these fallback and receive functions just in case somebody actually sends us contract money instead of calling the fund function correctly. So what we can do is let's add a receive function. So if somebody accidentally sends it money, we can still process the transaction.

We'll say receive is gonna be external payable and we'll just have the receive function call fund. And we'll do the same thing with our fallback function. We'll have fallback external payable, we'll just have it automatically call fund. Now if somebody accidentally sends us money without calling our fund function, it'll still automatically route them over to the fund function.

This means too that if somebody doesn't send us enough funding, it'll that transaction we'll still get reverted. So let's go ahead now and let's switch to rpe. To test this on a real testnet, I'm on rink B and my meta mask. Let's switch over to injected web three and we'll scroll down. We'll choose our FundMe contract and we'll go ahead and deploy this meta mask pops up.

I'm gonna go ahead and confirm the transaction and we see our FundMe contract here right now. We can see the own, we can see I'm the owner. We can see minimum U S D, and we can see of course that it's a blank contract and there's nothing funded in here. If we copy the address and then go to RPE Ether scan base the address in, we can see that there's no ether in here.

And the only transaction associated with this has been the contract creation. We saw what happened before when we hit the fund function, our contract was updated with a new balance and that funder was added to our array. Let's see what happens now if we just directly send this contract money without calling the fund function here.

If we did this right, our receive function should pick it up and kick the transaction over to fund. So let's copy this address, we'll go to our meta mask, we'll hit send case the address in here, we'll 0.02 E again because this should be more than the minimum amount in U S D. We'll hit next. I'll go ahead and confirm this and after a slight delay, if we did this right, we, we should see this transaction having called the fund function here.

Now that our transaction has gone through and after a brief delay and waiting for Ether can update, we do indeed see that our balance has updated to 0.02, which of course this makes sense and we see in the transactions list here, we see that this actually went through as a tra as a transfer. Instead of us calling the fund function, let's go ahead and remix and see if our funders was updated.

It looks like it was at the zero width position of funders. We have our address and if we take our address and pop it into address, two amount funded, we can see exactly how much we had funded. This means that since we added this receive function in here, we automatically had to call our fund function up here.

So awesome work. We were able to add a receive function to help people who accidentally call the wrong function or accidentally send this contract money instead of correctly calling the fund function. Now, if they had directly called the fund function, it would've cost them a little bit less gas, but at least this time they're gonna get credit and added to our funders array for having sent our funding contract money.

We've even learned some advanced sections of solidity, and this is gonna be the last time that we start our projects in remix. We're gonna be moving over to a code editor now where we can get even more advanced with our solidity and our setups. For the most part, you've gone over the vast majority of solidity basics.

There are a number of things that we still haven't learned yet, and the reason we haven't gone into them is because they get more advanced and understanding their real use doesn't really make too much sense until a little bit later. Some of the things that we're gonna go over are enums events, tri, tri catch function, selectors, ABI and coding hashing, and the mule slash and then u slash assembly.

However, if you've gotten this far, you probably can read most solidity code and understand what's going on, which is absolutely fantastic, so you should give yourself a huge round of applause for getting this far and doing this. Let's do a quick summary of this more advanced section and make sure we understand what we learn in solidity.

There are a couple special functions. Some of them are receive fallback and constructor. These functions don't need to have the function keyword and instead can just be called like. So. Receive and fallback are two very special functions. If data is sent with a transaction and no function was specified, the transaction will default to the fallback function if that fallback function exists.

If data is empty and there's a receive function, it'll call the receive function. There are a couple of keywords that can help us save gas in the long run. Some of those keywords are gonna be constant and immutable. Constant and immutable are for variables that can only be declared and updated once.

Once we say minimum U S D is 50 times one E 18, this minimum U s D can never be changed again, and this helps us save gas. Immutable can also save gas similar to constant, however immutable variables can be declared one time in the constructor. Once an immutable variable is declared, it can't be changed later on.

In fact, if we even tried to update an immutable variable or a constant variable and we compiled, a compiler would give us an error saying, can't write to immutable here, or if we tried to change our constant variable, Our compiler would say, Hey, you can't assign to a constant variable, sorry. In remix, if we wanna send Ether to a contract that's on the JavaScript virtual machine, we can deploy that contract, and then in the contract, we can just hit the transact button without any call data and update the value that we send with the transaction.

If call data is blank, it'll trigger a receive function if it exists, but if there's data that doesn't specify any of the other functions, it'll trigger the fallback function.

All right, my code's done. Time to ship it. Ability free box. You dog water, zero err zero P In the age of ai debugging and getting into software engineering has never been easier. You're the exact six steps you need to take to unblock yourself from any software engineering area you'll ever get. Number one, tinker.

Try to pinpoint your error. You can usually use an AI buddy to help you out here. Pinpointing your error will potentially solve your problem before you even go into an AI and allow you to craft a better question to an ai. Once you've pinpointed the issue, you can move to step two, which is ask your ai.

You can use chat chip bt, find Bing's ai, or if you wanna get wrong answers, Google's barred. There's six principles to prompt engineering so that you can get the best out of your ai. Write clearance specific instructions. Give as much context as possible. Use delimiters to clearly indicate distinct parts of the input, and especially look out for something called hallucinations.

Hallucinations are when your AI gives you an output that it thinks is right, but it's completely wrong. For example, if I write about writing solidity and variant tests and foundry, BT disgraces us by saying We have to MPM install it from Open Zeppelin. These can be tough to spot, but once you try it out, you'll see it doesn't work.

And finally, you want to understand the limitations of the AI you're working with and iterate constantly. Large learning language models are trained on human conversations so you can interact with them as if you're having a conversation. But it's important to know the limitations of these ai. As most AI have a limit on how many tokens or words they can keep in context.

At one time. AI is trained off human language, so if you're good at asking other humans questions, you'll probably be good at asking robots questions too. Asking questions is a skill, so keep practicing. I've got a link in the description to learn dot deep learning.ai, which is a free course to help software engineers be better prompt engineers.

Now when the AI can't help you, you'll have to go back to the old standbys actually doing work yourself. And one of the first pieces of work is reading the documentation. You probably should have done this already. However, we can still use chat chipp t cuz a strategy that I constantly use is I'll copy paste section of the documentation at chat chipp ts context and say someone like the above or the docs for tool X based on those docs.

How do I do Y? So Google might be crying because chat chipp T is eating its lunch, but Google still has what? AI doesn't have the entire internet. Previously, anytime I ran to an issue, I prayed, someone else had run into it before I made a post on it so I could Google search that exact issue. There's a new tool called Find that combines web search with AI as it does a web search and it crawls through all the data of the sites, reads them all, and then gives you an answer based off of what it reads.

Five, ask a form. Sometimes the information just isn't out there and we need to ask human beings. We always wanna ask our question on a WebEd indexed forum like Stack Exchange, stack Overflow, ANA or Reddit. This way web crawlers and more likely AI can scrape the data from these sites and learn from us.

That way the next time we have this question, we can get our answers quickly asking on Discord and Twitter our, because your knowledge will get lost at the unsearchable. No conversations that Discord is, and web crawlers don't index them. The super secret alpha is to ask a question on stack exchange and then post your stack exchange link to Discord.

You should 100% always ask your questions and format them with markdown. And if you're not sure how to do markdown, you can ask chat to BT to help you format your questions. And markdown ask on the support GitHub or forum is the tool you're working on. Open source, awesome. Ask a well formatted question on their Git page, not open source.

Never use that tool again. This is how we improve our tools by creating issues, engaging with each other and even taking on issues and contributing to the open source code. And then finally iterate. Do all these same steps over again. And as always, keep popping through the code. And until next time, stay riveting my fellow blockchain ears.

All right, fantastic. So now we know a little bit more about the different tools and techniques we can use when we do in fact get stuck. We use something like J T B T forums to ask questions. We obviously want a Google search and especially for this course, you definitely wanna make sure you use the discussions channel.

But I wanted to give you some very specific tips about working with this course. Number one, limit your self triaging to 15 or 20 minutes. For example, if we're trying to compile our price converter dot sole, and maybe we forgot to add the address in here, right? And we're going ahead and compile and we're getting this error, this is exactly one argument expected for explicit type conversion.

Now this should be pretty obvious what the error is. Hey, it's expecting one argument and we obviously just removed that argument. But maybe you're having a really hard time and you're trying all this different stuff and you can't seem to figure it out. Limit yourself to 15 or 20 minutes. We do not want to be messing around for so long that we can't figure something out, right?

Something like this would be very easy for us to compile, copy this air, go to chat G B T and say something like, Hey, I'm getting an error, compiling my solidity. Here is the error. Do three back ticks, paste it in here like that. Three back ticks is marked down. And like we said in the video, we want to use Delimiters to clearly identify what is code versus what is not.

Oops. And I hit and I hit enter. Whoops. The daisy. We're actually gonna hit stop generating and we're gonna copy paste the question again. And now we're gonna say, here is my solidity. It's wrong. And then we'll copy the solidity line once again. Three back ticks. We'll say solidity here, we'll paste it in three back ticks to end it and enter.

And it'll probably give us the answer here. And sure enough, the error message suggests that you need to provide an address when using explicit type conversion. So we go, ah, okay. Whoops. We need to actually add an address in here. It gives us an example and we can go back to our code and you know, paste that address in here and and be good to go.

So limit self triage to 15, 20 minutes. That's gonna be the first tip. Number two, don't be afraid to ask AI, but don't skip learning. The purpose of this course is for you to be able to learn everything here. AI is going to get things wrong, and it's only the people who actually have learned what's going on under the hood who are gonna be able to call out when AI gets something wrong.

When AI gets something wrong, it does something called hallucinate. And we talked a little bit about that in that AI video we just watched. So hallucinations are when the AI makes something up that it thinks is right, but it's completely wrong. And that's something we absolutely need to watch out for when we're coding and when we're learning.

A perfect example of this is with Foundry, which is a tool we're about to learn very soon. In order for us to install Foundry, we actually need to run this command, right? Get foundry.sh. It's the first thing that it tells us to do at the time of recording chat. G b T has not been trained on the Foundry tool.

So if I ask it a question like, I'd like to initialize a Foundry project with Solidity, can you show me how to do that? And we'll let enter. So the first sentence out the gate is wrong. It's not aware of Foundry, so it tried to guess what Foundry was and it got it wrong. It is not a rough paced framework for building blockchains at all, and it is directly related to solidity.

So it's really important that we use AI to augment our learning, but we don't skip over the learning with ai. It's really good to bounce questions, good ideas off of, but in order for us to be even able to recognize when Foundry is hallucinating and making stuff up, we need to have that knowledge ourself.

Step three, of course, use the forms Web three education.dev will have a place for you to ask questions, but in the meantime, definitely be sure to use the Foundry full course discussions. Use this to your advantage and use this to help other people out who have questions. This is a community project we're all gonna be helping each other out learning.

Number three, Google the exact error. If AI doesn't know the forums aren't know Google the exact error. Maybe somebody else has come across this error previously, ask the question online and you can just Google it. And then of course, post your question in Stack Exchange or Piana. And like we said in that AI video, you want to use markdown and format your questions as best as possible.

So if you're unfamiliar with how to use Markdown, if you're unfamiliar with how to format your questions, again, please be sure to ask Chat G B T or some other AI how to best format your questions. You can even simply say, ask chat G B T, could you gimme an example of a well formatted stack workflow question with God or code?

And it'll actually give us a really good formatted question, so it gives us the question. It formats the code for us. It's using this with the three back ticks that I, I showed you in order to get this code block here. It's using three back ticks and it's being very verbose in giving all the details of the question.

So be sure to ask questions like chatt, bt awesome. Again, let's say we're in here, compile, get this air exactly one argument expected for explicit type conversion. If we copy this error, go to Google, we paste just the error in, we'll remove this. Our specific code looks like the first thing we get in Google is actually contract inheritance, and we can see that this is actually exactly the error that we're getting.

It looks like this does actually explain the answer, but it's a little bit confusing to understand here. So maybe you would copy paste this in a chat Illa context, right? There's a lot of creative ways you can approach debugging some of your issues. Obviously, when you're out in the wild and you're actually building things yourself, obviously the education site and the discussions channel of the getup repo, the people in these aren't gonna have context for the new creative thing that you're working on.

So I want you to get used to doing that methodology that we're teaching here, right? Asking your AI buddy if your AI buddy doesn't know Googling, asking questions on Stack Exchange Ethereum, asking questions on Piana. Piana is arguably better because you're asking your questions in a decentralized location as opposed to a centralized server.

But I definitely want you to practice asking questions and go to piana. Go to stag Exchange. Make accounts for these so that when you do run into an issue because you will, you'll know where to post them. I'll encourage you to pause and post a question on one of these forms right now just so that you get used to it, just so that you get out of your shell and you're going to suck at asking questions in the beginning, and that's okay.

You will get better at asking questions as you continue with this course. Asking good questions is a skill in itself, and if you learn how to ask very good questions, that's the secret sauce to being amazing at AI prompting as well. Now, the final step in all of this is actually going to be posting an issue on GitHub slash git.

A surprisingly, incredibly important part of being a software engineer and being a developer in web three is interacting with the community. The vast majority of these tools that we're working with are gonna be something called open source, meaning that the code associated with them is actually available for anybody to view.

This tool Foundry that we're gonna be working with is one such example, and if you see it has this issues tab where there's just a ton of issues people are posting while using this tool. This is how code is able to be improved and move forward. All this code is public for people to use and work with, and if there's a question that isn't answered, you can post here and tell the developers of this tool, Hey, I'm running into an issue.

Maybe we should make a project improvement. I would say be very respectful with the way that you make issues. You definitely want to do some searching on issues to make sure that nobody else has asked the question that you're working with, and be assured to use these other resources first, like Piana, like Stack Exchange.

But in the future, once you leave this core, it's gonna be incredibly important for you to participate in the ecosystem by making issues, by making poll requests, and actually improving some of the tools that we're gonna be working with yourself. Even Ethereum has GitHub, and if there's any improvements that you wanna make, you can add an e I P to actually improve E Ethereum.

We'll talk about E IIP some more later. You can improve some of the clients that Ethereum runs. So interacting with each other is incredibly important. And in fact, if you don't have a GitHub, we are going to get you set up with GitHub right now because GitHub is a platform that most developers use to share code and write code and interact with code in between each other.

So if you don't have a GitHub, let's sign up right now, and we're gonna use the GitHub to create our own portfolios of all the different cool coding projects that we've created. This way, when you go to apply for a job, you can say, Hey, go look at my GitHub. I've got all these really cool projects. So we're gonna make you a GitHub right now.

You don't have an email. You're gonna need an email. I made a burner account just for this video, and I'm also gonna walk you through formatting a question. And I know I'm belaboring the point here, but I really, really want to stress the importance of formatting these questions really well. So we're actually gonna show a clip for my past video.

So we're gonna be using the full blockchain Solidity course js. But again, for this video, just be sure to use the GitHub repo associated with this course and not that other old GitHub repo. All right, let's watch this video.

In fact, if you haven't already, let's sign up for GitHub right now and let me walk you through formatting one of these questions, because the better you format your questions, the better chance you have of actually getting the answer. And remember when asking questions on these forums, when asking questions in these discussion communities, people answer these questions outta the goodness of their heart, right?

So if you don't get a response, there's a chance that maybe nobody knows. Maybe it's your question isn't formatted very well and et cetera. So we're gonna learn how to ask really good questions here. And if you're new to blockchain, do not skip this section. Okay? This is gonna be that piece that's gonna give you the superpower to unblock yourself from any coding issue you run into.

So don't skip this part. Be sure to follow along. Okay, so if you don't have a GitHub already, you do need an email to get started. So I'm gonna go ahead and sign in, made a burner account just for this video. So what we're gonna do, we're gonna go ahead and sign up, GitHub, enter your email,

and we hit Create account. They're gonna send us an email, so we're gonna come back to our email. We're gonna get our launch code here, paste it in, answer a little bit of information. We're gonna choose the free version and fantastic. We've now created a GitHub profile.

Awesome. So now we've created a GitHub. So I'm actually using a GitHub that I used in my last course, so that's why I have all these repositories over here. Now, in order to create a new discussion over the foundry, full course F 23, let's go over to the discussions tab. We'll hit new discussion and we'll hit general.

And I'll say something like, test discussion. You like. Feel free to say hello here, start discussion now. I'm gonna show you a question that's formatted poorly and I want you to never, ever, ever ask a question like this. And if you see somebody ask a question like this, please help them format their question correctly.

Hey, why my code not be good? And then let's just have it be an issue like this, right? What's wrong, wrong with this? Okay, well, why my code not be good? Obviously isn't clear what's going on. The code isn't formatted well, and even an AI would have a hard time answering this. So let's fix this to be a little bit better.

As we know, we want to copy the exact error we're getting. So we'll say, we'll copy the error, we'll go back, we'll say, I am receiving this error. We'll do the three little back ticks, paste our error right in here like that. Actually, let's be even more supposed to. I'm receiving this error while compiling, here's my code three back ticks.

We'll put solidity here, copy the whole line that is airing, paste it in here, and someone help me figure out what the issue is, right? And you see how this is much, much better, right? We have these two blocks that pop up because we did the back ticks. And the secret is that this is gonna get you a much better answer from an AI as well, right?

If we edit this, we can copy the whole thing and mark down, go over to chat, g b t, paste it in, zoom out a little bit, and we're gonna get actually an answer. Hey, you're receiving this error because you're trying to create an instance of aggregated V interface without providing the necessary argument, blah, blah, blah.

Oh, and it actually gives an outdated version of that, but it helps us out here. So ask format your questions correctly. You will get better answers from both ais and humans. And I know I'm spending a long time on this, but I really, really need you to understand that the secret to prompt engineering is actually just being able to ask better formatted questions with human beings.

And it's better for interacting with human beings as well. Now the other thing that I did really well here was I only posted the relevant code to the error that I was getting. What we see a lot of people do is they just copy paste their entire code base into here. This is not very helpful as it's gonna make somebody who wants to help you, their job, a lot harder if they have to read your entire code base, right?

We reply here, this is so much more reading for them to do. It's gonna take them a lot longer and they might not actually read it. And we didn't actually highlight this with the bag ticks. And it goes the same thing with ai. If you give your AI too much text, it can't read all of the text. Because again, some of these ais have limitations in how much text they can read.

So it's the exact same thing with working with human beings. So feel free to take some time to either in CHATT or whatever AI you're using or in this test discussion forum to post some well formatted questions. And remember, you can use AI to help you get those formatted questions in markdown. Be sure to ask chapter BT to give you the output in markdown.

So if you haven't worked with markdown before, that's okay, you'll learn as you go along. But one of the biggest differences, especially when working with markdown, that's gonna make your code so much more readable and I 100% need you to always do this whenever you ask questions, is you see how this got like some syntax highlighting in this above question?

Well, if we go click edit again, we can actually see why up here we did those three back ticks and then we type the word solidity. When you do these three back ticks in your questions, if you type the word or you type the language next to the first three back ticks, it'll actually add some formatting to make it more readable.

So if you scroll down to this poorly formatted question, you can see that this is just all white and like impossible to read. It would be at least slightly better if we hit edit. And next to these three back ticks, we wrote solidity. If this was like Java code or Python code, we could write Python or Java or whatever.

But since this is solidity, we'll write solidity. I'll hit update and you can see that it is substantially nicer and it is much more readable now. So even though this is still a bad question, obviously because we just copy paste all of our code, it's at least much more readable. So anytime you do a code block like this of any of your code, absolutely 100%, be sure to do the three back ticks and then the language of the block of code.

So just remember this. There are no bad questions, but there are poorly formatted questions. Make your questions well formatted for both human beings and for ai. And then most importantly, be sure to join these forums. And like I've said a hundred times, interact with these people. Interact and help and give back.

The more people that use and are good at the tool that you're working with, the more likely that they're gonna help you sometime in the future. And this is how I've met so many people in the industry, is just giving back and interacting with other people. So whenever you ask a question, especially in the beginning, cuz you're in the beginning, you're gonna have more questions than not.

Be sure to at least try to go back and answer a question. Think of it as question and answer debt. Every time you answer a question, make a little mental note and say, ah, in the future I need to at least try to answer one of somebody else's questions. This is how we grow and move so much faster.

Now this next piece that I'm gonna show you is actually outside of this course, but it's a resource that I wanted to show you in case after this course is done. You want more resources to learn about Ethereum and learn about the E B N. It's with my good friend Austin, who's going to show you speed run Ethereum, and definitely something you might wanna check out after taking this course.

What's up? I'm Austin Griffin. Happy Bow Tie Friday. I'm gonna show you the best way to get started building on Ethereum. It is speed run ethereum.com. It'll teach you how and why. You'll, you'll build a simple N F T, you'll build a decentralized staking app. You'll learn that the superpower of Ethereum is allowing you, the builder to create a simple set of rules where an adversarial group of people can coordinate financially.

You'll build a token vendor, you'll build a dice game, and you'll learn about randomness on chain and where it works and where it doesn't, and what you can do about that. You'll learn about a decks and what a hyper structure is and how people can use liquidity to swap. You'll learn about state channel and scalability and sign messages and multisig wallets and account abstraction and SVG NFTs.

Lots of fun stuff along the way. Like I said, not just the how, but the why. Go to speed run ethereum.com and get started today. Uh, it'll have you do a quick video, uh, and then it says to use scaffold eth to start tinkering. I wanna show you how to do that. First of all, all this stuff is open source. Uh, it's all ungated and open source.

Just get in and get, get in, get learning, okay? But the scaffold e thing, uh, scaffold eth is a great way to tinker, uh, with solidity and kind of get your, your, your bearings, right? So let me show scaffold too just for a second. If we zoom in, uh, I've already kind of, uh, gone through the whole read me and installed everything.

I wanna show this right here. Here's a smart contract, and I have my front end that's, uh, auto adapting to the smart contract. And so, uh, when in speed run Ethereum, it tells you to tinker with each one of these concepts. Let's just go look at mappings or STRs or modifiers. Let's just go look at a mapping and let's grab a mapping, right?

And let's copy and paste it right into our smart contract. So something called my map, I don't even know what it is, right? And then we yarn deploy, and we'll see that my map show up over here. And this is kind of the feedback loop I want you to get into where you can grab some stuff from, solidity by example, paste it into your smart contract, deploy it locally, and then tinker with it.

There's my, my map. Let's see what vitalic valance is in my map. It's zero. Uh, okay. So check out speed, run Ethereum, check out scaffold, eat, get started building cool things on Ethereum today. Happy bow tie Friday. Heart Hearts. Hearts. So.

Now, the reason I especially wanted to show you all of these debugging things right now is because we are about to move off of remix. Remix has been this phenomenal I D E or this phenomenal integrated development environment that allows us to quickly try things and quickly deploy things. But we're actually gonna move off of remix to a more professional setup, and we're gonna be using a modern set of tools that most of the rest of the development community also works with.

And I'm gonna tell you this right now. Often installing these new tools and often just getting your local development environment set up, not using Remix or not using what's called a Cloud i d e, can often be the actually most difficult step in this whole process. So I want you to be absolutely vigilant in using all of the resources that I just showed you, using the chat, using Chat gpt, using piana, using Stack Exchange eth, using Web three education.dev.

Once we get this up and live, be sure to use these tools and don't let installing these slow you down, because in my mind, installing these can be the hardest part of this whole course. And it's okay, things might not work the first time, and that's okay. Just be sure to ask questions and be very specific with the errors that you're seeing and installing these things.

That's what we're gonna learn how to do right now. So Remix is a phenomenal tool, but now we're gonna move over to this more professional setup called Foundry. Foundry is one of the most popular smart contract development frameworks similar to Hard Hat or Brownie, if you're familiar with those. And it's known specifically for its speed, Foundry is easily the fastest to work with smart contract development framework.

One of the unique aspects about Foundry is that whereas Hardhat is JavaScript based, brownie is Python based. Foundry is completely solidity based. So we don't have to learn any other programming languages other than Solidity to work with Foundry. And similar to everything that we've been doing so far, all of the code for all of our Foundry products are going to be in the GitHub repo associated with this course.

However, the documentation for Foundry I think is also phenomenal. So be sure to use this as you code along. And something very interesting that I really love to do, most of these pages are pretty small. So even if your AI isn't trained off of Foundry, which as a recording, it's not, what we can do is something called context injection.

When we have issues, so we can copy the entire page of documentation. We can say, I'd like to start, I'd like to install Foundry. Here are the documentations for installation. How can I do it? Do the three back ticks, paste the whole thing in there, and by giving Ouris the documentation for work with Foundry, it's actually going to give us outputs to install Foundry.

So this is a methodology you'll see me use from time to time, this context injection. You can find more information in the GitHub repo, once again, associated with this course on installation and setup Macs. And this should be Linux. And then we have some Windows set up stuff down here. We're gonna go over how to set up all the important things for this course.

So be sure to use this as a reference. Now a great question you might be asking is, well, what's even the purpose of Foundry? Why do we need to use this other tool? Remix is working great. Well, in remix, you notice that we did a lot of stuff manually. Like I came in here, I had to go to compile, maybe I wanted to test something out.

I would go deploy it. Uh, I gotta put a price feed in here, or a price feed in here. Deploy. Okay? Does the get version work? Uh, something's wrong with my GET version. Okay, my own I owner works. Okay, minimum u S D works. Oh crap, I, I gotta go make some little change here. You know, maybe I want get version to actually return, you know, seven plus two or seven plus one.

Now I gotta go, you know, delete this. I gotta go redeploy, I gotta go click this, I gotta go down, I gotta click ever. And then if I have a hundred things that I change, testing all this is gonna take a really long time. And anytime you do something, anytime us as human beings changes our code in some way, there's a chance that we break something.

And remember, these smart contracts are immutable. So if we break something, if we mess something up, that's really bad because that mess up will be permanent on the blockchain. So we want a framework that helps us deploy our smart contracts, test our smart contracts, and interact with them in a much more programmatic way, rather than we having to manually click around, right?

If I change 10 functions and I wanted to test, they all work, I would have to go click 10 buttons. That's ridiculous. In Foundry, we can do all of that in one command or one button. So that's why we're gonna be using Foundry here. And I'm so excited for you to be using this Foundry tool because like I said, it's the fastest smart contract development framework out there right now.

But additionally, it's also the framework of choice for smart contract security engineers and auditors. And I expect more and more projects in the future to be built in Foundry. So, incredibly excited for you here. Now, for the rest of the course, I'm gonna be using a code editor called Visual Studio Code.

This is one of the most powerful code editors on the planet. And if you've already got it set up, feel free to go ahead and skip this part. You'll often hear people refer to this as VS Code or Visual Studio Code, or just Visual Studio. However, it's important to note that Visual Studio Code, this is different than Visual Studio, which you might see look like this.

So Visual Studio Code is what you want, not Visual Studio. Visual Studio is a different application. Make sure you're on Visual Studio Code. Now, if you choose so, and you're a total Hardo, you can absolutely work just with your terminal or just with PowerShell or just with whatever coding environment that you want, like Adam or Sublime.

However, for us, we're gonna be working with Visual Studio Code, and I'm gonna be going through setting up Visual Studio Code. The way that I like to set it up, you can absolutely set it up whatever way that you feel comfortable. Now we're gonna go through three different installation processes and pick the one that's most appropriate for you.

The first one is gonna be for Mac and Linux users. The second one is gonna be for Windows users, and then our third one is gonna be a last ditch effort. If for whatever reason you can't get Windows or Linux or the Mac instructions to work, we're gonna use a GI Pod installation. Now, I highly, highly recommend that you try to get everything working locally without using GI Pod.

However, if for whatever reason you can't get those installation pieces to work, we will have GI Pod instructions for all of the repos that we work with here. But to get started, we'll start with the Mac and Linux installation instructions.

The first thing you're gonna wanna do is download the Mac, or if you're working with Linux, download the Linux installation of Visual Studio Code. Once you have it installed, it'll look a little something like this, and if it's a fresh installation, it'll even give you some tips and tools to actually get started.

If you've never worked with Visual Studio Code before, I highly recommend going through any get started or getting instructions, tips that come with opening Visual Studio Code. Additionally, we have a Visual Studio Code crash course in the GitHub repo associated with this course. Now, one of the awesome things about Visual Studio Code is it has this thing called terminals, which are command line prompts that allow us to run scripts.

Basically, it's where we're gonna be running all of our code. The way we can open up the terminal is we can go ahead and hit terminal and select new terminal. It'll get something like this. Now you might have Bash or Z C H or some other type of shell. The type that you have doesn't really matter because on Mac and Linux it's going to be Linux based.

And like I said, sometimes installing this can be the hardest part of this entire course, so, so don't get discouraged and please use Stack Overflow, stack Exchange Ethereum and the GitHub repo to move past any issues you run into. Now if you're on Mac or Linux, you can actually hit control back Tick to actually toggle your terminal mode.

This will pull the terminal up and down for you. Getting familiar with keyboard shortcuts will actually make your life a lot easier, cuz you'll be able to move around Visual Studio Code much more effectively. We have a link to a list of keyboard shortcuts. Additionally in the GitHub repository associated with this section.

As we move along, I'll give Tip on different keyboard shortcuts that you can optionally use. Otherwise you can just go ahead and click as well. You can click the trash can to delete the terminal, go back up terminal new terminal to pop it back up. Now the next thing that we're gonna need a little bit later, we're not gonna need it for this section, but it's good to install it now is gonna be Git.

We will have links to the installation instructions in the GitHub repository. Installing Git on Linux, you're gonna use one of these two commands and on Mac Os, if you just type get on the command line, it should go ahead and prompt you to install it. So if we're back in our command line and we just type get, it should prompt you to go ahead, install it, and if you do get dash dash version, you should get something that looks like this.

You can also use a Mac Os. Get installer by clicking this link here and running through the installation process. All right, now that you have Git and Visual Studio Code installed, we can continue on to the next section. Awesome. If you're not planning on using Windows or Git Pod, feel free to skip the next two sections.

And for this Windows setup, we're gonna be learning about a tool called wsl. And to introduce that to us, we have my friend who has done amazing work helping me on some of my past courses, and he's gonna be helping us here today. So take it away. This tutorial is going to be useful for any Windows version from Windows 10 and above.

Let's get started by installing our code editor in this case, B Studio Code. So let's type B code on the browser and hit enter, select, or version for Windows. Select the destination and click Safe and installation process is going to be the same as any other program. So let's select an accept the agreement, click next.

Add code to the pad, create a desktop icon next, and install this. Shouldn't take a lot. And this is how the editorial is going to look like the first time we install it. We can customize the theme, create shortcuts, and sing with another devices. And if you want to go deep into Biral Studio Code, well I suggest you to pause the video for a moment and go through all these steps one by one.

Now we could 100% go forward and install the rest of our tools in a Windows environment. But Basi is actually going to explain to us that the Windows environment isn't really actually the best way and the best place to do our installations. Microsoft has definitely increased their support for developers in the recent years, but when it comes to smart contract development, there is a better option to consider using wsl.

The Windows subsystem for Linux, trust me, is a game changer. You see, a smart contract development often involves working with tools and utilities that are commonly found on Unix based environments where Windows has come a long way in accommodating developers. There can still be some challenges when it comes to running certain command line tools and setting up the right development environment, not mentioning that if you want your code to run on any machine using a unit base system, Mac and Linux is better for your developer needs.

Here is where WSL shines. By installing a Linux distribution through wsl, you can access to a full fledge Unix like console right on your Windows machine. And don't worry, you don't need to be a hack hacker or wear a hoodie to make it happen is actually quite simple. So let's do it for that. Let's open the Windows terminal.

This is a pre-installed application on Windows 11 and something you can easily install through the Microsoft store on Windows 10, just type terminal. And here you're going to have the Windows one. So let's install WSL by typing WSL M Min in Hit Enter is going to trigger us, uh, admin operation and installation is going to start.

And here we just have to wait until the process finishes. Once the process is done, this will require you to reboot your operating system. So I see you on a second. Once rebooted, this is going to automatically open this terminal and the installation process is going to proceed. Now you have to input a new Unix username.

For me, it's going to be chrome wire, and then you have to set up your password. Don't worry, the password is always hidden on UX operating systems. And as this is that, we already have a operating Linux terminal inside or Windows machine. So we can now close this. Now we open a new instance on the Windows terminal.

Click here on this dropdown arrow. We can have now this Ubuntu Shell on which we are going to style all the development requirements we are going to use during the course. So the next step is to make B Studio Code compatible with wsl. So let's do that. Let's go to the extension tab. Let's search for remote development and install all these extensions.

This is going to automatically install the compatibility to connect or Visual Studio code with wsl. And as you can see over here I have a new econ called Open a Remote Window. If I click here, I can directly connect to wsl. However, there is an easy way to do this. Let's close this of the studio code. And on the Linux stream, let's just create a new folder, for example, MCA Solid Solidity course.

Let's move to that folder. And now let's open BI Studio Code. Inside this folder, just type code dot. Hit enter. This is going to install the latest server for WSL on BI Studio Code. And once this is done, we are going to have a new instance of B Studio Code. But using W S L, let's just trust the outdoors.

And as you can see here, I'm getting this WSL Ubuntu banner over here. And it's because I already connected this with the Windows instance. So you have to options. From now on, you can start using just the Windows terminal to execute all the things we are going to need. Or you can use the integrated terminal, which comes with B Solar Studio Code.

Just go to terminal new terminal. And now we are going to have a terminal using the exact same w l instance, so we can start using pseudo commands, for example, pseudo PT update. And this is going to work properly. Now just take something in consideration. Maybe you are going to develop all your projects.

On a folder called Development Inside Your Documents on Windows, and you can do so. However, if you take a look to the Linux terminal with the LS command, as you can see here, you are going to have just access to the local files and folders inside of the WSL instance. And I highly recommend you to do that because of course you can do something like typing the address of your local development folder and use the projects from here at the communication from the WSL console.

And the local Windows files are actually quite slow. So I prefer just to keep simple and use all the folders inside W Cell. Remember that you have to just manage simple commands, such as Ls, to know all the folders on the current directory and CD to navigate through them. Now, if you go back to your VS code and you hit Terminal New Terminal and it'll open up a terminal, we're gonna want to then install Git.

We're not gonna use Git for this lesson, however, we will definitely be using it in the future. See if Gits installed type Git dash dash version, sometimes Linux will automatically come with Git installed and you'll see something output like this. However, if you are the ones who decided to keep using Power Shell and just Windows instead of wsl, don't forget to go to the official GI page and install it for Windows.

The process is as same as we did before. Ready a standard, just the common sequence of clicking next. And of course, please do read the license agreement. And now if you've made it this far, you should be able to follow along with the Mac and Linux constructions as if you're running on a Mac and a Linux, even though you're running on a Windows.

Just be sure that whenever you're in your VS code, you take a look at the bottom left and make sure you're on W S L Ubuntu. Like I said before, if you want to run in PowerShell or in a Windows environment, you're more than free to do so. But like I said, if you've made it this far, huge congratulations.

Awesome work.

And then finally, our last setup is gonna be using a tool called GI Pod, starting from lesson five. The lesson that we're on right now, ether's JS Simple Storage. All of our code repos are gonna come with a button and the repo scroll down. It'll come with this open in GI POD button. Now GI Pod is a cloud development environment.

Where you can actually run your code on a remote server. It's kind of similar to remix I D E, but it allows you to run Visual Studio Code in the browser or connected to another server. This is good because then you don't have to do any installation on anything since all the tools that you can want to use are just gonna be running on this remote server.

This has its downsides though, obviously since you'll only be able to code if GI Pod is up and working for you. Additionally, when it comes to private keys, you absolutely do not want to run any code with a private key that has real money in it on GI Pod. Why? Well, once again, since you're running your scripts on a remote server, those servers have access to your private keys.

But since you've Pinky promised that you for this course, you're not gonna be using a meta mask or a private key with actual money in it, it should be fine. The other downside is that these often cost money to use and GI Pod isn't free, but it's an option if you absolutely cannot get any of the installation working.

So if you go ahead and you hit this opening GI Pod button, you'll get a welcome to GI Pod showing up. Uh, we're gonna go ahead and continue with GitHub since you've signed up for GitHub here, you want to go ahead and authorize GI Pod and it'll go ahead and start creating this workspace for you. And you'll notice it looks exactly like Visual Studio Code since I opened the repo up in GI Pod.

It came with all the code and you can even open this workspace up in VS. Code desktop. So this is, might be a little bit confusing, but basically you can run off of GI Pod using your local Visual Studio code. And if you see GI Pod here, that's how you know that you're running off of GI Pod. If you see this popup, do you want to open this workspace in vs.

Code desktop? You can hit open and it'll ask you if you wanna open up Visual Studio Code, which I'm gonna go ahead and hit yes and you'll get something that looks like this on your Visual Studio code. It'll tell you that it wants to install the GI Pod extension and then open that GI pod url. So you can go ahead and install it, reload window and open.

And it's gonna go ahead and start connecting to our the GI pod workspace. And this is gonna be the same as running GI Pod in the browser here, or you can also do it manually by hitting the GI pod in the bottom left and then type in open in VS code. And then you should be able to run an individual studio code.

For now, I'm gonna recommend that if you're using GI Pod, just stay in the browser just so that you know, okay, I am running this on a remote server. And just as a reminder for you that you're not actually locally developing and hopefully this will be a trigger to not actually put any special private keys or anything like that.

But you can make workspaces, you can make new folders and you should be able to run all the commands on here as if you were running locally with Visual Studio Code. So open up the terminal, you can hit this little bar on the top left, go to Terminal New Terminal, or use Control Tilda, exact same as Mac OS and Lennox Keyboard shortcuts.

To create a new folder, we can change directory cd.do mk d i r, new folder. Mk. D i r makes make directory called New folder. And then we're gonna change our directory and into new folder and hit enter. And now we're in that new folder. For each section, you can either open up the entire source code right into GI Pod, or you can create a new folder for each section yourself and start from blank.

And then you would just type code period, and you'd be in a brand new folder.

And if you're using Windows, this should say W S L or Ubuntu or something like that. And if you have all that, that means we're ready to go. Now a quick note, something that you'll see me do a lot, and you can do this as well. Oftentimes when my terminal gets really, really big or there's a ton of commands in here, gets a little bit overwhelming for me.

So one thing that you can do is you can type clear and hit enter to clear it. Or what you can do is you can hit Command K if you're on a Mac or control K if you're on a Linux or a Windows. And it's one of my favorite keyboard shortcuts that I use all the time. Additionally, the trash can and the X here are very different.

If I go do a couple of enters here and we're down here, if I hit the X here and then pull my terminal back up by doing the toggle or by doing terminal new terminal, you'll see all those lines are still here. But if I hit the trash can and then pull the terminal back up, you'll, you'll see it actually refreshes minus a special command that prints stuff out.

Trashing your terminal is basically deleting whatever's running in it and then the X is just hiding it and it's hitting control Tilda or toggling our terminal or whatever command it is on your environment. That's equivalent to hitting the hide, not the trash. So if we want to remove and start a terminal over, we hit the trash can and then we pull it back up.

So after we have that set up, the next thing that we're gonna want to install is actually Foundry itself in the Foundry book. You can find this in the installation tab or you can go to get foundry.sh and it'll have this command that you can actually just go ahead and copy Windows users. We're gonna teach you how to do it, the Linux or Mac West Way.

So just stay tuned. So we're gonna go ahead and copy this and run this command. Again, we can go terminal new terminal. And there are also some shortcuts to do this. I'm just gonna go ahead and paste this in here and hit enter. You will need internet access for this to work because it's actually downloading Foundry from.

This website, and let me just move this up, zoom in a little bit here, and you'll see me do this a lot in the terminal. I'll type clear a lot to remove anything that's been coded or output in our terminal here. Or you'll also see me do command K like that, which clears the screen. When I'm typing in the terminal.

You'll see me hit control W a lot, which actually removes the most recent block of code you've written. You'll also see me do Control U, which deletes the entire line. So I'm gonna use command C for copy and command V for paste a lot. For those of you on Windows and Lennox, it might be Control C and control V.

And if you're unfamiliar, you can Google the keyboard shortcuts for co, for copy and pasting for Windows or Linux. If you're on a Windows. These keyboard shortcuts might be a little bit different. We've got a list of keyboard shortcuts in the Git repo associated with this course. But if you've just run that curl command, you'll see an output at the bottom down here that says something like detected your preferred shell is whatever your shell is here and added Foundry up to path run source or simply start a new terminal session to use Foundry up.

And once you run that, we can go ahead and run Foundry up and this will actually install and update Foundry to the latest version. Now, whenever we want to install an update foundry, we can just run Foundry up like this. It'll automatically install everything. And Foundry comes with four components, forge, cast, anvil, and chisel.

We'll know we've installed these right? If we run forge dash dash version, and we'll see an output that looks something like this. Now, something important to note, if you hit this trash can in the top right, this actually kills the terminal. It's different from the X, which is just close the panel. If we close the panel and then we reopen our terminal by hitting terminal new terminal like this.

This actually creates a new terminal, which we can kill like this, but our old terminal is still up. In order to actually delete this terminal, we have to hit the trashcan. Now you want to try this out now delete your terminal like we just did. Open up a new terminal and run foundry up. If this doesn't run, we might have an issue with your path and you might need to add Foundry to your path.

If this is an issue that you have, please make a discussion on the GitHub repo associated with this course or check. Please first check this lesson six of the GitHub repo associated with this course, and we'll add some debugging tips to make sure that that does indeed happen. Or if there is no debugging tips here, make a discussion on the course.

But first, be sure to check to see if that discussion already exists and you should be able to do forge dash dash version. However, what can happen is if you trashcan the terminal and open up a new terminal, if you run forge dash dash version now, It might say Forge command not found. This means that you have to rerun this command, this source command that Foundry told us to do.

If you're working with Bash, most of the time this Bash RC file automatically gets loaded, but sometimes it actually won't, depending on what your setup is if this happens for you. Another thing that you can do is you can type CD and go to your home directory and type this line Echo Source, and then whatever Foundry Up told you to do double carrot dot bash profile and hit enter.

For example, when we just ran Foundry upright here, it gave us this command here. The source users, Patrick Bahar C, that's what we would want to echo. However, this will change depending on your terminal setup. So look to the GitHub repository for the command that you should be using for your setup. Please make a discussion thread if one does not already exist.

What this will do is it'll add this command to the end of your Bash profile. Make sure you do double like this. Otherwise, you could override whatever's currently in your Bash profile. Now, I'm gonna give you a command that if you screw up, you could accidentally override some stuff. If you've never used Bash profile before, you kind of don't have to worry about it though.

The other command you can run is something like this. If you do get an issue, we can just ask an AI something like, how do I get my dash dash RC to load by default? And there's a couple of different ways for this, depending on what system you're using and what you're working with. All I'm gonna say though is if this happens to you, if you run forge dash dash version, and instead of getting an output, you get something like Command not found, ask an AI or come into the discussions of the channel.

And as people run into this, we'll build and start a discussion. And if enough people have issues, we'll create a new file here to help people to bug that issue. So, but it looks like chat G B T does give a pretty good output of what we can do. We can edit our bash rc, our Bash profile, our profile, et cetera, and work with it like that.

So if you run into that issue, there's plenty of things we can do to fix it, don't worry. But if you're a little nervous, feel free to use the discussions channel of the course. Got it. Okay, great. If you see an output like this, you've done it, right? If you see an output, like we don't know what you're doing, you've done it wrong.

All right, great. And again, installing these can be some of the hardest parts of this course. So don't get discouraged if this doesn't work right away. If it worked right away for you, that's actually amazing.

Now also, the control spec, tick shortcut toggles the terminal visibility between up and down. I also have Command J as a toggle for panel visibility as well. This is a key binding that you'll see me use pretty often because we often will flip back and forth between the terminal and our code, which is gonna be up here.

In fact, if we click this explore button on the left, we can select this area, select new file. Do something like, hello T Xd or better yet, hello. So, and we can add some code in here. What's important to note is if you see this white.in the top section here, this means that this file isn't saved. Command S or control S, depending on if you're on a Windows or macro Linux will save it and make that white dot go away.

Unsaved saved, unsaved saved. It's important to recognize if a file is saved or not because if it's not saved, it might not do what you think it should do, so I kind of by default will always automatically save by hitting command S and it's a good practice to get into just always auto save everything you do.

We can also delete this file we just created by right clicking it and selecting delete move to trash. Final thing that we want to install and we'll install a lot of these as we go along, is actually an AI extension, something envious code to help us actually have AI inside of our Visual Studio code. If you select this little box looking thing that says extensions, you get a search box which allows you to search for extensions.

The AI that I work with the most is GitHub copilot, but you can use whatever AI you want or you could just not even use an AI GitHub copilot does cost money to use, so feel free to also not use it. There's some other free VS code extensions that use ai, so feel free to browse around and choose which one you like.

For me, I'm gonna go ahead and install GitHub copilot. You'll get a little guy in the bottom right for your VS code that will let you know that you've done it correctly. You'll need to sign into GitHub, which is something that we've recently made in order for it to work. Now you'll see me using GitHub copilot pretty often when I write my code.

Because I have this little due dead on down here, I can start writing some code and GitHub copilot will start giving me suggestions as to what I should write. For example, if I were to add S P D X like Sense Identifier, GitHub copilot actually automatically starts to gray out and gimme a suggestion. If I hit tab, I can auto complete my code with GitHub copilot suggestion.

Alternatively, what I could do then, for example, I could keep coding and I can see it's already giving me a suggestion here, and if I hit up key enter, I'll actually open up this bit on the side where GitHub copilot will give me a ton of different solutions on what it thinks I'm trying to write, and I can just pick one of these solutions.

Obviously some of these aren't doing anything. We'll learn about the command pallet soon, and we can also use any of the GitHub copilot commands that come with the command pallet. An alternate to VS code is a tool called VS code, so VS. Code is a tool that's owned by Microsoft and it sends up to telemetry data up to Microsoft.

So basically it can send data about ways to make your experience better with VS. Code. For people who have a more security mindset, this is an open sourced version of VS. Code that I highly recommend you check it out. Another extension that you might want to add is GitHub, copilot Labs. GitHub. Copilot Labs has AI features that are experimental, so it might be worth installing as well.

All right, fantastic. At this point, you should be 100% set up with Visual Studio Code and Git. If you're using Git Pod, that's great as well. And if you're using Windows, you should be 100% using WSL because the rest of the commands are only gonna work if you're using wsl and we're only gonna be working with Linux Bash or Zsh commands moving forward.

If you want to be a hardo, like I was saying, do everything in PowerShell, that's great too. Moving forward, what I want you guys all to do is open up your terminal the different ways I showed you and create a folder by typing an MK D I R boundary hyphen F 23. And then you do CD Foundry F 23. You'll notice something else I do a lot is I'll type the first couple letters of the folder I want to go into and then I'll hit tab, which will auto complete a lot of stuff for you in the terminal.

Sometimes it doesn't work. You'll get better at figuring out what auto completes and what doesn't. If I hit enter, this means I'm now inside of my Foundry F 23 folder and I can run commands inside of this folder. Moving forward, I want you to put all of your repositories inside this folder, this way moving forward in the future, when you start actually working on projects in real life, you can refer back to this folder and refer back to code that you wrote and refer back to your notes to make sure that you understand stuff Moving forward.

We've got Git dash dash version, forge dash dash version. We have cast dash dash version, which cast came with Forge and Foundry. We have anvil dash dash version, and we also have chisel dash, dash version. I'm gonna type clear or hit command K to clear everything in the terminal.

And all right, now that we have everything set up, let's go ahead and start creating our simple storage project. In a professional environment, this is going to be the exact same environment that the big protocols use. These are the environments that Unis Swap, Ave Curve, et cetera, these billion dollar groups use.

You are learning the exact same tools as them. Additionally, for those of you who are interested in security and auditing, Foundry is the most popular tool amongst auditors. So for those of you who wanna become security researchers, you're gonna learn the exact same tools that the best of the best use.

You ready? I sure am. So let's go ahead and create a new folder inside of this folder here. To do this, we're gonna type MK D I R, boundary Simple Storage, F 23, and then we're gonna CD into Foundry Simple Storage F 23. And you'll notice I hit tab there to Auto Complete again. Now everyone's terminals are gonna look a little bit differently.

Mine tells me the exact path of the folder that I'm in, but I have a alias called Video Shell, which just shows me the current folder that I'm in, and I'm gonna use that for the rest of the video. So if you see my terminal look like this, it means I'm at this location. Now, if you're inside of this folder, you can actually type in code and then hit a period, and then you should get a new Visual Studio Code, which is now defaulted to that folder.

If you don't, you can also hit file open folder and select the folder that you wanna open, which will also open up a new Visual Studio code inside of that folder. If you open up your terminal. Now you'll see that we are indeed in the folder for this project. And now on the left hand side over here, this Explore piece, we create a file.

You'll see it pop up in the left hand side of our explorer. Touch is a command to create or touch a file, and we can go ahead and click it and type stuff in this file. Now all these CD and mk, d i r and all these commands are known as Bash or Zsh or like Linux Terminal Commands. And we're gonna be using them a lot throughout this course if you want.

Great lesson on working with Bash and CCH and Linux commands on the free CODEcamp YouTube. But at the same time, most of the time, Chiche bt and most ais are actually very well versed in Bash and Linux commands. So anytime you have a problem doing something, you can often just ask one of these ais and it can help you out as a recording.

This one just came out a couple of weeks ago, so it's incredibly up to date. So if you want to get the basics down, it's only about 45 minutes long. I definitely recommend watching this so you can at least be familiar with some of the power that Bash has. You can absolutely continue on with the course as is and just use AI to augment you.

But for those of you who want to get more knowledge, definitely check that out. And again, the reason I have this dash F 23 is to let everyone know that this is associated with the Foundry 2023 course, but awesome. We can actually begin getting set up with our own local environments similar to that remix VM that we saw when we were working with Remix.

We can work with our own local blockchain and do a bunch of stuff locally. As you can tell by the name of this project. And from what I was saying earlier, this is gonna be our simple storage project, but coded with Foundry, which again is a smart contract development framework that's gonna make our deployments and an interactions with a code much more professional to get started with Foundry.

What we can do is we can open up our Explorer to see what's in here. Let's go ahead and delete I t Xd Move to trash. I'm gonna do my video shell command here, which won't work for you, but it works for me. What we're gonna do is we're gonna run a command to create a new Foundry, basic project for us. And if you go through the Foundry documentation, this is gonna be basically this creating a new project section of the documentation.

And if you wanna follow along with the documentation, you can do that as well. But to do this, we're just gonna run, forge and knit like this. And we'll see it created a ton of folders over on the left hand side for us, if you run into an air, because you accidentally have some files in here, for example, if I run Forge in it right now, it's gonna say, oh, it's not an empty directory.

What we can do is type forge a knit dash dash force period to say, let's do it in this directory. Hit enter. And it's actually gonna give us an error because it's gonna go, Hey, it already has everything that I was gonna do. So it's just, it's just not gonna do anything. But if you have files in here already, you just add this dash dash force piece.

Now, if you get a different error about Git, basily is actually gonna help us triage that. So take it away. And we are getting this error, and this is pretty common, don't worry. The reason is because even though GI comes print, install it on our WSL install, we still have to configure our username and our email so we can just use these commands.

Change this one, my actual email. And now let's also configure the username. After we have these configurations, we can run that command. Again, search in it. Hello Foundry. And if we check this out, we have our first Foundry project ready to be used with all the things we are going to need. And let's walk through what we have over on the left-hand side here.

So we have this GitHub slash workflows file, which we're gonna ignore for now, but we'll explain this later. We have Lib, which we're also gonna ignore for now, but we'll explain later. We have script with a file in here, which for now we're gonna go ahead and delete. We have ssrc, which is where we're gonna put all of our smart contracts that we want to deploy right now.

It comes packed with this counter, so which we're also going to delete, move to trash. And then we also have tests, which we haven't learned about yet, but we will. And for now, once again, you guessed it, we're gonna go ahead and right click and delete Source is gonna be the main section that we're gonna be working with.

SRC stands for source. And you'll see in a lot of projects, this is where they put all of their main contracts. Test is where we're gonna put code to test what's in src. And Script is where we're gonna put code to interact with our contracts that are in src. Get Ignore is gonna be files that we're not going to push up to GitHub.

If we push our code to GitHub, which is gonna be really important GI modules we can ignore for now. Teach about that later. And Foundry dot Tamel is a file that is going to give us configuration parameters about working with Foundry. And as we go along in this course, we're gonna update this folder because we're gonna update how we're gonna work with Foundry.

Now for us to get started here, we're gonna add our simple storage code into the SRC or source folder. If you close your remix, we can just come on back to the repo associated with this course. We'll scroll down to the remix, simple Storage, select the code base, and we'll go here and just copy all the code in here.

Come back over to BS code and in an src, we'll right click new folder. Simple Storage. So. Space it in here and hit save.

Now one of the first things that you'll notice is this is formatted horribly. It's just all white text. This cute little eth logo comes up, which is really nice, but we want a way to actually format this code correctly. So there are a lot of different VS code extensions that actually will format our solidity code for us.

One of them is the solidity. If we, if we simply type solidity in the extensions bar, we'll get a whole bunch of options that we can use. I'm a big fan of the hardhat solidity extension, even though hardhat is another framework, it also can format our code in Foundry. Another one that a lot of people like is the Solidity visual developer.

So that's another option if you want to use that one. And this one by Juan Blanco is probably the most used on the planet. But we're gonna go ahead and hit install to install this NAMIC Foundation Solidity vs code extension. And if we go back to our simple storage dot, so you'll see it is now formatted with syntax highlighting similar to what we saw in remix.

If it doesn't automatically highlight for you here, what we can do is hit command shift P or control shift P, which opens up our command bar here. And we can type in settings and we want to open our user settings in J. You can also hit code and then settings as well in here. And a lot of you might have nothing in here.

So what you can do is you create these little brackets to say, Hey, whatever's in here is gonna be our new settings. And we want to type these little quotes, little brackets and say solidity like this little set little colon here, some more brackets. And since I'm using GitHub copilot, it's even starting to give me suggestions, which I'll explain much later.

But we could do editor dot or you could paste in this editor dot default formatter noac foundation dot hard hat solidity. I'll have this code in the repo associated with this course. So you can just copy paste this if you want to. I've got a whole bunch of other stuff in here, so I'm gonna go ahead and delete this though.

But that way your solidity code will default format using that hardhat extension that we just installed. Great. Additionally, this foundry dot toil file also isn't formatted very well. So we'll go to extensions, we'll type in toil and we'll install this better toil here. We'll close this. Now if we go to foundry dot toil, we'll see this is now highlighted very nicely too.

Great. Now just remember, whenever you see this little.here, this means that it's not saved. So hit command S or file save and do that a lot. The other thing that's really good about us adding that default formatter is in our code here. You know, maybe this isn't formatted very nicely, right? Maybe we, we've got this over here and, and this over here, and it's kind of not looking very nice here.

If I go ahead and save without formatting, It'll save it here, but what we can do is if we add that auto formatter. Now, if we do command shift P, again, that brings this up, this command palette up, you can also get it by hitting view command palette, and we type format document. It'll format our code automatically, depending on what formatter we're defaulting to.

Since we opened our JS and we defaulted to the solidity hardhat, it'll automatically format with that. If your code isn't auto formatting, that's okay. Don't worry about this too much. Be sure to use ai, a web search and the forums to get your formatting. Good. The other thing that I like to do is we'll go over to settings.

Again, we're not gonna go to the jsm. We're gonna open the user settings and we're gonna type in format on save, and we'll check this box on this way. Every time we save, it'll automatically format. So if I have this and I hit save, it'll automatically format my Solidity code for me. If I don't want it to format again, we open the command pallet with Command Shift P or View Command Pal, and we can say Save without Formatting, and it'll save it.

See, the white.is gone and it will not be formatted, but I'm going to save and reformat it because I like it formatted in. Just to note, we pretty much never want to open these default settings, Jason, so avoid that one.

All right, great. And just with this little pieces of Code and Foundry installed, we can go ahead and compile our simple storage dot, so right in our terminal. So what we can do is we pull up our terminal and we can type in Forge, build, or Forge, compile, and this will compile our code like so. Once we compile, we see a couple new folders show up.

One of them is out, and this file and Out has all the different information that the remix compiler would have. For example, it has the A b I. If we go back to remix, we go to the compiler tab, we go to one of our contracts, we scroll down, we can see we have the ABI section, or it's also in the compilation details in VS code.

We can even click this little dropdown thing next to it and it'll minimize the A b I. And we can see the rest of this stuff like bike code, method identifiers, and all this other stuff, which we'll learn about later. We also get this cash folder. This is a folder that you would basically ignore. Now, anytime in our terminal we hit up, we can actually cycle through commands that we've recently run.

So if I run some crazy long command, like this echo here, which is a bash command, don't worry about it. And I wanna run it again. I can just hit up.

All right, great. So one of the things that we did in Remix quite a lot was we deployed our code to a remix VM or a JavaScript virtual environment. We wanna be able to do the exact same thing in Foundry in order to test and interact with our contracts. Foundry actually comes built in with a virtual environment in the Shell.

And if you run Anvil, you'll get an output that looks, and we pull this to the top. You'll get an output that looks something like this anvil, and we get some fake available account with some fake private keys. You'll also get a wallet pneumonic. The Derivation path, which you can ignore some details about the blockchain, and then this endpoint or R P C U R L, which we're gonna learn about soon.

For now, if you want to close this, hit control C or just delete your terminal to end running the Anvil blockchain. Now moving forward, we're going to work with Anvil, but I do want to give you an intermediary step, and that's gonna be with the ganache ETH chain, and we'll have a link to this in the GitHub repo associated with this lesson.

Ganache is a one click blockchain and it gives us a user interface or an app for us to look at our transactions in an easier way. So if you go ahead and download it for your system, we can get started there. Now a note for Windows users, if you're using W S L, the setup here is a little funky. We ran into some issues with it in our previous course, and we'll have some troubleshooting tips for those of you who are using Windows and W S L.

If you wanna work with Ganache. Everything that we're gonna be doing moving forward though, does work with Anvil Ganache just allows us to see transactions a little bit better than viewing all this stuff in the terminal. So if you're having a hard time with Ganache, don't worry. We can do everything that we're doing with Anvil, which should work for you no problem.

Once you have Ganache installed, when you open it up, it'll look something like this. And if we hit Quickstart for Ethereum, we'll actually create a brand new locally running blockchain with a nice little UI to view things same as Anvil and same as Remix. We get some addresses, we get, each of them has balances.

They come with some dummy private keys and dummy addresses and the likes. What's nice about this is that we can see the blocks, we can see different transactions, and if we're working with Truffle, we can see contracts. We're not gonna work with Truffle though, but these are gonna be very helpful for us to view stuff.

Additionally, we're not gonna use Ganache again in the future, so if you have trouble setting up with it, don't worry. Just use Anvil. I'm gonna use it to show you what's going on. Remember though, don't use these private keys on a public blockchain. It's for development purposes only because everyone knows these private keys, cuz they're dummy private keys.

Now, in order for us to learn how to actually deploy to this blockchain or how to deploy to Anvil, if we're working with Anvil, we need to understand how even Remix was able to deploy to a public blockchain. When in remix, when we switched to injected provider meta mass, we know that meta mass popped up.

It asked us to add our password and we went ahead and got connected. And if we looked in meta mask, we saw our count is indeed connected to SE Polio. When we hit Deploy, our meta mask popped up again and it was able to deploy our contract to a real test network. Well, how did it know where to send our transaction?

How did it know where to send our contract? Well, let's go ahead and open up our meta mass here. If we click the three little dots and hit Expand view, we hit the little button now and we go to settings and we go to Networks. You'll actually see in here that each one of these networks, Ethereum, main neck, really seia line or whatever you have, comes with a whole bunch of information.

Let's go to E Main net and check that out for a second. It has a name, an R, pc uur, L, a, chain id, currency symbol, and Block Explorer. This R PC uur L is the actual HT to PS endpoint that we actually send API calls to when we're sending transactions. So whenever you interact with Meta Mask and you send a transaction, or you deploy a contract, you're actually making an API call to whatever is in here.

You'll see this is an infu endpoint. An INFU is known as a note as a service project that allows you to send transactions to a blockchain node without having to run one yourself. If you wanted to send transactions to your own blockchain node, you would just swap this out with your own blockchain node address.

We can't actually change the ones that come built into meta mass, but we can add new networks, which is what we're gonna do. Now in here, if we scroll to the bottom, we can hit Add Network manually and we can add information about our own custom network. So for us, we're gonna make this new network called Local Host or local chain, or whatever you wanna call it for R PC U rl.

If you're working with Ganache, it's gonna be this R PC server right here. If you're working with Anvil at the bottom, we have this listening here. So what we would do is we would copy this, or we would copy this from Ganache and paste it in here. Just note that you always need the HTTP or https colon slash slash.

Most of our local applications aren't gonna be https, they're just gonna be http. So if we're working with ganache, let's go ahead and copy the Ganache endpoint, paste it in here like so. Every single blockchain gets their own chain id. It's an easy way for us to know which blockchain that we're interacting with.

Ganache has 1 3 37, and Anvil doesn't say it, but it's 3 1 3 37. So Anvil is 3 1 3 37. Since I'm using the ganache endpoint here, I'm gonna type in 1 3 37. If you're using Anvil, it would be 31 3 37, but what's kind of nice is Meta Mask can actually identify why you're using and identify the chain ID and basically tell you what chain ID to use.

Just a note, it looks like the newer versions of ganache are using a different R P C server and a different network id, and make sure you're on this hard for the merge here as well. Although in practice I've found that even when you have 5 7 77, it still is expecting 1 3 77. So be sure to use the correct chain ID when you're working with this currency symbol.

We're gonna do eth, and since this is a local blockchain, we don't actually have a block explorer. Ethers scan has no way to connect to our own local blockchain, so we don't get a block explorer for this one. But if I go ahead and hit save, now it says network added successfully, and I can go ahead and switch to my local host chain.

Boom. And now we can see it in my list of networks of local host. I've got no assets, no NFTs, and no activity. Now if your local anvil or ganache chain isn't running after you've put it in your meta mask, if you actually try to swap to your anvil or to your local host or to your ganache, you'll just get this spinning wheel of death here, right?

And eventually you'll get this little x that'll show up and you'll have to switch to a different network. So if you're gonna switch to one of these that isn't running, it won't work, you'll have to either run it or you can hit X here. And then in your meta mask, you could just delete one of these right here.

While we're not running our ganache or our anvil, we're just not gonna have one of these selected. Great. So this is where on both anvil and ganache, they have these available accounts and these private keys. Since I'm using ganache, what I can do is I can select this show keys, copy this private key, and import it into my meta mask.

So I can go up, hit this little button, I can hit import account, paste my private key in here, and hit import. Now you'll see in my meta mask, I have a couple different accounts. Account three, the one I just imported has 100 eth. Why does it have a hundred eth? Well, because I'm using one of these dummy accounts from Ganache, and again, if you're using Anvil, they have, they start with a thousand eth.

This

process that we just did to add our new ganache local chain is also how we're gonna add any VM compatible chain on the planet. We'll just hit ADD network and meta mask actually comes built in with a lot of these. And for example, if we wanted to work with arbitrary one, we could just hit ADD and it would add all this information in for us, approve network adding successfully.

But if meta mass doesn't have those built in, that's the process. Now, if we go back to settings, network, local host, this endpoint is the most important thing. You need to send a transaction to a blockchain. You need a connection to a node in order to send transactions to. If you wanted to send transactions to your own node, you would run something like ga, which is an execution client, and then something maybe like Tecu or Prism, which is a consensus client and send transactions there.

I'm not gonna go over this right now, but I highly recommend that those of you who are curious, maybe you take some time and you try to run your own Ethereum node. I run many Ethereum nodes and it's a lot of fun. It's kind of a weird thing to say. It's fun to run nodes. Whatever it is, fun to run nodes.

Each one of these blockchains has different methods you could send to them to do things. If you're familiar with APIs and HTTP endpoints and you go to this Ethereum J S R PC specification site, you can actually see all the different methods that Ethereum blockchain nodes can make and most E V M blockchain nodes can make.

And when we actually sign and send transactions, it's these calls that we're actually making like each sign, sign, transaction, send transactions, send raw transaction, et cetera. We're actually not gonna be going over interacting with these because Forge actually handles a lot of sending these transactions itself.

If you wanna learn how to send a raw transaction, making raw API calls to your own Ethereum node or an Ethereum node as a service like Ferra or Alchemy, you would do that in a different programming language like Bash Python or JavaScript.

All right, awesome. Now that we have our endpoint and our private key, we pretty much have everything that we need to deploy to our own local blockchain, be it ganache or anvil. Same as working with a real blockchain. We need an actual balance to spend gas to deploy our contract. Now, there's actually two ways that we're gonna learn to deploy contracts, and the first way is actually with just working with the command line.

If we're in our command line, if we're in our terminal here and we do forge dash dash help, we can actually see all the different commands that Forge comes built in with. One we're gonna be working with right now is this create command. And if you read it, it says it deploys a smart contract, which is perfect.

That's exactly what we want to do. And if we're in our command here, let's sit clear and we do forge, create dash, dash help. We can see a ton of different options for deploying our contract. Click show keys, copy the private key. Again, if you're using Anvil, use the private keys there. If we do Forge, create Simple Storage, which is the name of our contract, it'll compile and then it'll throw an error, actually, or it might actually work, but because I'm working with this RPC server, but this RPC server is different from the one that Forge actually defaults to.

So instead what I can do is forge, create simple storage, dash, dash, rpc dash url, copy this, paste it in here. I might be upset with the uppercase. Let's just make that lowercase and I'll hit enter. And this won't work either. Well, of course we forgot to add a private key, so if I hit up, I can hit dash dash in, enter active as well, and now it'll prompt me for a private key.

Now, in a really important note that I want to tell you, never use a real private key in your VS code if you're using an application that potentially will send your information. A much better option is to use your own terminal as opposed to something like VS. Code, which might send data or get pod. Since we are just developing and we're just practicing, it's fine to paste our private keys here because.

This is a private key that's not gonna have any real money, right? It's a fake private key. So for now, we can go ahead, we can go back to our ganache or back to our Enil. Hit show keys, copy this private key, paste it in here. It won't show up if you hit paste, but I'll hit enter and we'll go ahead and see information about our transaction.

Now, if you're working with Ganache, we can now hit done here. We go to blocks. We see we created a new block. We go to transactions. We can see that we sent a transaction and we created a contract. And then you can see logs about working with this as well. Fantastic. If you're working with Anvil and you send a transaction, you're not gonna see any of those details.

For those of you who want to continue to see these blocks and these transactions and wanna keep working with Ganache, feel free to do so. Moving forward, we're gonna work with Anvil. So I'm actually gonna close Ganache Now I'm gonna hit Clear in the terminal and I'm gonna run Anvil here. And what I'm gonna do is I'm gonna create a new terminal by hitting the plus button here, and we're gonna run that command again, but we're gonna run it with a private key from Anvil.

So if we go to here, we can do Forge Create. This time we don't have to put in R PC because Forge defaults to the Anvil one, but I can say Simple Storage s Interactive. It'll do enter the private key. I will paste it and we'll go ahead and deploy, go to Anvil. We don't get any logs like this, but we can see we went ahead and actually deployed it to our Anvil blockchain.

Awesome Work. Another way we can do this, forage Create. It's by Running Forge, create Simple Storage. If we wanted to be incredibly explicit, we would do dash, dash, rpc, dash url, copy this http slash slash paste it in there, dash dash private key, and back in anvil. Copy the private key, paste it in like this, and we would get the same thing.

Now here's what I'm gonna tell you, and this is incredibly important. Hasting in your private key, like this is no bueno, very bad. We pretty much never want to have our private key in plain text A, especially our production or our private keys with actual money. Putting this private key in plain text is not a big deal because this is a fake dummy one.

It's also bad to have our private keys in our Shell or bash history. If I hit up once on my terminal, I can see the private key in here, which is why the interactive is a little bit better because it at least obfuscates the private key to remove your private key from your history. In Bash, you can do history C.

Now, if I hit up, I can't see any commands, and if I do history, I can see my entire history, which is just the history keyword. Now if I type clear, I'll do history. Now I see history, clear history. Great. And we don't have the private key in our command history anymore. We will learn more about proper private key safety in the future.

But I want you to do something for me right now in a new file. I want you to right click and I want you to write promise.md. We're gonna hide the terminal, and in here we're gonna say, I promise to never use my private key associated with real money in plain text. In fact, take this and tweet this. I promise to never use my private key associated with real money in plain text and I can't spell.

And that's fine. And then if you want to add me or you want to add safe for audits or whatever, go ahead and send that. We are gonna have more of these promises that you're gonna do. But this is the first one that I need you to understand right now. It's cool because these are dumbing keys, but in the future it will definitely not be cool.

And I'm stressing this because I've seen a lot of multi-million dollar companies not follow this and get their private keys hacked. Great. Now of course though, the basic way to deploy to any blockchain would be forged. Create the name of your contract, add the R P C U R L, and then add your private key.

We're gonna learn how to get RPC RLS for free using alchemy for any blockchain that we want. And like I said, more safe, private key methodologies in the future. But now you've just learned how to deploy your contracts to any chain from the command line. This is great.

All right, great. So now we've learned how to actually deploy a contract to any blockchain that we want using the command line. Now I'm gonna teach you the second way we're gonna deploy our contracts. And this is the way we're actually gonna do it for the rest of the course. When we're deploying our code, we wanna make sure we have a continuous reproducible way to deploy our smart contracts.

And when we test our code in the future, we want the tests to test the deployment processes as well as the code. So instead of just doing the command line, we're actually going to write a script for us to deploy our code. And because Foundry has everything written in Solidity, this script that we're gonna write to deploy our code is also gonna be written in Solidity.

And this is where Solidity as a contract language versus Solidity as a scripting language is a little bit different. Foundry has a whole bunch of built-in stuff to give our solidity even more functionality outside of just smart contracts. And you'll learn about how later in the course. But for now, we're gonna learn how to create a script to deploy our simple storage contract.

And the way we create a script to do it is first we come to our script folder. We'll right click new file will create Deploy Simple Storage S Soul. This S Soul is just a foundry convention. Most of the time scripts have a s. So instead of just being so, and in here, we're actually going to write a contract in Solidity to deploy our smart contract, which sounds a little bit weird, but don't worry too much about that.

This Deploy script is gonna be written in Solidity, but it, it shouldn't be considered a contract that we actually ever want to deploy. It's just for deploying our code, but it is written in Solidity. So since it's written in Solidity, we'll do the same thing as usual. S P D X license identifier, m i T. And if you're using GitHub copilot, it might even auto suggest like this.

And I'm just gonna go ahead and hit tab. I'll do Pragma solidity, 0.8 0.18, and then I'll create contract, deploy simple storage like so, and I'll hit save. If you go to the Foundry docs, we can actually scroll down to this solidity scripting section in the tutorials and you can learn how to actually write scripts and work with scripts.

The first thing that we need to do in order to tell that Foundry that this is a script, is we need to actually import some additional code. Now, one of the things that we saw in here was this lib folder, and this lib folder actually starts with another folder called Forge, s t D. This Forge s STD stands for Forge Standard Library.

In here there's a ton of helpful tools and scripts for working with Foundry. And to tell Foundry that this contract deploy Simple Storage is actually a script we need to import from Forge std. So we're gonna do import forge dash std slash script. So, and we'll have our contract deploy Simple Storage, inherit all the functionality of this script by saying is Script.

And I know we learned about Inheritance before, so you should know what that means is script. And then additionally, our Deploy Simple Storage is gonna need to know about our simple storage contract. So we'll go ahead and import that import. We'll go down a directory since we're in the script folder and we need to go to the SRC folder.

These two dots is how you go down a directory. We'll do slash SRC vs. Code even might help prompt you here. Dash and it again, auto prompted for me and I hit tab and we now we've imported simple storage. Now since we know that this is the new way to do imports, we're gonna do the cool way by using named Imports instead of nameless Imports.

Okay, great. Now, inside every deploy or script contract, we need our main function, which is gonna be called Run. And this is going to be the command that gets called when we go to deploy our contract. So we'll create a function called Run. We'll make it external and we can have it return a simple storage contract.

And in here we're going to use a new keyword that we haven't used before. We're gonna say VM dot start. Broadcast VM is a special keyword in the Forge Standard Library. The VM keyword is a special keyword that we can only use in foundry. It's related to something called cheat codes. We're not gonna go over that too deep right now.

You can see a whole list of foundry cheat codes in the documentation and forge standard library references, which have even more cheat codes as well. This VM stuff is only gonna work in Foundry. If you actually were to try to deploy this in remix or some other framework, it wouldn't work. These VM cheat codes only work in Foundry.

It's not valid in regular solidity, but if we're inheriting Forge S TD code, this VM keyword exists. If we're using the hardhat solidity extension, we can actually control or command click into VM and we can actually see where it's defined. But if that's confusing, ignore that for now. This VM dot start broadcast says, Hey, everything after this line inside of this function, you should actually send to the rpc.

And then when we're done broadcasting, we're gonna do VM dot stop broadcast. So everything inside of these is what we actually want to send and deploy. The reason we have this is because maybe we have some stuff like we wanna set some boilerplate code before we actually send transactions, and we don't wanna spend any gas to like set starting value to one, right?

So any transaction that we want to actually set, we need to put in between these VM dot start broadcast and VM dot stop broadcast. And for us to deploy our simple storage contract, we just do simple storage, lowercase, simple storage, right? These are different simple storage. The variable simple storage.

The contract equals new simple storage like this. And remember, what does this new keyword do? Well, the new keyword creates a new contract in Solidity. It's also gonna create a new contract in between our VM Star broadcast. This being in between these VM star broadcasts is gonna send a transaction to create a new simple storage contract.

If this is a little bit confusing for you right now, that's okay. It's gonna make more sense as we go on later in the course. But for now, just do this and follow along with me. And then of course, we can say Turn simple storage. Okay, great. Now, if we pull our terminal back up, we can see we have anvil running right now, and we can actually kill it with control C.

We'll clear to the top. And what we can do now is run forge script. Script, deploy simple storage dot s. So hit enter and look. Oops. Looks like I got some different solidity versions. So let's change this to a carrot in here. And let's change this to a carrot in here, this being an 18, so that they're both on the same version.

Let's type clear close these or minimize these out. We'll hit up twice and we'll run this again. And now what you'll see is it's compiling, it compiles both the script to deploy and our simple storage contract using 0.8 0.9 because we did the carrot Compile a successful scripts successful, tells us the gas, and then we went ahead, we returned our simple storage contract, which was deployed here.

Now you might be asking, wait, wait, wait, wait. Patrick, we, we don't have Anvil running. We don't have a local blockchain running. Where did this deploy to? Well, in Foundry, if you don't specify in our P C U R L, it'll just automatically deploy your contract or run your script on a temporary anvil chain. So once I ran forged script, it saw there was no RRP C R L.

So it spun up a temporary anvil blockchain deployed our simple storage and then tore it back down at the end. You can see at the bottom, if you wish to simulate on train transaction, pass an RPC url. So if we do clear, we run Anvil and then create a new terminal, we could run Forge Script script, deploy simple storage S dot.

So, and I'm hitting tab to auto complete that dash dash RPC url. Go back to anvil, copy this. Go back to bash http dot slash slash we, we actually almost deployed this to the blockchain. We actually did a simulation of deploying to our anvil chain here. It gives us one more piece of information to broadcast these transactions add dash broadcast and wallet configurations to the previous command.

And now we get a new folder, which gives us information about our previous deployments in case we forget. For example, if we deploy contract, we can flip back here and see where we actually deployed code. So let's pull up our terminal once more and actually deploy this to the blockchain. So we'll hit clear.

I'll hit up. We have our RP, C R L. So now let's do dash, dash broadcast and we'll do dash dash private key. And we'll grab a private key from Anil and paste that in here and hit enter. Boom. And we see at the bottom on chain execution complete and successful. And we see we get some transactions here. We waited for receipts, et cetera.

So fantastic. So we learned how to actually deploy our smart contracts through the scripting command. Now, awesome job.

Now let's learn a little bit more about what actually just happened, right? Because right now sending transactions is still kind of this. Magic thing, right? So let's hide our terminal and let's go up to our explorer. Let's pull this out a little bit and let's go into here. Now, what's important to note is that there's actually a couple different folders in here.

Dry run is the folder whenever we don't have a blockchain running. Otherwise, this gets separated by chain id, and we'll talk about this a little bit later. But if we go into one of these, either dry run or or even just run latest, we'll see details about the transaction. We'll see a hash transaction type contract, name, address, blah, blah blah.

This right here, this transaction section is actually what is getting sent on the chain. When we do forge script or forge create, this is the transaction that we send to that R P C U out, right? This is the A P I data. If you're familiar with HTTPS posts, this is the data that we actually send. We send the type, which for now just everything is type two because we're in the merge.

Don't worry about type one for now. We have A from, which is of course the from address that we want to have. We have a gas here and this is the hex value of gas. Now, if we pull our terminal back up, we'll clear this out. I'm about to show you an amazing trick that's gonna make your life a lot easier.

Down the line, cast actually can convert between hex and numbers really easily, and caste comes built in with Foundry. If we do cast dash dash two base, paste our hex in here and write D e C for decimal. It'll convert this hex value to its decimal value, zero x 7 1 4 C two, whatever is just this number, and I use this cast two base all the time.

You can put some value in here and then what you want to convert it to, and it's a very easy way to see what some value is. There's some other stuff in CAST as well. If you do cast dash dash help, there's some other ways to convert different units to each other, like from way Spice 32 and some other stuff.

But two base is gonna be one that we're gonna use a lot. So we have the gas, we have the value with the transaction. Yes, since deploying a contract is just a transaction, we can add a value to it if we want. And our deploy script right in here, we would just do some brackets. We would say like value in like one Ether.

If we wanted to deploy this with one ether, we can't send value here because in Solidity you can't set the option value. If the construction is not payable, we'd have to make the structor payable, but we could send value just like any other transaction. There's this huge data piece here. This is actually the contract deployment code.

And the contract code. In here. We have the nuns, which is gonna be that number that's only used once. And then don't worry about access list for now. But this is all the transaction information. And then of course we have our rpc. Now what's not stored in here is, is a couple other pieces of the transaction.

Now, additionally, there are these VR and S values that account for the transaction signature. It's not getting saved here cuz it's technically part of this from, anyways, they're public values and these r, s and V allow our private key to sign the transaction. So what's really happening when we send this, the reason we need our private key is we need the private key to actually sign the transaction that we built.

And that's happening a little bit under the hood. So whenever we send a transaction, there is a signature happening. We are signing a transaction and then we are sending it. And that's important for later in the course. They don't save it here, but signing the transaction does happen when you sign a transaction.

It's very similar to doing that hex thing we showed you way, way at the beginning of the course with the blockchain. Only the private key can sign the transaction. This is how when we send our data to a node, it knows that it's able to execute it because it's signed by our private key. I'm not gonna go too deep into that right now.

This nun piece is a little bit important. Every single wallet has a counter of transactions, which is basically the nuns. Whenever you send a transaction, you give it ANU or this value, this number only used once to basically count your transactions. This is really good because if you want to replay transactions, you would just send the same transaction data with the same nuns.

For example, if we have a transaction that didn't go through, you'll see that this is in this run latest with the dry. If we run this again, if we hit up, you'll see that if we run our transaction again with our anvil deployed here, we'll actually deploy another transaction. If we go back to our broadcast folder, we see there's actually two runs and a new run.

Latest. If we go to our run latest now you'll see that the most, the latest run now has zero x one. So this increments, every single time we send a transaction, you're nuns increments every time you send a transaction. And again, contract deployments are transactions. Now, we went over a lot of stuff in here, but the most important takeaway I want you to have from this is any, anytime you change state on the blockchain, it does it in a transaction and the differentiator is going to be whatsoever in this data field.

This data field contains the OP codes to tell the blockchain, Hey, I'd like to create a new contract. We're not really gonna go too deep into what these OP codes are or this VM bike code. We'll briefly talk about op codes later in this course. But if you wanna really learn about op codes and assembly, we have another course on security coming out that will go over that.

But this is the most important thing to take away. When we're in remix and we're sending transactions with these buttons, we're doing the exact same thing. We're populating the data field of a transaction, but instead of the data being associated with creating a contract, the data is associated with sending a transaction.

All right, great. Now that we've actually deployed our contracts, though, we should learn how to interact with them in the same way that remix allows us to interact with them with our buttons here. Now there's two ways to actually interact with our contracts. One is gonna be doing what we did before with scripts, but the other way is actually gonna be doing directly from the command line.

So we're actually gonna learn the command line parts in this project and then we're gonna learn how to do scripts in a later project. So let's pull up our terminal here. And just to make sure that we have this deployed, let's hit up a couple times and we'll rerun this deploy script. Now in just a second, we're gonna learn how to actually interact with our contracts from the command line as well, similar to how Remix has all these buttons that we can press.

However, first, we're gonna make this a little bit better and we're gonna take a couple of different approaches to not having this in the command line. As you saw before, we could use Forge, create interactive, paste our private key in, and it wouldn't be in our command line. We actually can't use Interactive for when we're sending scripts at the moment.

I'm sure in the future they'll make it a little bit easier for us to do this, but right now we really don't want to have to do dash dash private key and paste our private key in Plain Tech. So what else can we do? What alternatives can do? We have? Now what I'm about to show you once again, only do this for your development environments.

Do not put a real private key in here. The reason I'm showing you this is because it is much quicker to test, however it's terrible to use in production. So this is cool for development purposes, this is not cool for actual production purposes, what we're gonna do is we're gonna create a new file called env.

And whenever you create a Dov, the first thing you should do is go to a get ignore file. Make sure that a dot env is in this get ignored. I'll explain what the doc get ignored does in the future, but for now, just have that be the first thing you do. In our Dov file, we can put in what's called environment variables.

These are variables that might be a little bit sensitive that we don't want to actually write in the command line or accidentally expose to the public. One of those, of course, is gonna be our private key. So let's go to Anvil. Scroll up, grab that private key copy and paste it in here. And we have this private key equals this.

Typically you'll also see RPC URL equals what's our anvil RPC URL's? This right here. So we'll do http slash slash paste that in there and great. Now that we have those in there, what we can do is now run source dot emv, which will add these environment variables into our shell here. And we can do echo private key like that.

And we'll see our private key actually show up like so. We can also do echo dollar sign RP C U R L, and we'll see our RPC Uur L actually show up like this. And then what we could do is we could go back to our forge script and instead of typing in our private key, we would just do dollar sign, private key and dollar sign rrp, C U R L.

So now our rrp C R L and our private key at least aren't being run in our command line so that it's not stored in our Shell's history. The issue of course is that, okay, well now we have it stored. In this env, anytime you have your keys stored in plain text, you should be afraid, you should be a little bit nervous.

So we can actually take one more step to make this even more secure. And this is gonna be one of the steps that I recommend that you take when you're actually working with production code. You definitely do not want to launch production code with the Dov file, and I'm gonna summarize all this very soon.

Just stick with me. I promise this is a little bit boring, but it's incredibly, incredibly important that you get this right and I'm gonna try to prevent you from getting wrecked. Now, Foundry is a tool that is constantly being improved and updated and there's an issue in the Foundry repo right now called Improve Wallet Management, us using Key Store, I would love a way for you to actually encrypt your private keys so that none of you accidentally push a private key up to GitHub or expose a private key that it's in plain text.

If you run Forge Script dash dash help and you scroll up, you get this wallet options section where you can actually pass the path to an encrypted key store file and a password. A key store is a file that has your private key but encrypted by a password. Instead of having your private key in plain text, you would have it encrypted and you would just need the password to decrypt.

That is a much safer way to deploy your contracts. I've added some context and another issue on Foundry as well, and if you all could come in here and give this a thumbs up, that would be fantastic. A way to encrypt your private key into a key store file natively doesn't exist in Foundry yet, but I've put out a bounty for someone to actually implement this, so be sure to just check the GitHub repo associated with this course to check to see whether this feature is implemented.

So what I'm really trying to get at is for the moment, a private key in our dot EMV file is cool so long as we don't expose the dot EMV file. But for real money, you're not gonna do that. We're not gonna do that. Okay, for real money, we're gonna use the dashes interactive to paste our private key, or we're gonna use a key store file with a password.

Once Foundry adds that. There are some tools like DAP tools e-sign that you could optionally download if you want to deploy and interact with wallet that have real money in them. And it does have this import keyword where you can import your private key into a key store file and then you would just obviously encrypt that with a password.

So for the moment, this is your setup, but in the future this is gonna be your setup. Okay, this is cool now, but not in the future. And additionally, if you go to the Foundry full course F 23, you go to discussions and this will also be in, and this will also be somewhere on this site. At some point you'll see this, the dot e pledge, which has a whole bunch of information about working with DOT EMV files and keeping your private keys safer.

For the rest of this course, we are gonna be working with this EV syntax cuz it is easier. However, I'm really hoping that Foundry in the future adds this key store encryption by default so that we don't accidentally expose our private keys. And I'm not doing this to scare you, but I'm doing this to impress upon you the importance of making sure you keep that private key and that pneumonic safe.

The other reason that we're okay to put our private key in our dot b file is that you have already promised me that you're only going to work with a development private key or a private key that you're not gonna add any real money into. So if you expose it, it'll be fine, but you still wanna practice not exposing it.

So please take, take some time to read this and then if you do agree to everything, just say I will be safe as a comment on this dot v pledge. So I'm gonna read it out and it's important for you to understand this moving forward. So it's gonna be a little dry here, but I am just gonna read it. I solemnly swear that I will never place a private key or secret phrase or pneumonic in a dotting V file that is associated with real funds.

I will only place private keys in a Dotting V file that have only tested ETH link or other cryptocurrencies. When I'm testing and developing, I will use a different wallet than the one associated with my real funds. I'm aware that if I forget a dot, get ignore and push my key slash phrase to GitHub even for a split second, or show my key slash phrase to the internet for a split second.

It should be considered compromised and I should move all my funds immediately. This is a really important line. Even if you show your private key to anywhere on the internet for even a split second, it is considered compromised and you should move all your funds immediately. If I'm unsure if my account has real funds in it, I will assume it has real funds in it.

If I assume it has real funds in it, I will not use it for developing purposes. I'm aware that even in my meta mask, if I hit create account or ad account on my meta mask or other ETH wallet, I will get a new private key, but it will share the same secret phrase slash pneumonic of the other accounts generated in that meta mask.

And these are some additions that I made from the last course. For this course, I will only use funds associated with my brand new narrow before used meta mask or other wallet. And again, most browsers, you can choose a different profile and install a meta mask on a different profile and use that meta mask for this development purpose.

If I must use a private key associated with real funds in the future until I'm 100% sure what I am doing, I will always either use encryption methods like the DAP tools key store file. I'm not gonna show you how to work with this because some of the installs might be a little bit tricky, but they have a way to actually import and encrypt private keys to a key store file.

Use the Foundry's built in key store crater, which isn't implemented yet. Anybody here who is a rust developer or knows some rust or wants to participate, definitely be sure to check out this issue, which is on Foundry. And I would love somebody to take a crack at this, or if you must use the command line as a way to pass your private keys and then delete the command line history immediately afterwards.

If I never actually deploy anything to May, not myself or work with a private key with real funds, I do not need to be concerned. For any of you who are getting a little bit nervous about this, just remember, if you don't work with any real money, you don't have to worry about this. Okay? So a lot of you people who are, who are newer here, who are going to be going through this course, we're not gonna use any real funds.

So you won't have to be worried about this. For those of you who are doing the extra credit, which is with real funds, you will need to keep this in mind moving forward. And I would try to load your real meta mask with real money, with small amounts so that if it all gets stolen, you won't lose sleep at night.

Okay, great. And I'm telling you all this to arm you with this knowledge that you can be more secure moving forward. Take a look at this, read this, internalize it, and if you wanna copy paste this on Twitter in a huge tweet thread, shout this from the rooftops, put this in an article, make a TikTok with this.mv pledge.

Have an absolute blast. The more people who know about this and the more people who understand this, the better. Thank you for coming to my TED Talk. Right? So I know that was a lot of private key information and there's gonna be more soon too. So, but the reason I'm harping on this is because I really, really, really, really, really wanna make sure that all of you don't accidentally mess this up since you were the developers.

You are the gonna be the ones responsible for dealing with all this, and I wanna make sure that you get it right.

One final option that we can do as well, which again saves us from having to have our private key in plain text is gonna be using something like third web deploy. So we actually have Kira from the third web team to explain third web deploy. Now she is going to use the MPX command, which comes with node js and MPM installation, which we haven't gone over in this course.

But we will leave some links in the GitHub repo associated with this course to download that if you're interested. So take it away, Kira. In this video we are going to learn how to easily deploy any contract to any E V M chain using one simple command. This command requires no setup, hard coded private keys, RPC URLs or scripting required.

Third web handles all of the complexities for you because there's no need to export your private key. This is much more secure. The deployment is done through the dashboard UI using your own wallet. So with that said, let's jump into deploying our contracts. So let's say we have coined this repo or written our own contract.

This can obviously be any contract at all, but I have gone ahead and cloned this simple storage contracts just to demonstrate how we can deploy our contract, as you can see in the sidebar. Um, so yes, I've opened this up in my code editor in the sidebar. There is no NV file. I haven't set up an RRP C R l, I haven't exported my private key.

There is no setup needed here. I want to reiterate this. You do not need to pre-install anything. There are no dependencies. So to deploy our contract, we are going to run the simple command N P X third Web deploy. So what this done is detected our project type, which is Foundry and also could be hard hat or Brownie.

And then it has compiled our contracts and then it's allowing me to select which contract to deploy. So I'm going to select the simple storage contract. So this is now uploading the contract metadata to I P F S, and it means that our contract is going to be automatically verified. If you would like more details on how this actually works, then please go ahead and visit the third web developer docs, which you can see here, which is@portal.thirdweb.com slash deploy.

And you can read all about how this works. So what's happened now is that a browser tab has popped up in my browser. Um, and this allows me to deploy my contract from a frontend. So if I had construct prams, which I do not, in this case there are no constructive parameters, um, then I would be able to fill these out from the frontend right here.

Next, what we need to do is select the chain that we want to deploy to you. As I said, this can be any E V M network. So we can select ones that are popular, such as base, or we could add a custom network if this is not already in the list. But I'm going to select Mumbai when I click Deploy. Now this is gonna trigger two transactions.

The first one is gonna be the transaction to deploy my contract. The second one is going to be a message which I will sign. And this is a gas list step. And this just adds your contract to your dashboard so that you have a user interface in which to interact with this contract. A little bit like remix.

So I'm gonna click this button. I'm just gonna sign these two transactions and then I will be right back.

As you can see, our contract has now been successfully deployed. How easy was that? Awesome. So you can see the contract address here, which we can copy if we needed to use that later. I'm just gonna give you a very quick overview of the dashboard. So there's this build tab here, which just enables you to build your contract into a front end with easy to use hooks for different languages, uh, hooks and functions for different languages.

Uh, the explore tab allows you to see all the read and write functions on your contract. So you could add a person and then input the parameters here. You can store list the people name to favorite number and retrieve all of the functions that we wrote in the contract. You can see and interact with.

Here you can see the events on the contract and the source code. As you can see, this was a super simple, easy and safe way to deploy your contracts using third web. Third Web is the fastest way to build Web three apps. We can have SDKs in multiple languages. We have prebuilt contracts. We have a Solidity, s d k, an infrastructure for your Web three development needs.

For more information, please head to third web.com or visit our documentation. And if you have any questions, please head to our Discord cord.

Whew. In any case, let's go ahead and let's learn how to interact with these contracts from the command line first. And in later courses we'll learn how to do it from scripts. So we have our anvil running and we've deployed our contract using our Deploy, using at least something marginally better using private key as an environment variable as opposed to just pasting it right in here.

So what we can do now is we can take this contract address and we can actually start to interact with it. Foundry has another tool built in called Cast, and if you type cast dash help, you'll see we get a whole bunch of commands to work with cast. One of the commands that we can work with is going to be send, which is to sign and publish a transaction.

So what we can do is we can do cast send help, we can see the help of send and we can see the arguments it takes is gonna be two, the signature and the arguments. So on Remix for example, we have our simple storage contract and we deployed it. If we wanted to call our store function and send the transaction, we would just add some numbers in here and then click store like this, right?

If we want to call store from the command line, we could do cast send the address we want to do. The signature, which for now just know is the, is the function and the input types it needs. So we could call store with parenthesis U two fifty six cuz we're calling the function store, which takes a U 2 56 as input parameter.

And then the arguments or the values we wanna pass to our store function. And we'll go ahead and hit enter. Of course this fails because we need to add our private key and RRP C R L. So we'll hit up, we'll do R P C U R L, we'll do dollar sign RP C U R L and then we'll do dash dash private key and then private key like that.

And now you'll see we'll get all of this data about our transaction back. We'll get the block hash blocked number. Contract address is blank probably cuz it's a local chain logs we can learn, we'll learn about logs later, the transaction hash, et cetera. Now in order to read this we're gonna use cast call, which is going to read off the blockchain.

And if we do cast call dash dash help and we'll gonna scroll up a little bit. We'll see Call takes two signature and arguments. Exact same as send, but the difference is it's like call is like doing one of these blue buttons, it's calling as opposed to sending a transaction. It's just doing a view function, not actually sending a transaction.

So we'll do ca call, we'll paste the contract address, we'll call retrieve R E T R I E V E R E T R I E V. Oh did I spell retrieve wrong? I dunno. I guess we'll find out. No input parameters here and no arguments. We can just hit enter and we'll see We get the hex value back. This is where I said you're gonna be converting stuff from hex back and forth a lot.

Then we can do cast dash dash two base, paste the hex and say decimal. And we can see we get back 1, 2, 3, which is exactly what we've stored on chain. So if we hit up a couple times back to our cast send transaction, our cast send command and we change one to three to 7, 7 7, we hit enter, we'll send that transaction.

Now if we hit up three times, two or three times, we'll call cast, call retrieve now and we should see the new number, which we get back as a hex. And then we'll do cast dash dash two base, paste it in deck and we do indeed see 7 77 return to us. Awesome. So now we know how to actually interact with our contracts from the command line.

And this is gonna be the same way we can actually interact with our contracts on an actual test net or on an actual main net.

All right, so now you might be asking, okay Patrick, what does this look like on a testnet or a live network? So let's go ahead, let's go to our dot EMV file and let's update this so that it's a dot EMV file for an actual testnet. So the first thing is we're gonna need an R P C R L for an actual testnet for an actual network.

And this is where our meta masks actually have inferior connections built in. Remember before we went to our settings networks, there a main net we saw, oh, we saw we have this inferior connection. We can't use this one because this one's designed specifically for our meta masks. So we're gonna have to get our own R P C R L for an actual testnet.

Well, one of the things we could do is we could run our own blockchain node, but a lot of people don't wanna do that. So what a lot of people do is use something called a node as a service. To do this, what I'm gonna recommend you do is actually come over to the foundry, full course repo, scroll down, and there's gonna be a section called Deploying to a Testnet or a main net.

If we click this link, we'll actually go ahead and we'll get sent to the Alchemy platform where we're gonna sign up for a free notice as of service that we can actually send transactions to. And we're gonna go ahead and sign up for their platform. You can sign up with Google, sign up with sso, whatever you wanna do.

I'm gonna go ahead, sign in with Google, I'm indeed human, and we're gonna come to their user interface that looks something like this. We're gonna deploy this to seia, but remember, go to the recommended testnet section of this course. So what we're gonna do now that we're in here is we're gonna go ahead and create a new app, and you can name it whatever you want.

I'm gonna call it Chipotle testing. I'm just gonna copy this for our description. This is on the Ethereum chain, but on Ethereum seia, we're not gonna do any advanced features. We'll go ahead to Create app. And now we have this Ethereum selio app where we can view details, we can see how often we're calling this and we can see different details about our node.

And if we hit view key, we see we have this HTTPS endpoint, and this is gonna be the exact same thing as that anvil or ganache or meta mask endpoint that we saw. And we're gonna go ahead and copy this back in our B N V. What we could do is we C, we can create a new RPC URL called seia rpc URL equals, and we'll paste that in here.

Now we have an RPC that points to an actual testnet with our private key. We can't use this as our private key because this is an anvil private key and it doesn't have any real money in it and it doesn't have any testnet ethernet. But what we can do is instead we can use our, one of our private keys in our meta mask.

So if we switch back to seia in our meta mask, we can pick one of our accounts that actually has some money in it. I'm gonna pick account number one. We'll hit the three little dots. Account details, export private key. And remember, it's okay for me to show the private key here because this is just a dummy private key, but I'll add my password in.

And remember, I'm never gonna actually do any real money in with this. And I'll copy this done and paste this in here. And maybe I'll, maybe I'll comment this line out in dot inv file this hashtag or this pound sign is what the comment is. But maybe we'll do a new private key equals, and I'll paste this in here.

And now I have the private key for meta mask. I have the R PCR L. Those are all I need to actually deploy a transaction. So what I can do now, pull my terminal back up. So we're gonna run this command to actually deploy this to a real testnet from our foundry, using Alchemy as our node as a service. And you'll see in the user interface of Alchemy, you'll see a transaction actually come through our node.

This is us sending a transaction to a real node and we'll be able to see the stats here on our Alchemy dashboard. So let's go ahead, let's do this again. So first we're gonna need to run Source Dov to make sure all of our dot AMV stuff is loaded. Then we're gonna run Forge Script Script deploy simple storage dot s.

So, and I'm hitting tab to auto complete here. Dash RPC url seia RPC URL with the little dollar sign dash dash private key dollar sign, private key dash dash broadcast. If you don't add the dash broadcast, it won't actually send it. It'll simulate sending it. Now if I hit enter, we'll see it compile. And now we're running this script deploy Simple Storage S Salt, which actually deploys it.

And we'll see We went ahead and deployed our contract, simple Storage on the Saia chain. We see all these details about it. It's sending the transaction right now, it's storing the latest run under the broadcast folder under its chain ID in here in this run. Latest Jason. And after a brief delay, we'll see it went through.

And what we can do is we can grab this hash, go over to seia dot ether scan.io, paste that hash in here and we'll see. We actually successfully sent a transaction and if we click on our contract after we, we just created, we'll see. We actually just created this contract on a real testnet. If we go back to our Alchemy dashboard and we hit refresh, we'll see we actually sent, we sent some requests.

We scrolled down, we can see some of the different requests we sent ETH Send Raw Transaction was the request that we sent to actually send our transaction to the blockchain. But we also got some stuff about the chain ID, fee, history, et cetera.

One thing that you'll notice though, when looking at this on Ether scan is that the contract, oof, it's just a whole bunch of bite code here, right? This isn't very readable. What we can do is we can actually verify this contract, and now I'm gonna show you the hard way first and I'm gonna teach you the easier way later.

But you can manually verify a contract on Ether Scan or other Block Explorers by selecting Verify going to Solidity. This is a single file contract, so we're gonna do single file. I know that we're on 0.8 point 19, and our open source license is m i t. We'll hit continue. We'll go back to our simple storage dot.

So, and we'll copy the whole contract. Scroll down, we'll hit paste. Optimization is gonna be yes. There's no constructor orgs, no contract library addresses, no miss settings. I'm not a robot. And we hit verify and public. Sometimes this can be a little bit tricky to get right and we're gonna work with programmatic verification pretty soon.

That makes it a lot easier. But if we did it correctly, what'll happen then is if we click on our contract address here and we go to contract and we scroll down, we can actually see our contract right in Ether scan. This will also give access to these read and write contract buttons, which we can see and how looks really similar to what's on remix.

And we can actually interact with our contract right from Ether Scan or another block explorer. Like I said, that's the manual way to verify your contracts and you can run into a lot of issues doing that. So I don't recommend doing it. I recommend doing the programmatic way, which I'm gonna teach you very soon.

All right, so now we're just about done with our very basic project here, which is fantastic. We've learned a ton already, but there's a couple things we wanna keep in mind here moving forward. And one of those things is when it comes to formatting, so we are using the VS code auto formatter to auto formatter code.

But if somebody else comes, and I'm gonna actually save without formatting. If somebody else comes to our code base, we're going to want to have them format it the exact same way that we format it. So what we can do is we can use the Forge format command, which if we run it, you see favorite number actually went ahead and formatted.

So I'm gonna save without formatting again, run Forge format, and it's gonna auto format our code here. So this is a command that will automatically format all of our Solidity code. Awesome. And additionally, for every single repo you ever work with, you always wanna make a read me MD file. So right click new file, read me, md.

I actually already made one over here and this is where you're gonna put information about your project. Here I put some notes about the private key usage, which I'm just gonna delete for now. Readme files are generally where you put information about your project, instructions to work with it, places to contact you, really any information that another open source developer should know when they want to interact with your project.

Because we are going to push this up to GitHub as well. We're not gonna push this up to our GitHub because it's kind of easy, but in the next project we're actually gonna push the code up to GitHub and I'm gonna teach you how to do that. Read me MDs are this markdown syntax. Remember how we were talking about answering questions or asking questions using markdown?

Synex? Well, this is gonna be the exact same if I do a hashtag or pound sign like this and I say hello and then some text down here. And if I had save, what I can do is I can actually preview this markdown. So in my extensions over here, we're gonna look for a markdown extension. I actually already have one marked down all in one or markdown preview or whatever you want to install.

And we can do open up our command pallet with command shift P or view command pallet. We can do markdown preview, open preview like this, and we can see what this looks like as if it was on a GitHub repo. We can see hello is big. We can see our hex down here is small. And if I were to do like some back ticks like this, I could say like code here, save that.

Look at our preview again. We could see this is formatted now as code. You can also do command shift V to automatically go to preview mode, or it might be control shift V for Windows and Lennox users. There's a lot of different ways to go preview your markdown and remember if formatting your, your README is difficult, usually AI is do a pretty good job at formatting your markdown for you if you just ask them politely.

Now, alchemy has a couple of other really cool features about it, especially when it comes to learning more about what's actually happening with our transactions. Whenever we send a transaction to a blockchain node, it actually enters something called the Mem Pool. It's basically the place where transactions go before they get actually sent.

And the Alchemy Dashboard is a great place to actually view those transactions and see their status. So I'm gonna go ahead and turn it over to Vito from the Alchemy team who's gonna explain more about what Alchemy has to offer, some of the other cool parts of Alchemy and more Zika, stark Zika, narc, Zika proof Zika.

Oh, what? Oh, I'm, I'm sorry. I'm gm. GM everyone, and welcome this brand new video. I'm Vito, and today I'm gonna walk to, this is not my channel, this is not even a's channel where the that. Oh my God. This is the latest Patrick Collins video about Foundry that everyone must watch. Uh, well welcome everyone. I am Vito and thank you Patrick for hosting Austin this Cam.

I guess my job today is to tell you a bit more about what Alchemy is, what we do, how we do it, and how you can get the most out of it. Well, before getting started, let me quickly, quickly introduce myself. I am Vito lead developer experience at Alchemy Block and developer and web free content creator on a mission to onboard 1 million developers onto web free.

Of course, today we're not here to talk about me, but we are here to talk about how Alchemy can help your decentralized applications scale to billions of users. So to get started, what is Alchemy? Well Alchemy is a node provider and web three developer tooling platform, borrowing hundreds of thousands of Web three and web chew applications out there.

Things like Open C Nifty Gateway, but also Zero X Argent Dapper, but as well as Big Ma massive Web two companies such as Adobe, Shopify, and Stripe. The question here probably is, why do these companies use us? Why alchemy? Well, that's the question which I to answer here briefly. The thing is, when you need to develop an application, chances are you won't run the servers.

You'll code, your code will run on, and most likely you won't even develop the deployment and integration pipelines for it. To do this, you will use services such as aws, Azure, Google Cloud. Well, alchemy does exactly this, but for web three, you can see it as the AWS of Web three with APIs, SDKs, libraries that will simply make your developer experience better.

But how do we do that? Well, we do it in mainly freeways. The first one is the supernode, a blockchain proprietary engine that hacks as a load balancer on top of your node and make sure you'll always get the latest available data from the blockchain. On top of the supernode, we built the announced APIs.

The announced APIs are a set of APIs that will allow you to pull data from the blockchain with ease. Here, you can see how we envision this with the alchemy Supernode at the center as the core infrastructure powering its ecosystem all around, such as our announced APIs, but also our monitoring tools, and of course supporting all the chains that we support.

To date, I, we'll get back to it in a few seconds, but the question is, of course, how do you get started? Well, the first thing that we're gonna do is navigate an on alchemy.com and we are gonna create a new account. Creating an account on alchemy.com is completely free. And actually cool thing is that you'll be able to scale your application using our premium plan because it's quite generous.

So don't be concerned about paying anything. Everything you'll see today and probably in Patrick's course is completely free to use. Let's go back at creating a new account. In this case, I will just sign in. Of course, I already have an account, so I'll click on sign in, and as soon as we'll open this window, you will see all of your applications.

Of course, if this is the first time you log in on ami, you will only see the demo application. But no worries. We're gonna learn how to create a new application right now. Super important. Click on Create Up and let's give it a name. So we're gonna call it Patrick is Cool, and I'm gonna use Underscores just because of personal preference.

Feel free to use spaces or name your application the way you want. We're gonna also give a description, this is optional, you don't have to, but I really think that Patrick is cool. And then we're gonna select a chain. As we said before, we support the majority of E V M compatible chains. As you can see here, we support Ethereum, polygon, pos, also zk, E V M, as well as optimism and a Star.

And on top of that, we support Solana and non E V M chain. Here you can select your chain and here you can select your network. In this case, we will go for a here main net, but feel free to try out all the other networks and testnet. Of course, we have one for all of these, uh, main net that we support. So we'll create the new app, and once the app is being created, I can just go and search for my name.

So Patrick is cool and click on my application. Here we go. Once the application has opened, you will be able to see the application specific dashboard, and this is a big changer, big game changer for all decentralized application developers because this gives you full visibility over your application and infrastructure health.

You'll be able to see things such as latency, compute units, that that is how many RPC calls are eating your no, as well as the success rate of your calls, the throughput, and so on and so forth. Super useful when you need to debug. So let's say that here you see 98% of success rate. You'll be able to understand why your transactions are not going through well.

Let's actually do an example. Let me go back and find an application that has actual calls. So here we go. I just navigated to this demo key application that, as you can see, has a ton of calls, but also as you can see, it has a success rate of 98.5%. That means that 1.5% of our calls are failing to go through.

But how do you understand that? How do you debug this? Well, if you are not using alchemy, chances are that to debug your RPC calls, you will have to spin up your own nodes or be run a local node. And in that case, you'll be able to see the logs coming from the node. Otherwise, there is no possibility to see the logs coming from the node.

This is not something you will see on it. Scan using Alchemy, you'll be able to see all the issues related to your calls as well as the known issues related to your calls in this dashboard. So let's say that we have 1.5% of course not going through. What we can do is go on the recent embodied request tab, and here all the requests that didn't go through will be listed as well as the reason why they didn't go through.

For example, here we have an ETH sand road transaction that didn't go through because there weren't sufficient gas funds. Well, let's take another one here. Execution reverted, for example, means that probably there is a problem with the smart contract. So as you can see the bugging as well as you can see other information on the left hand side.

But I will go back at this in a few seconds because I wanna show you another tool that is even more precise to see the information about the actual request. Here you'll be able to debug your PC calls with super ease. On top of that, as I was saying, we have other tools to help you debug and get more visibility on your application.

So if you click on the menu and here, what we can do is navigate on the manpo. And the manpo is actually just like the manpo that you might think about when you're thinking about Ethereum. So it is a place where all of your transactions are, and you can see the status of the transaction, the information about the transaction, what if the transaction is going through, if didn't go through, if it's spending for hours, if it got combined, how much it costs, and so on and so forth.

So let's say we, we just navigated on our Manpo watcher and here we have all the transactions going through on our applications here. I have a bunch of applications, so that's why I'm seeing a lot of transactions here. On the top, you can see all the mine transactions. So the transactions that already went through like me mined or validated pending transactions.

Um, let me just select one application because of course otherwise it's gonna take a long time. Here you have all the pending transactions that mean all the transactions that are waiting to be mined or validated. And here you have dropped and dropped and replaced. So transactions that have been dropped, canceled, or replaced by other transactions with the same non same call data and the same gas fees or dropped means there are transactions that have been canceled and won't be validated or mined.

But on top of that, you can get even more information on these calls on these transactions. If a click here on the hash, this one bring me on, ethos account will bring me on the mepo transaction summary page. And here I can see all the information about the transaction. I can see how much gas it cost, uh, which network it was on, of course, uh, the transaction hash as well as the from address.

So who signed the transaction and who's sending the transaction to, as well as the value inside the transaction, the time it took to get sent and the time it took to get, um, validated. This is more clear on validated transactions where everything is ready be filled out. So I can go back in my mind page.

So here we go. I can select one and as you can see here, I have all the information. So I have max fee per gas, I have the transaction type. So this was using the EAP 1559 and a bunch of other information about the transaction itself. Super helpful to debug and get full visibility over it. All right, now that we've quickly gone through our Alchemy works, what it is and how its features can help your developer experience become way better and develop faster.

I don't wanna steal much more of your time while learning during this amazing course. So what I'm gonna do is leave you with a couple of resources that will make your developer experience with Alchemy even better. The first one is our documentation. So our documentation has everything you need to get started using our APIs, sdk, libraries, and also tools that we didn't have the time to go through today, such as our generalized custom graph q web books that allow you to pull data real time from the blockchain through GraphQL queries.

On top of that, you will also have tutorials and guides to build your applications and compliment the knowledge you are creating during this course. Of course, follow us on Twitter at Alchemy Platform or Alchemy Learn. And if you wanna shoot me a message, tell me the amazing things that you're building while learning from the Patricks course.

Please shoot it at Beto stock on Twitter. Thank you so much, Patrick once again for us. And thank everyone for speaking with us for 12 minutes. It's been a pleasure. See you around and happy building.

But for this one, you should be incredibly proud of yourself. You just did an entire project in Foundry. Huge congratulations. So let's do a quick recap of everything we learned and then we'll move to the next project. And yes, we are gonna push our next project up to GitHub into a lot more Advanced Foundry and a lot more advanced tooling here.

So let's do a quick recap of what we learned so far. Well, first we learned how to create new Foundry projects with Forge Dash, dash and Knit, which will give us all of these folders on the left hand side here to actually start working with our projects in a more professional environment. We learned about some of the basic Foundry commands, such as Cast, anvil and Forge.

Forge is used for compiling and interacting with our contracts. Cast is used for interacting with contracts that have already been deployed, and Anvil is used to deploy a local blockchain similar to Ganache, which is another local blockchain that we worked with. We learned that whenever we send a transaction on our meta mask, we're actually making an HTTP post request to this R P C U rl.

And we can also take an RRP C R L from a node as a service like Alchemy and use it to actually send transactions from our Foundry projects. We learned both how to actually compile our code in Foundry and then also write a script to deploy it directly in Solidity. We've learned some very basic information about keeping our private keys safe.

For the rest of the course, we're gonna be working with a Dov file, but when we're working with real money, we might not want to actually have our private key in plain text ever. So we learned how to deploy our contracts to a blockchain programmatically, and then we learned how to interact with them using the cast keyword and send to send transactions and then cast call to read from those contracts.

We've learned how to auto format our contracts with Forge format and we learned the manual way to actually verify one of our contracts on the blockchain. Whew, we learned a lot here, so be absolutely sure to take a minute to go on a walk, go get a cup of coffee, go grab some ice cream, go post on Twitter that you've taken an extra step in your Web three developer journey.

You should be incredibly proud of yourself for getting this far. Like I said earlier, installing some of these tools like VS. Code and Foundry, can be one of the hardest parts of this entire course. So if you're in here, if you're working with me, you're doing fantastic. We've got a lot more to go, but just by getting this far, you've done incredibly well.

So with that being said, take that break. Remember, breaks are good for your brain. Take that break and we'll see you in the next one.

