{
  "courseId": "aca7cb85-ea1f-4fd3-9bc6-fc39f4609a0a",
  "title": "Security and Auditing",
  "slug": "security",
  "folderName": "security",
  "lastUpdated": "Mon Dec 11 2023 12:04:20 GMT-0500 (Eastern Standard Time)",
  "trailerUrl": "",
  "previewImg": "https://res.cloudinary.com/droqoz7lg/image/upload/f_auto,q_auto/v1/updraft/courses/rdmkzepzrx9b3sf0t3ko",
  "description": "Start your career as a smart contract auditor! Learn the best practices for writing secure and optimized smart contracts. Explore techniques like fuzzing, invariant testing, formal verification, and more to identify bugs and protect web3 protocols.",
  "path": "content/learning-paths/foundations.json",
  "number": 0,
  "overview": {
    "learnings": "Smart contracts invariant and fuzz testing, Stateless And Stateful Fuzzing Practice, Upgreadable smart contracts, smart contracts auditing, Aderyn, Slither, Manual review, Smart contracts testing ",
    "preRequisites": [
      "Blockchain Basics",
      "Solidity fundamentals",
      "Foundry fundamentals",
      "Advanced Foundry"
    ]
  },
  "duration": 24,
  "authors": [
    {
      "author": "content/authors/patrick-collins.json"
    },
    {
      "author": "content/authors/tincho-abbate.json"
    },
    {
      "author": "content/authors/josselin-feist.json"
    },
    {
      "author": "content/authors/owen-thurm.json"
    },
    {
      "author": "content/authors/andy-li.json"
    },
    {
      "author": "content/authors/johnny-time.json"
    },
    {
      "author": "content/authors/pashov.json"
    },
    {
      "author": "content/authors/juliette-chevalier.json"
    },
    {
      "author": "content/authors/alex-roan.json"
    }
  ],
  "sections": [
    {
      "sectionId": "bc71e716-ae9a-45d5-8f06-75bd621b4e98",
      "number": 0,
      "title": "Course Introduction",
      "slug": "smart-contract-security-introduction",
      "folderName": "0-introduction",
      "lessons": [
        {
          "lessonId": "5d21322f-ee36-4445-868f-cd39113e7e9b",
          "number": 1,
          "title": "Trailer",
          "slug": "trailer",
          "folderName": "1-trailer",
          "description": "",
          "duration": 1,
          "videoUrl": "yq3a3-w8oAI",
          "rawMarkdownUrl": "/routes/security/0-introduction/1-trailer/+page.md",
          "markdownContent": "---\ntitle: Security Course Trailer\n---\n\n_Follow along with this video_\n\n\n\n---\n\n---\n\n## Ultimate Smart Contract Security, Assembly, and DeFi Curriculum\n\n### Introduction\n\n**Welcome to the ultimate Smart Contract Security, Assembly, and DeFi Curriculum.** This course is designed to provide the most advanced and comprehensive training in EVM assembly, security auditing, and DeFi (Decentralized Finance).\n\n### Course Overview\n\n- **Target Audience:** This course is tailored for individuals seeking deep insights and extensive knowledge in smart contract security, assembly language in EVM (Ethereum Virtual Machine), and decentralized finance applications.\n- **Course Structure:** The curriculum is structured to cover the intricacies of security auditing, the fundamentals and advanced concepts of EVM assembly, and critical aspects of DeFi.\n\n### Objectives\n\n1. **Deep Understanding of Smart Contract Security:** Gain an in-depth knowledge of the security aspects vital for smart contracts in the blockchain ecosystem.\n2. **Proficiency in EVM Assembly:** Develop a solid understanding and hands-on experience with EVM assembly language, crucial for advanced blockchain development.\n3. **Mastery of DeFi Concepts:** Explore and master the concepts and applications of decentralized finance, an emerging and significant sector in the blockchain world.\n\n### Expectations\n\n- **Commitment and Readiness:** The course demands a high level of commitment and is intended for individuals who are ready to dive deep into the complex world of blockchain technology.\n- **Advanced Level:** This is not an introductory course. It is expected that participants already have a foundational understanding of blockchain and programming concepts.\n\n---\n\n**Are you ready to embark on this journey and expand your knowledge in smart contract security, EVM assembly, and DeFi?** Let's get started! üöÄ\n\n---\n",
          "updates": []
        },
        {
          "lessonId": "f7a230be-cc9c-48d4-ba18-bc5b228fb249",
          "number": 2,
          "title": "Welcome to smart contracts security",
          "slug": "welcome-smart-contracts-security",
          "folderName": "2-welcome",
          "description": "Explore the future of smart contract security in this course. Learn from experts and learn advanced smart contract auditing and research techniques.",
          "duration": 5,
          "videoUrl": "kJW7TAzyg98",
          "rawMarkdownUrl": "/routes/security/0-introduction/2-welcome/+page.md",
          "markdownContent": "---\ntitle: Welcome to the ultimate Solidity Course\n---\n\n_Follow along with this video_\n\n---\n\n## The Future of Web3: A focus on Security\n\nWelcome to the future of Web3 security; welcome to what is possibly the most comprehensive course on this subject ever created! As smart contract developers continue to bloom, it becomes imperative to ensure that the security scene keeps up. That‚Äôs the core focus of this guide - to level up the game and ensure a safer environment in the Web3 space.\n\n> _\"Security is one of the most important things to unlocking the future of Web3.\"_\n\nWith multiple detailed courses delivered in the past, dedicated to helping novice and intermediate smart contract developers enhance their skills. The accompanying study materials have garnered over 5.5 million views, making them the most-watched smart contract development courses on the planet. Thousands of budding developers have thus started their Web3 journey, equipped with the right knowledge and skills. They are now activated and productive developers in the Web3 space.\n\nThis guide, however, is not for the newcomers. It's an advanced course aimed at those familiar with smart contracts and comfortable with terms like _storage_, _self-destruct_, _fallback functions_, and _ERC20s_. A refresher will be offered at the beginning, but the primary focus will be to provide learners with intensive training in smart contract auditing and research.\n\n## Expert Opinions Matter\n\nIt's always enriching to learn from the best, and this guide takes care of that too. Featuring guest lecturers who are renowned experts in smart contract development:\n\n1. Josselin from Trail of Bits\n2. Owen from Guardian Audience\n3. Andy from Sigma Prime\n4. Johnny Time from Gingersec\n5. Pashov, legendary security researcher.\n6. Hans, one of the top competitive auditors.\n7. Tincho, the former lead auditor at Openzeppelin.\n\nWith these experts by your side, not only will you gain in-depth insights, but also get to explore extensive and carefully curated code samples. A special shout-out to Tincho, who has been actively supporting the development and auditing of the codes that will be discussed in detail.\n\n## Mastering The Skills: Developer to Researcher\n\nPeople planning to take up this course should have a basic understanding of blockchain basics, solidity fundamentals, and working with a smart contract framework such as Hardhat or Foundry. We will primarily focus on Foundry in this guide, but the skills learned can easily be transferred to other frameworks as well.\n\nThe course is not just for auditors; it is also aimed at training security researchers. Because who better to explore and learn about new attacks and analyze possible advances in smart contract technologies than a researcher?\n\nThe [GitHub repo](https://github.com/Cyfrin/security-and-auditing-full-course-s23) associated with the course offers a detailed curriculum and additional resources. If you are already familiar with certain sections, feel free to skip directly to the ones that you need help with or wish to learn more about.\n\n## A Peek into the Future\n\nWe want you to learn effectively, and that's where Cyfrin Updraft comes into play. It's a tool developed to HyperCharge your learning experience and help you grasp things faster. It‚Äôs free to sign up for those interested.\n\nYou are perfectly up to speed with the prerequisites if you have already taken the Foundry full course. Access more resources to get up to speed in the GitHub repo associated with the post.\n\n## About the Author\n\nMy name is Patrick Collins, and I am a smart contract developer, educator, security researcher, co-founder of Cyfrin Audits. As an absolute lover of Web3 and smart contract development, I believe that the ability to do fantastic things rests within this sphere. I delight in fueling driven individuals with the knowledge to become productive and start doing amazing things.\n\nArmed with unique insights from top competitive auditors like Hans, independent auditors like Pashov, and seasoned security veterans like Tincho, this blog endeavors to jump-start your security and auditing career. It encapsulates everything learned so far and aims to equip you with the right knowledge to become a positive force in the smart contract security auditing and safety space.\n\nLet's get Froggy. üê∏\n",
          "updates": []
        },
        {
          "lessonId": "1e19c090-66e6-41ac-a4af-804f32a4c0ff",
          "number": 3,
          "title": "Prerequisites",
          "slug": "prerequisites",
          "folderName": "3-prerequisites",
          "description": "Find out what prerequisites are required for this course to ensure you're well-prepared for the upcoming lessons.",
          "duration": 3,
          "videoUrl": "iU6z78oEIoo",
          "rawMarkdownUrl": "/routes/security/0-introduction/3-prerequisites/+page.md",
          "markdownContent": "---\ntitle: Pre-requisites\n---\n\n_Follow along with this video_\n\n\n\n---\n\n## Pre-requisites for the Smart Contract Security Course\n\n### Introduction\n\nThis course is **not** for beginners. We'll be covering advanced security and DeFi topics in this course and in order to get the most out of it you will _need_ to have a foundation to build upon.\n\n### Necessary Background Knowledge\n\n1. **Blockchain Basics:** A fundamental understanding of blockchain technology is essential.\n2. **Solidity Fundamentals:** Proficiency in Solidity, the primary programming language for writing smart contracts.\n3. **Smart Contract Framework Experience:** Familiarity with a smart contract framework like Hardhat or Foundry is crucial, with a preference for Foundry, as it is the main tool used in this course.\n4. **Key Terms and Concepts:** Terms like storage, self-destruct, fallback functions, and ERC20s should be familiar.\n\n### Course Expectations\n\n- **Level of Skill:** The course assumes a certain level of skill and will only provide a brief refresher at the beginning.\n- **For Auditors and Researchers:** If you have experience in security or auditing, this course will enhance your skills, focusing on not just auditing but also security research and building those skills and habits to make you successful in the space.\n\n### Additional Resources\n\n- **Foundry Full Course:** Our Foundry Full Course will prepare you with all the skills you need to be successful here.\n  - [Foundry Fundamentals](https://updraft.cyfrin.io/courses/foundry)\n  - [Advanced Foundry](https://updraft.cyfrin.io/courses/advanced-foundry)\n- **GitHub Repository:** Additional resources to help get up to speed are available in the course's [GitHub repository](https://github.com/Cyfrin/security-and-auditing-full-course-s23).\n\n### Course Philosophy and Goal\n\n- **Building a Strong Foundation:** The course aims to provide a solid base in smart contract security.\n- **Empowerment:** It focuses on empowering developers and researchers to contribute significantly to the Web3 space.\n- **Importance of Security:** Emphasizes the crucial role of security in the future of Web3.\n\n---\n\n**Are you ready to build a strong foundation in smart contract security and contribute to the future of Web3?** Let's embark on this journey together!\n\n---\n",
          "updates": []
        },
        {
          "lessonId": "bccddc5e-3f92-4f8f-9606-01566523e6a5",
          "number": 4,
          "title": "Best Practices",
          "slug": "best-practices",
          "folderName": "4-best-practices",
          "description": "Learn about best practices in Web 3.0 security to ensure safe and efficient smart contract development.",
          "duration": 5,
          "videoUrl": "hsMCnoxDrf0",
          "rawMarkdownUrl": "/routes/security/0-introduction/4-best-practices/+page.md",
          "markdownContent": "---\ntitle: Best Practices\n---\n\n_Follow along with this video_\n\n\n\n---\n\n## Best Practices\n\nWelcome to our Smart Contract Security course! I'm super excited to guide you through this journey. Let‚Äôs make sure you get the absolute best out of it.\n\nEssential Resources:\n\n- Cyfrin Updraft - If you're reading this, you're already here. All the most up to date corrections, content and updates will be available here, as accessible as ever and as part of a community eager to help.\n- GitHub Repo - The [Security and Auditing Full Course](https://github.com/Cyfrin/security-and-auditing-full-course-s23) repo is going to be your bible throughout this course. It is packed with all the code and references you need to succeed.\n\nNow, let's talk about how you can really get into the groove of things:\n\n- **Code Along**: Trust me, coding along with me during the lessons will make things stick way better. Have the video up along with your IDE of choice and follow along. Actually going through these motions are what will commit them to memory.\n- **Join the Chat on GitHub**: Got questions? Want to chat with others? Head over to our [GitHub Discussions](https://github.com/Cyfrin/security-and-auditing-full-course-s23/discussions) tab. It's a great spot to talk things out.\n- **Stay Up-to-Date**: Remember, the world of coding changes fast. Keep an eye on Cyfrin Updraft for the latest and greatest in course content.\n- **Dive into the Community** - We have a [Discord](https://discord.gg/cyfrin) server that is great for networking with fellow students and being involved in the community. Join us and share your successes and help others! To go far, we go together!\n\nAbout your learning pace ‚Äì everyone's different, right? So:\n\n- **Take Breaks**: They‚Äôre not just okay, they‚Äôre necessary! Your brain will thank you.\n- **Control the Tempo**: Feel free to speed up or slow down the videos. Video playback settings are available to control the pace.\n- **Keep Track of Your Journey**: Use those timestamps in our [GitHub repo](https://github.com/Cyfrin/security-and-auditing-full-course-s23) to bookmark your progress.\n- **Jump Around**: The course is set up so you can hop between sections as you like. Reflect on each lesson to really make it stick.\n\nAnd don‚Äôt forget, you‚Äôre not alone in this:\n\n- **Connect with the Community**: There are awesome places like [Ethereum Stack Exchange](https://ethereum.stackexchange.com/) and various decentralized Q&A forums, not to mention GitHub, for some solid discussion and collaboration.\n- **Learn Together**: The blockchain and smart contract space is all about teamwork and sharing knowledge. So, getting involved with others will only boost your learning.\n\nAlright, ready to jump in? Just follow these tips, and you'll be navigating through the Smart Contract Security course like a pro. Let‚Äôs get started! üöÄüë©‚Äçüíªüë®‚Äçüíª\n",
          "updates": []
        },
        {
          "lessonId": "96c362b5-9aee-4a51-a686-de476257a351",
          "number": 5,
          "title": "Current state of web3 security",
          "slug": "current-state-of-web3-security",
          "folderName": "5-current-state",
          "description": "Stay up-to-date with the current state of Web3 security and understand the challenges and advancements in this field.",
          "duration": 7,
          "videoUrl": "-bxlLNAh18E",
          "rawMarkdownUrl": "/routes/security/0-introduction/5-current-state/+page.md",
          "markdownContent": "---\ntitle: The current state of web3 security\n---\n\n_Follow along with this video_\n\n\n\n---\n\n## The Current State of Web3 Security: A Crucial Call to Action!\n\nThe current state of Web3 security is pretty objectively terrible. Let's look at where we're at and what needs to be done to improve security in the industry.\n\n### A Shocking Reality: Billions Lost in Hacks\n\n- **Billion-Dollar Troubles:** Did you know in 2022 alone, a jaw-dropping $3.1 billion was stolen in crypto hacks? And 2023 isn't looking much better. It's a call to arms for all of us in the Web3 space!\n- **DeFi's Dilemma:** Imagine this - about 7% of DeFi's total value is getting swiped by hackers. That's like saying, \"Hey, deposit your money here, but there's a scary chance it might vanish!\"\n\n### Attack Patterns: The Usual Suspects\n\n**Top Threats:**\n\n- Price oracle manipulation\n- reward manipulation\n- stolen private keys\n\nThese represent only a few of the common attack vectors we see lately. Some vulnerabilities have been around for years and _still_ people are making these mistakes - I'm looking at you _reentrancy_. There's a clear lack of best practices and we need to push back!\n\nThere's an amazing newsletter, every serious security researcher should sign up for called [Block Threat Intelligence](https://newsletter.blockthreat.io/) by Peter Kacherginsky.\n\nJust recently (as of October, 2023), we've seen multi-million dollar hacks, just in the last couple months.\n\n### The Big Picture: How do we move forward?\n\n- **Mainstream Hesitation:** With all these risks, no wonder big financial players are tiptoeing around Web3. It's incumbent upon us to make this space safer for mainstream adoption. How do we do accomplish this?\n- **Reducing the Risk:** It's simple - fewer hacks, more trust. More security focused education, fewer hacks.\n\n### The Bright Side: The future of Web3 Security\n\nSecurity in Web3 is improving every day.\n\n1. More and more people are moving into the security space in Web3. More auditors, more experts, more...safe!\n2. Education is improving in Web3 Security and Web3 as a whole. People are more informed of best practices and what to watch out for\n3. Tooling is improving - with AI and constantly developments in static analysis and vulnerability aggregation - we've never been more equipped to improve security in the space. [Solodit](https://solodit.xyz/) in particular is a tool we'll come back to again and again in this course.\n\n**Protocols Playing It Safe:** More and more Web3 protocols are investing in security. They're auditing their code, they're opening bug bounties for post deployment coverage, they're finally realizing that spending $1 Million on security now, is worth saving $100 Million in being hacked.\n\nWe also have an increase of pre-deployment experts like:\n\n- Cyfrin\n- Trail of Bits\n- OpenZeppelin\n\nCompetitive audit platforms ([CodeHawks](https://www.codehawks.com/)), independent security researchers like ([Pashov](https://twitter.com/pashovkrum)) and a greater security focus all come together to make me optimistic about the future of Web3 Security.\n\n### Yet, There's More to Do: Our Collective Mission\n\n- **Centralized Technology** is a big problem. Private keys being compromised, or offchain centralizing are regular vulnerabilities seen in the space.\n- **Lack of Post Deployment Practices** is something we'll cover later in the course. But needless to say, active monitoring practices and emergency triage in Web3 leave much to be desired. Few even leverage bug bounties to incentivize ongoing security on their protocol post launch.\n- **Not Following Best Practices**\n- **A Disconnect** seems to exist between the industry and security professionals. Audit(security review) != 100% Safe. If no one is reading the security reports, no one is any safer.\n\n### Wrapping Up: Your Role in Shaping Web3's Destiny\n\nThis isn't just a course. It's a mission. Together, we can transform Web3 into a fortress of trust and innovation. Keep going for some exercises to sharpen your skills.\n",
          "updates": []
        },
        {
          "lessonId": "6407d102-4af4-439f-b6cf-571a615d14dd",
          "number": 6,
          "title": "Exercises",
          "slug": "exercises",
          "folderName": "6-exercises",
          "description": "Prepare for practical exercises that will help you apply your knowledge and skills gained throughout the course.",
          "duration": 4,
          "videoUrl": "DaNiFAbLiZI",
          "rawMarkdownUrl": "/routes/security/0-introduction/6-exercises/+page.md",
          "markdownContent": "---\ntitle: Exercises\n---\n\n_Follow along with this video_\n\n\n\n---\n\n### Section 0: Excercises\n\nThe first exercise is important. This is **just for you**. This isn't meant to be a motivation to share with others, or chat about publicly, this is what inspired you to take the first step and what will continue to inspire you to take the next.\n\n_This is for you._\n\nMake it as long and detailed as possible. Pour your emotion into defining why you want this. Don't bullsh\\*t yourself. There'll be opportunities to shout your accomplishments loudly - but this is just for you.\n\n---\n\nüéØ Exercise: `Write yourself a message about why you want this`\n\nThis will be important for when things get hard\nIs it money? Save web3? Become someone?\nWrite down as many reasons as possible.\n\nSection 0 NFT Challenge üëÄ\n\n[Welcome! (Arb)](https://arbiscan.io/address/0xf923431da74ecc873c4d641fbdfa2564baafca9f#code)\n\n[Welcome! (Sepolia)](https://sepolia.etherscan.io/address/0x39338138414df90ec67dc2ee046ab78bcd4f56d9)\n",
          "updates": []
        }
      ]
    },
    {
      "sectionId": "7918b334-ee76-4134-a88b-86f30ba20f98",
      "number": 1,
      "title": "Review",
      "slug": "review",
      "folderName": "1-review",
      "lessons": [
        {
          "lessonId": "8a95ea78-0301-4dc3-814a-36699ab23b05",
          "number": 1,
          "title": "Tooling requisites",
          "slug": "tooling-requisites",
          "folderName": "1-tooling-requisites",
          "description": "This lesson provides an overview of the essential tools required for Solidity and Smart Contract development. It includes a guide to text editors like Visual Studio Code and VSCodium, and an introduction to frameworks such as Foundry, alongside compatibility tips for different operating systems. It also highlights the importance of AI tools like Find and ChatGPT in the development process.",
          "duration": 4,
          "videoUrl": "J1uE6YX71yI",
          "rawMarkdownUrl": "/routes/security/1-review/1-tooling-requisites/+page.md",
          "markdownContent": "---\ntitle: Tooling Pre-requisites\n---\n\n_Follow along with this video_\n\n---\n\n## Pre-requisite Tools\n\nBefore we get deep into coding, there are some useful tools we're going to be using throughout the course. Best to prepare them now.\n\nFirstly, you will need some kind of IDE or text editor. I like to use [**Visual Studio Code**](https://code.visualstudio.com/). For those of you more security and privacy focused you may want to check out [**VSCodium**](https://vscodium.com/) which removes a lot of the Microsoft _stuff_.\n\n## Frameworks\n\nThe primary framework we'll be working with in this course is Foundry. You can view installation instructions for that [**here**](https://book.getfoundry.sh/getting-started/installation).\n\nBut hey, if you‚Äôre more familiar with [**Hardhat**](https://hardhat.org/), [**Brownie**](https://eth-brownie.readthedocs.io/en/stable/), or any other framework, don't stress; you can absolutely follow along using your tools. We'll be tackling some Foundry-specific tasks, but you're always welcome to adapt them for your framework of choice.\n\n> Remember: You can use commands `foundryup` to update your Foundry tools and `forge --help` to access a help guide.\n\nAdditional Foundry specific features we'll be using include `cast` and `chisel`, both of which we'll learn more about in this course.\n\n## Coding Environment\n\nIf you're using a PC with Windows, ensure you're using **Windows with WSL**.\n\nThis tool ensures the Linux terminal commands we run are compatible with your machine too. There's a brilliant [**guide by Vasiliy**](https://youtu.be/umepbfKp5rI?feature=shared&t=23546) walking you through the WSL installation process if you need it.\n\nFor Linux and Mac users, you can simply stick with the environments you're already using.\n\nAI tools like [**Phind**](https://www.phind.com/) or [**ChatGPT**](https://www.chat.openai.com) aid in seeking answers when things get tough. One nifty feature **Phind** offers is web searching; you can query \"_install Foundry for the ETH ecosystem_\", and the tool will surf the web, compile an answer, and offer you a digestible solution for your query!\n\n<img src=\"/security-section-1/1-tooling/tooling1.png\" style=\"width: 100%; height: auto;\" alt=\"block fee\">\n\n## Web3 Is About Community\n\nI highly recommend you consider creating accounts on platforms like:\n\n- [**Peeranha.io**](https://peeranha.io/) - A great platform for discussion and QA for Web3\n- [**Ethereum Stack Exchange**](https://ethereum.stackexchange.com/) - One of _the_ best blockchain developer resources available\n  and of course\n- [**GitHub**](https://www.github.com) - Every developer needs an account here. It's objectively the best space online to collaborate, discuss and share coding support.\n\nRemember to jump in and ask questions. Don't pretend to have answers when you don't. The learning experience is about being humble and is most rewarding to those willing to ask questions and seek clarity. Embrace the \"I don't know, and I will find out\" attitude.\n\n> One of the worst things you can do as a security researcher is pretend to know something you don't.\n",
          "updates": []
        },
        {
          "lessonId": "10c4f125-eba0-41a7-bc7a-154842f2bc01",
          "number": 2,
          "title": "Solidity Prerequisites",
          "slug": "solidity-requisites",
          "folderName": "2-solidity-requisites",
          "description": "This lesson covers the prerequisites for working with Solidity, focusing on skills like using Remix for compiling and deploying contracts, and the basics of Foundry framework. It emphasizes the importance of familiarity with local and cloud-based coding for effective contract development.",
          "duration": 4,
          "videoUrl": "vNr-b6u503M",
          "rawMarkdownUrl": "/routes/security/1-review/2-solidity-requisites/+page.md",
          "markdownContent": "---\ntitle: Solidity Pre-requisites\n---\n\n_Follow along with this video_\n\n---\n\nAlright! All of the pre-requisites I've mentioned so far, and those mentioned here can be found in the Foundry Full Course ([Fundamentals](https://updraft.cyfrin.io/courses/foundry) _and_ [Advanced](https://updraft.cyfrin.io/courses/advanced-foundry))\n\n## The Prerequisites: Solidity Basics\n\nTo keep up with this course, you should be familiar with all the basic functions of [Remix](https://remix.ethereum.org). This includes `compiling`, and `deploying` to both local and testnet blockchains.\n\nAll of the basic Solidity, variable types, contract structure etc should be second nature.\n\n## Foundry Familiarity\n\nYou should also be familiar with the working environments of Foundry, or your framework of choice. You should understand how to initialize a project in your framework and navigate it's working tree.\n\n<div style=\"text-align:center;\">\n<img src=\"/security-section-1/2-solidity-req/solidity-prerequisites1.PNG\" style=\"width: 40%; height: auto;\" alt=\"block fee\">\n</div>\n\nCommands like these should ring lots of bells.\n\n```shell\nforge init\nforge build\nforge test\n```\n\nThe basic code seen in the Foundry example contracts should be things you recognize as well.\n\n```js\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\ncontract Counter {\n    uint256 public number;\n\n    function setNumber(uint256 newNumber) public {\n        number = newNumber;\n    }\n\n    function increment() public {\n        number++;\n    }\n}\n```\n\n---\n\n## Testing\n\nThe Foundry example test setup contains two distinct test types, a regular test and a fuzz test. These distinctions you should be a little familiar with, but we'll definitely go more indepth throughout this course.\n\n### Exploring Test Types: Regular Test and Fuzz Test\n\nIn the regular test, we merely incept the counter contract and increment it, ensuring the counter number equals one. The Fuzz test, however, involves passing a random number into our test.\n\nAs you may recall, we run this test with a certain number of runs, using different random numbers. No matter the chosen value for X, the test will always hold.\n\nHow do we change the number of fuzz runs? Simply browse to Foundry's TOML file and copy the variable.\n\n```md\n[fuzz]\nruns = 256\nmax_test_rejects = 65536\nseed = \"0x3e8\"\ndictionary_weight = 40\ninclude_storage = true\ninclude_push_bytes = true\n```\n\nIn the TOML file, you have the ability to set the number of runs. For instance, we could change it from 256 to 600.\n\n```shell\n$ forge test\n```\n\nVoila! You'll see that the test Fuzz ran 600 times. This indicates that the test ran with 600 different random numbers.\n\n```bash\nRunning 1 test for test/Counter.t.sol:CounterTest\n[PASS] testFuzz_SetNumber(uint256) (runs: 600, Œº: 27398, ~: 28409)\nTest result: ok. 1 passed; 0 failed; 0 skipped; finished in 14.63ms\n\nRan 1 test suites: 1 tests passed, 0 failed, 0 skipped (1 total tests)\n```\n\n## Advanced Fuzzing: Stateful Fuzzing and Invariant Tests\n\nOn to the next level ‚Äì **stateful fuzzing**, also popular as invariant tests in the Foundry universe. This aspect of coding might not be your forte yet, but no worries, that's what we're here for.\n\nLet's look more closely at fuzzing and invariant testing in our next lesson.\n",
          "updates": []
        },
        {
          "lessonId": "7ca092d5-a77c-4d01-b952-53d530f5a25e",
          "number": 3,
          "title": "Fuzzing and invariants",
          "slug": "fuzzing-and-invariants",
          "folderName": "3-fuzzing-and-invariants",
          "description": "Explore the concepts of fuzz testing and invariant testing in Solidity. This lesson explains how fuzz testing can help uncover unexpected application failures, and dives into the practice of testing invariants, or properties that always hold true, in smart contracts.",
          "duration": 10,
          "videoUrl": "jCO69E5BfEM",
          "rawMarkdownUrl": "/routes/security/1-review/3-fuzzing-and-invariants/+page.md",
          "markdownContent": "---\ntitle: Stateless Fuzzing, Stateful Fuzzing And Invariants/Properties\n---\n\n_Follow along the video_\n\n---\n\n## Testing the Unknown\n\nOften, hacks result from scenarios you didn't anticipate or consider for testing. But what if you could write a test that checks for every possible scenario, not just one? Welcome to the world of **Fuzz testing**.\n\n## What Is Fuzz Testing?\n\nAlso known as _fuzzing_, this is all about supplying random data to your system in an attempt to break it. Imagine your code is an indestructible balloon. Fuzzing involves you doing random things (like poking, squeezing, or even kicking) to the balloon with the sole intention of breaking it.\n\nThis makes it a useful technique for unearthing unexpected application failures. This lesson aims to walk you through the concept and practical application of fuzz testing.\n\n### The Fundamental Principle: Testing Invariants\n\nEach system, from a function to an entire program, has an integral property, often referred to as the _invariant_. This property must always hold true. For instance, you could have a function called `doStuff` that should always return zero, regardless of the value of the input. In such a case, returning zero would be the invariant of that function.\n\nLet's dark dive deeper into what such a function could look like:\n\n```js\nfunction doStuff(uint256 data) public {\n    if (data == 2){\n        shouldAlwaysBezero = 1;\n    }\n    if(hiddenValue == 7) {\n        shouldalwaysBeZero = 1;\n    }\n    hiddenValue = data;\n}\n```\n\nA unit test for this function would look something like this:\n\n```js\nfunction testIsAlwaysGetZero() public {\n    uint256 data = 0;\n    exampleContract.doStuff(data);\n    assert(exampleContract.shouldAlwaysBeZero() == 0);\n}\n```\n\nThe above test is going to pass because in that specific situation (where `data == 0`), our invariant isn't broken.\n\nFrom the function above, you can expect that `should_always_be_zero` is always zero, regardless of the `data` value. But wait, what happens if our input is `2`? We get `should_always_be_zero` as `1`. That violates our invariant!\n\nOf course, this is a pretty straightforward example. But what if we have a function that looks a bit more complicated? Writing a test case for every scenario could be tedious or impossible. We need to adopt a more programmatic approach to test these cases en masse.\n\n## Introducing Fuzz Tests and Invariant Tests\n\nThere are two popular methodologies when dealing with edge cases: using _fuzz tests/invariant tests_, or _symbolic execution_ (which we'll save for another day).\n\n> \"Fuzz testing and Invariant testing are great tools to assess the robustness of your code.\"\n\nLet's consider an example of a fuzz test in Foundry. Here, we set our data right in the test parameter, allowing Foundry to automate the process of providing random input data during tests.\n\n```js\nfunction testIsAlwaysGetZeroFuzz(uint256 data) public {\n    exampleContract.doStuff(data);\n    assert(exampleContract.shouldAlwaysBeZero() == 0);\n}\n```\n\nFoundry will automatically randomize data and use numerous examples to run through the test script. This test will be supplied random data from 0 to uint256.max(), as many times as you've conifigured runs.\n\n> Reminder: You can configure the number of runs in your foundry.toml under the [fuzz] variable\n\nNotably, this pseudo-random mechanism is not exhaustive. It won't provide a scenario for every single possible data input. That's why further understanding of how the Fuzzer generates random data is crucial.\n\n## Stateless Fuzzing versus Stateful Fuzzing\n\nFuzzing also comes in flavours, the above being an example of `stateless fuzzing`. Another that is valuable to understand is `stateful fuzzing`. `Stateful fuzzing`, instead of resetting the contract state for each new run, will use the ending state of your previous run as the starting state of your next.\n\nThis is important for situations like our `doStuff` function\n\n<img src=\"/security-section-1/3-fuzz-test/fuzz2.png\" style=\"width: 100%; height: auto;\" alt=\"block fee\">\n\nA stateful fuzz test would instead utilize the same contract we just triggered and call another function on it, creating an interlocking sequence of functions throughout a single run. Achieving this in Foundry requires using the `invariant` keyword and a bit of setup:\n\nFirst, we need to import `StdInvariant` from `forge-std` and inherit it in our test contract.\n\n```js\n//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0\n\nimport {StdInvariant} from \"forge-std/StdInvariant.sol\";\n\ncontract MyContractTest is StdInvariant, Test {...}\n```\n\nThen, in the setup of our test contract, we need to tell Foundry, which contract we'll be calling random functions on.\n\n```js\nfunction setUp() public {\n    exampleContract = new MyContract();\n    targetContract(address(exampleContract));\n}\n```\n\nNow our `stateful fuzz` test is going to look something like this:\n\n```js\nfunction invariant_testAlwaysReturnsZero() public {\n    assert(exampleContract.shouldAlwaysBeZero() == 0);\n}\n```\n\nWith the above test, Foundry is going to call random functions on the `targetContract` (in our case `doStuff` repeatedly, but were there other functions, they would be called in a random order) and pass those functions random data.\n\n## In Summary\n\nFuzz testing involves mainly understanding your system's invariants and writing tests that can execute numerous scenarios. This is either achieved through `stateless fuzzing`, which provides random data alone with each run independent of the last, or `stateful fuzzing`, allowing both random data and random function calls subsequently on the same contract. This is the new standard for web3 security.\n\nGoing forward, aim to fully understand the invariants in systems you're working on, and write fuzz tests to ensure they are not broken\n\n> \"Fuzz testing is a technique that some of the top protocols are yet to adopt, yet it can aid in discovering high severity vulnerabilities in smart contracts.\" - Alex Rohn, co-founder at Cyfrin.\n\nNext lesson we're going to talk about common Ethereum Improvement Proposals (EIPs)!\n",
          "updates": []
        },
        {
          "lessonId": "9d521d8e-81b8-4bc0-b446-07362440e116",
          "number": 4,
          "title": "Installing Libraries",
          "slug": "installing-libraries",
          "folderName": "4-installing-libraries",
          "description": "Lorem ipsum dolor sit amet consectetur adipisicing elit. Quisquam ad porro a iusto rerum sed veniam nisi dolores cupiditate voluptatum?",
          "duration": 0,
          "videoUrl": "",
          "rawMarkdownUrl": "/routes/security/1-review/4-installing-libraries/+page.md",
          "markdownContent": "---\ntitle: Installing Libraries\n---\n\n_Follow along the with the video_\n\n---\n\nWe'll go over Fuzz and Invariant testing in more detail later. For now, let's briefly go over importing valuable libraries into our code base.\n\n### OpenZeppelin Contracts and ERC20\n\nSay, you're working on a project and you'd like to include an `ERC20`, but are unsure where to start. This is where [OpenZeppelin Contracts](https://github.com/OpenZeppelin/openzeppelin-contracts) come into play. This popular library, available on GitHub, provides prewritten contracts for your use, making your life a whole lot easier!\n\nUse the following command to install this library to your project directory:\n\n```shell\nforge install OpenZeppelin/openzeppelin-contracts --no-commit\n```\n\n### Configuring Project Files and Creating New Contracts\n\nNow, navigate to the `foundry.toml` file in your project directory. Here, specify the remappings by setting `@openzeppelin/contracts` equal to `lib/openzeppelin-contracts/contracts`. This sets up the path for the compiler to locate OpenZeppelin contracts.\n\n```markdown\nremappings = ['@openzeppelin/contracts=lib/openzeppelin-contracts/contracts']\n```\n\nOnce remapped, the library and it's contracts can be imported into your project like so:\n\n```js\n//SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\ncontract MyToken is ERC20 {\n    constructor() ERC20(\"MyTokenName\",\"MTN\") {};\n}\n```\n\nFor those who might need a brush up on what exactly ERC20 is or are curious about other types of tokens like the ERC721 (also known as NFTs), stay tuned as we'll be covering them in our upcoming discussions.\n",
          "updates": []
        },
        {
          "lessonId": "0f2eefd6-73c5-4991-ac1b-2fd319840ed5",
          "number": 5,
          "title": "What is an ERC20?",
          "slug": "what-is-erc20",
          "folderName": "5-what-is-erc20",
          "description": "This lesson offers an introduction to ERC-20 tokens, their functionality, and applications. It explains the basics of ERC-20 token creation and its significance in the blockchain ecosystem, including use cases like governance tokens and network security.",
          "duration": 2,
          "videoUrl": "2x1llxOruiY",
          "rawMarkdownUrl": "/routes/security/1-review/5-what-is-erc20/+page.md",
          "markdownContent": "---\ntitle: What is an ERC20/EIP20?\n---\n\n_Follow along the with the video_\n\n---\n\n## What are ERC20 tokens?\n\nFirstly, let's define what ERC20s are. ERC20s are tokens that exist and function on a blockchain network using a predefined standard called [the ERC20 token standard](https://ethereum.org/en/developers/docs/standards/tokens/ERC20/). This standard is essentially a set of rules that dictate certain functions a token should have, allowing it to interact seamlessly with other tokens on the network.\n\nHowever, the magic doesn't just stop at being tokens. ERC20s are also smart contracts. This hybrid nature allows ERC20 tokens to embody complex functionalities on the blockchain. Isn't that cool? A few notable examples of ERC20s include tokens like Tether, Chainlink, Uni and DAI.\n\n> **Note:**Chainlink technically falls under the ERC-677 standard, a higher standard that introduces additional functions while still retaining compatibility with the original ERC20 standard. So, you can think of Chainlink as an upgraded ERC20 token.\n\n## Why care about ERC20 tokens?\n\nAt this point, you might be wondering, \"Why should I even care to make an ERC20 token?\". Well, there are a number of compelling reasons.\n\nERC20 tokens find extensive use in a number of areas. They can serve as governance tokens, allowing token holders to vote on various matters within a DApp (Decentralised Application). They can be used to secure the underlying network. They can also represent some type of static asset, and much more. The sky's the limit when it comes to what you can achieve with ERC20 tokens.\n\n## How to create an ERC20 token\n\nNow that we've addressed the 'what' and 'why' of ERC20 tokens, let's delve into the 'how'. You can create your very own ERC20 token by crafting a smart contract that conforms to the ERC20 token standard.\n\nAn ERC20 compliant smart contract needs to have certain functions - `name()`, `symbol()`, `decimals()`, to name a few. These functions are called to retrieve information about the token. Furthermore, functionalities such as transferring tokens and checking the balance of tokens must also be included in the smart contract.\n\nOf course, the ERC20 is not the be-all and end-all. There are several other upgraded token standards, such as the [ERC-677](https://github.com/ethereum/EIPs/issues/677) and the [ERC-777](https://eips.ethereum.org/EIPS/eip-777) that you might want to check out. These other standards provide additional functionality while maintaining full compatibility with the ERC20 standard.\n\nTo sum up, ERC20 tokens are versatile and powerful constructs in the blockchain realm. Whether you wish to create your own token for a DApp, or simply wish to understand the underlying mechanics of various tokens, gaining a strong grasp on ERC20 tokens can undoubtedly open a plethora of avenues for you. Happy learning!\n",
          "updates": []
        },
        {
          "lessonId": "65635349-225c-4583-b9ad-62bd27930683",
          "number": 6,
          "title": "What is an ERC721?",
          "slug": "what-is-erc721",
          "folderName": "6-what-is-erc721",
          "description": "Dive into the world of ERC-721 tokens and NFTs (Non-Fungible Tokens). This lesson discusses the uniqueness of NFTs compared to ERC-20 tokens, their various applications, and the role of ERC-721 in representing unique digital assets on the blockchain.",
          "duration": 6,
          "videoUrl": "516bzGbgYak",
          "rawMarkdownUrl": "/routes/security/1-review/6-what-is-erc721/+page.md",
          "markdownContent": "---\ntitle: What is an ERC721/NFT?\n---\n\n_Follow along the with the video_\n\n---\n\nThe buzz around non-fungible tokens (NFTs) or `ERC721s` lately is becoming impossible to ignore, especially within the spheres of art and blockchain technology. NFTs, originally authored on the Ethereum platform, present a unique form of digital asset that holds the potential to revolutionize the world of art, gaming and beyond. But what exactly are they?\n\n## Understanding NFTs\n\nNFT stands for non-fungible token. Unlike `ERC20` tokens, such as LINK, DAI etc, each NFT is entirely unique, and no two tokens can be interchanged.\n\nTo better understand, let's look at a simple analogy. Think of a dollar bill; it holds the same value as any other dollar out there. You can freely exchange a dollar for another, and their value remains the same. This makes them _fungible_. Contrastingly, an NFT is the complete opposite. It could be likened to a unique Pokemon. Each Pokemon is unique and no two Pikachu's are exactly the same.\n\nAs a more relatable analogy, consider an NFT as a distinct piece of art, trading card, or any other one-of-a-kind item. So to sum up, NFTs are unique, non-interchangeable tokens best thought of as indestructible digital pieces of art with a permanent history detailing their ownership and alterations.\n\n## The Many Uses of NFTs\n\nAlthough NFTs are mostly associated with art, they extend beyond that. They can be assigned any property, or manipulated in any way you like, thanks to the underlying smart contract technology.\n\n<div>\n<div style=\"text-align: center\">\n    <img src=\"/security-section-1/6-erc721s/erc721s1.png\" style=\"width: 20%; height: auto;\" alt=\"block fee\">\n    <img src=\"/security-section-1/6-erc721s/erc721s2.png\" style=\"width: 21.7%; height: auto;\" alt=\"block fee\"> \n    <div style=\"font-size: 10\">An NFT example from <a href=\"https://opensea.io/assets/ethereum/0x5af0d9827e0c53e4799bb226655a1de152a425a5/7874\">Milady</a></div>\n</div>\n</div>\n\nThese unique tokens are deployed on a smart contract platform and can be traded on numerous NFT platforms such as [OpenSea](https://opensea.io/) or [Rarible](https://rarible.com/). While these decentralized marketplaces provide user-friendly interfaces for trading NFTs, one could just as easily buy and sell outside of them.\n\n## NFTs: Bridging the Gap for Artists\n\nMany might find the whole concept of NFTs puzzling. Isn't art meant to be tangible? But consider this: artists often aren't adequately compensated for their work. Their creations get copied and shared with zero attribution; they simply lose ownership. But with NFTs, artists can finally get the recognition, and more importantly, the compensation they deserve.\n\n> \"Having a decentralized royalty mechanism, or some type of mechanism where these artists can get accurately comped for what they're doing, is crucial.\"\n\nYes, NFTs can be a solution to current issues plaguing the art industry by creating an auditable and transparent trail of royalties without the need for any centralized service.\n\n## The Role of the ERC721 Standard\n\n`ERC721`, or the NFT standard, forms the basis of it all. To keep it simple, the main distinction between `ERC721` and `ERC20` tokens is that each `ERC721` token has a unique Token ID, an attribute that indirectly represents the asset linked to that token.\n\nTo illustrate the unique attributes of an asset, let's say a piece of art or a character in a game, NFTs rely on metadata and `Token URIs`. Due to the prohibitively high gas prices on Ethereum, it's quite impractical to store these intricate art pieces directly on the chain.\n\n## How Token URIs Work\n\nThe solution? The developers introduced what is known as a `Token URI` in the NFT standard‚Äîa universally unique identifier that provides information about what an asset (or token) looks like, and the attributes of that token. Data storage platforms like IPFS or a centralized API usually provide this `Token URI` through a simple API call.\n\nThe `Token URI` should return data in a preset format, including the name, image location, description, and any other attributes that add to the uniqueness of the token.\n\nHowever, storing metadata off-chain does come with its challenges. If the centralized system hosting these assets crashes, every link associated with your NFT is lost. Modern discussions in the NFT world often debate the pros and cons of on-chain metadata versus off-chain metadata. Regardless of the limitations, there's something truly groundbreaking about NFTs, and it's exciting to envision where this technology could lead us.\n",
          "updates": []
        },
        {
          "lessonId": "ce4c93b4-da09-44e7-87a8-340d4e0d36a8",
          "number": 7,
          "title": "Advanced Solidity Prerequisites",
          "slug": "advanced-solidity-prerequisites",
          "folderName": "7-advanced-solidity-prerequisites",
          "description": "Lorem ipsum dolor sit amet consectetur adipisicing elit. Quisquam ad porro a iusto rerum sed veniam nisi dolores cupiditate voluptatum?",
          "duration": 0,
          "videoUrl": "Mek5xKplxuM",
          "rawMarkdownUrl": "/routes/security/1-review/7-advanced-solidity-prerequisites/+page.md",
          "markdownContent": "---\ntitle: Advanced Solidity Pre-requisites\n---\n\n_Follow along the with the video_\n\n---\n\nLet's look at a couple advanced solidity concepts that will be important to understand as you progress through this course.\n\n## The Core of Smart Contracts: Storage\n\nThe first advanced feature we'll be covering today is storage in smart contracts. Every smart contract includes this integral element. This critical component is the space allotted to your variables within the contract.\n\nWhen you create a state variable within your contract, an individual storage slot is carved out just for that variable.\n\nIt's worth noting, however, that constants or immutable variables do not occupy space in storage. This unique trait is due to their nature of being stored directly within the contract's bytecode.\n\nTo illustrate:\n\n<img src=\"/security-section-1/7-advanced-solidity/sol2.png\" style=\"width: 100%; height: auto;\" alt=\"block fee\">\n\n### Hands-on Learning with Code\n\nYou can see this yourself through a few commands in Foundry. In the above contract, if we use...\n\n```bash\nforge inspect Counter storage\n```\n\nWe'll get a readout of the storage slots in our `Counter` contract which looks like this:\n\n```bash\n\"storage\": [\n    {\n      \"astId\": 44623,\n      \"contract\": \"src/Counter.sol:Counter\",\n      \"label\": \"number1\",\n      \"offset\": 0,\n      \"slot\": \"0\",\n      \"type\": \"t_uint256\"\n    },\n    {\n      \"astId\": 44625,\n      \"contract\": \"src/Counter.sol:Counter\",\n      \"label\": \"number2\",\n      \"offset\": 0,\n      \"slot\": \"1\",\n      \"type\": \"t_uint256\"\n    },\n    {\n      \"astId\": 44630,\n      \"contract\": \"src/Counter.sol:Counter\",\n      \"label\": \"number4\",\n      \"offset\": 0,\n      \"slot\": \"2\",\n      \"type\": \"t_uint256\"\n    }\n  ],\n```\n\nNotice how the variable `number3` isn't returned. This is because this variable is contained as a constant within the contract's bytecode.\n\n> Remember, always experiment with code, because it's in the _doing_ that we grasp the most complex concepts!\n\n### Wrapping Up with a Video Recap\n\nThe next lesson will be a quick video refresher on storage to get up to speed on the concept and prepare for the harder stuff to come!\n",
          "updates": []
        },
        {
          "lessonId": "4b6fc572-3728-4858-8396-a22e09e10647",
          "number": 8,
          "title": "Storage",
          "slug": "storage",
          "folderName": "8-storage",
          "description": "Gain a comprehensive understanding of storage in Solidity. This lesson covers global variables, the storage data structure, handling dynamic variables, and the role of constant and immutable variables. It also explains the use of the 'memory' keyword for efficient data management.",
          "duration": 5,
          "videoUrl": "ioD_szSZQpk",
          "rawMarkdownUrl": "/routes/security/1-review/8-storage/+page.md",
          "markdownContent": "---\ntitle: Storage\n---\n\n_Follow along the with the video_\n\n---\n\nIn this lesson, we are going to discuss some important aspects related to variables in Solidity. Much of what we'll cover is conveniently summarized in the [**Solidity documentation**](https://docs.soliditylang.org).\n\n## Understanding Global Variables and Storage\n\nFirst and foremost, we need to familiarize ourselves with the concept of `Storage`. In Solidity, when we refer to variables that are global or those that persist over time, we are actually referring to variables that exist in `Storage`.\n\n<img src=\"/security-section-1/8-storage/storage1.png\" style=\"width: 100%; height: auto;\" alt=\"block fee\">\n\nThink of `Storage` as a huge array or list that contains all the variables we create in Solidity. When we declare a variable in a contract‚Äîsay a contract named `fundamentalStorage`‚Äîto be a certain value, such as `favoriteNumber`, we're essentially demanding this variable to persist. This persistence is obtained via `Storage`.\n\nIn code this looks like:\n\n```js\ncontract fundamentalStorage {\n    uint favoriteNumber;\n}\n```\n\nThis `favoriteNumber` variable is stored in the `Storage` and can be called whenever required.\n\nNow, `Storage` is essentially an array where every variable (and its value) gets slotted into a 32 byte long slot. This is crucial in understanding how Solidity manages memory and data storage. The indexing of these storage slots starts from 0, and increments just like array indexing in most languages.\n\n```javascript\ncontract fundamentalStorage {\n    uint favoriteNumber = 25;\n    bool ourBool = true;\n}\n```\n\nFor instance, if a variable‚Äî`favoriteNumber`‚Äîis assigned the number 25, this number is stored in its bytes implementation `0x19`.\n\n## Dealing with Dynamic Variables\n\nWhile static variables are straightforward, things get slightly intricate with variables that are of dynamic length or can change length. Variables in the form of dynamic arrays or mapping are stored using some type of hashing function (outlined in the documentation).\n\nThe object itself does take up a storage slot, but it doesn't contain the whole array. Instead, the storage slot contains the length of the array. If we add a new element to the array by calling `myArray.push(222)`, the array's length and the new element are stored at separate locations determined by the hash function.\n\n```js\ncontract exampleContract {\n    uint[] myArray;\n\n    function addToArray(uint _number) public {\n        myArray.push(_number);\n    }\n}\n```\n\nIn the code example above, `myArray.length` is stored in `storage slot [0]`, while the elements within the array (myArray.push(\\_number)) are stored at `storage slot [keccak256(0)]`.\n\n## Constant and Immutable Variables\n\nInteresting to note is the fact that constant and immutable variables do not occupy spots in `Storage`. This is because such variables are incorporated within the bytecode of the contract itself. Solidity automatically substitutes any reference to these variables with their declared values.\n\n```js\ncontract exampleContract {\n    uint constant x = 123;\n}\n```\n\nIn the example above, the constant variable `x` does not occupy a storage slot.\n\n## Temporary Variables: Function Scope\n\nFor variables that are declared inside a function, their existence is ephemeral and scoped merely to the span of that function. These variables do not persist inside the contract and are not stored in `Storage`. Instead, they're stashed in a different memory data structure, which deletes them as soon as the function has finished execution.\n\n```js\ncontract exampleContract{\n    function myFunction(uint val) public {\n        uint newVar = val + 5;\n    }\n}\n```\n\nIn this example, `newVar` only exists for the duration of `myFunction`.\n\n## Memory Keyword: Necessary for Strings\n\nFinally, the `memory` keyword. Primarily used with strings, `memory` is needed because strings are dynamically sized arrays. By using this keyword, we tell Solidity that string operations are to be performed not in `Storage`, but in a separate memory location.\n\nSolidity needs this explicit instruction because arrays and mappings require more space, hence the need to ensure that space is allocated in the appropriate data structure.\n\nHere's a code snippet using `memory` keyword with string:\n\n```javascript\ncontract exampleContract{\n    function getString() public pure returns (string memory) {\n        return \"this is a string!\";\n    }\n}\n```\n\nAll of what we've covered here is outlined in detail in the Solidity Documentation. Understanding these concepts and how Solidity handles variables is integral to attaining a deeper understanding of the language and compiler.\n\n> \"Understanding the nitty-gritty of Solidity variables and storage will significantly amplify your solidity coding skills.\"\n",
          "updates": []
        },
        {
          "lessonId": "2a197fd8-42ba-4c0b-90c7-0dbb309c7abd",
          "number": 9,
          "title": "Fallback and Receive",
          "slug": "fallback-and-receive",
          "folderName": "9-fallback-and-receive",
          "description": "Learn about the fallback and receive functions in Solidity. This lesson explains how these functions enable a contract to accept ETH, their default settings, and the significance of encoding in smart contract functionality.",
          "duration": 2,
          "videoUrl": "pTn0Kfp9JHg",
          "rawMarkdownUrl": "/routes/security/1-review/9-fallback-and-receive/+page.md",
          "markdownContent": "---\ntitle: Fallback and Receive\n---\n\n_Follow along with the video_\n\n---\n\nIn the world of Solidity smart contracts, it's important to understand the fallback and receive functions. By default, Solidity smart contracts reject any Ether (ETH) sent to them. In order to enable your contract to accept ETH, we would implement `fallback` and `receive` functions. Let's look at these mose closely.\n\n## What are the Fallback and Receive functions?\n\nThese two specific functions - `fallback` and `receive` - enable a contract to accept and react to native ETH sent to it. Both these functions can be made \"**external payable**\", indicating that they can receive and handle ETH.\n\nSo, how do they function? Here's the core logic to give you a better understanding:\n\n<div style=\"text-align: center\">\n    <img src=\"/security-section-1/9-fallback-receive/fallback-receive1.png\" style=\"width: 30%; height: auto;\" alt=\"block fee\">\n</div>\n\nTo put it simply, consider the case of sending ETH to a smart contract without any data. In such an instance, the `receive` function would be called, resorting to `fallback` if the `receive` function does not exist.\n\nOn the other hand, if there _is_ data, Solidity will skip straight to the `fallback` function, bypassing the `receive` function entirely.\n\n## Default Settings in Solidity\n\nIt is worthwhile to note that the `fallback` function may or may not be payable. If the contract lacks a `receive` function and the `fallback` function isn't payable, then the `fallback` function won't be called when you send ETH to the contract.\n\n```js\nfallback() external{}\nreceive() external payable {}\n```\n\nBy the same token, a contract that does not contain any of these functions will reject any ETH sent to it. In fact, Solidity will automatically compile this contract to reject ETH - with at least one notable exception we'll go over later.\n\n## Deepening Understanding: Encoding\n\nThe next lesson is a clip you might remember from the Foundry Course. We're going to go over encoding and explain how it can be used to call any function on any contract from another contract.\n\nLet's do it.\n",
          "updates": []
        },
        {
          "lessonId": "3c15b341-1146-4e78-abfd-fc77d99fae7f",
          "number": 10,
          "title": "ABI encode",
          "slug": "abi-encode",
          "folderName": "10-abi-encode",
          "description": "This lesson focuses on ABI (Application Binary Interface) encoding in Solidity, explaining its role in concatenating strings and encoding data into binary. It provides insights into the process of compressing binary data and techniques for multiple data encoding.",
          "duration": 23,
          "videoUrl": "k0WSQNXCMU4",
          "rawMarkdownUrl": "/routes/security/1-review/10-abi-encode/+page.md",
          "markdownContent": "---\ntitle: Abi.encode & Abi.encodePacked\n---\n\n_Follow along with the video_\n\n---\n\n## Understanding ABI.encode & ABI.encodePacked in Solidity\n\n### Introduction\n\nThe topic we're diving into is how to concatenate strings in Solidity, specifically exploring `abi.encode` and `abi.encodePacked`. This is advanced stuff, delving into the low-level workings of Solidity, binary, and opcodes. Remember, it's okay if you don't grasp it all on the first go!\n\n> Remember: You can find all the code we'll be working with [**here**](https://github.com/PatrickAlphaC/hardhat-nft-fcc/tree/main/contracts/sublesson).\n\n### Getting Started\n\n- **Setting Up:** We'll use Remix for this exploration. Start by creating a new file named `encoding.sol`.\n\nYour contract should look something like this:\n\n```js\n//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.7\n\ncontract Encoding {\n    function combineStrings() public pure returns (string memory) {\n        return string(abi.encodePacked(\"Hi Mom! \", \"Miss you.\"));\n    }\n}\n```\n\nCompiling this contract and calling the `combineStrings()` function in Remix is going to give us the whole string `\"Hi Mom! Miss you.\"`\n\n### Exploring `abi.encode` and `abi.encodePacked`\n\n- **Understanding Encoding:** We use `abi.encode` and `abi.encodePacked` for encoding strings and other data types into a binary format. In our function above `\"Hi Mom!\"` and `\"Miss you.\"` are both converted into binary then concatenated. We then typecast the returned binary is a string.\n\n`encode` and `encodePacked` are examples of globally available methods in Solidity. There's a [**Cheatsheet**](https://docs.soliditylang.org/en/latest/cheatsheet.html) you should checkout with more information and tonnes of examples of these globally available methods and variables.\n\n> Note: As of `Solidity 0.8.12` you can also use `string.concat(stringA, StringB)` to achieve the same result as our `\"Hi Mom!\"` example.\n\nBefore getting to deep with encoding, let's take a step back to understand what's happening when we send a transaction.\n\n### Compilation Breakdown\n\n<img src=\"/security-section-1/10-encoding/encoding1.png\" style=\"width: 100%; height: auto;\" alt=\"block fee\">\n\nAs seen in the image above, when we compile a smart contract, the solidity compiler is returning two things `contract.abi` and `contract.bin`. The `abi` you likely remember from previous lessons.\n\n`Contract.bin` is the binary representation of your contract. This is the actual code that get put on the blockchain.\n\nWe see this binary object in transaction we send to the blockchain. Recall what constitutes a transaction:\n\n```js\ntx = {\n  nonce: nonce,\n  gasPrice: 10000000000,\n  gasLimit: 1000000,\n  to: null,\n  value: 0,\n  data: \"BINARYGOESHERE\",\n  chainId: 1337,\n};\n```\n\n> Note: When we're deploying a new contract, this is still a transaction on the blockchain, but our `to` property is empty and the `data` field will contain both the `contract init code` and `contract bytecode(binary)`.\n\n[**Here's**](https://etherscan.io/tx/0x112133a0a74af775234c077c397c8b75850ceb61840b33b23ae06b753da40490) a transaction on etherscan.io with a binary data object you can inspect.\n\nAt first look, the binary data in a transaction looks like chaos. Just a garbled mess of letters and numbers. You may be asking yourself - how does the EVM (Ethereum Virtual Machine) make any sense of these instructions?\n\nWell ...\n\n### Intro to EVM Opcodes\n\n> Opcodes are the building blocks of EVM instructions. Each opcode represents a specific operation.\n\nOpcodes are effectively the alphabet of the ethereum machine language. Each pair of characters in the binary object discussed above represents an Opcode with pertains to a specific operation to be performed.\n\nYou can find a list of the EVM Opcodes [**here**](https://www.evm.codes/?fork=shanghai).\n\nThis means that the binary object we pass in our blockchain transactions is ultimately a long list of these operations we're telling the EVM to perform.\n\n### Why This Matters\n\nUntil now we've only used `encode` and `encodePacked` to concatenate strings, but in reality these functions are much more powerful. You can encode virtually anything into its binary format.\n\n- **abi.encode** - returns the binary of the provided argument\n- **abi.encodePacked** - returns the binary of the provided argument, but with stipulation/compression\n  - types shorter than 32 bytes are concatenated directly, without padding or sign extension\n  - dynamic types are encoded in-place and without the length.\n  - array elements are padded, but still encoded in-place\n\nRead more about [**Non-standard Packed Mode**](https://docs.soliditylang.org/en/latest/abi-spec.html#abi-packed-mode)\n\nThe other side to this whole equation is that we also have the ability to _`decode`_ things.\n\n<img src=\"/security-section-1/10-encoding/encoding2.png\" style=\"width: 100%; height: auto;\" alt=\"block fee\">\n\nand finally .. we can even `multiEncode` and `multiDecode`.\n\n## <img src=\"/security-section-1/10-encoding/encoding3.png\" style=\"width: 100%; height: auto;\" alt=\"block fee\">\n\n# Conclusion\n\nHopefully this lesson has shed some light on some of the finer details of using encoding functions in solidity and the power they can hold. In the next lesson we'll be looking at how to encode function calls directly.\n",
          "updates": []
        },
        {
          "lessonId": "8aaefdb7-de7a-47ce-abbd-953fb53bb1c5",
          "number": 11,
          "title": "Encoding Functions",
          "slug": "encoding-function",
          "folderName": "11-encoding-function",
          "description": "Delve into the concept of ABI encoding for direct function calls in Ethereum. This lesson highlights how to populate the data field in transactions with binary code for specific function calls, enhancing the ability to interact with the Ethereum Virtual Machine.",
          "duration": 6,
          "videoUrl": "vDf9qFIODrE",
          "rawMarkdownUrl": "/routes/security/1-review/11-encoding-function/+page.md",
          "markdownContent": "---\ntitle: Introduction to Enconding Function Calls Directly\n---\n\n_Follow along with the video_\n\n---\n\n## Understanding ABI Encoding\n\nWith the previous lesson's foundation laid, lets look at what encoding is like within the context of sending transactions.\n\nWe know the EVM is looking for this encoded information, this binary _stuff_. And since transactions sent to the blockchain are ultimately compiled down to this binary, what this allows us to do is populate the `Data` property of a transaction with this binary ourselves.\n\n<div>\n<div style=\"text-align: center\">\n    <img src=\"/security-section-1/11-encoding-function/encoding-function2.png\" style=\"width: 95%; height: auto;\" alt=\"block fee\"> \n    <div style=\"font-size: 10\">Remember the properties of a Transaction</div>\n</div>\n</div>\n\n### ABI Encoding and Transactions\n\nWhen an Ethereum transaction is initiated, it is essentially reduced to binary code. This transformation pertains not just to a contract deployment but also a function call. In both cases - transactions and function calls - the data field holds the key.\n\nIn a contract deployment, the data field contains the contract's binary code. But for a function call, the data field holds the instructions about what data to send and which function to address.\n\nLet's dive into an example. If we inspect a transaction on Ethereum using Etherscan, you'll notice a field labeled 'Input data.' Within this field, you'll discover a jumble of hexadecimals - this is the encoded function call.\n\n**Example Input Data**\n\n```js\nFunction: enterRaffle(...)\nMethod ID: 0x2cfcc539\n```\n\nThis `Method ID`, sometimes referred to as a `function signature`, is an encoding of that particular function, including it's name and argument types.\n\nThis encoded function call in the data field is how the EVM, or any EVM compatible chain, deciphers which function should be executed.\n\n### Direct Function Calls\n\n<img src=\"/security-section-1/11-encoding-function/encoding-function1.png\" style=\"width: 100%; height: auto;\" alt=\"block fee\">\n\nWith our understanding of ABI encoding, the possibilities expand. We're now able to populate the data field of our transactions directly with the binary or hex code corresponding to the desired function call. Remember, when you initially compile your transaction, `data` was a field that existed? This is where that comes into play.\n\nYou may wonder why this ability is any better than directly using the interface or the Application Binary Interface (ABI). However, there could be scenarios when you might only possess the function name or the parameters. You might even want your code to make arbitrary calls, dangling at the edge of advanced programming. This is when knowing how to populate the data field directly becomes pivotal.\n\n### Sending the Transactions\n\nSo, how do we transform this understanding into action - how do we populate the data field and then send these custom, data-encoded transactions?\n\nIn solidity, we rely on some low-level keywords - `staticcall` and `call` - to perform this function. `staticcall` and `call` are used for view or pure functions and functions that change the blockchains' state, respectively.\n\nIn these functions, the code that specifies a particular function to execute goes into the parentheses (data field). For instance, in a previous function utilized for our lottery contract,\n\n```js\nfunction withdraw(address recentWinnder) public {\n    (bool success, ) = recentWinner.call{value: address.(this).balance}(\"\");\n    require(success, \"Transfer Failed\");\n}\n```\n\nthe `{value: address.(this).balance}` segment updates the transaction's value field while the empty parentheses imply there's no function to call; the transaction merely sends money.\n\nHowever, if a function needs to be executed or data should be sent, it can be specified in the parentheses, let's combine this with our previous `Method ID` we got from etherscan.\n\n```js\nfunction enterRaffle(uint256 entryFee) public payable {\n    PuppyRaffle puppyRaffle = new PuppyRaffle;\n    puppyRaffle.call{value: entryFee}(\"0x2cfcc539\");\n}\n```\n\nIn the above example, you can see that we're passing the `entryFee` as an argument to the `value` property of the transaction and in the `data` field we are populating the `function signature`. This will tell the EVM, what to call, where and how much to send.\n\n### Wrap Up\n\nTo wrap it up, remember that although the realm of Ethereum and EVM might seem overwhelming at first, understanding their machinations, such as ABI encoding, one concept at a time allows you to become an active participant in the blockchain network, enhancing your ability to interact effectively and perform more advanced operations.\n\n> \"The function of good programming is to do the thinking for you, to the extent possible, so that when you're using it, your mind is free to think.\" - Joshua Bloch\n",
          "updates": []
        },
        {
          "lessonId": "315ac33d-e452-4aa2-b577-9b72f1f6ace2",
          "number": 12,
          "title": "Upgradeable contracts",
          "slug": "upgradeable-contracts",
          "folderName": "12-upgradeable-contracts",
          "description": "Explore the design of upgradeable smart contracts using Proxy and Delegate Call. This lesson covers the functionality, applications, and coding techniques of these concepts, crucial for managing contract upgrades while preserving the contract's state.",
          "duration": 6,
          "videoUrl": "fCP26ewN38A",
          "rawMarkdownUrl": "/routes/security/1-review/12-upgradeable-contracts/+page.md",
          "markdownContent": "---\ntitle: Upgradeable Contracts\n---\n\n_Follow along with the video_\n\n---\n\n## Upgradeable Contracts\n\nIn this section we're going to ask ourselves `what is a proxy?` and `how does delegateCall` work? in an effort to better understand the advantages and disadvantages of upgradeable smart contracts.\n\nAll the code we'll be working with here is available in the Upgrades repo of the Foundry Course, available [**here**](https://github.com/Cyfrin/foundry-upgrades-f23/tree/main).\n\n## SmallProxy.sol\n\nLet's take a look at a simple proxy example:\n\n```js\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/proxy/Proxy.sol\";\n\ncontract SmallProxy is Proxy {\n    // This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1\n    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    function setImplementation(address newImplementation) public {\n        assembly {\n            sstore(_IMPLEMENTATION_SLOT, newImplementation)\n        }\n    }\n\n    function _implementation() internal view override returns (address implementationAddress) {\n        assembly {\n            implementationAddress := sload(_IMPLEMENTATION_SLOT)\n        }\n    }\n}\n```\n\n> Note: we're importing `Proxy.sol` from [**openzeppelin**](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/Proxy.sol) as a boilerplate proxy for our example.\n\n### Preface to Yul\n\nThe contract we're importing here uses a lot of `Yul`.\n\n> \"`Yul` is an intermediate language that can be compiled to bytecode for different backends.\" - [**Solidity Docs**](https://docs.soliditylang.org/en/latest/yul.html)\n\nWe won't go too deeply into `Yul`, but please read more in the documentation if it interests you. Note, however, even if you're a really advanced user, avoiding the implementation of really low-level calls is preferred. It's much easier to make significant errors, the lower you are in your code.\n\n### Proxy.sol - a closer look\n\nWithin our `Proxy.sol` contract, we've got the `_delegate()` function. This function is called by `Proxy.sol`'s `fallback()` function. This means any time our contract received data for a function it doesn't recognize, it's going to call our `_delegate()` function.\n\nThe `_delegate()` function, then sends that data over to some `implementation` contract.\n\n<img src=\"/security-section-1/12-upgradeable/upgrades2.png\" style=\"width: 100%; height: auto;\" alt=\"block fee\">\n\nLooking at `SmallProxy.sol` you can see you have these two functions:\n\n```js\nfunction setImplementation(address newImplementation) public {\n        assembly {\n            sstore(_IMPLEMENTATION_SLOT, newImplementation)\n        }\n    }\n\n    function _implementation() internal view override returns (address implementationAddress) {\n        assembly {\n            implementationAddress := sload(_IMPLEMENTATION_SLOT)\n        }\n    }\n```\n\n- **setImplementation()** - changes the implementation contract, effectively allowing a protocol to upgrade.\n- **\\_implementation** - reads the location of the implementation contract\n\nYou may also have noticed `bytes32 private constant _IMPLEMENTATION_SLOT = ...` this is the storage slot where we are storaage the address of our implementation contract. You read more about `Standard Proxy Storage Slots` in [**EIP-1967**](https://eips.ethereum.org/EIPS/eip-1967)\n\nLet's consider a based implementation contract:\n\n```js\ncontract ImplementationA {\n    uint256 public value;\n\n    function setValue(uint256 newValue) public {\n        value = newValue;\n    }\n}\n```\n\nNow we ask ourselves `What data needs to be passed to my proxy contract in order to call this function?`\n\nIf you recall from the last lesson, this data being passed is going to be the encoded function signature and any necessary arguments the function requires! We can get this encoding with a couple helper functions added to `SmallProxy.sol`:\n\n```js\n// helper function\n    function getDataToTransact(uint256 numberToUpdate) public pure returns (bytes memory) {\n        return abi.encodeWithSignature(\"setValue(uint256)\", numberToUpdate);\n    }\n```\n\nNow let's use a little assembly to read the storage slot this value is set to:\n\n```js\nfunction readStorage() public view returns (uint256 valueAtStorageSlotZero) {\n        assembly {\n            valueAtStorageSlotZero := sload(0)\n        }\n    }\n```\n\nWith that all set up, here's what we'd do next:\n\n1. deploy both `SmallProxy.sol` and `ImplementationA.sol`\n2. call the `setImplementation()` function on `SmallProxy.sol`, passing it `ImplementationA`'s address as an argument\n3. acquire the data needed for the transaction being sent\n   > By passing `777` to our `getDataToTransact()` function we have returned: `0x552410770000000000000000000000000000000000000000000000000000000000000309` this encodes the `function signature` with the passed arguement of `777`.\n\nWhen this is passed to our proxy contract, the contract won't recognize the function signature, will call `fallback()` (which calls `_delegate()`) and pass the data to our implementation contract which DOES recognize this data!\n\n4. Send transaction with the data\n\nNow, when we call the `readStorage()` function, we caan see that the value on our proxy contract has indeed been set to `777`!\n\nThis is a great illustration of how data is routed from our proxy contract to the implementation contract. Let's see what happens when we upgrade things by changing the implementation contract.\n\nIf we deploy a new implementation:\n\n```js\ncontract ImplementationB {\n    uint256 public value;\n\n    function setValue(uint256 newValue) public {\n        value = newValue + 2;\n    }\n}\n```\n\n...and subsequently pass this new address to our proxy's `setImplementation()` function...\n\n```js\nfunction setImplementation(address implementationB);\n```\n\nWhen we then pass the same data as before to our proxy contract, we can indeed see this is reaching `implementationB` and we're having returned `newValue +2`!\n\n<img src=\"/security-section-1/12-upgradeable/upgrades3.png\" style=\"width: 100%; height: auto;\" alt=\"block fee\">\n\n---\n\n### Wrap up\n\nNow, with this understanding in hand, it's easy to see the power proxies hold. On one hand, they are very convenient and afford developers some safeguard if things should need to change. On the other - if this process is controlled by a single (or small group) of wallets, this opens the door to some high risk centralization concerns.\n\nNext, we'll be looking at `selfDestruct` and how it can be used to circumvent intended contract funtionality!\n",
          "updates": []
        },
        {
          "lessonId": "69e4923d-69e2-4b4e-9856-272cf26ae896",
          "number": 13,
          "title": "Self Destruct",
          "slug": "self-destruct",
          "folderName": "13-self-destruct",
          "description": "Understand the use and implications of the selfdestruct keyword in Solidity. This lesson explains how selfdestruct can remove contracts and force ETH into specified addresses, a unique behavior with significant impact on contract functionality and security.",
          "duration": 12,
          "videoUrl": "2EgmJID8VxU",
          "rawMarkdownUrl": "/routes/security/1-review/13-self-destruct/+page.md",
          "markdownContent": "---\ntitle: Self-destruct\n---\n\n_follow along with the video_\n\n---\n\n## Forever On-chain ... mostly\n\nThe next concept I want you to know is that of the `selfdestruct()` keyword in Solidity. In essence this keyword will destroy, or delete a contract.\n\n## The Unique Characteristic of Selfdestruct\n\nWhy `selfdestruct` stands out lies in its exceptional behavior once a contract gets destroyed. Any Ethereum (or ETH) residing within the deleted contract gets automatically ‚Äòpushed‚Äô or ‚Äòforced‚Äô into any address that you specify.\n\nUnder normal circumstances a contract that doesn't contain a receive or fallback function (or some other payable function capable of receiving funds) cannot have ETH sent to it.\n\nOnly through the use of `selfdestruct` can you be permitted to push any Ethereum into such a contract.\n\nSo if ever you‚Äôre hunting for an exploit, or you have identified an attack where you need to force ETH into a contract, `selfdestruct` will be your instrument of choice.\n\n## `selfdestruct` in Action\n\nTo get a clear understanding, let‚Äôs put these into practice. Starting with a code base from [Solidity by example](https://solidity-by-example.org/hacks/self-destruct/) - and then carrying it into Remix, we will be able to observe this concept directly in action.\n\n```js\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// The goal of this game is to be the 7th player to deposit 1 Ether.\n// Players can deposit only 1 Ether at a time.\n// Winner will be able to withdraw all Ether.\n\n/*\n1. Deploy EtherGame\n2. Players (say Alice and Bob) decides to play, deposits 1 Ether each.\n2. Deploy Attack with address of EtherGame\n3. Call Attack.attack sending 5 ether. This will break the game\n   No one can become the winner.\n\nWhat happened?\nAttack forced the balance of EtherGame to equal 7 ether.\nNow no one can deposit and the winner cannot be set.\n*/\n\ncontract EtherGame {\n    uint public targetAmount = 7 ether;\n    address public winner;\n\n    function deposit() public payable {\n        require(msg.value == 1 ether, \"You can only send 1 Ether\");\n\n        uint balance = address(this).balance;\n        require(balance <= targetAmount, \"Game is over\");\n\n        if (balance == targetAmount) {\n            winner = msg.sender;\n        }\n    }\n\n    function claimReward() public {\n        require(msg.sender == winner, \"Not winner\");\n\n        (bool sent, ) = msg.sender.call{value: address(this).balance}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n}\n\ncontract Attack {\n    EtherGame etherGame;\n\n    constructor(EtherGame _etherGame) {\n        etherGame = EtherGame(_etherGame);\n    }\n\n    function attack() public payable {\n        // You can simply break the game by sending ether so that\n        // the game balance >= 7 ether\n\n        // cast address to payable\n        address payable addr = payable(address(etherGame));\n        selfdestruct(addr);\n    }\n}\n\n```\n\nLooking closely at the above contracts, we can see that `EtherGame` requires `address(this).balance == targetAmount`. The expectation of the protocol is that any user can only deposit 1ETH and each deposit transaction is checked as a winner.\n\nCan you think of how we'd break these invariants?\n\nBy leveraging `selfdestruct(payable(address(etherGame)));` on our `Attack` contract, we can force ETH to the `EtherGame` contract that isn't accounted for.\n\n```js\nif (balance == targetAmount) {\n  winner = msg.sender;\n}\n```\n\nBy forcing enough ETH to `EtherGame` we can assure the above condition is never met and a winner is never decided!\n\n## Conclusion\n\nThe `selfdestruct()` function is powerful. It's one of the only ways to force a contract to receive ETH that it doesn't want and in so doing exists as an attack vector for any protocol not prepared for it.\n",
          "updates": []
        },
        {
          "lessonId": "bb5432c8-381c-4143-9c43-d37769c15557",
          "number": 14,
          "title": "Fork Tests",
          "slug": "fork-tests",
          "folderName": "14-fork-tests",
          "description": "This final lesson guides you through the process of conducting fork tests, creating a simulated version of the mainnet for testing purposes. It covers the use of tools like Alchemy URL and practical exercises to solidify your understanding of Solidity and smart contract development.",
          "duration": 10,
          "videoUrl": "TPYcJeNgSrQ",
          "rawMarkdownUrl": "/routes/security/1-review/14-fork-tests/+page.md",
          "markdownContent": "---\ntitle: Fork Tests & Congrats!\n---\n\n_follow along with the video_\n\n---\n\n## Forking Mainnet\n\nForking is a valuable tool is a developer's box, it effectively takes a reference snapshot at a given block height on the provided chain. In practice, this allows us to interact with protocols as though we were interacting with them on mainnet.\n\n## Fork Tests in Foundry\n\n```bash\nforge test fork-url $MAINNET_RPC_URL\n```\n\nThis command in foundry tells the framework to run your tests while referencing a fork of the provided RPC URL, allowing you to interact with mainnet contract locally.\n\nAnother way to fork is within the test contract directly.\n\n```js\nfunction setUp() public {\n    vm.createSelectFork({blockNumber: 0, urlOrAlias: \"mainnet\"})\n}\n```\n\n> Note: `mainnet` will need to be set as an alias in your `foundry.toml` under a new variable `[rpc_endpoints]`\n\n```js\n[rpc_endpoints];\nmainnet = \"{MAINNET_RPC_URL}\";\n```\n\nWith the above in place running the following will run your tests with respect to a fork of a live chain!\n\n```bash\nforge test\n```\n\n## Useful Resources &amp; Exercises\n\nIf any concepts covered in this blog post seem confusing or new to you, take a moment to check out the Foundry Full Course here on Updraft ([**Foundry Fundamentals**](https://updraft.cyfrin.io/courses/foundry) & [**Advanced Foundry**](https://updraft.cyfrin.io/courses/advanced-foundry)) to level up those concepts and give you all the information you need to succeed here. These resources will expedite your learning and help you solidify the fundamental concepts.\n\nBefore signing off, I'd encourage you to join the [Cyfrin Discord](https://discord.com/invite/NhVAmtvnzr). This is an excellent platform where you can connect, collaborate, and share insights with a diverse group of people working on similar goals.\n\nIn addition to this, check out the [**Discussions on GitHub**](https://github.com/Cyfrin/security-and-auditing-full-course-s23/discussions) - this is a phenomenal place to get support and have your questions answered in a way that will be indexed by search engines and AI in an effort to improve the experience for people coming behind us.\n\n<img src=\"/security-section-1/14-fork-tests/forking1.png\" style=\"width: 100%; height: auto;\" alt=\"block fee\">\n\nCongratulations on finishing the refresher! Take a break, you greatly deserve it for getting this far!\n",
          "updates": []
        }
      ]
    },
    {
      "sectionId": "1645f5be-0f61-49bc-aba5-9485020053bd",
      "number": 2,
      "title": "What is a smart contract audit",
      "slug": "audit",
      "folderName": "2-audit",
      "lessons": [
        {
          "lessonId": "5a691a25-f2f3-4e52-a6d6-7fbb09d85976",
          "number": 1,
          "title": "What is a smart contract audit?",
          "slug": "what-is-an-audit",
          "folderName": "1-what-is-an-audit",
          "description": "This lesson delves into what a smart contract audit, or more accurately, a security review, truly entails. It discusses the three phases of a security review, the importance of these reviews in ensuring code security on immutable blockchain systems, and effective techniques used in the process. The lesson also emphasizes the distinction between the terms 'audit' and 'security review' and their implications in the context of blockchain and smart contracts.",
          "duration": 10,
          "videoUrl": "w-WVn_ZUDQ4",
          "rawMarkdownUrl": "/routes/security/2-audit/1-what-is-an-audit/+page.md",
          "markdownContent": "---\ntitle: What is a Smart Contract Audit?\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\nYou might think you've got a grip on what a smart contract audit is all about, but this lesson aims to help you dive deeper and truly comprehend the whole process. Brace yourself, as today we are stepping into the interesting realm of security reviews.\n\nLet's start off by stating that the term \"smart contract audit\" is a bit of a misnomer. As a more appropriate alternative, I am a stout advocate of \"security review.\" I even have a T-shirt to prove my allegiance!\n\nYou might be wondering why this change of terms is required. Well, it‚Äôs because the term 'audit' might wrongly insinuate some kind of guarantee or even encompass legal implications. A security review, being free of these misconceptions, exudes the essence of what we are actually doing: looking for as many bugs as possible to ensure maximum code security.\n\n_Note_: Despite this, many protocols still insist on requesting a \"smart contract audit,\" so it's eminent to know that the terms are interchangeable. When you hear \"security review\", think \"smart contract audit\" and vice versa. Protocols are often unaware of these nuances, but you, as a trained security researcher, know better!\n\nBy now, I hope you're questioning with anticipation: \"What does a security review entail?\"\n\n## The Three Phases of a Security Review\n\nRight in our GitHub repository, we detail the three phases of a security review and what that process looks like. To give you a heads-up, there really isn't a \"one-size-fits-all\" approach to smart contract auditing. There are several unique strategies, each bringing a different set of pros and cons to the table.\n\nIn this post, we'll discuss two particularly effective techniques, the \"Tincho\" and the \"Hans\", to help familiarize you with the process. However, remember that these are just examples; there isn‚Äôt a definitive \"correct\" way of performing a security review.\n\nBefore we delve into the specifics, let's discuss why security reviews are critical.\n\n## Importance of Security Reviews\n\nAs code deployed to a blockchain is immutable, it‚Äôs crucial that it's error-free before deployment. The permissionless and adversarial nature of the blockchain means that protocols need to be ready to repel malicious users. Failure to do so can lead to hefty monetary losses, as evidenced by the nearly $4 billion stolen due to smart contract vulnerabilities last year.\n\nBut the benefits of conducting a security review go beyond just minimizing vulnerabilities. It also aids protocol developers in enhancing their understanding of the code itself, thereby accelerating feature implementation and increasing effectiveness. A security review can also familiarize your team with the latest trends and tooling in the space.\n\nWith this understanding, let's familiarize ourselves with the process of a typical audit.\n\n### Reach Out for a Review\n\nThe review process begins when a protocol reaches out, be it before or after their code is complete. After they make contact, it's important to deduce the duration and thus the cost of the audit based on the scope and complexity of the code. You can review the rough approximation of audit duration in terms of Lines of Code (LOC), shown in our thread.\n\nHaving the commit hash (the unique ID of the codebase) allows you to finalize the start date and final price. Some auditors may request a down payment to book the time slot.\n\n### Audit Begins\n\nNow that the admin work is done, auditors can roll up their sleeves and get to work. Using everything in their arsenal, they will strive to find as many vulnerabilities as possible in your code.\n\n### Initial Report\n\nOnce the review period is over, the auditors compile an initial report. This report includes all findings, categorized according to severity (high, medium, low, noncritical) and potential for improving gas efficiency.\n\n### Mitigation Phase\n\nThe protocol's team then has a fixed period to address the vulnerabilities found in the initial audit report. More often than not, they can simply implement the recommendations provided by the auditors.\n\n### Final Report\n\nUpon completion of the mitigation phase, the audit team compiles a final audit report focusing exclusively on the fixes made to address the initial report's issues. Hopefully, this cements a strong relationship between the protocol and the audit team, fostering future collaborations to keep Web Three secure.\n\n## Ensuring a Successful Audit\n\nFor an audit to be as successful as possible, you should ensure that there's:\n\n- Good documentation\n- A solid test suite\n- Clear and readable code\n- Clear communication channels\n- An initial video walkthrough of the code\n\nBy considering auditors as an extension of your team, maintaining an open channel of communication, and providing them with the necessary documentation and context, you ensure the audit process is smoother and more accurate.\n\nLastly, remember that a smart contract audit is an integral part of a security journey rather than an endpoint. Even after an audit, any subsequent code changes need to be reviewed as the new code is unaudited, regardless of the size of the change.\n\n## In Closing\n\nWhile this post comprehensively outlines a typical security review, also known as a \"smart contract audit\", it's essential to remember that no two audits are the same. Depending on your specific circumstances, tweaks to the above process might be necessary.\n\nStay tuned for upcoming posts where we'll discuss the difference between competitive audits and private audits! Don't forget to reach out to the Cypher team if you're looking for a security audit. Until next time, stay safe!\n\n> \"There is no silver bullet in smart contract auditing. But understanding the process, methods, and importance of regular security reviews can significantly enhance your protocol's robustness.\"\n",
          "updates": []
        },
        {
          "lessonId": "66f3d1fb-3ed8-4a12-9164-49b28b28281a",
          "number": 2,
          "title": "The audit process",
          "slug": "the-audit",
          "folderName": "2-the-audit",
          "description": "This lesson offers a comprehensive guide to the smart contract audit process, outlining the key steps from initial context gathering to the final mitigation review. It highlights the importance of embedding security audits throughout the development lifecycle, following the OWASP guide, to ensure the continuous security of smart contracts.",
          "duration": 5,
          "videoUrl": "O6ZnjMpKrFM",
          "rawMarkdownUrl": "/routes/security/2-audit/2-the-audit/+page.md",
          "markdownContent": "---\ntitle: The Audit (Security Review Process)\n---\n\n_Follow along with this video:_\n\n\n\n---\n\nWhen developing smart contracts, understanding and following the audit process is a crucial step towards achieving a more secure protocol. This guide will walk you through the entire audit process from initial review to the final mitigation phase, and why it's important to weave this process throughout your development lifecycle.\n\n## High-Level Overview of The Audit Process\n\nThe smart contract audit process can be briefly summed up in these steps:\n\n1. **Get Context**: Understand the project, its purpose and its unique aspects.\n2. **Use Tools**: Employ relevant tools to scan and analyze the codebase.\n3. **Manual Reviews**: Make a personal review of the code and spot out unusual or vulnerable code.\n4. **Write a Report**: Document all findings and recommendations for the development team.\n\nTo illustrate how this pans out in reality, we can look at the Tincho method used to audit ENS ‚Äì a process that landed him a cool $100,000 payout! We'll delve into this later on.\n\n## Diving Deeper: Breakdown of the Audit Process\n\nFor a more detailed perspective, let‚Äôs consider the process as broken into three distinct phases:\n\n**Initial Review:** In this phase, auditors go through the code to scope it. This gives an idea of how much time might be required for the audit, which can then be used to establish pricing. Key tasks include identification of all the contract‚Äôs dependencies and a general overview of the code. At this stage, auditors don‚Äôt dig deep into anything yet.\n\n**Reconnaissance:** The actual work begins here. Auditors start looking through the code thoroughly and start utilizing their analysis tools.\n\n**Vulnerability Identification:** Identifying all vulnerabilities and understanding how these vulnerabilities could be exploited. Post identification, a detailed report is written, which comprises all identified vulnerabilities, and importantly, the steps to take to make the protocol more secure.\n\nYour ultimate aim should be to make the protocol more secure. Therefore, ensure to take notes of all findings and steps and elaborate it in your report.\n\n> \"Your job is to do whatever it takes to make the protocol more secure.\"\n\nDifference in Audit Styles: Note that the aforementioned process details a private audit or a traditional security review. For competitive audits, you are typically optimized for time and identifying as many high vulnerabilities as possible.\n\nAfter handing over the report to the protocol, they should set about implementing every recommended change you've made in your report. Once all vulnerabilities are mitigated, they will hand the code back to you for the final phase.\n\n**Mitigation Review:** This is where you, as the auditor, have to verify that all the changes made actually fix the problems and, importantly, that no new bugs have been introduced.\n\nRemember, the goal of conducting contract audits isn't simply to tick a box. It's about ensuring the security and smooth running of the smart contract at all stages of its lifecycle. The more audits you conduct, the better you become at identifying potential security issues.\n\n<img src=\"/security-section-2/2-the-audit/the-audit1.png\" style=\"width: 100%; height: auto;\">\n\n## Embedding Security Audits in Development Lifecycle\n\nThe process of developing a smart contract follows a lifecycle too. According to the [OWASP](https://www.owasp.org/index.php/Main_Page) (The Open Web Application Security Project) guide, security isn't just a one-off step but a part of your ongoing smart contract journey. It is about fostering the mindset that security is continuous. The smart contract developer lifecycle entails the following stages:\n\n1. **Plan and Design**\n2. **Develop and Test**\n3. **Get an Audit**\n4. **Deploy**\n5. **Monitor and Maintain**\n\nOWASP strongly emphasizes that embedding security considerations into all stages of your Development Lifecycle is what it takes to build a secure decentralized application, not just conducting a one time smart contract ‚Äúcheck.‚Äù Before deploying your contract, think hard about the security measures in place and ensure to maintain and monitor your code post-deployment.\n\nWhile a smart contract security audit is an absolute necessity, also ensure to plan for any contingencies post-deployment. The key takeaway here is this: Smart contract security is a crucial part of the smart contract development lifecycle and should be treated with as much care as the development of the smart contract itself.\n",
          "updates": []
        },
        {
          "lessonId": "92351a2d-d6b4-4e2b-bcb5-885069e268d7",
          "number": 3,
          "title": "Rekt test",
          "slug": "rekt-test",
          "folderName": "3-rekt-test",
          "description": "This lesson introduces the Rekt Test, a set of critical questions designed to assess a protocol's readiness for a security audit. Covering aspects like documentation, security roles, and protective measures, it serves as a foundational checklist for developers to gauge if their protocols are prepared for thorough security evaluations.",
          "duration": 4,
          "videoUrl": "D9RdC-3jX9M",
          "rawMarkdownUrl": "/routes/security/2-audit/3-rekt-test/+page.md",
          "markdownContent": "---\ntitle: Rekt Test\n---\n\n_Follow along with this video:_\n\n\n\n---\n\n## The Rekt Test\n\nThe Rect Test is highly important as it poses a set of questions to gauge your protocol's preparedness for an audit. This tool helps insists that you think about security measures from a more proactive angle. Should your protocols fail to answer these questions, the chances are that they're not audit-ready.\n\nThe questions touch on several aspects like documentation, security roles, security tools, and protective measures, among others. Here's a curated list:\n\n- **Do you have all actors roles and privileges documented?**\n- **Do you keep documentation of external services contracts and Oracles?**\n- **Do you have a written and tested incident response plan?**\n- **Do you document the best ways to attack your system?**\n- **Do you perform identity verification and background checks on all employees?**\n- **Do you have a team member with security defined in the role?**\n- **Do you require hardware security keys for production systems?**\n- **Do you define key invariants for your system and test them on every commit?**\n- **Do you use the best automated tools to discover security issues in your code?**\n- **Do you undergo external audits and maintain a vulnerability disclosure or bug bounty program?**\n- **Have you considered and mitigated avenues for abusing users of your system?**\n\n<img src=\"/security-section-2/3-rekt/rekt1.png\" style=\"width: 100%; height: auto;\">\n\nAs developers, you must be able to answer all these queries before you proceed with an audit. If you're dealing with a protocol that fails to answer these questions, advise them on their lack of readiness and hold off on any audits until they are ready.\n\n> \"Delegate responsibility to someone on your team for security - Give your project a sense of ownership and a point person to handle any security breaches.\"\n\nWhile using hardware security keys might seem out of place in a digital space, they act as an additional layer of security that is arguably better than an authentication app or an SMS.\n\n## Nascent Audit Readiness Checklist\n\nThis checklist is another effective method to assess if you're ready for an audit. Though it offers different perspectives, it's another tool that helps you determine if your protocols are prepared for audits.\n\n## Basic OpSec and Other Essential Steps\n\nBefore we dive into the details of smart contract reviews, let's briefly touch on Basic Operational Security (OpSec). Protocols must fulfill certain requirements that ensure the smooth running of the deployed contracts. This includes running invariants, using automated tools for discovering security issues, maintaining a disclosure program for vulnerability, and most importantly, considering users.\n\n## External Audits and Other Security Reviews\n\nAn external audit is a powerful tool to ensure the resilience of your code against vulnerabilities. Apart from uncovering potential security risks, these audits also help maintain a Bug Bounty or Vulnerability Disclosure program.\n\nThese programs are beneficial as they encourage the identification of system vulnerabilities, thereby improving the overall security of the smart contract. It also creates a sense of accountability towards maintaining a secure system.\n\n## Post-deployment Measures\n\nEven after all the above steps, the process doesn't end with deploying the contract. Post-deployment planning, bug bounties, disaster recovery drills, and diligent monitoring are critical parts of the life-cycle of any smart contract. These measures ensure your readiness to deal with potential hacks and your ability to respond in a timely manner.\n\n<img src=\"/security-section-2/3-rekt/rekt2.png\" style=\"width: 100%; height: auto;\">\n\n)Consider these guidelines as a checklist. If your protocols can't tick off each of these requirements, you should postpone any audits or reviews until your protocol is ready to ship, and more importantly, able to withstand the tests of security after being live.\n",
          "updates": []
        },
        {
          "lessonId": "27302144-7410-43ef-939a-a772d20cbed8",
          "number": 4,
          "title": "Security Tools",
          "slug": "tools",
          "folderName": "4-tools",
          "description": "",
          "duration": 5,
          "videoUrl": "RFNY64PLRiM",
          "rawMarkdownUrl": "/routes/security/2-audit/4-tools/+page.md",
          "markdownContent": "---\ntitle: What tools do we use in Security Reviews?\n---\n\n_Follow along with this video:_\n\n\n\n---\n\n## Your First Line of Defense: Test Suites\n\nYour classic test suite is your project's first line of defense. Regarded as the foundry and hard hat of your codebase, they are standard tools like Remix tests and Rip Truffle. These powerful tools can help maintain a healthy, secure codebase.\n\nThroughout this lesson, we will deep dive into various robust test suites that should be emulated to enhance codebase security. Also, look forward to learning about test coverage in our forthcoming security reviews.\n\n## Static Analysis: Debugging Without Execution\n\nStatic analysis represents the next level of defense. This method automatically checks for issues without executing your code, hence the debugging process remains static. Slither, Fornelizer, Mithril, and Aderyn are some prominent tools in the static analysis category.\n\nThroughout our discussions, we'll weigh heavily on Slither and Aderyn, imparting knowledge on these invaluable tools.\n\n## Fuzz Testing: Randomness Meets Tests\n\nNext on our list is fuzzing or fuzz testing. Remember when we spoke about providing random data inputs during testing? Well, fuzz testing is just that!\n\n<img src=\"/security-section-2/4-tools/tools1.png\" style=\"width: 100%; height: auto;\">\n\nIt's an exceptional way to quickly uncover any esoteric bugs in your smart contracts. And then, there's stateful fuzzing. In 'stateful' testing, the system recalls the state of the previous fuzz test and proceeds with that state in the new test. No, it has no bearing on your cat's fuzziness, but this method would genuinely pass that test if it existed!\n\nIn future audits, we'll explore how to write stateful fuzz tests, invariant tests, and many more.\n\n## Formal Verification: Putting Math Into the Code\n\nFormal verification is a broad term for deploying formal methods to affirm the correctness of hardware or software. Often, these methods involve converting the codebase into mathematics and deploying mathematical proofs to authenticate that the code does or doesn't do something specific.\n\nA popular formal verification approach is symbolic execution. This method converts your Solidity function into math or a set of boolean expressions. Manticore, Sartora, Z3 stand tall in this domain.\n\nWe will delve deeper into formal verification in later sections.\n\n## AI Tools: Not Quite There Yet\n\nLastly but importantly, AI tools offer another dimension to imagine code auditing functionalities. However, despite their potential, they have some distance to cover before they provide substantial value for securing a codebase. At present, using AI tools could serve as a sanity check or aid in looking for something quickly in a codebase. But remember, if a project suggests it has been audited by an AI tool like Chatgbt, it is best to be skeptical and question if the project takes security seriously.\n\n## Wrapping Up\n\nAn important takeaway for you is that around 80% of actual bugs and competitive audit bugs are not auto-detectable by machines, including our present-day AI tools]. This revelation underlines two key facts:\n\n1. Our current tools aren't up to the mark, and we need better ones.\n2. Human auditors and human security researchers remain paramount. The vast majority of bugs often stem from business logic and incorrect implementations rather than common solidity or cryptography oddities.\n\nThroughout this course, we will reinforce and expand on these lessons, further equipping you to create more secure, robust codebases.\n\nThanks for reading this lesson, we'll see you on the next one.\n",
          "updates": []
        },
        {
          "lessonId": "0c8d34f8-8bce-4d6c-9370-e85de0d4be31",
          "number": 5,
          "title": "What if a protocol I audit gets hacked?",
          "slug": "hacked",
          "folderName": "5-hacked",
          "description": "",
          "duration": 4,
          "videoUrl": "oHER_x1vshM",
          "rawMarkdownUrl": "/routes/security/2-audit/5-hacked/+page.md",
          "markdownContent": "---\ntitle: What if I do a Security Review and the protocol gets hacked?\n---\n\n_Follow along with this video:_\n\n\n\n---\n\n# Penetrating the Scenario: What If Your Security Audit Fails?\n\nAs the world moves towards a more digital infrastructure, the importance of security audits cannot be overstated. But who carries the blame when these audits fail? Should it always land at the feet of those responsible for conducting the audit?\n\nWhile broaching upon this intricate subject, I recently had a pleasant chat with a fellow security researcher, Tincho, who imparted an inspiring perspective. He offers valuable insights on the way we should perceive the role and responsibilities of auditors in these precarious scenarios. Think of it as your handy guide to navigating through the messed-up aftermath of a security audit gone wrong.\n\n## Redefining the Role of Auditors\n\nIn the eyes of many, the fundamental purpose of a security audit is to identify and rectify the most critical vulnerabilities in a system. However, Tincho encourages us to look beyond this simplistic view.\n\n> Auditors should provide value, regardless of whether or not they spot critical issues.\n\nIn other words, an auditor's value doesn't solely rest upon their ability to find existing flaws. Instead, their advises should strengthen the overall security protocol and offer pragmatic solutions for future scenarios.\n\nA successful auditor should solidify his reputation based on the efficacy of the overall system rather than isolated cases of critical incidents. The ultimate goal should always be to bolster Ethereum's security rather than simply mitigating immediate threats.\n\n## Who Owns the Blame?\n\nThe notion of finding a scapegoat when a system is exploited is a regressive one.\n\n> Many factors could lead to the successful exploitation of a vulnerability.\n\nAttributing the failure of a system to an auditor's incompetency is simplistic and misguided. If a vulnerability was missed, it means it slipped past numerous stages of checks and balances, of which an audit is just one. When a flaw goes unnoticed for as long as four months, there are perhaps lapses in system monitoring and in many other security parameters.\n\n## The Auditor‚Äôs Role in the Wake of a Breach\n\nSo, what should an auditor do if a protocol they've reviewed ends up compromised? The answer is that a responsible security partner should not abandon their client in the midst of a crisis.\n\nAs an auditor, your role is to help mitigate the damage, restrict the scope of the attack, and possibly identify the hackers. A quality auditor must be there, lending their expertise, during the inevitable chaos that ensues after a breach.\n\n> Your responsibilities to the client are outlined in the agreement that you initially signed. However, to be a trusted partner and maintain a good relationship, you will need to go above and beyond in assisting them in whatever scenario arises.\n\n## Conclusion\n\nWhile 100% secure systems may be the ultimate goal, it is also a journey. It was great catching up with Tincho whose outlook on security audits balances realism with the optimistic pursuit of improvement. He perfectly encapsulates that the blame game is counterproductive. Instead, every party involved in a security protocol must work together as a team and learn from any failure to ensure a safer, more secure digital environment.\n",
          "updates": []
        },
        {
          "lessonId": "100452f0-5541-4c78-9d25-a8c86e433cfa",
          "number": 6,
          "title": "Top Web3 Attacks",
          "slug": "attacks",
          "folderName": "6-attacks",
          "description": "",
          "duration": 1,
          "videoUrl": "MUMRXR4GEfA",
          "rawMarkdownUrl": "/routes/security/2-audit/6-attacks/+page.md",
          "markdownContent": "---\ntitle: Top kinds of Attacks in Web3 Today\n---\n\n_Follow along with this video:_\n\n\n\n---\n\nWelcome to this lesson, fellow warriors of digital combat. As stated several times, the essence of excelling in the cybersecurity landscape lies in embodying the **attackers and defenders mindset**. It is a continuous journey, an exhausting climb that requires us to be constant learners and relentless improvers. Striding through this daunting field, I will introduce you to countless tools, snippets of wisdom, and enticing exercises that catalyze your growth. Our vision is to master the art of digital defense, to create a widespread ambiance of cyber resilience, and to safeguard the intricate webs of our technological world.\n\nIn this lesson, we'll dive deep into the updated list of recent top attack vectors, eloquently brought to us by Peter from Block Threat Intelligence. Over time, we'll dissect each lurking danger and learn how to counteract these digital dark arts.\n\n## Unraveling the Top Attack Vectors\n\nImpenetrable security is a myth. There are countless cracks where potential threats can sneak in, countless crevices that serve as entrances for the malevolent spirits of the cyber world. Expanding our arsenal of countermeasures begins with understanding these threats ‚Äì the **‚ÄúTop Attack Vectors.‚Äù**\n\n1. **Private Keys** - The cryptic combinations that possess the power to unlock a user's digital identity. It is their vulnerability that tops our list.\n2. **Reward Manipulation** ‚Äì This vector involves the manipulation of decentralized incentive systems that could disrupt the balance and fairness within a network.\n3. **Price Oracle Manipulation** ‚Äì Imagine a threat actor manipulating the external information that a smart contract uses to execute. It‚Äôs a chilling thought, isn't it?\n4. **Insufficient Access Controls** ‚Äì A classic barrier, or a lack thereof, between sensitive resources and potential threats.\n5. **Logic Error Function Parameter Validation** - A less discussed but equally threatening potential flaw in a program's logic or parameters affecting its execution.\n6. **Re-entrance** - This sneaky attack can trick a contract into enabling an attacker to take control or drain resources.\n7. **Governance Misconfiguration** ‚Äì Often overlooked, this comprises of loops and backdoors in governance models that could lead to devastating breaches.\n\nCollectively, we will tackle these bugbears and issues in our forthcoming security reviews.\n\n> Always remember, my friends - Cybersecurity isn't about the systems or the codes; it's about maintaining a mindset. A mindset akin to an endless game of chess, predicting the opponent‚Äôs moves and always staying a step ahead.\n\n# Engaging in Persistent Learning and Improvement\n\nTo be clear, this journey won't be a walk in the park. We will get hit, and we will fall. Still, we never surrender, and we never retreat. The best defense arms itself with knowledge and experience. Your mind, sharpening with each passing moment, is your greatest weapon.\n\nIn the forthcoming series of digital security audits, you'll get hands-on practice with data analysis, encryption methods, tackling suspicious scripts, and combating various cybersecurity threats. The exercises will stimulate your intellectual growth and help ingrain essential concepts into your tech-strategist mind.\n\nStay tuned, stay vigilant, and remember ‚Äì genuine cybersecurity lies not in the security of the systems, but in the security of the minds that create and protect them. To win any battle, we must first win the war within ourselves. Let our collective journey of learning and improvement commence.\n\nJoin me as we walk down the path of mastering cybersecurity, steadily navigating the pitfalls, and rising to the challenge it presents. Together, we will fortify the digital world against the threats it faces. Together, we will build a safer, unpenetrable cyberspace.\n\n\"Optimism is true moral courage.\" Let's face our digital future with optimism, courage, and an ever-evolving cybersecurity acumen. Stay hungry. Stay Foolish. Stay Secured.\n",
          "updates": []
        },
        {
          "lessonId": "42962aa0-116e-45ae-8c31-2d01d7313526",
          "number": 7,
          "title": "Recap",
          "slug": "recap",
          "folderName": "7-recap",
          "description": "",
          "duration": 3,
          "videoUrl": "wnU8Wz4JiE8",
          "rawMarkdownUrl": "/routes/security/2-audit/7-recap/+page.md",
          "markdownContent": "---\ntitle: Lesson 2 Recap\n---\n\n_Follow along with this video:_\n\n\n\n---\n\n## The Basics of Smart Contract Audits\n\nA smart contract audit is essentially a timed, extensive examination, targeting possible security vulnerabilities within a smart contract. But why is it vital?\n\nWell, its main function is to ensure that a protocol is as shielded and invulnerable as possible. It's like drawing a hero's map to the treasures of security. Any detected bugs, vulnerabilities, or inefficiencies are noted and suggested fixes, enhancements, or optimizations provided.\n\nHowever, we must accept that there's no one ultimate solution to auditing or conducting security reviews. So, there's absolutely \"no silver bullet,\" as we may say. It's not a one-size-fits-all scenario. The process is unique for each piece of code and requires custom examination depending on its specific function and architecture.\n\n## The Fundamentals of a Security Review\n\nGenerally, a security review is divided into three crucial stages:\n\n1. Initial review: This phase involves drafting the scope and engaging in reconnaissance.\n2. Write up vulnerabilities: All vulnerabilities are documented in detail.\n3. Protocol fixes: At this stage, the flaws are tackled, and verification is conducted to affirm if the fixes work perfectly.\n\nKeep in mind that ensuring security isn‚Äôt only a crucial point in the smart contract development lifecycle, it's a continuous, never-ending process!\n\n> \"_Security shouldn't just be an afterthought or some box you check. You need to have a security mindset from day one_\".\n\nThinking about post-deployment planning, monitoring and maintaining is just as important as the development itself.\n\n## Tooling for Security Review\n\nIn future posts, we'll be delving into the various tools utilized in conducting security reviews. Trust me, you'll need to get your hands dirty with resources like static analysis, Slither, Adarin, invariant tests and fuzzing form of verification, AI, etc.\n\nBefore any project undergoes an audit, it should ideally comply with a safety checklist or preferably, the rect test 100%. Why? Because, as security researchers, we need to be continually learning and evolve.\n\nAlways remember, be it in 2023, 2024, or 2025, the key is to keep mastering the top attack vectors.\n\n## Learning from the Past to Secure the Future\n\nLet's briefly touch on some of the top attacks that took place in 2023, and probably, would recur in the years to come. Take reentrancy, for instance. Since 2016, this issue has lingered, hitting time and again. But there's hope.\n\nThrough this course, our aim is to drop that number to zero! A drop in reentrancy issues to zero, in 2024! An ambitious goal, you say? But one that we must strive for because no one deserves to fall victim to these malicious hacks.\n\nLet's bet on improving the security of the crypto ecosystem by starting with your own smart contract, are you ready?\n",
          "updates": []
        },
        {
          "lessonId": "4c9a5a26-4242-41f9-8764-093d3776afef",
          "number": 8,
          "title": "Exercises",
          "slug": "exercises",
          "folderName": "8-exercises",
          "description": "",
          "duration": 3,
          "videoUrl": "PacZkQkdwcY",
          "rawMarkdownUrl": "/routes/security/2-audit/8-exercises/+page.md",
          "markdownContent": "---\ntitle: Exercises\n---\n\n_Follow along with this video:_\n\n\n\n---\n\n## Continual Learning in Security Research\n\nThe landscape of security research changes rapidly. As key players in this space, we need to keep learning and adapting. It's only through constant exposure and education that we can stay ahead of attackers.\n\nAny time a hack takes place, we have a chance to glean insights from the exploit and to improve our defenses against similar future threats. One efficient way of staying well-informed is by subscribing to security newsletters and reports.\n\n> \"Education and learning in the realm of security research are an ongoing journey, not a destination.\"\n\n### Solidity and Other Learning Tools\n\nTo get started, there are various resources you can tap into. Here, I'll suggest some that I find particularly helpful:\n\n1. **Solidit:** We plan to utilise Solidit later on in the journey, and registering now would give you a head start.\n2. **Rekt News:** Personal favourite that gives updates consistently.\n3. **Ethereum weekened &amp; Consensus Diligence Officer CIA:** Excellent sources to sign-up as well.\n\nSign up for a resource that suits your needs and preference. What matters is maintaining a continuous stream of information.\n\n<img src=\"/security-section-2/8-exercises/ex1.png\" style=\"width: 100%; height: auto;\">\n\n## Kick-starting Smart Contract Audit\n\nNow that we've touched base with staying updated, it's time we turned our attention to the central theme of the day ‚Äî a smart contract audit. This segment will provide a high-level overview of what it is and what the process looks like.\n\n### The Password Store Audit\n\nParticularly, we'll be focusing on the Password Store Audit. At the time of recording, this was a **CodeHawks First Flight Audit**.\n\nHaving covered all that, take a moment, take a deep breath, go through your notes or even better, stand up for a little stretch or go get a coffee. Once you‚Äôre ready, we will dive into an end-to-end audit with a minimal code base. Our mission? Stopping hackers from destroying our smart contracts and learning plenty about the audit process.\n\nBefore we jump into our first audit, make sure to take a break and prepare to give this your all.\n\n---\n\nEnd of lesson - See you next time when we begin our journey into the world of smart contract auditing together!\n",
          "updates": []
        }
      ]
    },
    {
      "sectionId": "62db753e-7568-4d6a-b630-823949273491",
      "number": 3,
      "title": "Your First Audit | PasswordStore",
      "slug": "first-audit",
      "folderName": "3-first-audit",
      "lessons": [
        {
          "lessonId": "074d29d9-9aac-4daf-b61f-3b040acc2acd",
          "number": 1,
          "title": "Your First Security Review",
          "slug": "first-review",
          "folderName": "1-first-review",
          "description": "",
          "duration": 5,
          "videoUrl": "tTu_9DW_9n8",
          "rawMarkdownUrl": "/routes/security/3-first-audit/1-first-review/+page.md",
          "markdownContent": "---\ntitle: Your First Security Review\n---\n\n_Follow along with this video:_\n\n\n\n---\n\nWelcome everyone! I hope you're well-rested, rehydrated, and ready to dive into the nitty-gritty of how smart contract audits work. We've had a good start with a high-level overview of what a smart contract audit or a security review contains. Now, we're going to go a level further by conducting not one, but a handful of audits from sections 3 to 8.\n\nThis is an exciting journey to improve our understanding of audits. We'll strengthen our knowledge and learn from some of the best people in the world such as Hans, the number one competitive auditor in the world for the first half of 2023. Now let‚Äôs kick things off with the Password Store audit.\n\n## The Password Store Audit: A Closer Look\n\nFor today's adventure, we're immersing ourselves into a scenario where we'll perform our own private audit, just like you could if you were working for a firm like Cyfrin IO. It's a very immersive and experiential way of learning as we'll virtually submit a request for an audit, engage in the inbound process, and review the audit in detail.\n\n<img src=\"/security-section-3/1-review/review1.png\" style=\"width: 100%; height: auto;\">\n\n## What‚Äôs the Catch?\n\nNow, don't be fooled. We‚Äôve picked a shorter codebase with minimal bugs for this exercise - one with less than 20 lines of code in fact, making it easier to understand at this stage. But remember, being a security expert means finding quirks where others might not see them.\n\nThis process might not be as straightforward as it seems, as clients often lack the knowledge and expertise that you bring. Thus, it is crucial that we don‚Äôt miss out on any bugs and threats.\n\n## Remember the Phases\n\nIt‚Äôs important to remember the phases for each audit or security review. They include:\n\n- Initial review\n- Protocol fixes\n- Mitigation review\n\nIn this course, our main focus will primarily be on the initial review. After the protocol fixes the identified bugs in the code base, the initial review is usually repeated, sans the scoping, which has already been done.\n\nHaving this strategy helps to keep our goals organized and in focus.\n\nSo, with the expectations set and our targets defined, let's move ahead and commence our very first smart contract audit or security review. We'll start off with a scenario that will help us better understand what our roles as auditors will look like.\n\n**Stick around for the next few sections where we truly get our hands on the auditing process and uncover the complexities within the audits!**\n",
          "updates": []
        },
        {
          "lessonId": "2024196b-0a32-4a2e-a04b-da11d01beb92",
          "number": 2,
          "title": "Scoping: Etherscan",
          "slug": "etherscan",
          "folderName": "2-etherscan",
          "description": "",
          "duration": 6,
          "videoUrl": "jD9_ZAOf6hk",
          "rawMarkdownUrl": "/routes/security/3-first-audit/2-etherscan/+page.md",
          "markdownContent": "---\ntitle: Scoping Raw Etherscan\n---\n\n_Follow along with this video:_\n\n\n\n---\n\nIn this lesson, we'll examine the initial steps of performing a security review with live examples, focusing on a Password Store audit. I'm going to take a deep-dive into the scoping phase, which is the primary step in conducting a security review.\n\n## The Scoping Phase and Initial Review\n\nThe scoping phase is where we receive the contract and fathom the scope of the review for this particular security audit of a Password Store. Conventionally, like any other audit exchange, the codebase will be solicited for immediate auditing with the end goal of gaining official listing.\n\nImagine a scenario like this:\n\n_CLIENT: \"Hi, we're the Password Store audit team looking to get our codebase audited ASAP to get it listed officially.\"_  \n_AUDITOR: \"Hi Password Store, I'm beginner auditor number one. Really excited to help. Could you send your codebase to me?\"_  \n_CLIENT: \"Sure, here's the etherscan link to our codebase.\"_\n\nThis exchange is all too common. However, it poses a high risk.\n\nWhy?\n\nBecause what you've received is simply an etherscan link to the contract that's been verified on-chain. While it's great that it's been verified on-chain, this should immediately raise a red flag. It's not acceptable to perform an audit or a security review on a code base that is exclusively on Etherscan.\n\n## The Downside of Relying On Etherscan Exclusively\n\nThe point of security reviews is not just to detect bugs but also to get an understanding of the code's maturity level. You can't gage things like whether they've a test suite, a deployment suite or an evaluation of the overall maturity of the codebase just by looking at an exclusively Etherscan-based codebase. As a security researcher, our aim is to promote and propagate secure codebases, leaving all protocols interacting with us better equipped to secure their own code.\n\n> **Remember: Secure protocols not only safeguard the code but also our reputation as researchers. They will likely blame us for a security breach if we've audited a compromised codebase.**\n\nIf all they provide is an etherscan link, can you assure the protocol's safety? In these cases, the answer is a harty **NO**.\n\n## Nowhere to Start: The Danger of Limited Documentation\n\nSo how, then, should we start with this etherscan link review?\n\nGoing back to what we learned about **audit readiness**, there's a simple security checklist and the **rect test** that proves handy.\n\nThe **_rect test_** probes for:\n\n1. Documentation of all actors, roles, and privileges,\n2. Documentation of all the external services, contracts and oracles,\n3. Is there a written and tested incident response plan?,\n4. Documentation of the best ways to attack the system,\n5. Identity verification,\n6. Security definitions.\n\nIf a codebase only provides an Etherscan link, it's hard-pressed to pass this test. Remember this rule:\n\n> **If you're offered monetary reward to audit an Etherscan-only codebase, that's a red flag. Say NO. Doing otherwise contradicts our mission to promote secure protocols.**\n\n### Proactive Steps: Questions to Ask Your Client\n\nTo ensure the more secure protocol, ask your client these rect test questions. If the protocol insists that they're not planning to install a test suite, offer to do it for them, after they pay for the additional consulting fee. Weighing on the side of caution, you might ask:\n\n> **\"Do you have a test suite? We want to be sure that your codebase is safe and secure. Do you have a Git repo, perhaps on Github or GitLab, where you have a testing framework related to this codebase?\"**\n\nMost likely, they'll appreciate your considerably detailed observation, and provide the necessary information. Adhering to these steps will ensure a more thorough, and overall secure, audit of the codebase. This approach emphasizes our goal as security professionals to leave protocols interacting with us better educated on code security - the first step towards a safer digital world.\n",
          "updates": []
        },
        {
          "lessonId": "b7294794-b3b1-4ee5-b00d-20a84f815bd3",
          "number": 3,
          "title": "Scoping: Audit Details",
          "slug": "details",
          "folderName": "3-details",
          "description": "",
          "duration": 13,
          "videoUrl": "_dMiBys00jc",
          "rawMarkdownUrl": "/routes/security/3-first-audit/3-details/+page.md",
          "markdownContent": "---\ntitle: Nailing the Audit Details\n---\n\n_Follow along with this video:_\n\n\n\n---\n\n## Getting Started\n\nStarting off, we have our Git repository linked to this tutorial. Our client has graciously updated the codebase for this security review, featuring an improved framework and enhanced verbosity in their Security Review Code V2.\n\nExploring the new codebase, we find it to be comprehensive with an `SRC` folder and a script detailing deployment procedures. However, as we dig in, we find that the README needs refinement and tailoring to our needs rather than the template Foundry README. There is also a glaring omission ‚Äî there are no test folders.\n\nUncertainty remains on what changes were made to the files in the `Lib` folder and what exactly we have to audit within this codebase. It is crucial at this point to ensure we get a complete understanding of the audit scope before any actual auditing starts. This process, known as the scoping phase, will guide you to thoroughly onboard the protocol and the client.\n\n<img src=\"/security-section-3/3-details/details1.png\" style=\"width: 100%; height: auto;\">\n\n## Preparing for the Audit: Onboarding Questions\n\nFor your convenience, the GitHub repo linked with this tutorial contains an essential document called Minimal Onboarding Questions. This document will help you extract the minimum information necessary for a successful audit or security review.\n\nLet's go through these questions and understand why each one is important in preparing for our security review.\n\n1. **Details regarding the project and its documentation:** Knowledge about the project and its business logic is crucial. You need to be aware of what the project is intended to do so as to spot areas where code implementation does not align with the project's purpose.\n2. **Understanding the codebase:** Information about the size of the codebase, how many lines of code exist, and its complexity is incredibly vital. This data will help to estimate the timeline and workload for the audit.\n3. **Setting up the project:** Details regarding deployment of the project and how to build the project should be collected.\n4. **Security review scope:** Know the exact commit hash that the client plans to deploy and the specific elements of the codebase it covers. You do not want to spend time auditing code that the client has already modified or doesn't plan to use.\n5. **Identifying compatibilities:** Information about the solidity version the client is using, the chains they plan on working with, and the tokens they will be integrating is important.\n6. **Roles within the system:** This entails understanding the different roles and powers within the system.\n7. **Awareness of known issues:** Understanding existing vulnerabilities and bugs which may not disallow the system from working but are still significant to its security.\n\nGiving these questions to the client allows you to garner the bare minimum information to conduct the audit. It's worth noting that this allied assistance is a two-way street. While our onboarding questions help clients clarify their requirements to us, we, in turn, educate them on the value of a well-executed audit, the precautions necessary for optimal security, and the potential hazards of insufficient project documentation.\n\n## Modifying the Codebase &amp; Client Cooperation\n\nOnce our client has filled out the minimal onboarding questions and we have clarified all ambiguities, we are ready to start modifying the codebase.\n\nClients must provide an adequately documented codebase for comprehensive and effective auditing. For instance, missing sections like a test folder in our case clearly indicate that the codebase is unready for auditing.\n\nIn such cases, we go back to the client, highlight the gaps, and have them complete the documentation or supply any missing details.\n\nIn response, your client should comply and work on making the codebase secure, since they do not want to be vulnerable to hacking threats. We also advise our clients that including tests and elaborate documentation can only set up the codebase for more accurate assessment and effective security recommendations.\n\n## Digging into the Updated Codebase\n\nWith the client's cooperation and our earlier efforts, we can now go forward with the codebase inspection. We find a richly documented codebase optimized for security review in the 'onboarded' branch. For a quick reference, we usually set the essential scope details in the README.\n\nRemember, asking the right onboarding questions, setting clear auditing scopes, and ensuring proper documentation is not only helpful for a smooth auditing process but also indirectly teaches clients about taking security seriously.\n\nHappy auditing!\n",
          "updates": []
        },
        {
          "lessonId": "2b4e7a53-dc86-4f8f-a522-2b5e762cb09b",
          "number": 4,
          "title": "Scoping: cloc",
          "slug": "cloc",
          "folderName": "4-cloc",
          "description": "",
          "duration": 3,
          "videoUrl": "evYm83lAPpI",
          "rawMarkdownUrl": "/routes/security/3-first-audit/4-cloc/+page.md",
          "markdownContent": "---\ntitle: Scoping CLOC\n---\n\n_Follow along with this video:_\n\n\n\n---\n\nIn this lesson, we'll be going over a crucial step in scoping a contract: getting the stats of the protocol. As a part of this process, we'll be using a widely recognized tool known as CLOC, or Count Lines of Code.\n\nThe beauty of CLOC is about its compatibility; it works with pretty much any codebase you work with, be it Solidity, Python, Rust, and so on. It does exactly what it says ‚Äìcounts your lines of code, allowing you to quickly analyze the size and complexity of your projects.\n\n## Installing and Using CLOC\n\nTo use CLOC, the first step is downloading and installing. This can be done from a few different places; a popular method is to simply install via a package manager like NPM, Apt Brew for Mac users, among others. The entire installation process won't be covered here, but it is straightforward enough that anyone proficient in working with such tools should have no trouble.\n\nOnce successfully installed, run CLOC using your terminal. You can verify your installation by running CLOC help. This should give you an output showing a list of useful commands.\n\nTo get started, simply run CLOC with the directory or files you want to count the lines of code on. Upon hitting enter, you'll see a concise and detailed output. It will give you a few key stats: the number of files, the number of blank lines, the number of comment lines, and most importantly, the number of actual lines of code.\n\n```bash\ncloc /directory_name\n```\n\nThis is what the output might look like:\n\n```shell\nNumber of files: 1\nNumber of blank lines: 5\nNumber of comment lines: 12\nNumber of code lines: 20\n```\n\n## The Importance of Knowing Your Codebase Size\n\nWhy is knowing the number of source lines of code (also referred to as Nsloc) crucial? The answer lies in the process of auditing and security research.\n\nAs you perform more audits and delve further into security research, you'll start to gauge the pace at which you can audit a code base. Understanding that pace enables you to estimate more accurately the time required for future coding or auditing tasks based on the size of the code base.\n\nThis is incredibly useful, as with time, you can use your past audit experience and tell the protocol you're working with how long it will take to audit their codebase. Notably, this pace tends to speed up as you do more security reviews. Nevertheless, it's a good starting point.\n\n> _\"When auditing 1000 lines of code for the first time, you now have an estimated timeline for subsequent audits or security reviews of 1000 lines codebases.\"_\n\nOften, competitive audits might have a quicker timeline depending on the auditing platform. Upon having a good grasp of your auditing speed, it may assist in selecting competitive audits that align with your capabilities, or even ones that push you to accelerate your pace.\n\nIn conclusion, stats like the complexity score and Nsloc are crucial for proper auditing. They not only help you estimate the time taken for an audit but also potentially push you to improve your skills in the process. They are, quite literally, a measure of your codebase‚Äîand your abilities.\n",
          "updates": []
        },
        {
          "lessonId": "4729ad23-b598-4fb9-bbde-10e36f33d315",
          "number": 5,
          "title": "Recap I",
          "slug": "recap-i",
          "folderName": "5-recap-i",
          "description": "",
          "duration": 3,
          "videoUrl": "bMYONrWwu3o",
          "rawMarkdownUrl": "/routes/security/3-first-audit/5-recap-i/+page.md",
          "markdownContent": "---\ntitle: Recap I\n---\n\n_Follow along with this video:_\n\n\n\n---\n\n## Embracing Your Role as a Security Researcher\n\nFirst and foremost, you are not just coders or developers - you are security researchers. You are the gatekeepers ensuring the integrity of smart contracts. A mere [Etherscan](https://etherscan.io/) link‚ïÆ does not guarantee the maturity of any codebase. Our goal is to ensure that these protocols are not only safe and secure but also well-documented and supported with a robust test suite.\n\n> \"Smart contracts are the most adversarial environment on the planet, and we need to treat them as such.\"\n\nIf you are handed a code base within a smart contract development framework, yet find it lacking adequate tests or documentation, remember, this isn't going to be helpful. Our job often involves dealing with business logic bugs - understanding what the codebase does is crucial.\n\nAs much as we need more information from protocol developers, sometimes, it falls upon us, the security researchers, to educate them about the best security practices.\n\n## Scoping Out a Codebase\n\nWondering where to start? We provide you with a minimal onboarding form to begin your client interaction. This form facilitates your understanding of the fundamentals required for scoping out a codebase.\n\nAs you gain more experience, an extended onboarding form will be introduced. Let's not jump ahead though; we'll touch on this more in future sessions.\n\nWith our final security review code base, you have the answer key to all the bugs within the system. A final onboarded test suite (final security review v3) is available at your disposal.\n\nYou can customize the onboarding form based on your preferences. In competitive audits, you'll find the form already filled out for you. This form is the basic blueprint of what you'll need the codebase to be like.\n\n## Information - Your Key to a Successful Security Review\n\nFor a fruitful security review, obtaining thorough knowledge is critical. You should know\n\n1. How to clone the codebase\n2. How to build it\n3. How to test it\n\nMore than this, you'll need the exact commit hash, the precise files, and the scope with which you'll be working, as well as the Solidity version (Solc) and the chains involved.\n\nThus, your primary mission is to hunt down information.\n\n```\nThe steps involved in a security review:- Cloning the codebase- Building it- Testing it- Knowing the commit hash- Identifying the files and scope.- Understanding the Solc version and chains involved.\n```\n\n## Congratulatory Note and a Sneak Peek\n\nA huge congratulations on reaching this far! I know the journey might seem verbose and daunting, but trust me, all these painstaking steps are crucial. They will save you hours in the future, especially if you consider becoming an independent auditor or starting your firm.\n\nWhether or not you opt for a competitive audit, understanding these essentials will fortify your strategy for handling future security situations.\n\nStay tuned! The course has a lot more in store for you, as we will discuss different practices and insights key to your growth as a successful security researcher. Let's soldier on toward becoming the best guardians of the digital realm!\n",
          "updates": []
        },
        {
          "lessonId": "bfb6c3c7-e21e-4071-8144-ee62b276d586",
          "number": 6,
          "title": "\"The Tincho\"",
          "slug": "process-tincho",
          "folderName": "6-process-tincho",
          "description": "",
          "duration": 15,
          "videoUrl": "KJbU3pxscJw",
          "rawMarkdownUrl": "/routes/security/3-first-audit/6-process-tincho/+page.md",
          "markdownContent": "---\ntitle: The Audit Process With Tincho\n---\n\n_Follow along with this video:_\n\n\n\n---\n\n### Meet Master Tincho\n\nMaster Tincho is a part of Redgill, a firm specializing in smart contracts and EVM security. Tincho and the Red Guild are dedicated to ensuring security in the EVM space, and frequently contribute their wealth of knowledge, expertise, and passion to the community.\n\nHe has previously served as the lead auditor at the security firm OpenZeppelin and has graciously agreed to share his unique approach to performing security reviews on codebases. He was instrumental in the creation of this course and we owe him a huge round of applause for that!\n\nNow, are you ready to learn from the best?\n\n### The Tincho Auditing Method\n\nTo illustrate the Tincho auditing method, we're going to refer to a video where Tincho performs a live auditing of the Ethereum Name Service (ENS). \"Auditing ENS! That sounds complex\", you might be thinking. Well, fear not as we'll break this down into bite-sized pieces of easy-to-digest information.\n\n> \"I don't have a super formal auditing process. I will just show you briefly some things that I do...\" - Tincho\n\nFirst things first, let's clone the ENS repository into our local development environment and begin the mad reading.\n\n#### Reading... Reading... More Reading\n\nBefore diving into the code, familiarize yourself with some jargon that you might come across often in the code, such as what a registry or a resolver is - things that you'll gain understanding about as you read through the documentation.\n\n#### Tool Time\n\nNow let's move onto some handy tools for auditing:\n\n- **VS Codeium**: Tincho's text-editor of choice. It is a 'more-private' spin-off from VS Code that respects your data privacy.\n- **Clock**: A simple command-line utility that helps count lines of code which can give a sense of the complexity of different parts of the codebase.\n- **Solidity Metric**: Another tool developed by consensus that provides useful metrics about your Solidity codebase.\n\nOnce you get your initial overview, it's time to roll up your sleeves and dive deeper into the codes.\n\n> \"I would advise to keep the clients at hand. Ask questions, but also be detached enough.\" - Tincho\n\n### Audit, Review, Audit, Repeat\n\nKeeping a record of your work is crucial in this process. Tincho recommends taking notes directly in the code and maintaining a separate file for raw notes and ideas.\n\nRemember, there is always a risk of diving too deep into just one part of the code and losing the big picture. So, remember to pop back up and keep an eye on the over-all review of the code base.\n\nOne distinct part of the Tincho method is writing proof-of-concept (POC) exploits via Solidity tests in his preferred test environment, Foundry. This quickly verifies or falsifies any hunches about possible vulnerabilities.\n\nAt this stage of the process, keeping an open line of communication with the client is key. Often times they will have much more context on why certain things were coded the way they were.\n\nRemember, the goal is not to trust completely, but to validate.\n\n### Wrapping it All Up\n\nAfter your audit, it's time to neatly present your findings in a report. Note that your work isn't over once the report has been handed over. The client will go back, make the necessary fixes based on your suggestions and return to you with the updated code.\n\nYour final responsibility is to ensure that these fixes effectively correct the earlier identified vulnerabilities and that they didn't inadvertently introduce new ones.\n\n### Aftermath of a Missed Vulnerability\n\nThere will always be the fear of missing out on some vulnerabilities and instead of worrying about the cracks that slip through the net, aim to bring value beyond just identifying vulnerabilities. Imbibe the thought that even if you missed a critical vulnerability, the value you delivered was worth it.\n\nA last takeaway from Tincho:\n\n> \"Knowing that you‚Äôre doing your best in that, knowing that you‚Äôre putting your best effort every day, growing your skills, learning grows an intuition and experience in you.\"\n\nWith that, we conclude our detailed examination of the Tincho style of auditing in the EVM ecosystem. I hope you enjoyed learning about this process just as much as I enjoyed presenting it to you.\n\nStay tuned for more content geared towards making you the best auditor you can be. Until next time, folks!\n",
          "updates": []
        },
        {
          "lessonId": "2c621243-12a8-4b87-a757-dc85c1ec9bd5",
          "number": 7,
          "title": "Recon: Context",
          "slug": "context",
          "folderName": "7-context",
          "description": "",
          "duration": 5,
          "videoUrl": "NPoji_Z0hvs",
          "rawMarkdownUrl": "/routes/security/3-first-audit/7-context/+page.md",
          "markdownContent": "---\ntitle: Recon - Getting Context\n---\n\n_Follow along with this video:_\n\n\n\n---\n\n## First Step: Understanding The Codebase\n\nThe first thing we must do is clone the repository, centralising all our resources. After successfully cloning the repo, our mission is to understand the _raison d'√™tre_ of the code base. To do this, we'll utilize the 'doc'‚Äîan informational guide that deciphers a program's intentions and functionalities.\n\n1. Start by opening the 'docs'.\n2. If you‚Äôre using a Mac, hit `CTRL + SHIFT + V` to enter the README view state.\n3. Don‚Äôt worry if you're not a Mac user: open the command palette and enter `markdown open preview` to view README in its shining glory.\n\n_Quick tip: Check if an extension must be installed for Vs code if it's not working for you._\n\n<img src=\"/security-section-3/7-context/context1.png\" style=\"width: 100%; height: auto;\">\n\nPerusing through the docs, we can deduce that this operates as a smart contract application for storing passwords. Here's how it functions: users can securely store their passwords and retrieve them later, with the assurance that unwanted entities won't gain access to them.\n\nGreat! Now we have context and enough background info to start thinking of potential attack vectors. For instance, is there a vulnerability in the code that might make it possible for unauthorized individuals to access the stored passwords?\n\n## Next Phase: Scoping Out The Files\n\nOur next step involves an indispensable tool: Solidity Metrics. This extension is integral to exploring our codebase, identifying file lengths, capturing the call graph, and more.\n\n1. Find Solidity Metrics on the Visual Studio code marketplace.\n2. Once installed, right-click on the visuals of the files and select 'Run Solidity Metrics'. After this action, a report will be generated.\n\n_Further Quick Tip: If you're a Windows user, employ the Ctrl+Click method._\n\nAfter generating the report, navigate to the command palette and locate 'export this metrics report'. Once exported, you'll have HTML access to the report for future reference.\n\nApplying Tincho's methodology to this process, we can:\n\n1. Scroll down to the section containing the various files and their lengths.\n2. Copy this info and paste it onto any platform that allows for easy viewing and comparison‚Äî like Google Sheets or Notion.\n\nPlease note that if your codebase contains a solitary file like ours, this step won't be necessary.\n\nNevertheless, Solidity Metrics showcases its versatility and potency when dealing with Solidity codes. It effortlessly weeds out any node modules, tests, libraries while concurrently enriching the user experience with its easy-to-navigate interface - case in point, the inheritance graph, the call graph, and the contracts summary.\n\n> ‚ÄúPublic and external functions are going to be the ones that people can actually call. So these are going to be the ones that if a hacker wants to attack this, these are probably the functions that they're going to call.‚Äù\n\nUnderstanding your codebase and its functionalities is the first step towards securing it.\n\n## Moving Forward: Time for Detailed Recon\n\nNow that we've used Solidity Metrics to understand the project codebase, we can identify potential security issues and verify the uncertainty around external access points. Let's walk through the codebase of the SRC password store.\n\nTune in to the next blog post to continue with me on this walkthrough of the code base, where we‚Äôll be exploring potential vulnerabilities and strengthening our codebase. This is only the beginning: stay curious, and keep learning!\n",
          "updates": []
        },
        {
          "lessonId": "74157e59-a92c-4769-80d0-7a546369f7d6",
          "number": 8,
          "title": "Recon: Understanding the code",
          "slug": "understanding-the-code",
          "folderName": "8-understanding-the-code",
          "description": "",
          "duration": 6,
          "videoUrl": "Qd-I-BnvAkM",
          "rawMarkdownUrl": "/routes/security/3-first-audit/8-understanding-the-code/+page.md",
          "markdownContent": "---\ntitle: Recon - Understanding the Code\n---\n\n_Follow along with this video:_\n\n\n\n---\n\n## How Tincho Cracked the Code\n\nTincho, a prominent security researcher, shared an interesting method to hack through an encrypted code: walking through the code line-by-line. This method might seem like he was looking for bugs/vulnerabilities in the code. But actually, he was just trying to understand the codebase better. In essence, understanding the functionalities and architecture of the code forms the first and most important part of code inspection.\n\nSo let's take it from the top, just like Tincho did‚Ä¶\n\n## Step 1: Understanding What the Codebase Is Supposed to Do\n\nBefore you start scrutinizing the code, it's crucial to comprehend the purpose of the code. In our case, the codebase allows users to store their passwords securely.\n\n## Step 2: Scanning the Code from the Top\n\nAfter gaining a fundamental understanding, you can start going through the code. You can jump directly to the main functionality. However, to keep things simple, let's just start right from the top and start working our way down.\n\nOn observing the code carefully, we find that the Solidity compiler language version is 0.8.18. Although this is not the most recent version (quite normal), trying to understand if this was the correct compiler version can be a query. So, mark it with something like `Q: Is this the correct compiler version?`\n\n## Step 3: Taking Notes\n\nWhile walking through the code, you can jot down some points in a `Notes.md` file. These could include your thoughts, attack vectors, or even a summary of the project. You can also mark queries that you can come back to later.\n\n> **Bonus Tip**: Some security researchers, like Zero Kage from the Cypher team, even print the source code and use different color highlighters to visualize the codebase better.\n\n## Step 4: Observing the Code Structure and Naming Convention\n\nOn further deep-diving, we find some well-followed conventions, state variables like `sowner` and `s_password`, and an event `set_new_password`. The good convention use adds points to the code strength, while a poorly followed convention may raise some questions.\n\n## Step 5: Reading the Documentation\n\nNext, we find some extensive documentation written as comments. This documentation gives additional context about the functionality of the protocol.\n\n## Step 6: Identifying Functions\n\nWe can see a function here where only the owner can set a new password. Gaining clarity about this function is vital, as this is part of the main functionality of the code. And in the case of poor documentation, it can be helpful to ask the protocol directly about a function.\n\nFor example, if the function isn't clear, note down the question like `Q: What does this function do?`\n\nIt's paramount to get a context about the code base, and these questions, comments, and annotations will help you achieve that.\n\n## Final Word\n\nThough this might seem like a simple walkthrough, it‚Äôs a process that will help you understand the core functioning of any codebase. Remember, the idea is not to hunt for bugs in the first go, but to understand what the code does. As you get to know the code more, you‚Äôll identify its bugs and vulnerabilities. Happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "1bc03555-0cb0-4d70-b9ee-eab97e748943",
          "number": 9,
          "title": "Exploit: Access control",
          "slug": "access-control",
          "folderName": "9-access-control",
          "description": "",
          "duration": 3,
          "videoUrl": "DvWqYd35Cl4",
          "rawMarkdownUrl": "/routes/security/3-first-audit/9-access-control/+page.md",
          "markdownContent": "---\ntitle: Exploit Access Controls\n---\n\n_Follow along with this video:_\n\n\n\n---\n\n# Discovering a Bug: How to Identify Vulnerabilities\n\nWelcome to a bug hunting expedition! In today's post, we'll be breaking down some code hoping to locate a typical and highly common vulnerability, the missing access control error. By identifying and examining this mistake within a given function, let's dive in and uncover its layers.\n\nRemember, even if the bug seems glaringly obvious or you struggle to find it, our mission today is learning how to identify such issues in code.\n\n## The Bug\n\nLet's refer to the documentation and function at hand. The former states that \"this function allows only the owner to set a new password\". Given this crucial detail, can you locate the bug?\n\n\nThe function, `setPassword`, receives `string memory new password` and is marked `external`, meaning it automatically allows for a new password to be set. Can you spot the achilles heel here?\n\n## Questioning Code\n\nOften, making sense of code requires asking the right questions like, \"Can a non-owner set the password?\" Now, if this is true (as it seems to be), it blatantly contravenes our function description, thereby ringing some alarm bells.\n\n\"Should a non-owner be allowed to set a password?\" A rhetorical question really, since anyone but the owner getting their hands on the password could brew trouble. Since the documentation rules this scenario out, it implies that we‚Äôve sniffed out an issue.\n\nTo tie in code practice with our deduction, you could make this observation in your code by writing an audit comment, such as `@audit`. Usually, a high severity alarm since any user has the potential to change the password, leaving your system vulnerable to attack.\n\n## Uncovering Vulnerabilities\n\nDuring this recon phase, our keen detective work segues into a vulnerability identification phase. We've unearthed a common but significant vulnerability - the missing access control bug. This type of vulnerability surfaces when a function that is only supposed to be accessible by a particular user role is, in fact, accessible to all.\n\n\nConsequently, we've noticed a significant vulnerability in our function. Kudos to us! As a best practice, it's advisable to take a note of such findings, preferably with the `@audit` tag, and revisit at a later point.\n\nIt's important to remember that even if at first, it seems like a vulnerability, a closer look might reveal otherwise. For now, let's pat ourselves on the back for potentially uncovering this security risk!\n\n\n\n## The Triumph of Bug Discoveries\n\nIf you were able to pick up on the incongruity before it was pointed out, terrific job! That's a definitive sign that one is on the right track. However, if it slipped past your radar, don‚Äôt fret. Security is a vast field, demanding occasional rewiring of our conventional thought processes.\n\nLet's consider this as an exciting learning experience. Even if you didn't catch the bug but jotted down notes, you're making progress. Being vigilant enough to take notes is certainly a step in the right direction, and recognizing that we may have found a bug is a victory in itself!\n\n# Wrapping Up\n\nThrough this exercise, we deeply whoop it up for potentially making this protocol more secure. We have identified a consequential access control issue- a significant stride towards solidifying our system‚Äôs defense and aware development.\n\nLet's forge ahead, keeping this rigorous bug-checking mindset as we continue walking through more lines of code.\n\n",
          "updates": []
        },
        {
          "lessonId": "43ba5486-bd51-4a1f-b203-52cf1a2fea7c",
          "number": 10,
          "title": "Exploit: Public Data",
          "slug": "exploit-public-data",
          "folderName": "10-exploit-public-data",
          "description": "",
          "duration": 3,
          "videoUrl": "58ld0DjI7Cc",
          "rawMarkdownUrl": "/routes/security/3-first-audit/10-exploit-public-data/+page.md",
          "markdownContent": "---\ntitle: Exploit Public Data\n---\n\n_Follow along with this video:_\n\n\n\n\n---\n\n## Analyzing a Smart Contract Function - Not So Private After All\n\nIn this lesson, we will be taking a deep dive into the intriguing world of Smart Contract functions, specifically focusing on the last function of a given piece of code. This function is designed to allow owners to safely retrieve their passwords. However, as we will soon discover, all is not as it seems ...\n\n\n## Understanding The Function's True Aim\n\nTo provide a broad overview, the primary purpose of this function is to allow \"owners only\" to retrieve their passwords. This aligns with the need of users being able to securely store and later retrieve their password. The function is set up with a protective mechanism: if someone who is not the owner tries to access the password, it will immediately revert. This way, the owner's password maintains its legitimacy and stays secure from other users.\n\nAt first glance, you might feel reasonably comfortable storing your password on this contract. But is everything really as safe and sound as it appears to be?\n\n## Spotting The Issue\n\nUpon examining the function closer, we encounter a potential problematic scenario. The code seems to be signalling an `\"@param newPassword\"` which should theoretically represent a new password to be set. However, there appears to be no parameter for this set in the function. This is a clear discrepancy, implying the documentation for the password set must be reviewed and updated.\n\n> Attention should be drawn here - even if the courts deem it as a small discrepancy, such documentation errors could lead to practical implementation errors later on.\n\nMeanwhile, a more significant issue lurks in the background. The `s_password` variable, under the pretense of being private, is deemed completely secure. However, in a blockchain context, this assumption poses a significant error.\n\n \n## The Not-So-Private 'Private Data'\n\nOne of the fundamental principles of understanding blockchain is that *all data on the chain is public*. This means that -contrary to what this function might lead us to believe- just because the `s_password` is marked as private, it doesn't mean it's actually private.\n\nBy marking `s_password` as private, users could be lulled into a false sense of security, thinking that their password is safe. Unfortunately, the reality is quite the contrary. This breach has potential to cause significant damage as the entire protocol becomes vulnerable when just about anyone can read this supposedly 'private' password.\n\n## The Importance of Solid Foundation\n\nFinding bugs and vulnerabilities in code only appears obvious if you have a solid understanding of how Smart Contracts with Solidity works. If this blog post left you feeling a bit puzzled, you might want to check out my Foundry Course that dives deep into the mechanics of Solidity and Smart Contracts.\n\nThis blog post serves as a wake-up call for everyone in the blockchain space, highlighting the importance of understanding the foundational principles of blockchain and smart contracts. With the promise of safety and anonymity, it's crucial that we remain vigilant about the potential vulnerabilities that exist within even the most secure-seeming systems and continually strive for perfection and uncompromised security.\n\nIn the subsequent posts, we are going to write a proof of code to demonstrate how 'private' data can be read off-chain, providing further evidence for the points raised today. So, stay tuned!\n\n\n",
          "updates": []
        },
        {
          "lessonId": "2f9c6946-6eb1-4d65-be39-a4fb99a76125",
          "number": 11,
          "title": "Recap II",
          "slug": "recap-ii",
          "folderName": "11-recap-ii",
          "description": "",
          "duration": 1,
          "videoUrl": "hSSIhPgc4aA",
          "rawMarkdownUrl": "/routes/security/3-first-audit/11-recap-ii/+page.md",
          "markdownContent": "---\ntitle: Recap II\n---\n\n_Follow along with this video:_\\\n\n---\n\n# Unfolding Blockchain Security Issues: A Deep Dive into our latest Smart Contract Audit\n\nEager to gain insights into the world of blockchain security? Today, we'll examine three potential security vulnerabilities we discovered during one of our recent smart contract security audits. These vulnerabilities lay at the heart of access control with implications that could strike at the very essence of blockchain privacy.\n\n## Vulnerability 1: Access Control Issues\n\nFirst and foremost, we must start with access control ‚Äî a critical security factor. Here, the most concerning problem we identified concerns the setting of a password.\n\n**Access control should ensure that only the owner of the contract can set the password. However, during our audit, we found that the security mechanism missed a critical check.**\n\nTo simplify the concept, the access control should look like this:\n\n```javascript\nif (msg.sender !== s_owner) {\n  revert(\"Not owner\");\n}\n```\n\nThis logic check denotes that if the message sender doesn‚Äôt match the owner, then the system should revert or rollback any change, ensuring that only the correct owner can modify the password. Unfortunately, this check was missing in the audited contract, resulting in a major security lapse.\n\n<img src=\"/security-section-3/11-recap-ii/recapii-1.png\" style=\"width: 100%; height: auto;\">\n\n## Vulnerability 2: Erroneous Parameter\n\nThe second issue found during the audit is as seemingly insignificant as an erroneous parameter. While an erroneous parameter might seem harmless, it can lead to function misbehavior, cause inconsistencies, and eventually, weaken the security of the contract.\n\nAlthough less conspicuously problematic than the missing ownership check, an erroneous parameter has potential for misuse and exploits.\n\n## Vulnerability 3: On-chain Password Storage\n\nLast but definitely not least, we noticed that the application stored passwords on-chain. This is a major security concern as **all data on chain is public information**. Therefore, storing passwords, or any sensitive information for that matter, on-chain exposes them to public view, compromising the so-called private information.\n\n> _Remember, data stored on-chain equals to public information. Keeping passwords or any private data secure means that they must be off-chain._\n\n## Preliminary Audit Findings: Three Potential Vulnerabilities\n\nTo sum up our audit findings, we discovered three potential vulnerabilities: A missing ownership check, an erroneous parameter that could lead to future exploits and breach, and, most alarmingly, the practice of storing passwords on-chain.\n\nThese could be catastrophic if not addressed in time. However, the severity of these issues is yet to be assessed, which brings us to the next phase of our audit.\n\nWe hope to bring you more interesting insights from the audit trail once the severity of these potential vulnerabilities is gauged. So, congratulations to us and our eagle-eyed audit team. With our findings, we can contribute significantly to making the protocol safer.\n\nGreat work, indeed! Let us continue to uncover potential threats and fortify the world of blockchain one step at a time. Here's looking forward to safer and secure smart contracts for everyone in the blockchain community! Stay tuned for further updates on these security vulnerabilities.\n",
          "updates": []
        },
        {
          "lessonId": "98ac9db5-d6b3-4d8f-bc83-9ddfe3b4a322",
          "number": 12,
          "title": "Protocol tests",
          "slug": "protocol-tests",
          "folderName": "12-protocol-tests",
          "description": "",
          "duration": 3,
          "videoUrl": "gEqNT-2JfXM",
          "rawMarkdownUrl": "/routes/security/3-first-audit/12-protocol-tests/+page.md",
          "markdownContent": "---\ntitle: Protocol Tests\n---\n\n_Follow along with this video:_\n\n---\n\n# The In-depth Guide to Code Reconnaissance\n\nIn the exciting field of programming, the process of code reconnaissance plays a crucial role. Delving into a new code base can be daunting, whether it's your project or someone else's. But fear not, this lesson aims to guide you through diverse techniques and tools you can utilize to make sense out of a new codebase.\n\nWe'll go through recon steps such as:\n\n- Checking README instruction\n- Reviewing contract scope\n- Examining essential code functions\n- Testing and coverage checks\n\nReady to dive in? Let's start!\n\n## _README_ Instructions: Where It All Begins\n\nThe _README_ file is the launchpad for your process of understanding any new codebase. It usually includes essential commands you can execute, and in our case, we have: `make anvil`, `make deploy`, `forge test`, and `forge coverage`.\n\nThese provide a good starting point but we won't stop here. We might want to further scrutinize, say, the deploy function to ensure its validity.\n\n> **Note:** While sticking to the README allows you to understand the core functionalities, don't forget to step out of it and explore unknown territories.\n\n## Diving into Contract Scope\n\nThe most fundamental step is to get a grasp of the contract's scope. Analyze it thoroughly, then rinse and repeat till you're confident with its functionality. The more you explore, the higher the chance of spotting a loophole!\n\n### Ask Questions. A Lot of Them!\n\nThrough your investigation, a lot of queries might pop up. Ask them all! Are you using the correct compiler version? Went through all possible functionalities? No question is a bad question. The right questions can lead you to inherent vulnerabilities that might've been overlooked.\n\nWith our codebase, we were successful in answering all the puzzles, helping us understand the code better and potentially spotting some vulnerabilities.\n\n![](https://cdn.videotap.com/fy1smyAfljLp0FhGEGGG-71.64.png)\n\n## Testing and Coverage\n\nOnce you are through with the code's understanding, the next step is to dive into code testing. You might want to run `forge test` to evaluate the test coverage of the code base.\n\nPrior to this, ensure you've run a code build to know how many tests exist and perhaps peek into the test folder to understand more about existing tests.\n\n> **Pro Tip:** It's advisable to look for whether every potential scenario has a corresponding test.\n\nFor example, in our codebase, two tests existed - `test owner can set password` and `test non owner reading password reverts`. However, we found no test ensuring that a non-owner can't set the password.\n\nThis indicated a lack of comprehensive test coverage, possibly leading to unidentified vulnerabilities.\n\n## Vanity Metric?: Deciphering Code Coverage\n\nConducting an analysis via `forge coverage` could offer insights into the code coverage. Yet, it's important to remember that coverage can sometimes be a hollow indication of code quality.\n\nFor instance, even though our code reported a 100% coverage, we were able to discover significant vulnerabilities. Simply, anyone could set or read the password. Furthermore, we found misleading documentation.\n\n<img src=\"/security-section-3/12-protocol-tests/protocol1.png\" style=\"width: 100%; height: auto;\">\n\n## Finalises Code Audit\n\nOnce you've gathered all your findings, it's time to do a final review of your audit. In our case, we identified three major issues that need an elaborate write up.\n\nRunning a quick search for \"@audit\" would list down all issues identified. This is your final chance to ensure nothing slips through the cracks.\n\nIn conclusion, code reconnaissance is a step-by-step, detailed process that involves careful understanding, thorough checks, and comprehensive testing. Always remember, the more in-depth you delve, the more efficient your code audit would be.\n",
          "updates": []
        },
        {
          "lessonId": "96f8af07-f18f-4682-864f-cef0a6abc240",
          "number": 13,
          "title": "Writing an amazing finding",
          "slug": "finding-report",
          "folderName": "13-finding-report",
          "description": "",
          "duration": 4,
          "videoUrl": "FwFPrE38Epw",
          "rawMarkdownUrl": "/routes/security/3-first-audit/13-finding-report/+page.md",
          "markdownContent": "---\ntitle: Writing an amazing finding report\n---\n\n_Follow along with this video:_\n\n\n\n---\n\n## Moving Forward After Identifying Vulnerabilities\n\nAfter the identification phase, we are tasked with communicating our findings to the protocol. This phase is crucial on several levels:\n\n1. We need to convince the protocol that the identified vulnerabilities are issues.\n2. The issues require necessary fixes to prevent a recurrence.\n3. Our intention is not merely pointing out the problems but to make the protocol safer.\n4. In a competitive audit, proving the issues to the judges is our primary focus.\n\nBy effectively communicating this information, we position ourselves as educators, helping the protocol understand **why** these vulnerabilities are issues, **why** they were overlooked, and **how** to fix them to avoid running into the same issues in the future.\n\n## Writing Your First Finding\n\nNow comes an incredibly exciting part - doing a minimalistic write up of the vulnerabilities you've found. If this is your first time writing a finding, then buckle up!\n\nFor this walkthrough, we'll be using our main GitHub repository, from where we scroll all the way up to the files and look for a file named 'findinglayout.md' This minimalist markdown layout will guide us on what our findings should ideally look like. Here, we can quickly view its raw format and, for convenience, copy it over to our codebase.\n\nWe could create a new folder named 'Audit Data' and a new file marked 'Finding Layout MD' and paste the copied markdown layout here. This way, we have a markdown version of what our findings should look like.\n\nIf you use Visual Studio Code, you can preview the markdown layout by pressing \"command Shift V\" on a Mac. Fear not if you're on Linux or Windows, just opening the command palette and choosing 'preview Markdown open preview,' you'll get the same result.\n\n## Layout for Your Finding Writeup\n\nYou're free to customize the information in your finding writeup as per your style and the severity of the issues found. The aim is to convince the protocol that there's a problem, articulate the severity of the issue, and finally suggest how to fix it.\n\nHaving copied the markdown layout, we can create a new file called 'Findings MD' and paste the layout here as a starting point for our first finding.\n\n## Making Your Case\n\nLet's say our first finding is that the password variable is not as private as it may initially appear. Despite being marked 'private,' this does not mean that the data is inherently secure, as the keyword just denotes that other contracts can't read it. However, human beings can still read from a stored variable in the blockchain!\n\nTo illustrate the vulnerability, we provide the following example:\n\n> \"The S password variable is not actually private. This is not a safe place to secure your password.\"\n\nIt falls onto us to convince the protocol that the private keyword doesn't impart the level of security they might think, necessitating a change.\n\n## Conclusion\n\nWriting an audit report demands a deep understanding not only of the protocol's vulnerabilities but also the deft skill in communicating these findings effectively. As you develop your professional style, always remember the importance of your role as an educator. If executed correctly, your findings can drive crucial changes for a more secure protocol in the future.\n",
          "updates": []
        },
        {
          "lessonId": "508a9bbd-9427-41bb-a5be-3e6c63cfeaba",
          "number": 14,
          "title": "Writing an amazing finding: Title",
          "slug": "an-amazing-title",
          "folderName": "14-an-amazing-title",
          "description": "",
          "duration": 2,
          "videoUrl": "tiVy5MvFPaM",
          "rawMarkdownUrl": "/routes/security/3-first-audit/14-an-amazing-title/+page.md",
          "markdownContent": "---\ntitle: An Amazing Title\n---\n\n_Follow along with this video:_\n\n\n\n---\n\n# Writing Your Findings: A Guide to Eloquent and Effective Security Audits\n\nIn the world of data security and blockchain technology, precision is key. From the precision of coding to the precision of documentation, every iota of detail counts. Today, I'll walk you through how to articulate your findings proficiently, specifically when pinpointing vulnerabilities in a smart contract. Just as repetition hones a skill, I encourage you to write alongside me. Let's start refining your ability to document your audit findings accurately and eloquently.\n\n## Getting Started\n\nFirst things first, we need to discuss severity rating. We will revisit this later on, but it is a pertinent start to categorize your issue in terms of severity.\n\nThe main event of any audit report is _the title_. It provides the reader with an immediate overview of the issue and the implications. Crafting a title is a blending art and precision. A well-formed, succinct title is a straightforward combination of the root cause and the impact.\n\n## Identifying the Root Cause\n\nWhen we discuss the 'root cause', we refer to the originating flaw or glitch prompting the vulnerability. In our case, the root cause lies in the uninhibited visibility of the on-chain data storage. In other words, variables stored in on-chain storage are visible and accessible to anyone, disregarding any solidity visibility keyword.\n\n## Understanding the Impact\n\nMoving onto the 'impact', it's the specific issue or discrepancy caused by the root cause. In simpler terms, it answers the \"why\" something is problematic. In our situation, the fact that our 'password' stored on-chain is public makes it loses its privateness.\n\nThis could be a potential title, enveloping both the root cause and the impact. Yet, it tends to feel lengthy and a bit complex. The challenge here is to retain the essential details while making it more accessible and crisp.\n\n## Fine-Tuning Your Title\n\nLet us revise our initial title to achieve more brevity and clarity. How about, \"Storing password on-chain makes it visible to anyone?\"\n\nWith this simplified title, we now have a neat encapsulation of the root cause (\"Storing the password on chain\") and its respective impact (\"...makes it visible to anyone\"). It maintains the severity of the issue while discarding unnecessary complexity.\n\nIn summary, creating an ideal title in this context is a balance between the concise depiction of the root Cause and its resultant Impact. It implies the nature of the problem and its potential implications without being verbose or cryptic.\n\n> \"The success of your audit report depends largely on the clarity, precision and brevity of your titles that depict the root cause and its potential impact.\"\n\nUltimately, the goal here is to help you fine-tune your audit-writing abilities. The better you get at portraying your findings, the wider will be its understanding and more efficient the solutions. Now that you know how to craft a succinct and informative title, apply this drill to every vulnerability you encounter and notice your improvement in getting your findings across.\n",
          "updates": []
        },
        {
          "lessonId": "9620492b-6c47-44bb-80c4-48b43dd53f94",
          "number": 15,
          "title": "Writing an amazing finding: Description",
          "slug": "description",
          "folderName": "15-description",
          "description": "",
          "duration": 4,
          "videoUrl": "uhVuTDxudz8",
          "rawMarkdownUrl": "/routes/security/3-first-audit/15-description/+page.md",
          "markdownContent": "---\ntitle: Description\n---\n\n_Follow along with this video:_\n\n---\n\n# Unmasking The Vulnerabilities of Chain Data Visibility\n\nHello, you! Here's an exciting topic that's sure to peak your interest - the valuable teachings of the protocol and its vulnerabilities when dealing with on-chain data storage. We've carefully crafted a compelling and extremely informative blog post. Read on to uncover the potential issues that can occur.\n\n## Crucial Description\n\nA fail-proof practice while dealing with data uncovering in blockchain is to equip our auditors with a concise yet educative description. Given the fact that all data stored on-chain is visible to anyone, the assumption that they can be read directly from the blockchain is worryingly accurate.\n\nJust to illustrate, consider the 'S_password variable' - which is intended to remain private, with its sole accessibility granted via the getPassword function. This function is essentially restricted to the contract's owner.\n\nHowever, the card up our sleeves here is a curious knack of being able to reveal data off-chain. At this point, you must be intrigued to see one method of achieving this. Look no further, it's all here under \"proof of concept.\"\n\nSome of these variables might seemingly sink into oblivion when we're dealing with vast code bases. A widely followed practice in such scenarios is to distinguish variable and function names by highlighting them with backticks and specifying their contract name. For instance, here's how to format them:\n\nNow when you view these chunks of code, you immediately know that `S_password` is a variable and `GetPassword` is a function. And not to forget, they are directly fetched from the code base.\n\n## What's The Impact?\n\nHere's a jolt of reality - should anyone access the private password, it dismantles the protocol's functionality entirely. Quite some impact there, isn't it?\n\n<img src=\"/security-section-3/15-description/description1.png\" style=\"width: 100%; height: auto;\">\n\n## Convincing Proof of Concept\n\nThis next section is where we prove that our claims are real concerns and not just theoretical hypotheses. There's a somewhat humorous, albeit cynical, stereotype that dismisses auditors and security researchers as confused individuals trying to convince the protocol gurus about their 'imaginary' findings.\n\n> \"Yeah, yeah, sure, whatever, you dumb auditor, you dumb security researcher. I don't believe, you! You're confused.\"\n\nLet's change that perception, shall we? The 'proof of concept', sometimes referred to as 'proof of code', is where we do just that. The onus is entirely on us auditors to convince the protocol about its vulnerabilities and their aftermath.\n\nOur proof of concept is even more critical during competitive audits. Without it, it's nearly impossible to convince a judging panel about the legitimacy of your findings.\n\nBut what if you're dealing with a sophisticated protocol? And perhaps you've already hinted at them that their on-chain data can be read directly off-chain, to which they might react like so:\n\n> \"Oh, yes, oh my God, you're right.\"\n\nWell, in such cases, you might not need to bullish about providing an exhaustive proof of concept. Nevertheless, especially at the early stages of your career, it's advisable to err on the side of elaborate explanation.\n\nThat's what we're doing here. To help you visualize the protocol's flaws better, we've constructed a test case that exemplifies how anyone can access the password directly from the blockchain. This is where we attempt to outsmart the approach of reading data directly off the blockchain.\n\nTo wrap things up, let's remember that while dealing with protocol vulnerabilities, being succinct yet comprehensive is the key towards effective auditing and security research. Happy auditing!\n",
          "updates": []
        },
        {
          "lessonId": "b77665e5-0308-4fc4-b3d3-0077c840bcae",
          "number": 16,
          "title": "Writing an amazing finding: Proof of code",
          "slug": "proof-of-code",
          "folderName": "16-proof-of-code",
          "description": "",
          "duration": 3,
          "videoUrl": "LhsdSF5IaA4",
          "rawMarkdownUrl": "/routes/security/3-first-audit/16-proof-of-code/+page.md",
          "markdownContent": "---\ntitle: Proof of Code\n---\n\n_Follow along with this video:_\n\n\n\n---\n\n# Demystifying Blockchain Security: A Test Case with Anvil and Foundry\n\nIn this post, we'll explore how to deploy a password store on a locally running blockchain, read from the password store, and access data that's meant to be private. By doing this, we're going to demonstrate a real-world example of a serious blockchain security issue we should all be aware of.\n\n## Setting Up A Locally Running Blockchain Using Anvil\n\nThe first step is to set up a fake blockchain to work with. If you have Foundry installed, Anvil should also be part of your development ecosystem. Anvil allows us to create a fake blockchain, convenient for simulating scenarios without breaching actual blockchain security.\n\nRun the following command to initiate Anvil:\n\n```shell\nanvil\n```\n\nThis should set Anvil running, creating a local blockchain.\n\n## Deploying Password Store using Foundry\n\nThe next step involves deploying a password store onto the locally running blockchain. To do this, we'll need a new shell from your terminal. We'll then run a script that will deploy the password store to our locally running blockchain. This deployment script resides in a makefile.\n\nReading Data Off the BlockchainOnce the password store is deployed, we can use Foundry's capability to access the stored data. Foundry has a keyword `Storage` which is used to read from the blockchain. Let's say the password was stored in slot 1; we can retrieve the data like so:```shcas storage -a contract\\_address -s 1 -u rpc\\_urlNote: replace `contract_address`with the actual address and`rpc_url` with your Anvil's Remote Procedure Call URL.\n\nThis will return a byte representation of the password, i.e., `my password`.\n\n## Parsing Byte Representation\n\nTo translate these bytes back into their original form, we can use the `parse` command in Foundry.\n\nReplace `byte_representation` with the byte return from `cas storage`. The output should coincide with the initially stored password, `my password`.\n\n## Concluding Findings\n\nThe process we've discussed provides proof that it's possible to read private data directly off the chain. An attacker can potentially retrieve and misuse this data.\n\n> \"This test case is overkill in a private audit, but clearly illustrates the importance of blockchain security in a competitive audit or when dealing with less experienced developers.\"\n\nTo sum up: first, we initialized a fake blockchain using Anvil, then deployed a password-store onto this fake blockchain. We used Foundry to read from this password-store on the blockchain, and decoded the byte output back to its original form. This audit experience is a handy reminder for developers to take extreme caution while storing sensitive information on a blockchain. The potential repercussions of mismanaging blockchain security extend beyond mere financial loss - they can potentially compromise your user's data and trust.\n",
          "updates": []
        },
        {
          "lessonId": "b62a9017-ac67-450d-bca0-3aaa84fbe1ec",
          "number": 17,
          "title": "Writing an amazing finding: Recommended Mitigation",
          "slug": "recommended-mitigation",
          "folderName": "17-recommended-mitigation",
          "description": "",
          "duration": 2,
          "videoUrl": "jFepZXpu5QI",
          "rawMarkdownUrl": "/routes/security/3-first-audit/17-recommended-mitigation/+page.md",
          "markdownContent": "---\ntitle: Recommended Mitigation\n---\n\n_Follow along with this video:_\n\n\n\n---\n\n## The Problem\n\nLet's start with this premise: You're creating a contract. The main aim of this contract is to store a private password that no one else can see. The contract architecture is such that it guarantees complete security by hiding this password. But imagine finding a glaring bug that breaks this promise. The truth is, maintaining your private password's security isn't a piece of cake, especially in the current architecture. The question is, how can we work around this issue?\n\n\"To be honest, this isn't an easy problem to solve. And this is where the importance of having a security mindset from day one comes into play\" -_Anonymous_.\n\n## Mitigation Starts with the Mindset\n\nGreat developers, particularly those at the helm of solidity and smart contract development, have a security-first mindset from the get-go. This means that they factor in security loops and potential threats right from the outset, ensuring that the whole system architecture leans towards security as its major prop. So what's their secret to creating hack-proof smart contracts? How do we actually mitigate such issues?\n\n## Re-Thinking the Architecture\n\nLet's examine this scenario: A bug in your contract deems it useless. So, the question becomes, how do we create a contract that stays strong despite all odds? Well, the overall architecture of the contract needs to be re-evaluated and restructured.\n\n### An off-chain encryption solution?\n\nOne approach could be to encrypt the password off-chain, then store the encrypted password on-chain. This would require an additional password that the user must remember for decrypting purposes.\n\nTake note, though, if you're considering this approach, you'll likely want to remove the view function. This prevents the user from having to send a transaction with the password that decrypts your password most of the time.\n\n## Wrapping Up: Rethinking Security as Educators\n\nRecommended mitigations might include specifying the code changes you want to implement. However, because an entire architectural reconstruction is required, text-format suggestions should suffice.\n\nAs security researchers, our role veers more towards being security educators. Our goal is to educate about clever methods of securing protocols to ensure forward safety and credibility. If you think you can provide a better mitigation method or strategy, I'm inviting you to contribute to the discussion and broaden our collective knowledge.\n\nBy doing so, you're helping create a future where bugs like these are a thing of the past, and each new challenge brings us one step closer to creating safer and more secure smart contracts. Let's challenge ourselves to come up with better ways to secure our future in the ever-evolving world of blockchain and smart contracts. Never forget, your contribution can make a significant difference!\n",
          "updates": []
        },
        {
          "lessonId": "ae91e415-198e-419c-998a-126ad430ed59",
          "number": 18,
          "title": "Finding Writeup Recap",
          "slug": "finding-writeup",
          "folderName": "18-finding-writeup",
          "description": "",
          "duration": 4,
          "videoUrl": "C_i0jrSLR9k",
          "rawMarkdownUrl": "/routes/security/3-first-audit/18-finding-writeup/+page.md",
          "markdownContent": "---\ntitle: Finding Writeup Recap\n---\n\n_Follow along with this video:_\n\n---\n\n## Previewing Your First Write-Up\n\n<img src=\"/security-section-3/18-writeup/writeup1.png\" style=\"width: 100%; height: auto;\">\n\nThe only thing that's missing is the severity, but don't worry, we'll come back to that a little later. For now, let's go over the structure and content of your initial write-up.\n\n### The Write-Up Structure\n\n1. **Title**: It's hard-hitting and to the point. For example, \"Storing the password on-chain leads to privacy breach.\"\n2. **Severity Status**: This is currently absent but we'll come back to it.\n3. **Root Cause**: The title explains the bug's root cause ‚Äî the password storage on-chain is visible to anyone, which is a significant privacy issue.\n4. **Impact**: It highlights the considerable ramifications ‚Äî that the password isn't private anymore.\n5. **Description**: This is a brief explanation of the problem, widely enhanced by using markdown.\n6. **Proof of Code**: It explains how anyone, with available tools, could exploit this particular vulnerability.\n7. **Recommended Mitigation**: A practical mitigation is suggested, such as encrypting the password off-chain and storing the encrypted password on-chain.\n\nWhile it may feel provocative to suggest ditching the whole protocol, we'd like to keep things constructive, offering more context or solutions where possible. Our goal is to educate developers on securing their smart contracts better.\n\nWith this first issue sorted, you might want to delete it, or keep it for reference ‚Äî it's up to you.\n\n_For brevity, let's move on to the next issue we spotted: missing access control._\n\n## Identifying the Next Issue: Missing Access Control\n\nThe 'Set Password' function can be accessed by anyone, whereas it should only be callable by the owner.\n\n### Adding a New Finding\n\nWe'll follow the previous finding's format. Here we'll begin with identifying the root cause: the 'Set Password' function in the 'Password Store' has no access controls. The impact? A non-owner could change the password.\n\n### Crafting the Description\n\nHere's the description I penned:\n\n```\nThe 'Password Store' 'Set Password' function is an external function. However, the 'nat_spec' of the function and the purpose of the smart contract is that only the owner should set a new password.\n```\n\nAdding the flawed code segment can be helpful, as it equips readers with a clear visualization of the issue. To do this:\n\n1. Use three backticks to start a code block.\n2. Then write the language that you're using for syntax highlighting ‚Äî in this case, JavaScript.\n\nThe comments explicitly mention the problematic section, making it easier for others to spot the issue. This step enhances the markdown view and provides better readability.\n\n### Highlighting the Impact\n\nFinally, the impact explanation underscores the problem's gravity, emphasizing that the flaw allows anyone to set or change the contract's password, grossly violating intended functionality.\n\nStay tuned for the next installment, where we probe further into smart contract vulnerabilities. Happy auditing!\n",
          "updates": []
        },
        {
          "lessonId": "a0c6d506-23e5-450b-a9db-2e263070cb51",
          "number": 19,
          "title": "Missing access controls proof of code",
          "slug": "missing-access-controls-proof-of-code",
          "folderName": "19-missing-access-controls-proof-of-code",
          "description": "",
          "duration": 5,
          "videoUrl": "4DxPzYDiOeU",
          "rawMarkdownUrl": "/routes/security/3-first-audit/19-missing-access-controls-proof-of-code/+page.md",
          "markdownContent": "---\ntitle: Missing Access Controls Proof of Code\n---\n\n_Follow along with this video:_\n\n\n\n---\n\n## The Importance of Proof of Concept &amp; Code\n\nDespite seeming glaringly apparent, proof of concept or proof of code is not always given its due attention, leaving room for security mishaps. Hence, it is essential to validate the protocol. The protocol's existing test suite provides invaluable assistance in doing so.\n\n## Setting Up the Test\n\nHere is a step-by-step guide on creating a custom test:\n\n- Initially, navigate to the test folder for writing the test.\n- Write a function, let's name it `test_anyone_can_set_password`.\n- To make the process more robust, make it a fuzz test.\n- Next, select a random public address.\n- For the first step within this function, we'll need to mock the address, for instance, `VM.prank(random_address)`.\n- Now, establish a string memory, e.g., `string memory expected_password = 'my_new_password'`.\n\nThen, we must reserve a section for the setup function to get the password contract established. An essential part of being a security researcher is being able to code effectively, so congratulations on this milestone when you achieve it!\n\n## Writing the Function\n\nContinuing the coding, remember we're a random address, aiming to set up a new password. Prank the owner of the contract setup in the beforementioned function now with another `VM.prank`. Here is how:\n\n- The string memory, for instance, `string memory actual_password = passwordstore.get_password`.\n- Set an assertion that verifies the `actual_password` and `expected_password` are the same.\n\nIdentifying areas of weakness, understanding them and bringing them to attention is what security research is all about, and hopefully, through these steps, you can do just that.\n\n## Result Presentation\n\nThe results can sometimes appear messy when presented with the test suites, especially in markdown. However, with the use of HTML tags, you can collapse the details into a small, clickable bit, making it more visually appealing.\n\nFor instance:\n\n```markdown\n<details>\n    <summary>\n        Code Summary\n    </summary>\n</details>\n```\n\n## Mitigation\n\nFinally, after discovering the weakness, it is crucial to provide a recommended solution or prevention measure. The solution here would be to add an access control conditional to the 'set_password' function.\n\n```javascript\nif (msg.sender != s_owner) revert(\"PasswordStore: Not owner\");\n```\n\nThe resulting effect would be a more secure 'set_password' function.\n\nWe've thus covered the second part of the testing and proofed it with a practical test case. Careful scrutiny of seemingly minor security risks can drastically enhance the security levels of blockchain systems.\n",
          "updates": []
        },
        {
          "lessonId": "a74c5914-96ee-42ff-8367-877e8741d95a",
          "number": 20,
          "title": "Finding Writeup Docs",
          "slug": "finding-writeup-docs",
          "folderName": "20-finding-writeup-docs",
          "description": "",
          "duration": 3,
          "videoUrl": "wUKTDt44veE",
          "rawMarkdownUrl": "/routes/security/3-first-audit/20-finding-writeup-docs/+page.md",
          "markdownContent": "---\ntitle: Finding Writeup Documentation Fix\n---\n\n_Follow along with this video:_\n\n\n\n---\n\n## A Brief Overview\n\nThe third finding focuses on an overlooked mishap in the code - there is no new password parameter. While not as alarming as some other findings, it's still a concern that merits attention. As we progress into assessing its severity, you'll understand why it's taken as a relatively minor issue. But as we've done before, we'll be conducting a thorough write-up, irrespective of the severity level.\n\nBefore we begin, here's a heads up: once you get adroit at figuring out severities, you'll notice that gas and informational severities don't necessitate extensive write-ups. But for the sake of consistency and thoroughness, let's treat this finding with the same intensity as the others.\n\nHere's how we proceed:\n\n![](https://cdn.videotap.com/IArtvAsHoY19oT7nCiE3-30.97.png)\n\n## Diving Deeper: Root Cause and Impact\n\nThe root cause of this finding lies within the documentation. It advocates for the existence of a parameter in the code ‚Äî when it does not exist ‚Äî throwing the documentation accuracy off kilter. Specifically, the password store get password function's Natspec indicates a non-existent parameter, culminating in incorrect Natspec.\n\nLet's put this in simple terms, shall we?\n\n> **The root cause:** A contradiction between the documentation and the actual function, with the former falsely referring to a parameter within the `get password` function.\n\nThe impact, as you might assume, revolves around the inaccuracy of the Natspec due to the aforementioned discrepancy.\n\n## Getting Technical: Code Analysis and Description\n\nLet's get into the nitty-gritty details by examining the JavaScript code. As visual reference, we're referring to this particular section in the documentation. Here:\n\n> `passwordStore_getPassword` is the function signature, whereas the Natspec suggests the function should be `getPassword` with a string. The divergence results in incorrect NatSpec.\n\n## Proof of Concept: Do We Need this Section?\n\nInterestingly, in this case, a proof of concept seems unnecessary given the straightforwardness of the issue. So, for brevity, we move forward without it.\n\n## Deciphering Mitigation Strategies\n\nOur recommended solution is quite succinct: eliminate the incorrect Natspec line. And here we're going to do a fun little markdown trick where we're going to say a diff.\n\nThis is a markdown format where you can indicate which lines to remove via `diff`. Now, if you preview it, it nicely exhibits in red, signifying that the said line ought to be deleted. Also, if we were to add a new line, we‚Äôd mark it with a plus sign, which will display in green for clarity. While in this case, we're suggesting only line removal, diff syntax can be incredibly powerful with its clear depiction of modifications.\n\nThat said, remember: sometimes less is more ‚Äî a guiding principle that applies to our mitigation strategy.\n\nWhile the omission of the password parameter might seem trivial at first, failing to rectify such issues could lead to larger problems down the road. Therefore, as conscientious developers and security analysts, it's our responsibility to keep our eyes peeled for these issues ‚Äî no matter how seemingly insignificant they may be! Let's keep doing our part to make the world of code safe and sound.\n",
          "updates": []
        },
        {
          "lessonId": "29159beb-58fe-4173-8544-58e249532558",
          "number": 21,
          "title": "Augmented report with AI",
          "slug": "augmented-report-with-ai",
          "folderName": "21-augmented-report-with-ai",
          "description": "",
          "duration": 3,
          "videoUrl": "rjaLKCmQf7g",
          "rawMarkdownUrl": "/routes/security/3-first-audit/21-augmented-report-with-ai/+page.md",
          "markdownContent": "---\ntitle: Augmented Report with AI\n---\n\n_Follow along with this video:_\n\n\n\n---\n\n# Using AI to Improve Smart Contract Codebase Analysis: A Step-by-Step Guide\n\nHi everyone! Today, I'll take you through an interesting process of utilising an AI tool to improve a detailed analysis of a codebase for a smart contract. We'll specifically use Chat GPT (or similar AI) for this purpose. Let's get going!\n\n## A Background of the Case Study\n\nAfter an intense session of analysis, we were able to come up with three separate deductions from the smart contract codebase.\n\n![](https://cdn.videotap.com/oa11o3VbVFQH3Vs1bTeD-13.56.png)\n\nHere are our initial findings:\n\n1. `Password Store get password` indicates that the parameter does not exist\n2. Storing the password on the chain makes it no longer private as it becomes visible to anyone\n3. `Password Store set password` has no access controls, which means a non-owner could change the password.\n\nBut these write-ups were not in the best shape, and we needed to work on them. And that‚Äôs where AI comes in.\n\n## Introducing AI into Codebase Analysis\n\nLet‚Äôs dig deep into how the AI can assist in making our write-ups more polished. If you ever struggle with write-ups and want to validate the grammar, syntax and format, these AI tools can be a savior. Here are the steps involved:\n\n**1. Initiate a dialog with the AI**\n\nStart by introducing your task here. Copy your write-up and paste it into the AI, saying:\n\n> The following is a markdown write-up of a finding in a smart contract codebase. Can you help make sure it is grammatically correct and formatted nicely?\n\nPaste your finding and seal it with four backticks.`\n\n**2. Wait for AI feedback**\n\n![](https://cdn.videotap.com/CloYoQjFvCrEnY8Rw5d7-74.56.png)\n\nThe AI will generate insightful feedback, picking up typos, suggesting formats, and assessing the grammar. This can be incredibly helpful in refining the delivery of your findings.\n\nIn our case, we had spelled `'incorrect'` as `'incrrect'`, and this was promptly highlighted by the AI. Additionally, it recommended using code format for function signatures and slight grammatical adjustments for better clarity.\n\nWe hence received an edited version of our markdown from our AI-assistant. The final read was much clearer and better organized.\n\n**3. Ensure that the feedback is implemented correctly**\n\nTo ensure the AI assistant didn‚Äôt make any errors or omissions, it's critical to carry out a sanity check of its work.\n\nAfter we got the feedback, it was time to delete our previous write-up and paste the improved version from Chat GPT.\n\n**4. Final check of the findings**\n\nWe quickly cross-checked the edits made by Chat GPT. All function signatures were in place, the descriptions were in order and impact of the code was correctly determined. Also, typos and grammatical errors had been corrected.\n\nAfter a thorough assessment, we concluded that the final write-up met our desired specifications.\n\n## Conclusion\n\nArtificial Intelligence, through tools like Chat GPT, can significantly streamline technical write-ups. It adds a layer of quality control, ensuring that your findings read well, look good and most importantly, communicate effectively.\n\nRemember to use these tools to your advantage when drafting complex technical reports. But as we've learnt, always remember to cross-check their work to ensure it is free from errors.\n\nThat's all for today, happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "03512a5b-d520-4f96-8dbf-ce9ae1b4a002",
          "number": 22,
          "title": "Quick primer on what we are learning next",
          "slug": "quick-primer-on-what-we-are-learning-next",
          "folderName": "22-quick-primer-on-what-we-are-learning-next",
          "description": "",
          "duration": 3,
          "videoUrl": "hrHjtS-edFY",
          "rawMarkdownUrl": "/routes/security/3-first-audit/22-quick-primer-on-what-we-are-learning-next/+page.md",
          "markdownContent": "---\ntitle: Quick Primer on What We Are Learning Next\n---\n\n_Follow along with this video:_\n\n\n\n---\n\n# Converting Markdown Files to Professional Documents and Adding Severity\n\n## Ratings: A Complete Guide\n\nAlright folks, we've made significant progress already. Reflecting on our development journey, we have notched up three substantial findings which are currently in our repository. However, our to-do list isn't finished yet. We still have two crucial aspects to iron out: first, our three findings need to be appended with their respective severity ratings, and secondly, we need to convert our Findings MD - a markdown file to a professional-looking PDF that can be shared with protocols, community, and others.\n\n## Why Converting Markdown to Professional PDFs and Severity Ratings Matter?\n\nAs developers, markdown files are a piece of cake for us, but we can't presumptuously assume the same for everyone else. Some people may not find them as digestible, hence the necessity to convert these findings into a PDF file or a more standardized looking document. Another advantage of housing this professional-looking PDF file is that we can showcase it on our GitHub, contributing to our portfolio of projects we've audited.\n\n![](https://cdn.videotap.com/icJBNaM8sxENWNYlNi7X-21.65.png)\n\nAnd let's not forget about severity ratings. It serves as a measure to gauge the gravity of our findings - a crucial aspect that we haven't attended yet.\n\nIn short, our work will remain incomplete until these final two tasks are accomplished. To make your quest easier, both tasks are covered under this audit data branch of the GitHub repository associated with this course.\n\n## How to Make A Professional Looking PDF and Define Severities?\n\nBy following the guide provided, you can convert your markdown file into a polished PDF that provides a more congenial read for your protocols during a private audit.\n\n![](https://cdn.videotap.com/6WRfDfytGP8akINajDkG-61.35.png)\n\nMoreover, the course also covers how to define Severities for codehox, competitive audits, and private audits. Upon wrapping up these two tasks, your section is as good as done!\n\n> \"You're almost at the finish line. Your zeal so far has been commendable. No doubt, the codebase was quite minimalistic and elementary, but the learning didn't share the same simplicity. However, you won‚Äôt be left in the lurch. Rest assured, a refresher is on its way. Now, let's dive into the concept of Severity Rating!\"\n\n## The Final Stretch: Severity Rating\n\nStay tuned as we delve further into this crucial aspect of the Severity Rating. Together, let's unravel the journey of transforming a straightforward markdown file into a sophisticated PDF and assessing the severity of our findings effectively. No more waiting; let's get to it!\n",
          "updates": []
        },
        {
          "lessonId": "158ef783-65ee-44e5-875f-e61bee78c412",
          "number": 23,
          "title": "Severity rating introduction",
          "slug": "severity-rating-introduction",
          "folderName": "23-severity-rating-introduction",
          "description": "",
          "duration": 4,
          "videoUrl": "Weo1AlLpPQw",
          "rawMarkdownUrl": "/routes/security/3-first-audit/23-severity-rating-introduction/+page.md",
          "markdownContent": "---\ntitle: Severity Rating Introduction\n---\n\n_Follow along with this video:_\n\n\n\n---\n\n## Your First Audit: Severity Guide\n\nWe have a comprehensive guide on how to conduct your first audit. In this article, we‚Äôll be focusing on one of the most important aspects of auditing: severity ratings, and you can always check the documentation at [CodeHawks](https://docs.codehawks.com/hawks-auditors/how-to-determine-a-finding-validity) if you want more context.\n\n![](https://cdn.videotap.com/7lZzIpoo6m1i2yRO4L8G-32.62.png)\n\n## Categorization: High, Medium, and Low\n\nFor the purposes of this guide, we will be focusing on three categories of severity ratings: high, medium, and low. While some auditors prefer to include an optional ‚Äúcritical‚Äù rating, in this article, we‚Äôll stick with the basic three categories.\n\nDetermining the category comes down to two elements: the likelihood of an attack and the impact of the attack. Though these can be subjective, there are some standard guidelines.\n\n1. **High severity**: High impact would be where funds are directly or nearly directly at risk, or a severe disruption of protocol functionality or availability happens.\n2. **Medium severity**: With a medium impact, perhaps funds are indirectly at risk or there‚Äôs some level of potential disruption to the protocol‚Äôs functionality.\n3. **Low severity**: A low impact finding might not put funds at risk but could indicate a function is incorrect, or a state may not be properly handled.\n\nThink of it in terms of user experience - how upset would users of the protocol be if a certain attack occurred?\n\n11## Assessing likelihood: The Probability Factor\n\nAssessing the likelihood of a certain event happening can be somewhat subjective. That said, consider the following:\n\n1. **High likelihood**: Think of cases where a hacker can directly call a function to hit impact, for example.\n2. **Medium likelihood**: Here, perhaps more specific conditions need to occur for the event to happen, such as a specific type of token being used on the platform.\n3. **Low likelihood**: This would be rare situations that are unlikely to happen but are still technically feasible, such as a certain A, B, C event taking place at a specific time.\n\nOf course, there are situations that are 'computationally unfeasible', or so unlikely they are practically impossible. They are not considered as attack paths.\n\n![](https://cdn.videotap.com/X03vsMLjpN6hMQWiqf3J-168.51.png)\n\n> ‚ÄúTake security assessments seriously. Understanding the severity of problems is crucial when auditors are scrutinizing your code.‚Äù -- Raj K.\n\n## Applying the Ratings: Examples\n\nWith a foundational knowledge of categories and likelihood, we can begin applying these to various scenarios. Before we jump into this, take a moment here to digest the above concepts. You can also peruse these examples of high, medium, and low severity assessments to get a better grasp of what these categories might entail.\n\nFor a practical exercise, we can look at the Password Store protocol to understand how to determine the severity of its security issues. Through thorough understanding and application, the severity scales we've discussed here today will prove invaluable to your auditing efforts.\n\nRemember: the goal of any audit is securing the protocol, and an integral part of this process is understanding severity ratings. So make sure to keep these guidelines in mind as you continue your journey in security auditing.\n",
          "updates": []
        },
        {
          "lessonId": "e5f83485-c2e9-41db-bd7b-69b6bca81dce",
          "number": 24,
          "title": "Assessing highs",
          "slug": "assesing-highs",
          "folderName": "24-assesing-highs",
          "description": "",
          "duration": 4,
          "videoUrl": "NtEwjvnLfvA",
          "rawMarkdownUrl": "/routes/security/3-first-audit/24-assesing-highs/+page.md",
          "markdownContent": "---\ntitle: Assessing Highs\n---\n\n_Follow along with this video:_\n\n\n\n---\n\n# How to Evaluate Finding Severity: Hands-On on VS Code\n\nWelcome to the definitive guide on evaluating the _severity_ of your findings. Specifically, we will be drawing examples from storing a password on-chain and finding potential vulnerabilities. By the end of this journey, you'll understand the process of assessing your findings and identifying their severity.\n\n## Understanding the Structure\n\nHere we are, on our findings page, keen to figure out how we evaluate severity.\n\n![](https://cdn.videotap.com/uKAm9nbZqqFSb0JpwSD2-30.14.png)\n\nWithin Vs code, a nifty little drop down helps us to collapse the findings for easy visibility. This feature provides a more consolidated view for efficiency.\n\nHowever, in case your dropdown keeps auto uncollapsing, apprehend the scenario. This blog piece has been built using an approach that still presents the collapsed view for clarity.\n\n## Dissecting Storing Password On-Chain\n\nLet's set the stage with our first finding. Storing the password on-chain is a strategy that makes it visible to anyone, thereby stripping it of its private status.\n\nRanking severity requires us to consider two major aspects: **likelihood and impact**.\n\n### Looking at Impact\n\nWhat does it _criticality_ of making the password public hold? Does it put funds directly at risk? It does not. However, does it cause a severe disruption of the protocol functionality or availability? The answer is a resounding yes.\n\nThe core purpose of a password store protocol is ensuring password safety on-chain. So, when this is disrupted or diminished, we're looking at a high potential impact. This situation will undoubtedly tip towards higher severity.\n\n```markdown\nQuote: \"The impact of storing the password on-chain corresponds to high severity. It severely disrupts the protocol functionality\"\n```\n\n### Understanding Likelihood\n\nBut what is the probability of this mishap? The feasibility of a hacker directly calling this function, extracting money, or breaking the protocol? Indeed, it seems rather easy for this to happen. In the worst-case scenario, passwords stored on-chain could be read off-chain by anyone at any given moment. Hence, _likelihood_ maps to high in this case.\n\nHigh impact and high likelihood, you might know, translates to _critical severity_.\n\nBut we'll just denote this with an _H_ for high impact and high likelihood, signaling a high severity. This way, our first finding is:\n\n```plaintext\n[\"1\"]: H - Storing the password on-chain makes it visible to anyone, stripping it of its private status.\n```\n\nPractically, 'findings' range from high, medium, to low. The worst players are ranked higher, but this trend is more of a rule of thumb and can change based on context.\n\n## Examining Password Store Set\n\nNext, let's explore another scenario. What if the password store set has no access controls? The impact might look something like a non-owner being able to change the password. It's another disruption of the protocol functionality. Scroll down to learn more.\n\nIf any random person sets a password and then another comes to change it at their will, we're indeed looking at another situation with high impact.\n\nSurprisingly, this ploy is not too implausible to pull off. Any budding hacker merely needs to call the '_set password_' function, plug in a new password, and viola, the password has been altered!\n\nEchoing our previous finding, the likelihood of this event is high, making severity palpable.\n\nIrrefutably, this severity is also high. In the scope of this blog, this would be noted as:\n\n```plaintext\n[\"2\"]: H - Password store set has no access controls; a non-owner can alter the password.\n```\n\nOur second high-severity bug!\n\nDiscussing severity, it's important to mention that our first finding outweighs this in severity. It entirely undermines the purpose of the protocol, but this, too, is significantly harmful.\n\n## Investigating Incorrect Natspec\n\nAt last, we have landed on our final finding. If the password store's get-password NatSpec indicates a non-existent parameter, the NatSpec ends up incorrect.\n\nLet's follow the same procedure to evaluate its impact. What-acould-go-wrong with incorrect documentation in the context of severity? Find out in the next section!\n",
          "updates": []
        },
        {
          "lessonId": "1fd41478-a19f-4b64-abc0-cadc351170e2",
          "number": 25,
          "title": "Severity rating informational",
          "slug": "severity-rating-informational",
          "folderName": "25-severity-rating-informational",
          "description": "",
          "duration": 3,
          "videoUrl": "aNs-fKyP5t4",
          "rawMarkdownUrl": "/routes/security/3-first-audit/25-severity-rating-informational/+page.md",
          "markdownContent": "---\ntitle: Severity Rating Assesing Informational/Gas/Non-Crit\n---\n\n_Follow along with this video:_\n\n\n\n---\n\n# Understanding the Severity of Blockchain Protocol Findings\n\nAssessing the gravity of issues in blockchain protocols can be challenging, especially for beginners in this complex field. Let's crack the mechanics of this process in a digestible form by breaking down each factor that impacts severity - disruption to the protocol, risk to funds and the chances of occurrence. Additionally, we'll deep dive into differentiating a critical issue from an informational observation.\n\n## What Determines the Severity?\n\nDifferent aspects determine the severity, primarily including whether the funds are at risk or if there is a major disruption. There's an area in the middle, where we are faced with issues that don't explicitly endanger funds or bring total disorder but still present as disruptions that shouldn't be ignored. For instance, a function might not be functioning as intended or state mismanagement.\n\n![](https://cdn.videotap.com/7MnH5j3N8rEe92sSzFg5-23.62.png)\n\n> Examining if the protocol will operate as expected or if user assets are jeopardized aids in understanding the severity.\n\n## What is an Informational Finding?\n\nImagine a situation where there's incorrect documentation instead of a problem in the function itself. The repercussions are minor since the impact is limited to someone potentially misunderstanding the code.\n\nDoes this have a high probability of happening? Yes. However, since it doesn't affect the protocol's functioning or carry any risk, its impact remains negligible, making it a zero impact issue.\n\nConsequently, severity in such cases is assessed as informational or \"noncritz.\" An informational finding is a non-critical instance where you bring it to the team's attention to improve code readability, extend test coverage, or rectify design patterns.\n\nYou may also identify spelling errors, incorrect documentation, and opportunities for gas improvement, even though they don't qualify as bugs.\n\n![](https://cdn.videotap.com/RKj8pxAxknNIVZU5STC2-76.76.png)\n\nA wealth of tools can aid in informational findings to enhance your protocol. Make note of the fact that if you come across something that doesn't qualify as a bug but could potentially improve the code, it will often be an informational finding.\n\n## What are Gas Improvements and Non-critical Issues?\n\n\"Gas\" in the context of blockchain refers to a fee associated with performing certain actions on the Ethereum network. By optimizing the \"gas\" usage of a function or a contract, you can help to reduce the cost of transactions on the Ethereum network.\n\nFor any gas improvements, it's marked as a gas improvement in severity. On the other hand, we have non-critical issues ‚Äì casually referred to as \"non-Crits\" or \"NCs\".\n\n## Categorizing Severity\n\nEach instance can be easily marked with a simple categorizing system. For example, you can note it as 'I' for informational, 'NC' for non-critical, or 'G' for gas improvements. We will take the example of an incorrect documentation case and mark it as 'I', annotating it as the first informational issue with 'I1'. This approach brings clarity when multiple issues are present, providing an organized overview of severities.\n\nIn conclusion, to understand the severity of protocol findings, we need to evaluate the impact on funds, disruption level, probability, and classify bugs, improvements, and non-critical issues appropriately.\n",
          "updates": []
        },
        {
          "lessonId": "1e473170-594f-407a-958a-1e0a73e1e791",
          "number": 26,
          "title": "Timeboxing",
          "slug": "timeboxing",
          "folderName": "26-timeboxing",
          "description": "",
          "duration": 2,
          "videoUrl": "QuAmxV9PuXo",
          "rawMarkdownUrl": "/routes/security/3-first-audit/26-timeboxing/+page.md",
          "markdownContent": "---\ntitle: Timeboxing\n---\n\n_Follow along with this video:_\n\n\n\n---\n\n# The Art of Code Review: Managing the Password Store Inspection\n\nHello Coders! You know how we all love our code, always willing to add one more line, to make it perfect. Well, today, we'll be discussing a crucial aspect of the developer's life - Code Review, with a specific focus on Password Store.\n\n## Code Review: Do we need another round?\n\nI presume some of you might ask, \"Should we do another review of the Password Store?\" Before we dive in, why don't you take a pause, jot down what you think - do we need another run?\n\n## The answer - Maybe?\n\nWelcome back! So, what's the answer? Honestly, it could be a _maybe_. It's a never-ending process, you can always look at one more line of code or rerun one more box test. But as developers, there comes a point where you've to put down your coding gloves, and tell yourself, \"It's done. Time to move on\".\n\n> \"A good programmer is someone who always looks both ways before crossing a one-way street.\" - Doug Linder\n\n## The Human Aspect in Code Review\n\nAny lingering queries? Well, go ahead and try to get them answered. However, remember, programmers are humans too. Many-a-times, we face time constraints. In fact, I could spend an eternity scrutinizing a set of codes, deciphering more methods, and challenging my local findings. Understanding the intricacies of a particular protocol may seem tantalizing, but it's also essential to know when to stop.\n\n## The Art of Time-Boxing\n\nWhen it comes to reviewing codes, it's really important to master the art of 'time-boxing'. It's a strategy where you fix a maximum time limit to spend on a specific activity. In this case, deciding how much time you'd spend on code reviewing before moving on to reporting. By following this strategy, you ensure that you use your time effectively and avoid being stuck in an endless loop of code optimization.\n\nThe common outcry among most security researchers often is, \"I don't have enough time\". However, the key lies in not having more time, but in managing the available time better.\n\n## Wrap up, Write the Report &amp; Move on\n\nThere's always the lure to gaze upon another line of code, trying to level up your work. But, there comes a point when you need to compile your findings, pen down the report, and move on to the next assignment.\n\nSo, for now, we are at the end of the proverbial road, or let's say, the close of our coding task or nearing the audit deadline. We have our findings, it's time to wrap up and draft the report.\n\nWell then, let‚Äôs bring down the curtain here for now and look forward to a new day with newer challenges. Happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "dec1f423-fbec-418b-b257-afc6f123df6a",
          "number": 27,
          "title": "Making a PDF",
          "slug": "making-a-pdf",
          "folderName": "27-making-a-pdf",
          "description": "",
          "duration": 12,
          "videoUrl": "oJfVE91ooRI",
          "rawMarkdownUrl": "/routes/security/3-first-audit/27-making-a-pdf/+page.md",
          "markdownContent": "---\ntitle: Your First Full Report - Making a PDF\n---\n\n_Follow along with this video:_\n\n\n\n---\n\n# Creating Your First Professional Markdown Report\n\nHello and welcome back! In today's lesson, we're going to cover how to convert a list of findings into a professional-looking PDF using **Markdown**. This is particularly useful for independent security researchers, new firms, and anyone who wants to get familiar with writing reports and creating their own markdown reports.\n\nOur goal is to transform raw data into valuable information by creating a detailed and comprehensive report. Plus, this gives you something impressive to add to your portfolio!\n\n![](https://cdn.videotap.com/q1CDqX5IudNynKGhU2Z3-28.29.png)\n\n## The Basics\n\nWe're going to start off on Github, specifically our tailor-made repository for creating markdown reports. Make sure to read through the documentation provided in the repo to get a good understanding of the process.\n\nTo get started working with this repo, install **Pandoc** and **Latex** on your machine.\n\n> _Note:_ As mentioned in the course, installation will not be covered here. At this point in your journey, you should be comfortable with this process.\n\nAnother utility you'll need to install is the **[Latex project](https://www.latex-project.org/)**. Once the installations are successful, you should be able to run `Pandoc help` in terminal and receive an output like this:\n\n```\nPandoc 2.2.3\nCompiled with pandoc-types 1.17.5.1, texmath 0.11.1.2, skylighting 0.7.5...\n```\n\nThis is another point at which **Windows Subsystem for Linux** can prove invaluable for Windows users.\n\n## Including a Latex Template\n\nThe next step involves installing a latex template. For our purposes, we're using a package that leverages Pandoc to generate PDFs. This package comes with templates built with Latex syntax which we'll explore further.\n\nYou can find the template within the Github repo. Note that the syntax will look a bit strange - a mishmash of HTML and markdown.\n\nFor customizing your PDFs in future, consider using different templates or creating your own. Collaborating with colleagues proficient in Latex, like **Chat GPT**, can also yield fantastic results!\n\n## Adding Your Own Logo\n\nOnce your template is added, it's time to make the report more personalized. Add your PDF logo to the directory - when using VS Code, you can simply drag and drop the file. If you're having trouble viewing the PDF, try installing the **Vs code PDF** extension.\n\n## Markdown File for Findings\n\nTo detail our findings, we'll need a markdown file: `report_example.md`. On accessing the raw file, you may find the output a little crazy-looking since the markdown file is loaded with Pandoc-friendly text.\n\nCopy this file into a new markdown file named `report.md`. This will become your official report.\n\nInside the report, there are several things you'll need to customize:\n\n- **Title:** Name it something that describes your work precisely such as \"Network Vulnerability Assessment\".\n- **Author:** Replace \"_name here_\" with your own name.\n- **Date:** Update the audit date.\n- **Other Personal Details:** Replace every instance of `your name here` from Cypher or whatever you're working with. Put in your social links for connecting with people when necessary.\n- **Subtitle and logo:** Modify these fields as per your needs.\n\nNow, let's move to the sections under `===` which you can customize according to your audit:\n\n- **Prepared by:** Write your name.\n- **Auditors:** List all the auditors involved in the assessment.\n- **Protocol summary:** Describe the protocol and its workings.\n- **Disclaimer:** Let your clients know that this report is not a guarantee of a bug-free code.\n- **Risk classifications:** Explain the criteria for classifying severities into High, Medium and low.\n- **Audit details:** Include the commit hash that your findings correspond to.\n- **Audit roles:** Input the roles.\n- **Executive summary:** Give a brief overview of the assessment process.\n- **Severity and number of issues found:** This is a visual representation of the findings in the format of a table.\n- **Findings:** Give detailed explanations of the issues found.\n\n**Markdown All in One** extension is very useful for creating automatic Table of Contents in markdown files. It provides the update command at every save post which is really an add-on. If you want to go to any section directly, just click on it from Table of Contents section.\n\nOur report is now ready to be transformed into a marvelous, professional looking PDF!\n\n## Generating the PDF\n\nWe're going to use the Pandoc command provided in our Github repository's `audit report` section to convert our markdown file into a PDF.\n\n_Note: Replace the default file name `report_example.md` with ours - `report.md`._\n\nOnce the command runs successfully, we are left with an exquisitely formatted, professional quality PDF report ready for delivery to the client. We've successfully taken raw audit data, and turned it into a report that we can be proud of.\n\nCongratulations on creating your first professional PDF! Stay tuned for our next session, where we'll step up the game even further.\n\n![](https://cdn.videotap.com/xt6wnkzEX5SLQlpEFKGA-660.14.png)\n\nDon't forget to review what we've done today, and as always, happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "d6132ca3-3b84-4cca-8d12-bfb779c8cb46",
          "number": 28,
          "title": "Building your portfolio",
          "slug": "building-your-portfolio",
          "folderName": "28-building-your-portfolio",
          "description": "",
          "duration": 2,
          "videoUrl": "F4AoVbDE7N0",
          "rawMarkdownUrl": "/routes/security/3-first-audit/28-building-your-portfolio/+page.md",
          "markdownContent": "---\ntitle: Building Your Portfolio\n---\n\n_Follow along with this video:_\n\n\n\n---\n\n# Building an Audit Report Portfolio with GitHub\n\nIf you're looking to establish yourself as a credible smart contract auditor or simply a coding maven in security, having an organized and accessible portfolio of your audit reports can be a game-changer. Whether they're your latest software Security Reviews or faith-inspiring Code Hawk Learnings, these reports can narrate your journey and expertise, and impress potential clients or employers.\n\nIn this article, we'll be talking about how to compile your portfolio on GitHub and at the end of this, you'll have your first portfolio ready to charm the world! So let's jump straight in.\n\n## Step 1: Create a New Repository\n\nWe begin by creating a new repository in your profile. You can name this repository anything that suits the narrative of your work - \"My Audit Reports\", \"Security Reviews\", \"Updraft Portfolio\", etc. We decide to name our repository \"Codehawks Security Portfolio\".\n\nHere's how you create a new repository:\n\n![](https://cdn.videotap.com/ylBHN6CdlSHusSOxkXLn-28.09.png)Remember, our aim is to allow everyone to see your work, hence, while setting up, we are choosing to make this repository Public.\n\n## Step 2: Adding an Existing File\n\nScroll down to the Git setup page and click on ‚Äúupload an existing file‚Äù. If you're using a Mac, you can easily reveal hidden finder by right-clicking and choosing 'Reveal in Finder'. Of course, Windows users can find their own methods to navigate to the file explorer.\n\nWe are essentially looking to add our PDF reports here. I‚Äôll take an example report and add it to the repository.\n\n![](https://cdn.videotap.com/7MisAyQ4lUn7Krsu2RmR-51.5.png)> **\\*Note:** Renaming your report with a prefixed date, for example, \"Date2020_311_OnePasswordStoreAudit\", can help you stack your reports chronologically. This could, in turn, allow you (and others) to effortlessly trace your progression.\\*\n\nAdding the renamed report to the repository is as simple as copying it and pasting it back into the repository folder in your finder.\n\n## Step 3: Committing Your Changes\n\nOnce the report is added, you'll need to confirm your changes by 'committing' them. Click the `commit` button at the base of the screen to save the changes.\n\n## Step 4: Building On Your Portfolio\n\nNow the important figurative brick has been laid. You can continue building up by adding your reports as and when they come in. You can create a README file later to guide the repository visitors through what they can find and expect from this repository.\n\nBy clicking the link of your portfolio, now anyone can delve into your journey, witness the work you have accomplished, and instill trust in your abilities as a smart contract auditor or a security specialist. You can now use these repositories to display your portfolio to the world.\n\nCongratulations! You have successfully set up your first portfolio using Github. It's a huge milestone and now with this achievement, you are ready to showcase your work, experiences, and skills to the world. Keep this portfolio updated and it's only going to impress potential clients and employers and skyrocket your chances in landing that dream opportunity.\n",
          "updates": []
        },
        {
          "lessonId": "eae0082a-5f73-478d-a395-77171bf7dfd6",
          "number": 29,
          "title": "Exercises",
          "slug": "exercises",
          "folderName": "29-exercises",
          "description": "",
          "duration": 4,
          "videoUrl": "jXDA-a6Fh14",
          "rawMarkdownUrl": "/routes/security/3-first-audit/29-exercises/+page.md",
          "markdownContent": "---\ntitle: Exercises\n---\n\n_Follow along with this video:_\n\n\n\n---\n\n# Your Unprecedented Progress in Code Auditing and What's Next\n\nHey everyone! I just wanted to congratulate you on completing the first section of our code auditing course. It's a giant leap forward in your journey to beefing up your security skills. By far, this was the smallest and easiest code base we've dealt with - full of glaringly obvious bugs, perfect for beginners.\n\nBut did you find it too challenging? Don't worry! The challenges are only set to spike from here. Remember, in your exploration and troubleshooting, you may sometimes get presented with poorly written code. Don't let the bad code distract you. Your focus should be on debugging it.\n\n## Cheers to your Accomplishments!\n\nAgain, a massive congratulation to everyone for your achievements so far! You've taken a crucial first stride. But don't get too comfortable - we're just getting ramped up!\n\nBy the end of this course, your portfolio will contain not one, but six impressively professional security reviews! Here comes the exiting bit - get ready to audit the final \"Boss Vault Guardians\", which is going to be nothing short of awe-inspiring!\n\n![](https://cdn.videotap.com/lczjZNOdteSEVFTeatFV-39.64.png)# Preparing for the Next Chapter\n\nBefore we conclude the section three, I have a couple of tasks for you to accomplish.\n\n1. **Tweet about your progress**: Publicly acknowledging and sharing your small wins often gives a big motivational boost. Tweet about your experience so far, and don't forget to join the community discussions on platforms like **discord** and **Cyfrin**.\n2. **Sign up for Code Hawks**: Now comes the practical application of what you have learned so far. After completing this task, you will be ready to start performing \"competitive audits\". Although there are a few more skills for you to learn, you're overwhelmingly ready for this challenge! So, sign up [here](https://www.codehawks.com/).\n\n# The Benefits and The Next Steps\n\nPerforming competitive audits not only helps you to practise your newly-acquired skills but is also one of the fastest ways to learn and grow. That's why we've incorporated a multitude of features into our platform to help you sharpen your skills and assist protocols to maintain security.\n\n> **However, my one piece of advice would be to continue the course to ensure a comprehensive learning experience.**\n\nSo there you have it! Your tasks at the end of this course: tweeting your progress and signing up for Code Hawks.\n\nNow, it's time for a breather. Grab that cup of coffee, take a walk, basically do anything that helps you unwind and refocus. I can't imagine the amount of learning you've accomplished so far and am pretty excited for you to start building your security portfolio. But remember, it's essential to rest before diving back in because the next section, 'The Puppy Raffle Audit', will prove more demanding.\n\nSo, take a well-deserved break, and I'll see you very soon!\n\n![](https://cdn.videotap.com/Q6RCCk0Sh02NOuZZhjXh-178.39.png)\n",
          "updates": []
        },
        {
          "lessonId": "2da34237-3c5f-48df-8f22-0a09d8cf1b12",
          "number": 30,
          "title": "Recap & Congrats",
          "slug": "recap-&-congrats",
          "folderName": "30-recap-&-congrats",
          "description": "",
          "duration": 9,
          "videoUrl": "V3oR3TsNHzk",
          "rawMarkdownUrl": "/routes/security/3-first-audit/30-recap-&-congrats/+page.md",
          "markdownContent": "---\ntitle: Recap & Congrats\n---\n\n_Follow along with this video:_\n\n\n\n---\n\n# The Comprehensive Guide to Conducting A Solidity Security Review\n\nToday, we're diving into how to conduct a security review for Solidity, the programming language behind Ethereum's smart contracts. We'll walk you through the major phases, from educating protocols about security necessities and onboarding them, to conducting a thorough security review and generating a professional report.\n\n## Starting with a Basic-Yet-Critical Lesson\n\nOne of the first things to understand is that audit requests often come in the form of Ether scan links, a practice that needs to change. A more comprehensive process is required to ensure security, which includes properly onboarding different protocols and teaching these protocols about safety measures.\n\n```markdown\nBasic Security Structure:\n\n1. Have a test suite\n2. Complete onboarding questionnaires\n3. Consciously plan for an audit\n```\n\nThe first step toward creating a secure protocol involves ensuring they're thinking about security in the right way.\n\n## Gathering Documentation\n\nOnce a protocol has been onboarded, you will need to amass all the documentation relating to the protocol, such as details about how to build the protocol and the actual scope of the security review.\n\nKey details to identify include:\n\n- Solidity version\n- Chains\n- Tokens\n- Roles\n- Known issues\n\n## Estimating Codebase Size\n\nLearning how to estimate the size of a codebase can also be beneficial when predicting the duration of an audit or security review. The tool \"Solidity Metrics\" is useful for this, as it provides a simple output detailing the number of source lines of code and a complexity score.\n\nAlternatively, the \"cloc\" command can be used, offering similar statistics and aiding the planning process for audits and reviews.\n\n## The Phases of A Smart Contract Audit\n\nParallel to conventional software engineering, security reviews also involve a number of phases, namely Scoping, Recon, and Vulnerability Identification.\n\nHere's a brief rundown on each phase:\n\n- **Scoping**: Collect initial information, determine what is within scope, and plan the review.\n- **Recon**: Look for potential bugs and abnormalities.\n- **Vulnerability Identification**: Identify actual bugs, tinker, take notes, comment, and figure out the severity.\n\nNext, the process also involves creating a detailed report post-analysis.\n\nThe final two phases involve the protocol fixing any issues identified, adding tests, re-testing, and conducting a mitigation review. This phase usually proceeds more swiftly, given that you would by then have gained substantial context about the codebase and only need to focus on the differences.\n\n## Imperial Advice from an Ace Security Researcher\n\nWe've had the privilege of learning from renowned security researcher, Wizard Tincho, who shared his method for carrying out smart contract security reviews. His advice? Start by reading the docs, take detailed notes, and then build from small to large concepts.\n\n> \"Read the docs, take notes, go from small to large.\" - Wizard Tincho\n\nYou can find his full-length interview [here](https://www.youtube.com/watch?v=bYdiF06SLWc&t=0s), where he dives deeper into his techniques for successful security reviews.\n\n## Getting Hands Dirty with an Actual Security Review\n\nAfter getting a good theoretical foundation, it's time to try it out. For instance, we conducted a security review where we detected missing access controls, a relatively common bug, yet one that provides crucial insights into the protocol.\n\nIn our review, for example, we found a section in the 'set password' function that should have stipulated that only the owner of this contract could set the password - this essential requirement was missing.\n\nThis is precisely why understanding the protocol's intended function is crucial for finding bugs. Often, with multiple roles within a protocol, identifying the appropriate access controls can get complicated and it's virtually imperative to clarify roles at the outset.\n\nConsequently, getting to know potential exploits such as private data and access controls is absolutely crucial, even if they seem highly evident.\n\n## Hand-holding through Writing a Phenomenal Review Report\n\nOne of the final and more essential steps lies in writing a comprehensive report. A template that works well includes a succinct description, where you mention the root cause and impact in your findings list. Here's a minimal example to illustrate this:\n\n```markdown\n### Findings1.\n\nStoring the password on chain makes it visible to anyone and no longer private. (Root Cause -> Impact)\n\n### Recommended mitigation\n\n_Depends on the findings; can range from code fixes to architecture changes._\n```\n\nAdditionally, it's quite useful to provide proof of code as an evident proof of the concept for the existing issue.\n\nFinally, don't neglect informational write-ups where you can flag potential areas of concern even if they aren't critical bugs.\n\n## The Magic of AI in Audits\n\nModern advancements mean we can embrace the power of Artificial Intelligence (AI) in helping us tackle an audit. Using AI, we can expedite and automate some tasks, saving countless precious hours.\n\n## Recognizing the Severity and Classifying Findings\n\nClassifying the severity of findings can initially seem a subjective task. However, with practice, distinguishing between high, medium, and low severity findings becomes easier.\n\nFundamentally, this distinction rests on the matrix of likelihood versus impact. For example, a high impact and highly likely finding that disrupts the protocol's functionality entirely would qualify as a 'high severity' finding.\n\n## Bringing It All Together with An Audit Report\n\nFinally, you'll consolidate all your findings into a detailed, professionally laid out audit report using a tool like Markdown. This will present your findings in a clear and accessible format and provides a great visual representation to clients.\n\nHowever, remember that this process is but a guide. You might decide to create your own report template or use different tools as you grow experienced in conducting audits and reviewing security. Bitcoin/blockchain is still a relatively new field, so the aim is to keep iterating, learning, and improving your review process. Whichever path you choose, the goal remains the same: to construct a secure, sound protocol.\n\nThat's your brief yet comprehensive guide to conducting a security review in Solidity. Audit on and ensure the crypto world stays secure!\n",
          "updates": []
        }
      ]
    },
    {
      "sectionId": "131e6eb2-4fa2-4f48-a788-33a008abf278",
      "number": 4,
      "title": "Puppy raffle",
      "slug": "puppy-raffle",
      "folderName": "4-puppy-raffle",
      "lessons": [
        {
          "lessonId": "9b46fac7-d345-4a64-afa2-54f6f7c2c8fe",
          "number": 1,
          "title": "Introduction",
          "slug": "introduction",
          "folderName": "1-introduction",
          "description": "",
          "duration": 5,
          "videoUrl": "3Tn_jJxYvoc",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/1-introduction/+page.md",
          "markdownContent": "---\ntitle: Introduction\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n---\n\n# Puppy Raffle Audit\n\nWelcome to the in-depth discussion on the Puppy Raffle Audit! Conducting audits, particularly for smart contract security, is a necessity in the field of computer programming. Engaging in audits not only fine-tunes your coding skills, but it also gives your portfolio a significant boost.\n\nWhat makes the Puppy Raffle Audit discussion interesting is that it is a current live event on the CodeHawks platform. This provides us with an opportunity to examine both private and competitive audits, helping you to hone your skills in writing professional audit findings.\n\n---\n\n## CodeHawks First Flights\n\nCodeHawks First Flights offers an excellent platform for budding smart contract security researchers. This platform contains relatively easy-to-understand codebases that resemble those you will find in this guide.\n\nIf you are a beginner, this reference will help you familiarize yourself with the nuances of code auditing. More experienced auditors will find it a chance to reiterate their learning and uncover new strategies.\n\n![](https://cdn.videotap.com/WViyXovd5mwSDrFG0B68-71.76.png)---\n\n## Learning Outcomes\n\nThrough this section, you will:\n\n- Familiarize yourself with your first set of tooling.\n- Understand what static analysis is and its role in enhancing protocol security.\n- Gain an insight into the different exploits in this codebase.\n- Finally, learn how to write reports of competitive audits and differentiate them from private audits.\n\n---\n\n## Your Journey\n\nThroughout your Puppy Raffle Audit journey, you will encounter a range of exploits in a sophisticated codebase. To cover more ground, this guide also includes case studies because historical attacks offer valuable lessons in improving security measures.\n\nHere‚Äôs your itinerary:\n\n1. Familiarize yourself with the Puppy Raffle audit codebase.\n2. Pinpoint and analyze numerous exploits inherent in the codebase.\n3. Conclude the mission with the production of a professional audit report.\n4. Learn how to create competitive audit reports that catch the eye for selections.\n\n![](https://cdn.videotap.com/7lcDGcvJJnJfWsy6ddge-202.24.png)---\n\n## Diving Into the Audit\n\nReady to take the plunge into the audit? Scroll to section four and select the repo to get started. You'll come across two branches: the **main** branch and the **audit data** branch. Unlike prior projects, the onboarding document of this project is already successful.\n\nUnder these branches, you will find detailed information including compatibilities, roles, known issues, the audit scope, and more. At this point, you have everything you need to embark on your audit journey. Just beware, future audits will demand more extensive onboarding so this super-detailed manual while making things easier, may set unrealistic expectations!\n\n![](https://cdn.videotap.com/HCLaeRMCU3Y5V1POfhjN-234.86.png)Inside the audit data folder is where all the audit/security review info resides. Although it could be helpful to dive straight into the answers given here, it isn't advisable. The real learning and skill-building come from individually tackling the codebase, unraveling the codes, and discovering the attack vectors.\n\nIn the case of the Puppy Raffle, there are four high severity vulnerabilities awaiting discovery. Bear in mind that the ultimate goal of this exercise is to thwart those looking to exploit these vulnerabilities. Every bug or issue you identify and report prevents potential hackers from exploiting the protocol.\n\n```\n\"There are always attackers looking to break these protocols, and we need to keep that in mind when we're working on them.\"\n```\n\nSo gear up, as the world of the Puppy Raffle audit has many secrets waiting to be unveiled!\n",
          "updates": []
        },
        {
          "lessonId": "0af77dc7-3aa4-4ba0-9d07-2cf85bacea1c",
          "number": 2,
          "title": "Puppy raffle primer",
          "slug": "puppy-raffle-primer",
          "folderName": "2-puppy-raffle-primer",
          "description": "",
          "duration": 2,
          "videoUrl": "XlWxaaH01jM",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/2-puppy-raffle-primer/+page.md",
          "markdownContent": "---\ntitle: Puppy Raffle Primer\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Taking on the Challenge: Navigating the Puppy Raffle Codebase\n\nWelcome to another exciting exploration into the world of programming, where we tangle with codebases and debug in the quest for learning and continuous improvement. We have a very thrilling activity lined up for you in this guide. We‚Äôre going to dive deep into the belly of a beastly codebase and find the bugs lurking within.\n\nSo ready your development kit and clear your schedules, we‚Äôre about to discover how it feels to do this all by ourselves!\n\n![](https://cdn.videotap.com/dGXjTG9jrsJQ7JfxnRls-7.5.png)## Our Main Mission: The Puppy Raffle Codebase\n\nFirst, let‚Äôs get a few things in order. Here is what you need to do:\n\n1. **Resist the temptation** to peek at the audit data branch. This section holds the answer key to the problems we‚Äôre trying to solve, and we won't get anywhere looking at that!\n2. **Spend some devoted time** working on this challenge by yourself. Maybe spend a solid 30 minutes on it. If that feels too long or frustrating, feel free to take a break.\n\nYour mission is to review, find bugs, and rectify them as best as you can.\n\n## The Phenomenal Playground\n\nNow, why are we doing this? Well, not only does this exercise help you test your skills and get some real coding experience, but it also gives you a good feel for the kind of challenges you might face when you‚Äôre working on your own projects.\n\n> \"This codebase is a phenomenal playground for you to test your skills and see how you're doing.\"\n\nThe objective isn‚Äôt just to find as many bugs as you can, but to understand their impact, their cause and most importantly, how to fix them. This first-hand experience can be invaluable in developing the skills and patience necessary to debug future projects.\n\n## The Adventure Begins\n\nHere‚Äôs a glimpse of the rollercoaster ride you can expect during this debugging process:\n\n```\nI don't understand this. Wait, I don't get it. Oh, I think that's a bug. I don't understand this. Oh, my God. I found something. I am a brilliant wizard. I don't understand this. Was this yep, that's definitely a bug. Okay, write that up.\n```\n\nIt's perfectly alright to alternate between confusion and comprehension, elation and frustration. These fluxes are part of the process, part of the journey.\n\n![](https://cdn.videotap.com/FCptVC8MaZVLfJkPNLN9-65.png)## Take The Leap\n\nNow that you're all prepped, it's time for you to tackle the Puppy Raffle codebase. Find as many bugs as you can, write them up, bask in that brilliant wizard feeling when you do find them, and always remember to keep going.\n\nOnce you've given it a good shot, we'll come back together and walk through the codebase. We'll compare notes, discuss the bugs found, and delve into how to fix them.\n\nBut for now, unleash your debugging prowess, and let's see how you do in this coding challenge. Dive in, get lost, be frustrated, but most importantly, enjoy the process of discovering and learning.\n\nTake at least 20 minutes to fully immerse yourself and accept the challenge. Unleash the brilliant wizard inside you and get cracking!\n\n![](https://cdn.videotap.com/cEB2wUwGPYlYBJ44rJLj-80.png)Good luck and happy debugging!\n",
          "updates": []
        },
        {
          "lessonId": "2951f741-904b-4b98-a3fc-91cd1c5fd334",
          "number": 3,
          "title": "Phase 1: Scoping",
          "slug": "phase-1-scoping",
          "folderName": "3-phase-1-scoping",
          "description": "",
          "duration": 4,
          "videoUrl": "Rtl1A-QEyKE",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/3-phase-1-scoping/+page.md",
          "markdownContent": "---\ntitle: Phase 1 - Scoping\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Bridging the Gap in Your Cybersecurity Journey: Exploring Codebase Exploits\n\nWelcome back, tech enthusiasts! If you're here for the first time, no worries, there's still time to catch up. Now, was everyone able to spend some time going through the code before coming back here? Excellent! As you know, practice makes perfect, and taking the time to familiarize yourself with the code makes the walk-through process much more beneficial.\n\nSo, let's dive into our fun-filled expedition, exploring various coding exploits, and reinforcing your knowledge base. Excitingly, by the end of this, you'll have a comprehensive report to add to your ever-growing developer portfolio.\n\nAre you ready? Good. Let's dive right in.\n\n## Navigating the Security Course\n\nCurrently, we are navigating through our structured cybersecurity course. Note-taking is essential during the journey, as there will be an array of essentials to learn, especially in this module.\n\nTake note of the below GitHub codebase, which we will be referencing throughout this course:\n\n```bash\ngit clone https://github.com/repository/examples.git\n```\n\nAfter doing a successful `git clone`, let's open the project in our favorite code editor (Personally, I prefer VS Code).\n\n## The Smart Contract Security Review\n\nBefore we explore the code, we need to understand what it is about. This stage is often referred to as the 'Scoping Phase'. We are encouraged to explore, question, and gain context on the ongoing project.\n\nIn this particular code base, we encounter a rather delightful concept: a 'Puppy Raffle'. Now, let's take a minute to go through the 'About' section, yes, the one right at the top of the page.\n\n![](https://cdn.videotap.com/wTq0wfCNib6lb1D2AqTZ-67.02.png)## Essential Prep Work\n\nIn the README, there are some instructions about tools we need in order to run the project, specific versions of Git and Foundry in this case. We've already cloned the project; now, let's have a look at the `make` file.\n\n```bash\ngit clone https://github.com/repository/examples.gitcd examplesmake run\n```\n\nWhat happens when we run `make`? We're executing three commands, remove, install, and build.\n\nHere's a breakdown of the makefile:\n\n- Remove: Clears any previous build files.\n- Install: Handles the library and package installations. In this example, we're installing specific versions of OpenZeppelin and the BrushPD base64 package.\n- Build: Compiles the project.\n\n![](https://cdn.videotap.com/N8L5QF4tSzLDWWv68Ike-139.2.png)Running `make` should execute these commands in the terminal. We can then observe the dependencies being installed, files being compiled, and possible warnings thrown.\n\nHowever, remember:\n\n> A warning isn't an error. However, warnings need attention just as much as errors.\n\nContained within our makefile is a command for running tests, `forge test`. But, before we run tests, we want to gauge the solidness of the test coverage. Running coverage reports give us some insight into the maturity level of the code base.\n\n```bash\nmake coverage\n```\n\n## Navigating the Codebase\n\nNext, we recognize the commit hash - an opportunity to delve into different versions of the code base. We're not going to run the `git checkout` at this moment.\n\n```bash\ngit checkout <commit-hash>\n```\n\nFor the next stage of this exercise, you should ensure you're working in the main branch. We're focusing on a single file in the scope: `puppyraffle.sol`.\n\nWithin in this file, we can see some interesting aspects: a firm amount of comments, which is always encouraging, several functions, compatibility with solidity version 0.7.6, contract deployment to Ethereum, and various assigned roles.\n\n![](https://cdn.videotap.com/elVBGNan7XfaFJokz2Yt-216.53.png)So far, everything seems in order, which can be deceiving. There could be potential exploits or weaknesses. But don't panic just yet. That's precisely why we're here: to navigate this curiosity-filled world of cybersecurity. Join us in the next part, as we continue unravelling this mystery.\n\nStay curious and until next time - Happy Coding!\n",
          "updates": []
        },
        {
          "lessonId": "d6c942d9-d7fb-4b1b-a29b-14e55b2a8f6e",
          "number": 4,
          "title": "Tooling: Slither",
          "slug": "tooling-slither",
          "folderName": "4-tooling-slither",
          "description": "",
          "duration": 6,
          "videoUrl": "nucwsAB9A8A",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/4-tooling-slither/+page.md",
          "markdownContent": "---\ntitle: Tooling - Slither\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Demystifying Smart Contract Audit Tools\n\nAuditing smart contracts is an arduous yet essential task in the blockchain realm. To facilitate this process, there are excellent tools to help auditors catch bugs efficiently. In this post, we'll explore two popular static analysis tools that can significantly speed up the auditing process: Slither and Aderyn. Having knowledge of these tools isn't just beneficial for auditors ‚Äî anyone aiming to be a top developer should consider these tools as an essential part of their toolbox.\n\n## Static Analysis - Boosting Your Auditing Efficiency\n\n![](https://cdn.videotap.com/PcwCRznO4FQcKvoOOcOy-32.16.png)Static analysis is a method where code is checked for potential issues without actually executing it. Essentially, it's a way to \"debug\" your code by looking for specific keywords in a certain order or pattern.\n\nThis elegant strategy saves time and effort as it forgoes the execution of code, thereby accelerating the process of identifying coding errors. The most widely used tools for this purpose include Slither, developed by the trail of bits team, and a Rust-based tool that we've developed known as Aderyn.\n\n> **Note**: It's important to remember that these tools should be run before going for an audit.\n\n## Slither - A Python-Powered Static Analysis Tool\n\nSlither tops the charts as the most popular and potentially the most potent static analysis tool available. Built using Python, it offers compatibility with both Solidity and Viper developments. An open-source project, Slither allows developers to add plugins via making PR.\n\n![](https://cdn.videotap.com/NXCBcJHzsWxWjBZYMfp5-117.91.png)The repositories for Slither on GitHub provide instructions on installation and usage. Among the standout features of Slither, its collection of **Detectors** offers a comprehensive checklist for auditing your code.\n\nThese detectors are designed to catch a vast array of potential issues. For example, the **protected VARs** check can identify unprotected variables that are marked as protected. This could have assisted in preventing bugs in the password store.\n\nRunning this check will generate an alert: \"Hey, add access controls to the venerable functions\" whenever this owner variable is modified without the 'only owner' modifier.\n\n![](https://cdn.videotap.com/N91Jg6hbSfCQH4c5Ej7u-160.78.png)Now that you've understood the power of Slither, let's look into it's installation and usage.\n\n### Installing Slither\n\nDifferent methods of installing Slither are available, i.e., via Pip, Git, or Docker. Installation might be occasionally troublesome, but the pain is well worth the outcome.\n\nFor debugging installation issues, you may want to depend on ChatGPT, or find help on Google Search.\n\n**Here's an example of the command you'd use to upgrade Slither once installed:**\n\n```bash\n$ pipx upgrade slither-analyzer\n```\n\n### Running Slither\n\nTo access Slither's numerous features and abilities, you can reach out to the command `Slither help` and idly navigate through the wealth of information it provides.\n\nFor instance, to run Slither on a Hardhat, FoundryDep, or Brownie application, use the command `Slither .`. This command allows Slither to automatically recognize the smart contract developer framework in use and compile accordingly.\n\n```bash\n$ slither .\n```\n\nWhile running this command could take a while to execute, it's worth being patient. You'll be rewarded with a detailed output on possible areas of concern in your codebase.\n\nThe output color codes potential issues: **Green** signifies an area that's probably okay but might require a check, **Yellow** indicates an issue that needs to be definitely checked, while **Red** acts as a red-alert forcing you to inspect it immediately.\n\n![](https://cdn.videotap.com/PseBWolSqkqt0Dt144NL-321.56.png)By leveraging Slither, audits become more efficient, making it a fantastic tool for developers who are looking to minimize the time they spend on debugging and maximizing value addition to their projects.\n",
          "updates": []
        },
        {
          "lessonId": "76b4b6ad-f6df-4073-8f6f-f87b91f2e2db",
          "number": 5,
          "title": "Tooling: Aderyn",
          "slug": "tooling-aderyn",
          "folderName": "5-tooling-aderyn",
          "description": "",
          "duration": 2,
          "videoUrl": "XPf_TjwsnjU",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/5-tooling-aderyn/+page.md",
          "markdownContent": "---\ntitle: Tooling - Aderyn\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Introducing Aderyn: A Rust Based Static Analysis Tool\n\nIn this blog post, we are going to dive into the nitty-gritty of a tool by name Aderyn, a handy static analysis tool for smart contracts. Created by Alex Roan, an established name in the realm of smart contract development, Aderyn adds to the cryptic dimension of the Rust programming language.\n\nTo effectively get started with Aderyn, it's essential that you have Rust installed. Although the installation process of Rust won't be illustrated here, there are abundant online resources that can guide you.\n\nOnce Rust is installed, you're a step away from running Aderyn. Simply use the command `cargo install Aderyn`.\n\n## Installation of Aderyn\n\nMake sure your terminal or console is clear. If not, type `clear` to have a crisp console. Next, you are to run `cargo install Aderyn`. This command installs the Aderyn tool.\n\nA thing to note: Aderyn does not need reinstallation if it's already installed. You'll be informed on the terminal that Aderyn is already installed, as seen in the example below:\n\n![](https://cdn.videotap.com/pnFtrBJS6gg7wF4fAor8-17.29.png)## Running Aderyn\n\nTo run Aderyn, the command is `Aderyn root` along with the path leading to your Foundry or Hardhat project. Since we're at the root directory in our case, we're going to use a little dot (.) as our path.\n\n> `Aderyn root .`\n\nThe command mentioned above will recompile all the contracts, giving out compilation warnings just like any other code compiler.\n\n## Generating the Audit Report\n\nAt the end of the recompilation phase, the console will provide interesting information: `report printed to report.md` .\n\nThe `report.md` mentioned is a Markdown file where Aderyn prints the audit report of your smart contract.\n\nNavigating to the `report.md` file will header you to an almost ready audit report of your smart contract in the intuitive Markdown format.\n\nBelow is how the audit report looked:\n\n![](https://cdn.videotap.com/aZCpkdjtzg2vgNCWYwi2-49.41.png)## Exploring the Audit Report\n\nWhen previewed, the Markdown file shows the vulnerabilities categorized into 'medium', 'low', and 'non-or-information'.\n\n- Medium issues are the ones that have moderate impact and are to be solved on a higher priority.\n- Low issues, as the name suggests, are of less priority but it's recommended to have them fixed for better performance of the smart contract.\n- Non or Informative issues are ones that do not pose any direct threat to the smart contract but improving them can enhance the overall performance.\n\nAderyn does a pretty good job of segmenting these vulnerabilities, then marking them up for you to address in your audit report.\n\nDon't worry if it feels overwhelming. In forthcoming posts, we'll be taking a deep dive into each of these issues, how to resolve them and even potentially avoid them in your smart contract code.\n\nStay tuned!\n\n## Conclusion\n\nFast, efficient and intelligent, Aderyn offers a swift audit report of your smart contracts which is almost ready to be presented. Aesthetically neat and structurally organized, the tool is a quick starter for anyone looking to audit a smart contract. Keep exploring!\n",
          "updates": []
        },
        {
          "lessonId": "3dec10d0-e6c7-4d0d-a220-fcdcad3d42c6",
          "number": 6,
          "title": "Tooling: Solidity Visual Developer",
          "slug": "tooling-solidity-visual-developer",
          "folderName": "6-tooling-solidity-visual-developer",
          "description": "",
          "duration": 3,
          "videoUrl": "sIb_geciuiU",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/6-tooling-solidity-visual-developer/+page.md",
          "markdownContent": "---\ntitle: Tooling - Solidity Visual Developer\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Static Analysis Tools in Understanding Solidity Metrics\n\nNext we're going to dive deeper into the exciting world of static analysis tools. We'll take a closer look at the Solidity Metrics tool, which we introduced before, and also explore another tool known as Solidity Visual Developer.\n\n## A Deeper Dive into Solidity Metrics\n\nWe already have a familiarity with the clock and have explored Solidity Metrics. However, if we go back to the Solidity Metrics and scroll to the bottom, we can discover a few more useful insights.\n\n```bash\nrun solidity metrics\n```\n\n![](https://cdn.videotap.com/D6ISDBvfop9mmTwaeeNA-26.74.png)Down there, we can see:\n\n1. **An Inheritance Graph**: Here, we can see our puppy raffle is of type ERC 721 and it's also ownable.\n2. **A Call Graph**: It illustrates what functions call, what other functions; a valuable tool while debugging.\n3. **A Contract Summary**: It gives a list of the different public and external functions. These are the functions that an attacker would mostly call.\n\nThese features provide essential information, especially from the vulnerability perspective.\n\n> **Note:** This is slightly more on the scoping side of things.\n\n## Introducing Solidity Visual Developer\n\nNot all code bases have clear, easy-to-decipher variable names identified by markers such as an 's' underscore to help distinguish them as storage variables. In some instances, you'll find that these variables are just a single word. The functions are often similar ‚Äî just a single word without much distinction between a storage variable, memory variable, and others. This kind of code can make comprehension quite challenging.\n\nThankfully, we have other helpful VS code extensions, with one of the key ones being the Solidity Visual Developer.\n\nThis tool is a favorite for some auditors and smart contract security researchers. Once installed and we go back to our code base, we can see some automatically highlighted variables.\n\n- An immutable variable is in a purple hue.\n- A storage variable is identified by a yellow color.\n- If it's a constant, its highlight is noticeable.\n\nThese features significantly improve code readability. However, how much this tool makes a difference to individual developers varies. You can disable it or keep it according to your preference.\n\n## Understanding the Big Picture\n\nWe've skimmed over some tooling essentials and run some tools. We've also dug deeper into scoping. I have merged them all into one section here. But let's finally get into scoping and reconnaissance where we understand the puppy raffle and its purpose, and then return to these tools.\n\nOnce we have the context for how the code base operates, the static analysis outputs will give us a lot more meaningful information. Let's get this context and start step one of the exercise: Reading the Documentation. I hope this brings you a comprehensive understanding of the Solidity Metrics and how to make the most of it, not just in your work, but also in your learning journey.\n",
          "updates": []
        },
        {
          "lessonId": "9e5aea50-0a65-4d44-940c-5ca0f7662c9f",
          "number": 7,
          "title": "Recon: Reading docs",
          "slug": "recon-reading-docs",
          "folderName": "7-recon-reading-docs",
          "description": "",
          "duration": 2,
          "videoUrl": "TOxiR6h-zn8",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/7-recon-reading-docs/+page.md",
          "markdownContent": "---\ntitle: Recon - Reading Docs\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Puppy Raffle Audit: Understanding and Solving the Challenge\n\nIn this blog post, we venture into the realms of Non-Fungible Tokens (NFTs), exploring an intriguing and adorable project that revolves around the theme of puppies. We‚Äôre diving into the core branch of the **Puppy Raffle Audit**. This project enables participants to enter a raffle to win a cute dog NFT. Let's break down the documentation and delve into some critical aspects of the raffle protocol.\n\n![](https://cdn.videotap.com/8KjNYsUhdCgFwmWSjMzk-4.61.png)## About The Puppy Raffle Audit Project\n\nThe Puppy Raffle Audit project essentially marries the worlds of cute dogs and blockchain technology. Participants can enter a raffle with the hope of getting minted a unique, adorable puppy NFT. However, there's more to this raffle game. By understanding the protocol and the functionalities adhered to it, one can exploit loopholes to increase winning prospects.\n\nThrough an **About** section on the project, the protocol functionality can be summarized as follows:\n\n- Participants are required to call the `enter raffle` function using an array of addresses - these refer to the list of participants entering the raffle. This could include just you, or a mix of you and your pals. Do bear in mind though, any duplicate addresses will be rejected.\n- Once entered, users are permitted to ask for a refund of their ticket value by invoking the `refund function`.\n- Every X seconds, a random draw is conducted by the raffle protocol, given the existence of a winner, a puppy NFT is minted.\n- The protocol owner sets a fee address and receives an cut from the value.\n\n## Diving Into the Project Code\n\n1. Open Puppy Raffle Audit project in your VS code\n2. Delete the Adarin output\n3. Start creating a `notes MD` file for jotting down your observations\n\n![](https://cdn.videotap.com/QAQwQv1b28oFN8yHiDw4-39.15.png)And voila! You've the documentation of the Puppy Raffle Audit opened right in front of you!\n\n### Keeping Track of Project Details\n\nIt's a good habit to jot down relevant project details in your own words, such as what exactly the project does, and what functionalities it offers. This step helps in understanding the project in a better way. Also, exploring the provided functions and how they interact aids in comprehending how they work together to make the protocol function smoothly.\n\n## Quick Start and Coverage Instructions\n\nOnce you're done understanding the `docs` and have successfully set up your working environment, take a look at the `quick start stuff` and `coverage` aspects.\n\n`Quick start stuff:` This is meant to aid in getting things started quickly and effectively. It represents an overview of the entire protocol and provides guides on how to start interacting with the project.\n\n`Coverage:` It elaborates the potential reach or target audience of the protocol. In order to comprehend the impact or reach of the project, understanding coverage becomes essential.\n\n### A Peek into the Project's Functionality\n\nLet's look into functions and how they are playing their part in this raffle protocol\n\nThe protocol functions are the gears that power this puppy raffle machine. Getting a grasp of how these pieces come together informs us about the underlying functionality of the project.\n\n> \"Understanding the project's functionality is just like solving a puzzle. Each piece of information fits in to complete the whole picture.\"\n\nDo stay tuned for more updates on this adorable, fun project. Happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "5efe7fcf-556b-464d-96be-e49c83a841a8",
          "number": 8,
          "title": "Recon: Reading the code",
          "slug": "recon-reading-the-code",
          "folderName": "8-recon-reading-the-code",
          "description": "",
          "duration": 5,
          "videoUrl": "_cKTcb3R6xc",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/8-recon-reading-the-code/+page.md",
          "markdownContent": "---\ntitle: Recon - Reading the Code\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Deep Dive into Codebase: Unraveling the Main Entry Point and More\n\nWelcome everyone! Today we're embarking on an insightful journey through an intriguing codebase. What's truly exciting about this voyage is that we'll be starting from the main entry point of the protocol. This approach offers a thrilling way to understand the critical functions and operations that govern the system.\n\n## Locating the Main Entry Point\n\nThe adventure starts with a bird's-eye-view of the codebase. This 'quick skim' gives me an idea of the overall landscape. However, identifying the best point of entry can be tough if you don't know where to look.\n\nHere is where Solidity Metrics comes in handy. If you scroll all the way down to the bottom, you'll see **Contract Summary** that lists down the public and external functions.\n\n![](https://cdn.videotap.com/iZyEcW0QPu9UkA6c5Xlf-36.03.png)Alternatively, for forge projects, run the following command:\n\n```bash\nforge inspect PuppyRaffle methods\n```\n\nThis command will print a list of methods you can check out.\n\n![](https://cdn.videotap.com/O4YijeMcS1T44HRm1v5c-72.06.png)Some of the core functions that I focus on include public functions such as `enterRaffle`, `refund`, and external functions like `selectWinners`. These are especially fascinating if they modify any state.\n\n## Zooming In: The `enterRaffle` Function\n\nFor this project, I identify `enterRaffle` as a possible main entry point. It's a decisive function that gives users access to participate in the raffle.\n\nInterestingly, the code documentation explains that the user entry into the raffle involves paying the entrance fee, multiplied by the number of players. This bit can be slightly confusing, so I'm gonna clarify it for you.\n\nWe see `address[] memory new_players` in the parameters. This suggests that a user has to pay the entrance fee times the `number of players`. If this seems perplexing, just remember to ask questions or make a note for further investigation.\n\nFurthermore, the documentation highlights that **duplicate entries are not allowed**. We can expect to see validation for this in the `enterRaffle` function.\n\n### Clearer Variable Naming\n\nNow, the `enterRaffle` function's syntax doesn‚Äôt sit right with me.\n\n```javascript\nfunction enterRaffle(address[] memory new_players)\n```\n\nIn case I was conducting a private audit, I'd note that variable names in this function could be more expressive. This critique is mainly based on `entrance_fee`which is an Immutable variable. A `I_` prefix before `entrance_fee` would provide better clarity, suggesting that it is immutable. Alternatively, another syntax could be used to indicate the immutability of `entrance_fee`.\n\n**Note:** If you are using Solidity Visual Developer, such states are pretty palpable.\n\n### Navigating Around Codebase with Keyboard Shortcuts\n\nQuick tip for Mac users to zip through the codebase. Using the keyboard shortcuts come really handy in swiftly moving forward and backward through the code-files.\n\nFor instance, click `entrance_fee`, scroll down, click something else, and then hit `CTRL -`. This combo works like 'The Back Button' - bobbing you right back to your last cursor location.\n\n- `CTRL -` = Go Back\n- `CTRL+Shift -` = Go Forward\n\nThese shortcuts dramatically speed up your code navigation, making life a bit easier. Various text editors like Vim, VI or Emacs offer great support for such keyboard shortcuts.\n\nThis quick skim up until here should arm you with some pointers when embarking on a code audit or simply understanding a new codebase. In our next session, I'll delve into more details about the `enterRaffle` function, but until then, Happy Coding!\n\n```markdown\n> \"When in doubt, break things down!\"> - Your tactical guide to navigating complex codebases.\n```\n",
          "updates": []
        },
        {
          "lessonId": "4cbdd7b4-0509-4c40-9950-63db5206f49b",
          "number": 9,
          "title": "Recon: Reading docs II",
          "slug": "recon-reading-docs-continued",
          "folderName": "9-recon-reading-docs-continued",
          "description": "",
          "duration": 3,
          "videoUrl": "eLecAxF3NzU",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/9-recon-reading-docs-continued/+page.md",
          "markdownContent": "---\ntitle: Recon - Reading Docs Continued\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Unravelling Solidity 0.7.6: Custom Reverts, Entrance Fees, and Subtle Bugs\n\nIn this deep dive, we're going to get our hands dirty with the old-but-gold version of Solidity‚Äî0.7.6. We'll explore a few nifty tricks, highlight some potential pitfalls, and wrap things up by identifying a rare bug hidden in the code.\n\n![](https://cdn.videotap.com/iyVJ7Q1TioFr0xBkwxjL-5.17.png)## Understanding Reverts in Solidity 0.7.6\n\nYou may be familiar with the newer versions of Solidity that come with custom reverts‚Äîa feature that wasn't evidently available when Solidity 0.7.6 was launched. A common question that arises is:\n\n> Were custom reverts available in Solidity 0.7.6?\n\nLet's take a look at some of the code.\n\n```js\nrequire(message.value == entranceFee * newPlayers.length);\n```\n\n## Entrance Fee Calculation\n\nThe code above shows the `require()` function ensuring the `message.value` is equal to the `entranceFee` multiplied by the number of `newPlayers`. This essentially means that the entrance fee gets scaled according to the number of players. If there are no players (`newPlayers.length == 0`), then the total cost is also zero. A possible query at this point could be:\n\n> What if `newPlayers.length == 0`? What can possibly happen then?\n\nNow, if 10 players are added, the total cost will be whatever the `entranceFee` is, times ten. It's noteworthy that the `entranceFee` is set to be `immutable` and its value is assigned in the constructor.\n\n## Handling Player Arrays\n\nAs the code continues, it performs some functions on an array of players.\n\n```js\nfor (uint i = 0; i < newPlayers.length; i++) {players.push(newPlayers[i]);}\n```\n\nThe code loops through the `newPlayers` array and pushes each player onto another array‚Äî`players`. This `players` array is a main storage variable where the raffle stores information about all participating players.\n\n## Identifying Duplicate Players\n\nNow, let's turn our attention to how the code handles duplication.\n\n```js\nfor (uint i = 0; i < players.length; i++) {for (uint j = i + 1; j < players.length; j++) {if (players[i] == players[j]) {emit DuplicatePlayer(players[i]);}}}\n```\n\nTo check for any duplicate players, the code loops through the `players` array...twice! It's essentially checking every player against each other for duplication. Once a duplication is found, an event is emitted to notify of the duplicate entry.\n\n## The Hidden Bug\n\nAs experienced coders navigating through numerous code bases, one develops an innate ability to \"smell\" bugs or potential issues. In this case, if your senses are tingling, they're onto something!\n\n```js\nfor (uint i = 0; i < players.length; i++) {for (uint j = i + 1; j < players.length; j++) {/*code here*/}}\n```\n\nThe suspicious concern here is the double looping mechanism this block of code is following. Double loops in Solidity can be incredibly gas-expensive, and that's indeed a red flag. Seeing this practice should usually serve as an indication of a potential bug.\n\nWait a moment...there _is_ a bug in the code!\n\nBut what could that be? A double loop isn't exclusively a coding faux pas. However, if it's harboring and obfuscating a bug inside, that's when things get sinister. Can you figure out what exactly that bug is?\n",
          "updates": []
        },
        {
          "lessonId": "c05360dd-ce70-4852-ac01-d7f15c9d2f44",
          "number": 10,
          "title": "sc-exploits-minimized",
          "slug": "sc-exploits-minimized",
          "folderName": "10-sc-exploits-minimized",
          "description": "",
          "duration": 1,
          "videoUrl": "dxSZndn5DLY",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/10-sc-exploits-minimized/+page.md",
          "markdownContent": "---\ntitle: sc-exploits-minimized\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Unearthing a Denial of Service (DoS) Bug\n\nIf you have a keen interest in cybersecurity, cryptography, or perhaps dabble a bit in code, then you're in for a thrilling and insightful read! Today, let's talk about a particular bug type known as the _Denial of Service (DoS)_ bug ‚Äì we shall delve into it and explore its inner workings using a minimized example from the Cyfrin Security and Auditing Full Course GitHub repo.\n\n![](https://cdn.videotap.com/0RDNeBw8jICr19QclxVo-9.92.png)## A Milestone: Discovering our First Bug\n\nExcitingly, this DoS is the first bug we've identified. To provide a detailed understanding of this, we'll be looking at a more simplified variation of this bug.\n\nTo get started, go to the \\[_Cyfrin Security and Auditing Full Course GitHub repo_\\](https://github.com/Cyfrin/security-and-auditing-full-course-s23) (you might want to zoom out a bit for an easier view). Scroll back to the top, then navigate to 'welcome to the course'. In this section, you‚Äôll find resources for the course - scroll down to the 'resources' section.\n\n![](https://cdn.videotap.com/vj0NLA9BWMOiVDvYZo0p-29.75.png)From here, you can access an informative page chock-full of 'exploit resources', particularly if you click on _sc-exploit-minimized_.\n\n## Utilizing the 'sc-exploit-minimized' Repository\n\nOn accessing the _sc-exploit-minimized_ repository, you find yourself in an informative hub brimming with simplified examples of the bugs we're covering. It provides a great chance for you to study and practice them. Additionally, example contracts are made available on [Remix](https://remix.ethereum.org/), a powerful open source tool that helps you write smart contracts in Solidity.\n\n![](https://cdn.videotap.com/rsCebPuyEmgS3Hkm0UQ9-49.58.png)At the bottom of the _sc-exploit-minimized_ repository, you have buttons you can click on to access these example contracts on Remix, and experiment with them. You can also find _Capture The Flag_ challenges that allow you to practice bug identification in realistic scenarios within games like _Damn Vulnerable DeFi_ and _Ethernaut_, among others.\n\n```markdown\n> **NOTE**> Remember, practicing with actual examples in real-time simulations is crucial to mastering the bug identification process.\n```\n\n## A More Detailed Look at the Denial of Service Bug\n\nTo further analyze this DoS bug, navigate to the SRC folder. It holds various other bugs we'll cover in future posts. For now, delve into the Denial of Service folder (Dos) for a minimalist illustration of a DoS bug.\n\nOnce inside, scroll down until you find 'Denial of Service'. Here, click on the Remix button that will direct you to the Remix IDE which comes preloaded with the code base we'll be working with in this blog.\n\n![](https://cdn.videotap.com/Rfdo8u2omH90wiKb0Ix1-89.25.png)If this redirect fails, simply open 'SRC Denialofservice Dos Sol' manually and copy-paste the code into Remix. Voila! You're all set to delve into our first bug ‚Äì the Denial of Service bug!\n\n```markdown\n> **PRO TIP**> For experiencing code in a hands-on way, using a versatile platform like Remix can be incredibly beneficial. It's like being in a virtual lab where you can manipulate code, learn, and grow.\n```\n\nStay on this journey as we continue to uncover and understand more cybersecurity and cryptographic bugs!\n",
          "updates": []
        },
        {
          "lessonId": "22735d90-b37e-49c8-9c29-5267ddbf07fa",
          "number": 11,
          "title": "Exploit: Denial of service",
          "slug": "exploit-denial-of-service",
          "folderName": "11-exploit-denial-of-service",
          "description": "",
          "duration": 7,
          "videoUrl": "ylkWB3vnruo",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/11-exploit-denial-of-service/+page.md",
          "markdownContent": "---\ntitle: Exploit - Denial of Service (DoS)\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Understanding Denial of Service Attacks in Smart Contracts\n\nIn this blog post, we will be discussing an important cybersecurity issue in the world of blockchain - the Denial of Service (DoS) attack. More specifically, we'll learn how this attack relates to and affects smart contracts.\n\n## What is a Denial of Service Attack?\n\nDenial of Service attacks target computer networks and systems, often overloading them with unnecessary requests to cause a disruption in the service provided. In the context of smart contracts built on blockchain networks, a Denial of Service attack can significantly impede its functionality by making it gas-intensive and, therefore, expensive to use.\n\n## The Attack Strategy: A Basic Overview\n\nLet's understand this with concept with a minimalist Ethereum smart contract that we'll call `Dos`.\n\nHere is an outline of how this contract functions:\n\n1. We have an `address[]` array named `entrance` that stores the addresses that interact with the contract.\n2. There is a function named `enter` that allows an address to enter into the `entrance` array.\n\n   ```javascript\n   function enter() public {...}\n   ```\n\n3. Inside this function, the contract checks the `entrance` array for duplicates of the address attempting to enter. If no duplicate is found, the address is then pushed into the `entrance` array.\n\nThe more addresses are added into the array, more looping will be required for the duplication check, increasing the gas costs exponentially.\n\n## Avalanche Effect and DoS\n\nTo understand how this causes DoS, let's consider a case where the `entrance` array is currently empty. In this scenario, the `enter` function doesn't have to make a single loop, and the incoming address is pushed into the array without any hassle.\n\nHowever, the situation drastically changes when multiple addresses (let's say 10) are already in the array. Now, the `enter` function will loop through these 10 addresses before adding any new ones. Now let's say there are 100 addresses. The loop now has to go through all these addresses, and the resulting gas costs shoot up drastically.\n\nThis is the avalanche effect, and it is this accumulation of gas costs that makes a smart contract susceptible to a DoS attack. A malicious actor can blast the `enter` function with loads of calls, inserting numerous addresses onto the `entrance` array. This would render the contract unusable due to the incredibly high gas fees required to interact with it.\n\n![](https://cdn.videotap.com/3iSoxXBYl3uLnVWzprD8-208.76.png)## Seeing the Attack in Action\n\nLet's simulate this DoS exploit.\n\nWe compile and deploy our `Dos` contract. We then use a test account to call the `enter` function. For every call, we examine the gas fees involved:\n\n- The first call to the `enter` function consumes relatively minimal gas.\n- As we make additional calls with more test accounts, we see the gas consumption increasing.\n\nBy running the `enter` function enough times and overloading the `entrance` array, the exploit becomes clearer. The contract becomes so costly to interact with that you would need to spend an exorbitant amount of Ether, making the contract essentially unusable. This is the essence of a smart contract DoS attack.\n\n## Testing the Attack and Mitigation\n\nA good way to educate yourself further on DoS attacks is by creating test scenarios, simulating the attack, and experimenting with potential solutions.\n\n```javascript\nfunction testDosAttack() public {\n    Dos dos = new Dos();\n    address dummyAddress = address(1);\n\n    for(uint256 i=0; i<1000; i++){\n        dummyAddress = address(uint(dummyAddress) + 1);\n        dos.enter(dummyAddress);\n        }\n        uint gasCost = dos.enter(dummyAddress).gas;\n        assert.greaterThan(gasCost, expectedGasCost, \"DoS attack simulation failed\");\n        }\n```\n\nThis simple test creates a new instance of the `Dos` contract, and then inserts 1000 addresses into the `entrance` array by calling `enter(address)`. It then calculates the gas cost for the 1001st transaction and asserts if this cost is higher than an expected standard cost.\n\nThis way, you can observe how drastically the gas costs have increased due to the DoS attack.\n\n## Final Thoughts\n\nDenial-of-service attacks are a persistent security concern for smart contracts. As active participants or enthusiasts in the blockchain and smart contract community, understanding these vulnerabilities and exploring potential solutions is vital.\n\n> ‚ÄúKnowledge is power. Information is liberating. Education is the premise of progress, in every society, in every family.‚Äù - Kofi Annan\n\nFeel free to clone the SC exploits repository and run the `Dos` contract and attack simulations yourself.\n\nIn the end, make your contracts robust, keeping possible attack vectors in mind, ensure you‚Äôve done thorough testing before deploying, and most importantly, stay informed!\n",
          "updates": []
        },
        {
          "lessonId": "f92b18c6-4e62-46f7-82d8-5b3c43e6e24d",
          "number": 12,
          "title": "Case Study: DoS",
          "slug": "dos-case-study",
          "folderName": "12-dos-case-study",
          "description": "",
          "duration": 21,
          "videoUrl": "vdmyrRdE8Xw",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/12-dos-case-study/+page.md",
          "markdownContent": "---\ntitle: DoS - Case Study\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Understanding Denial of Service (DoS) Attacks in the Wild of Security Protocols\n\nDenial of Service (DoS) attacks presents a legitimate issue that often victimizes numerous security protocols. In this blog post, we delve into two different kinds of **Denial of Service Attacks** or simply **DoS attacks** as they materialize from real security reviews of real protocols. Owen, the founder of Guardian Audits, will share insights from his work, showing us how these vulnerabilities arise and the best frameworks to uncover them.\n\n## Who's Talking?\n\nA brief intro for context: my name is Owen, and about two years ago, I founded Guardian Audits. Since then, our team has carried out scores of security reviews, with hundreds of smart contracts undergoing scrutiny for these audits. Over this period, we have unearthed well over 100 high-impact bugs and vulnerabilities in DeFi smart contract systems. We‚Äôll be unpacking some of our findings related to DoS attacks and their ramifications.\n\nThe ultimate goal is to equip you with the knowledge and tools you need to sidestep these potholes in your own security evaluations or when writing your solidity code, whether you're conducting a contest, private security review, or just a protocol developer interested in security.\n\n## Case Study 1: DoS Vulnerabilities in the Bridges Exchange\n\nThe first DoS vulnerability we'll touch on is found in the dividends distribution system of the Bridges exchange.\n\n### Attack Mechanics\n\nThe issue arises from an unbounded for loop in the `distributeDividends` function, resulting in the risk of a DoS attack. An ill-intentioned party can cause the distribute dividends function to violate the block gas limit, effectively blocking all dividends by continually generating new addresses and minting minimal quantities of the Bridges pair token.\n\nThe `distributeDividends` function can be found in the Bridges pair contract under line 221. As its name suggests, an unbounded for loop allows for indefinite iterations of this for-loop. If there are sufficient iterations, the gas used will exceed what can be executed within the block gas limit, making it impossible to execute the transaction that distributes dividends.\n\n### Confirming the 'Unbounded' For Loop\n\nTo confirm that this users' list is, indeed, unbounded, we should inspect all instances where the users' list is used. If you examine the `mint` function, there are no constraints. The only prerequisite is that the balance of two is zero ‚Äì a situation that an attacker can easily configure. This allows an attacker to call the `mint` function several times from different addresses, adding multiple different addresses to this list, ultimately making the list too long to iterate over.\n\n### Mitigation and Remediation\n\nIn such a case, executing the distribute dividends function exceeds the block gas limit, freezing the functionality of dividend distribution - classic DoS. The best way to rectify this vulnerability is to revamp the approach or design of distributing dividends. For example, the Bridges team migrated to a dividends-per-share model, simplifying the process and circumventing the issue.\n\n## Case Study 2: Dos Attack in GMX V2 System\n\nThe second instance of a DoS attack shows up in the GMX V2 system and is entirely different than the Bridges case mentioned above.\n\n### Attack Mechanics\n\nThe problem arises from a boolean indicator called `shouldUnwrapNativeToken`. This flag can be leveraged to set up positions that can't be reduced by liquidations or ADL orders. When the native token unwraps (with the flag set to true), a position can be formed by a contract that can't receive the native token. This leads to order execution reverting, causing a crucial function of the protocol to become unexecutable.\n\n### Understanding the Flow\n\nIn order to comprehend this, consider the `decreaseOrderutils processOrder` function. This function is responsible for executing liquidations, a process that needs to proceed in order for the protocol to operate flawlessly. If we trace logic flow through the function, it eventually calls the `transferOut` function, which in turn can lead to the `transferOutNativeToken` function if the token to transfer out is the wrapped native token.\n\nThis function then calls the `withdrawAndSendNativeToken` function, leading down a rabbit hole of functions until we reach the `transferNativeToken` function. If successful, the native tokens are successfully transferred. However, if this external call fails due to the receiver contract being unable to accept the ether, the result is an error called `nativeTokenTransferError`.\n\n### Cases Leading to Failure\n\nThere are other conditions that could result in failure, triggering this error and causing a Dos attack. These could include:\n\n- The receiver is a contract that can't accept ether;\n- The receiver contract requires more gas than the gas limit to execute its function;\n- The receiver contract maliciously reverts on purpose.\n\nTo mitigate this type of Dos attack, the GMX team could specify the `shouldUnwrapNativeToken` to false so that transfers happen using wrapped ERC20 tokens which do not risk calling third-party addresses. Alternatively, they could rewrap the token and send it back in the event of failed transfer, an approach that they eventually adopted.\n\n## Unmasking Denial of Service Attacks\n\nTo wind up, here are a couple of frameworks to help uncover these DoS attacks when navigating through a code base:\n\n1. **For-Loops**: Take extra caution with for-loops. Ask yourself these questions:\n   - Is the iterable entity bounded by size?\n   - Can a user append arbitrary items to the list?\n   - How much does it cost the user to do so?\n2. **External calls**: These can be anything from transferring ether to calling a third-party contract. Evaluate ways these external calls could fail, leading to an incomplete transaction.\n\nDoS attacks can arise from multiple sources and don't boil down to a single root cause. Whether it's caused by an external call failure or an unbounded for-loop, the end result is that a transaction is prevented from being executed when it is essential.\n\nIt is the hope that these frameworks serve you well in future security reviews or development endeavors.\n",
          "updates": []
        },
        {
          "lessonId": "89c740dd-2506-4ce9-87a8-41f58e0a1076",
          "number": 13,
          "title": "DoS PoC",
          "slug": "dos-poc",
          "folderName": "13-dos-poc",
          "description": "",
          "duration": 8,
          "videoUrl": "Tv7RrCcIZo0",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/13-dos-poc/+page.md",
          "markdownContent": "---\ntitle: DoS - PoC (Proof of Code)\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Uncovering a Denial of Service Vulnerability in a Puppy Raffle Smart Contract\n\nIn our journey exploring the fascinating world of decentralized applications and smart contracts, we stumbled upon a potential vulnerability in a puppy raffle smart contract. What's exciting today is that we suspect this vulnerability could be a denial of service warning - a significant cybersecurity threat.\n\nBefore we dive into the fascinating journey of how we exposed this issue, don't forget how important auditing is in the world of blockchain technology and smart contracts. Only thorough auditing can assure that a contract is bug-free and secure.\n\n## The Suspicion\n\nLet's head back to our `PuppyRaffle.sol` contract. On observing it, we started suspecting a potential 'Denial of Service (DOS)' issue. We wanted to confirm it though and prove its potential effect. Time to put on our programmer hats and delve into some code.\n\n## Writing the Proof of Code\n\nHow do we confirm our suspicion? That's right, by writing a 'proof of code'. But first, we need a testing suite. Let's try using Forge Test:\n\n```bash\nforge test\n```\n\nThankfully, the test suite works perfectly, meaning we can use it for our audit. We opened up the `puppyRaffle.t.sol` to see what's in there.\n\nHere's a challenge for you, reader, to try writing the proof of code before scrolling further down. Go ahead and pause here, take some time and challenge yourself.\n\n## Time to Prove It!\n\nAlright, now that we have the test suite we can start building our DOS test. For those who carried out the challenge - well-done! For those who haven't, let's carry on together.\n\nThe path we'll take is to repurpose the `test_can_enter_raffle` function for our audit. Something like this:\n\n```javascript\ntest_denial_of_service(){...}\n```\n\nWe start by commenting out the earlier content to serve as a reference. Let's look into the proof in detail.\n\n### Creating Fake Players\n\nFirstly, we enter 100 players into the raffle using addresses that we generate in a loop, like this:\n\n```javascript\nuint256 players_num = 100;\naddress[] memory players = new address[](players_num);\nfor(uint256 i = 0; i<players_num; i++) {\n    players[i] = address(i);\n    }\n```\n\nThis approach lets us generate 100 unique addresses, because the contract forbids duplicates.\n\n### The Final Test\n\nLastly, we insert a test condition to compare the gas used for the first and second sets of players. If our suspicion is correct, the gas used for the second set should be substantially higher than the first.\n\n```javascript\nassert(gas_used_1st < gas_used_2nd);\n```\n\nRunning this code reveals, surprise surprise, a substantially higher gas cost for the second batch of players!\n\n## Validating our Suspicion\n\nOn running our finalised test, we found that indeed it cost significantly more gas for the second batch of players to enter the raffle. It confirms our suspicion about a denial of service issue. Someone could potentially spam the contract with entries and make it prohibitively expensive for other participants to join the raffle.\n\nThis situation is problematic because as more people enter the lottery, participants need more financial resources to participate, giving an enormous advantage to early entrants.\n\nTypically, normal users wouldn't think about such issues, which is why we need thorough auditing ‚Äì to ensure fair play, security, and performance efficiency. Congratulations! You've gained a new insight into smart contracts, their auditing, and potential vulnerabilities. Keep digging to foster safer and efficient blockchain technologies.\n\n> Remember, the code we write today could be at the core of tomorrow's financial world.\n\nStay tuned for more behind-the-scenes looks into other smart contracts and their potential mischievousness. Happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "3eda855d-5826-4449-aeea-cd481090ba34",
          "number": 14,
          "title": "DoS: Reporting",
          "slug": "dos-reporting",
          "folderName": "14-dos-reporting",
          "description": "",
          "duration": 8,
          "videoUrl": "GP4Fto4u5dQ",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/14-dos-reporting/+page.md",
          "markdownContent": "---\ntitle: DoS - Reporting\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Unpacking a Denial of Service Attack: A Practical Look into Security Writeups\n\n![](https://cdn.videotap.com/Dj7HsLraeSv2ZrJ1t1L1-10.38.png)Today we delve deep into the inner workings of a Denial of Service (DoS) attack - a prevalent cybersecurity threat that we might stumble upon in the realm of software auditing.\n\n## Step One: Set the Stage - Create a New File\n\nWe'll begin our journey by creating a new file, which we'll optimistically name `findings.md`. The purpose of this file is fairly simple - it serves as the canvas where we'll write up our findings. We encapsulate our journey of discovery and understanding into this space, shedding ample light on the severity and various aspects of the underlying issue.\n\n## Giving Feet to the Ghost: Identifying the Root Cause\n\nAs the saying goes, a problem well stated is a problem half solved. It is crucial to nail down the root cause of the issue before moving forward. Our root cause for the DoS attack turns out to be a piece of code in `PuppyRaffle` which loops through the players array to check for duplicates.\n\n```javascript\n// Pseudocode for the root cause\nfunction loopThroughPlayersArray(playersArray) {\n  for (let i = 0; i < playersArray.length; i++) {\n    /*Check for duplicates*/\n  }\n}\n```\n\n## Estimating the Impact\n\nTo comprehend the severity of the DoS attack, we need to dissect its impact - the higher the impact, the more destructive our DoS attack.\n\nThe looping mechanism in `PuppyRaffle` causes a rise in gas costs for every additional player entering the raffle due to the added overhead of checking for duplicates. Consequently, our system becomes increasingly costly to use. We might debate over the severity - is it medium or high, but considering the additional gas users would have to spend and the resultant inconvenience it could cause, we'll settle for a medium severity rating.\n\n## Drill Down into Details: Write Up a Description\n\nAt this point, let's delve deep into our DoS finding and write a meticulous and articulate description.\n\n```markdown\n## Description: The 'enterRaffle' function loops through the players array to check for duplicates. As the length of the 'players' array increases, the gas costs and the number of checks a new player must carryout also increase. This issue has the potential to deter players that enter later due to the remarkably higher gas costs.\n```\n\n## Light upon the Impact\n\nNow it's time to put the spotlight on the impact of this issue. The intensifying gas costs as more players enter the queue make it a less attractive proposition for potential players. Coupling this with the possibility of a rogue player filling up the raffle to guarantee a win makes for a pretty daunting scenario.\n\n```markdown\n## Impact: The skyrocketing costs for users entering the raffle at a later stage could deter participation. Furthermore, an attacker with large enough resources could monopolize the system, crowding out other potential participants.\n```\n\n## Unveiling the Proof of Concept\n\nTo demonstrate the vulnerability at hand, we could showcase the escalating gas costs with a simple comparison - taking two sets of 100 players each and observing the gas charges. Our projected surge in costs could look something like this:\n\n```markdown\n## Proof of Concept:\n\n1st set of 100 players: ~70,000 gas\n2nd set of 100 players: ~210,000 gas\nNote: The second set of players face a gas cost more than 3 times that of the initial set.\n```\n\n## Forge a Solution: Propose a Mitigation\n\nNow that we've gathered knowledge about our vulnerability, it's time to suggest a viable solution. In our case, a possible mitigation could be altering the check for duplicate players. We'd replace the existing iteration-based solution with a more gas-efficient method like using a mapping system.\n\n```markdown\n## Mitigation: We recommend altering the manner in which duplicate players are checked ‚Äì switching from an iteration-based system to a mapping-based system ‚Äì which would be a far more gas-efficient solution.\n```\n\nNo vulnerabilities are impenetrable. With adequate knowledge and an apt comprehension of the system, we can certainly transform the most complex of vulnerabilities into well-understood and manageable problems.\n",
          "updates": []
        },
        {
          "lessonId": "48c3d22f-6318-47cb-8781-f8d732186cd4",
          "number": 15,
          "title": "DoS: Mitigation",
          "slug": "dos-mitigation",
          "folderName": "15-dos-mitigation",
          "description": "",
          "duration": 3,
          "videoUrl": "NpCFoZeXp8E",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/15-dos-mitigation/+page.md",
          "markdownContent": "---\ntitle: DoS - Mitigation\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Strategies to Mitigate Duplicate Entries in Smart Contract Code\n\nIn the world of smart contracts and their associated applications, security is a pivotal asset. One primary issue often encountered is the challenge of dealing with duplicates. The system needs to acknowledge these duplicates without compromising its original function. So, how do we achieve this functionality while also mitigating potential risks?\n\n## 1. Keeping the Original Functionality\n\nIndeed, the easiest action we might suggest is to stop checking for duplicate entries altogether. However, our mission is to preserve the original functionality as much as possible, so let's dissect some potential solutions with that mind.\n\n> **NOTE:** Remember, in suggesting these solutions, our ultimate goal is not to change the original functionality, but to enhance it for improved performance and security.\n\n### A. Consider Allowing Duplicates\n\nFirstly, let's consider the option of allowing duplicates. In altering the protocol's original functionality, there needs to be a solid foundation that supports this decision. So, why might we actually benefit from permitting duplicates? Here's the argument:\n\nUsers, if they want, can create new wallet addresses at will. In light of this, checking for duplicates does little to prevent the same user from entering multiple times, as it only prevents the same wallet address's multiple entries.\n\n![](https://cdn.videotap.com/U40Y4UOf96RccTmlPQua-31.96.png)### B. Using a Mapping for Duplicate Checks\n\nIf the creators of the protocol insist on maintaining the check for duplicates, we suggest using a mapping to do this check. This strategy would grant constant time lookups to ascertain whether a user has already entered or not. Let's take a look at how we could change the existing code to implement this functionality:\n\nOriginal Code:\n\n```js\nfor (let i = 0; i < player.length; i++) {\n  if (player[i] == _address) return true;\n}\n```\n\nSome Modification:\n\n```js\nmapping(address => bool) entered;\nif (entered[_address])return true;\n```\n\nWith this mapping in place, the smart contract instantly reviews duplicates from only new players instead of traversing the whole array of players, thereby averting potential risks related to time complexity.\n\n![](https://cdn.videotap.com/jAgeqw0BOdnWiWPCG0Kn-86.28.png)### C. Leveraging OpenZeppelin's Enumerable Library\n\nHere's our last recommendation. An alternative technique could be to utilize OpenZeppelin's Enumerable library.\n\n```js\nimport \"@openzeppelin/contracts/access/Enumerable.sol\";\n\ncontract SomeContract {\n    using Enumerable for Enumerable.Set;\n    Enumerable.Set private players;\n    // In some function‚Ä¶\n    // if (players.contains(_address))return true;\n    // players.add(_address);\n    }\n```\n\nThis option might be a viable solution, improving both performance and security of the protocol.\n\n![](https://cdn.videotap.com/HGAjhb2SQjm8rllHFWci-140.61.png)## Next Steps\n\nWith all these in mind, we now have a template to approach duplicate checks in smart contract codes. Though incomplete, it provides several viable options for updating the code while remaining true to the original functionality.\n\nRegardless of whichever strategy you choose to mitigate this issue, ensure your chosen solution suits your unique smart contract needs. Remember to thoroughly review all proposed changes before implementation to ensure its robustness and security. This will help in maintaining the integrity of your contracts, and by extension, the entire protocol.\n",
          "updates": []
        },
        {
          "lessonId": "0733bc61-511d-4f22-8773-3b4239943a85",
          "number": 16,
          "title": "Exploit: Business logic edge case",
          "slug": "exploit-business-logic-edge-case",
          "folderName": "16-exploit-business-logic-edge-case",
          "description": "",
          "duration": 3,
          "videoUrl": "c_120vFf52A",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/16-exploit-business-logic-edge-case/+page.md",
          "markdownContent": "---\ntitle: Exploit - Business Logic Edge Case\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# A Deep Dive Into the 'PuppyRaffle‚Äô Contract\n\nHey there! Today, we'll unwrap the layers of the `PuppyRaffle` contract. We‚Äôll conduct a detailed analysis identifying how the contract works, pinpointing possible issues and areas of concern, and discuss how we can improve it.\n\n## Understanding the Enter Raffle\n\nWe‚Äôve found some interesting pieces of code that we think should be analyzed. The crucial operation, as it appears, revolves around the `players` array. The ‚ÄòEnter Raffle‚Äô logic seems to store value in this array, and it gets updated with new entries ‚Äì jot that down for a later review.\n\n![](https://cdn.videotap.com/UXaQJF1HNUDQ9qWrwwvD-21.57.png)As we go through this, we might have some questions. One in particular is: **\"What resets the `players` array?\"** ‚Äì a point we‚Äôll come back to later.\n\n## Examining the Refund Function\n\nThe next essential function we‚Äôre interested in is the `refund` function. According to the `README` file, this function allows users to claim a refund of their ticket value.\n\n![](https://cdn.videotap.com/pdFQ3caBtnyX6H3J3nNf-43.14.png)\n\n```js\nfunction refund(player_index){...}\n```\n\nThis function requires a `player_index`, obviously referring to the index of the player in the `players` array. The question then becomes, how do we obtain this index?\n\n## The GetActivePlayerIndex Function\n\nDelving into the contract, we find the answer in the `GetActivePlayerIndex` function:\n\n```js\nfunction getActivePlayerIndex(player_address){...}\n```\n\nThis function, given an address of a player, returns the corresponding index. Although it seems straightforward, there might be a potential flaw here, and this is where our Spidey-sense starts tingling.\n\n![](https://cdn.videotap.com/pqfJnRhCJl6hQKNlJck4-102.46.png)If a player is not present, this function defaults to returning zero. The issue, however, arises if there‚Äôs an active player at index zero.\n\n> **Possible Attack Vector:** If the player is at index zero, the system might mistake it as the player not being active!\n\nThis is absolutely a flaw that must be highlighted in our audit report.\n\nWe might just have discovered a significant bug affecting the `GetActivePlayerIndex` function. Specific as it may be, this finding indicates the need for thorough analysis of any smart contract ‚Äì regardless of its perceived simplicity.\n\nTo wrap this up, it‚Äôs clear that the `PuppyRaffle` contract, just like any smart contract, harbors its own unique intricacies and possible vulnerabilities. With a methodical approach, we can uncover these issues, ask the right questions, and improve the system's overall quality and security.\n\nThank you for following along this deep-dive. Stay tuned for further examinations as we continue to unmask more bugs and features in future posts.\n",
          "updates": []
        },
        {
          "lessonId": "a4298f9d-7469-40b4-864d-437f10d6bbf4",
          "number": 17,
          "title": "Recon: Refund",
          "slug": "recon-refund",
          "folderName": "17-recon-refund",
          "description": "",
          "duration": 3,
          "videoUrl": "sci43xJcAhA",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/17-recon-refund/+page.md",
          "markdownContent": "---\ntitle: Recon - Refund\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Understanding the Active Players Index: A Deeper Delve into Solidity Coding\n\nIn this post we go down the rabbit hole to understand the intricacies of handling arrays, managing edge cases, and safeguarding against vulnerabilities in Solidity, the contract-oriented language of Ethereum.\n\n## Getting Active Players Index\n\nLet's start with the function of `getActivePlayerIndex()`. This seemingly simple process has a twist to it - the function allows for blank spots within the array.\n\nWhile on surface this might not seem like an issue, there is a potential caveat. A pitfall known as Minor Extractable Value (MEV) presents itself when people try to \"front-run\" this function. For the novice, MEV refers to the ability of miners or validators to exploit their position for profit by reordering or censoring transactions within the blocks they produce. However, to keep things simplified, let's skip the MEV complexities in this explanation and imagine that the function works perfectly as expected without it.\n\n![](https://cdn.videotap.com/ROdzfVev0ULFYEDhkigd-14.19.png)\n\n## Tracing The Function\n\nStarting with the premise that our active players array works as desired, let's unravel the intricacies of this function. Here's an illustrative code for reference:\n\n```js\nfunction getActivePlayerIndex(uint playerIndex) public view returns (address) {\n    address playerAddress = players[playerIndex];\n    require(playerAddress == msg.sender, \"Player mismatch!\");\n    require(playerAddress != address(0), \"This player has either refunded or is not active\");\n    return playerAddress;\n    }\n```\n\nThe function begins by obtaining the player's address from the player index. This is pretty straightforward - click on a player, get their address.\n\nNext, it brings in two requisites for the player's address. These validation checks solidify the function's parameters:\n\n- `msg.sender` must be equal to the player's address. This check is in line with good security practices to ensure that only the owner of the account can initiate transactions.\n- The player's address should not return to `address(0)`. Essentially, this check protects the system from getting an address that has been removed or flagged as inactive.\n\nThese require statements guard the integrity of the function while preventing unauthorized access.\n\n## Dealing with Player Removal\n\nBut what happens to the player details post-removal? Digging deeper into the code, once the value transacts successfully, the function resets the player's address to zero - `address(0)`. This effectively cleans the slot for future use.\n\n> Note: Resetting to zero essentially deletes that player entry, signaling they're either refunded or not active.\n\n## Spotting the Send Value Function\n\nInterestingly, the process implies the use of a `sendValue` function. Now, this function plays a crucial role. It quite literally sends the entry fee back to the player. But is this `sendValue` essentially a built-in function or is there an external library managing this aspect?\n\nDelving further clarifies that this function sourced from OpenZeppelin, a library well-known for providing reusable smart contracts in the Ethereum community. Examining it shows a range of validation or 'require' conditions.\n\n```js\nfunction sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, \"Address: insufficient balance\");\n    (bool success, ) = recipient.call{value: amount}(\"\");\n    require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n```\n\nThe `sendValue` function is equivalent to essentially sending the entry fee back to the `msg.sender`.\n\n## Did You Spot the Glitch?\n\nHere's a scenario: everything seems to be flowing well, the MEV complexities were ignored as promised, and we got a little bit of help understanding what's going on. But amidst this, there seems to be one more issue... can you tell what it might be? Well, let's call this a cliffhanger, and explore the issue in the next blog entry. Until then, happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "8596fc74-6778-4b65-bc85-56bedf6e1808",
          "number": 18,
          "title": "Exploit: Reentrancy",
          "slug": "exploit-reentrancy",
          "folderName": "18-exploit-reentrancy",
          "description": "",
          "duration": 14,
          "videoUrl": "gU7pV_6eO_M",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/18-exploit-reentrancy/+page.md",
          "markdownContent": "---\ntitle: Exploit - Reentrancy\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Unraveling the Reentrancy Attack in Solidity\n\nSolidity, the object-oriented programming language for writing smart contracts, is targeted by several types of attacks. Among these, the **Reentrancy attack** often comes up as a severe threat to solidity contracts. Understanding how this exploit works is a critical step in writing secure, robust contracts in the future.\n\n![](https://cdn.videotap.com/4xYTgBmqeFghdQVDVkIv-41.15.png)\n\n## Understanding the Attack: Using Slither\n\n[Slither](https://github.com/crytic/slither) is an indispensable tool in the effort to detect vulnerabilities and weaknesses in your smart contracts. A recent standoff with a test repo showcased the potency of the tool when it detected a reentrancy attack - a detection traced back to a `refund` function in our `puppyraffle` example.\n\n![](https://cdn.videotap.com/H7mM50IOIcsDSVV1PzTj-102.88.png)\n\nAn understanding of how reentrancy attacks work is needed to fully appreciate the need for vulnerability detection tools like Slither. To achieve this, let's revisit our cloned [sc-exploits-minimized](https://github.com/Cyfrin/sc-exploits-minimized) repo, where we'll find a minimalist code example inspired by [Solidity By Example](https://solidity-by-example.org/).\n\n## Examining A Minimalist Victim Code\n\nThe `ReentrancyVictim` contract within our cloned repo provides a basic engagement with this exploit.\n\n```js\ncontract ReentrancyVictim {\n    function deposit() public payable { /*...*/ }\n    function withdrawBalance() public { /*...*/ }\n    }\n```\n\nIt is a simple contract allowing users to deposit and withdraw money. The gap in this operation lies within the `withdrawBalance` function - making an external call before updating the contract state creates an opportunity for an attacker to strike. To get a solid understanding of this seeming design error, let's break it down using easy-to-follow diagrams.\n\n![](https://cdn.videotap.com/bXCu88smua0uVsrjJOWq-308.63.png)\n\n## The Normal Withdrawal: An Ideal Flow Diagram\n\nTypically, a user makes a deposit. The deposit quantity updates the `userBalance` and `contractBalance`. To cash out, the user calls `withdrawBalance`, and the contract does the following:\n\n1. The balance in `withdrawBalance` function is matched with the `userBalance`.\n2. An externall call is made to send money back to the user via `msg.sender.call`.\n3. Upon a successful transaction, `userBalance` is updated, setting it to zero.\n\nThis three-step flow ensures that the user recovers the fund in its entirety.\n\n![](https://cdn.videotap.com/aG9uFrfDZ3HoCPIXAaRP-493.8.png)\n\n## The Abnormal Withdrawal: How a Reentrancy Attack Proceeds\n\nThe real vulnerability manifests when a malicious entity exploits the contract design. Here's an outlined procedure on how this occurs:\n\n1. A victim deposits a certain amount of Ether(e.g., 5 ETH).\n2. The attacker then calls their `attack` function, which, interestingly, performs a deposit followed immediately by a withdrawal.\n3. The `msg.sender.call` function is subsequently activated within the withdrawal process, leading to an execution of the `receive` function in the attacker's contract.\n\nAt this point, the contract loops between the `receive` and `withdrawBalance` functions as long as there is a balance left. It effectively drains the victim's funds into the attacker's account.\n\nHow does it happen so smoothly? Well, the victim‚Äôs balance - which [should honestly be deducted before making external calls](https://consensys.github.io/smart-contract-best-practices/development-recommendations/general/external-calls/#avoid-state-changes-after-external-calls) - remains intact, allowing the attacker to repeatedly withdraw funds until the contract is empty.\n\n## Guarding Against Reentrancy Attacks\n\nIn conclusion, reentrancy attacks, just like other vulnerabilities within smart contracts, bank on the concurrent nature of contract interactions in Solidity. Developers must heed the best practices and recommendations for safe coding, particularly the guidelines on state changes made after external calls, which have proven pivotal in executing this attack. By cherishing small preventive measures and leveraging tools designed to detect such vulnerabilities, you're well on your way to significantly improving the security of your Solidity contracts.\n\n![](https://cdn.videotap.com/fTRdWZkSOGZLiSUhb43I-740.7.png)> _\"Coding safe contracts are better than fixing broken ones.\"_\n",
          "updates": []
        },
        {
          "lessonId": "4e5253aa-7047-431d-8c16-c6b408be05e9",
          "number": 19,
          "title": "Reentrancy: Remix example",
          "slug": "reentrancy-remix-example",
          "folderName": "19-reentrancy-remix-example",
          "description": "",
          "duration": 4,
          "videoUrl": "eDu2XBwFTos",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/19-reentrancy-remix-example/+page.md",
          "markdownContent": "---\ntitle: Reentrancy - Remix Example\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Preventing Reentrancy Attacks on Ethereum Smart Contracts\n\nWhen designing Ethereum Smart Contracts, one area that requires vigilance is the handling of user balances. A simple change in the sequences of function calls could open the door to a reentrancy attack, causing unexpected behavior and potentially wiping out users' funds.\n\n![](https://cdn.videotap.com/1J27BMPtiIfHtQifcabU-6.42.png)\n\n## Understanding the Problem\n\nThe main issue that makes smart contracts vulnerable to reentrancy attacks relates to the order in which we update the user balance. The problematic sequence in pseudocode looks like this:\n\n```javascript\n...\n// some contract code...//\nfunction withdraw(uint withdraw_amount) {\n    require(userBalance >= withdraw_amount, \"Insufficient funds for withdraw request.\");\n    user.transfer(withdraw_amount);\n    userBalance = userBalance - withdraw_amount;\n}\n...\n// more contract code...\n```\n\nIn a situation where a malicious contract reenters the `withdraw` function before the user balance was updated‚Äî`userBalance = userBalance - withdraw_amount`‚Äîthe smart contract would transfer the same amount again, despite the fact that the balance should have been reduced.\n\nQuote:\n\n> \"The heart of the problem lies in the sequence in which the balance is updated. If an attacker can interrupt this sequence, they can exploit this vulnerability to drain the contract's funds.\"\n\n## The Test Case Scenario\n\nTo reveal the vulnerability in action, let's consider this scenario in the `ReentrancyTest.sol` file:\n\n1. Prank the victim.\n2. Deposit the funds to the victim's account.\n3. Check the balance.\n4. Launch the attack.\n\nAs a result, the victim's balance goes to zero, while the attacker's balance increases by the deposited amount. This exact scenario can be witnessed in the [Remix IDE](https://remix.ethereum.org) directly, giving you a tangible feel of how this exploit plays out.\n\n![](https://cdn.videotap.com/LzhPJ3RR0EUmXpogirbd-102.71.png)The files to be watched are `ReentrancyVictim.sol` and `ReentrancyAttacker.sol`, which hold our hapless victim and the cunning attacker respectively.\n\nTo reproduce the scenario:\n\n1. Compile `ReentrancyVictim.sol` and `ReentrancyAttacker.sol`.\n2. Deploy both contracts.\n3. Deposit 5 Ether to the victim contract.\n4. Observe that the user balance is updated with 5 Ether.\n5. Now deploy the attacker and carry out the attack.\n\nThe result is the same as predicted. The victim's balance goes to zero, while the attacker ends up with 6 Ether.\n\n## The Solution\n\nHow then can we prevent such disastrous scenarios? The solution lies in adjusting the sequence of how the user balance is updated. Just move the `userBalance = 0;` line before the withdraw function. Here's the updated function:\n\n```javascript\n...\n// some contract code...//\nfunction withdraw(uint withdraw_amount) {\n    require(userBalance >= withdraw_amount, \"Insufficient funds for withdraw request.\");\n    userBalance = userBalance - withdraw_amount; // note the order of these lines\n    user.transfer(withdraw_amount); // note the order of these lines\n}\n...\n// more contract code...\n```\n\nThis way, even if the attacker reenters the function, the updated zero balance will not allow it to withdraw any funds.\n\nRemember, the safety and trust users have on your smart contract are built on the solid foundation of security diligence in your coding process. Being aware of potential threats such as reentrancy attacks and taking preventive measures will add to your credibility as a developer.\n\nFor further practice, dig deeper and try out test suites that explore more such scenarios. Practise makes perfect‚Äîall the best on your journey to mastering the security aspects of Ethereum Smart Contract development!\n\n![](https://cdn.videotap.com/O8nYCKukwbgtzZaFQ7DU-195.79.png)\n",
          "updates": []
        },
        {
          "lessonId": "b7ebb003-a608-4d31-a69c-46de78f4cb81",
          "number": 20,
          "title": "Reentrancy: Mitigation",
          "slug": "reentrancy-mitigation",
          "folderName": "20-reentrancy-mitigation",
          "description": "",
          "duration": 4,
          "videoUrl": "LbxQz6D2sP4",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/20-reentrancy-mitigation/+page.md",
          "markdownContent": "---\ntitle: Reentrancy - Mitigation\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Solving Reentrancy Attacks in Smart Contracts\n\nIn today's discussion, we will figure out possible methods to deal with common challenges we face while working with Smart Contracts. There are different ways to solve issues in smart contracts, and one of those frequently used methods is known as Checks-Effects-Interactions or CEI approach. Other new models have been introduced like new CEI or freePi but today, we will focus on the CEI approach.\n\n## What is Check-Effect-Interactions?\n\nIt's essential to understand the Check-Effect-Interactions model properly. CEI is broken down into three steps:\n\n1. Running checks like any required statements or conditionals;\n2. Updating the state of your contracts, which is known as running your effects;\n3. Lastly, interactions with external contracts.\n\nIn the following segment, we'll discuss how we can implement these steps in our contract in a function called \"`withdrawBalance`\". Please note, for demonstration purposes, we assume a contract without any checks since the balance line provided isn't treated as a check.\n\n## Implementing CEI in your Smart Contract\n\nLet's consider a function like \"`withdrawBalance`\" and see how we can use the CEI model to avoid potential contract issues.\n\n![](https://cdn.videotap.com/NPmvbUFZtOy30kA6ekhR-74.82.png)\n\nSo, first, we'll move the balance line, which is an effect since it indicates a state change, to the top. Next, locate the interaction and move it up as well. Finally, order the effect and interaction in place.\n\nWith these modifications, we are ready to redeploy the contract. Following the deployment, a user deposits ether. Like in the previous example, we switch the accounts and call an attack. This time, an alert pops up saying it's reverted.\n\nBut why did it revert?\n\n> \"The contract reverted because when calling the attack, the withdrawal process didn't send any data or value and instead was reverted.\"\n\nSo we can see with these changes, we have protected our contract against the issue causing it to fail when attacked.\n\n## Another Approach: Locks on Functions\n\nAnother way to solve this problem, besides the Checks-Effects-Interactions model, is to put a type of lock on the function using boolean variables. When we lock the function, it's prohibited for anyone to enter it until its status changes to unlocked.\n\n```js\nbool locked = false // Declare a boolean variable called `locked` and set it to false.\n// Inside your function\nif (locked) {\n    revert(); // If locked equals true, the function will terminate.\n    } else {locked = true; // If locked equals false, the function will operate and change the state of locked to true.\n    }\n```\n\nAfter the process, we can safely unlock the function again by assigning `false` to the `locked` variable.\n\nHowever, the lock process can also be accomplished more effectively using professional, open-source tools like Open Zeppelin Package Manager. The Open Zeppelin package includes a tool, `ReentrancyGuard`, that provides a `non-reentrant` modifier to protect against double spend attacks and contract reentry.\n\nSo, these are the two main ways to protect your smart contract from reentrancy issues. Always remember to perform necessary checks, run your effects, and then handle the interactions. Alternatively, you can optimally secure your functions with the aid of locks.\n\nProtect your contracts. Happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "7c86d2b3-42bb-4b17-800a-fbdc70f5e1ad",
          "number": 21,
          "title": "Menace To Society",
          "slug": "reentrancy-menace-to-society",
          "folderName": "21-reentrancy-menace-to-society",
          "description": "",
          "duration": 5,
          "videoUrl": "U9A50LLbYSc",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/21-reentrancy-menace-to-society/+page.md",
          "markdownContent": "---\ntitle: Reentrancy - Menace to Society\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Beware of the Reentrancy Attack in Your Smart Contract\n\nIn the world of crypto and blockchain, security is a paramount concern. When dealing with a web infrastructure that transacts and stores billions of dollars, any weakness in the security system could lead to irreversible financial loss. Many of these losses have been attributed to something known as the Reentrancy Attack, which still ranks among the top ten Decentralized Finance (DeFi) attacks of 2023.\n\nIn this post, I will thoroughly discuss Reentrancy Attacks, shed some light on tools that can help you identify them, suggest common-sense approaches to avoid them, and indulge in a little history by revisiting one of the most infamous cases of Reentrancy Attack.\n\n![](https://cdn.videotap.com/NRMDW7u49DDoO3HwaIgb-20.75.png)\n\n## What is a Reentrancy Attack?\n\nA Reentrancy Attack is a malicious maneuver where an attacker repeatedly calls a function within a Smart Contract before the original function has finished executing. This repetition allows the attacker to drain funds or manipulate data in an unintended way.\n\n## The Dogged Persistence of Reentrancy Attacks\n\nA glance at the data available in our GitHub repository related to this course reveals that Reentrancy Attacks have rather stubbornly stuck around. Not only are they persisting, but their occurrence rate is even increasing.\n\n> \"More people have still gotten hit by Reentrancy Attacks. It is still a common attack vector and is still stealing millions of dollars out of web three.\"\n\nDespite the availability of static analysis tools like Slither, which are fantastic at detecting them, these attacks somehow still find their way through the cracks. The issue with the 'puppy raffle' clearly demonstrates this point.\n\n## A Peek into the Past: The DAO Hack\n\nA great way to understand Reentrancy Attacks is to look back at their history and study some notable case studies. The DAO (Decentralized Autonomous Organization) Hack is one such case and remains one of the most notorious Reentrancy Attacks in history.\n\nIn May 2016, The DAO managed to attract nearly 14% of all Ether tokens issued to date. However, this promising start came to a halt when it was discovered to have a massive bug. The 'reward withdrawal' form was one of the main culprits, having an insidious pattern: it made an external call and then updated the state.\n\n```js\nfunction withdrawReward (address _account) public returns (bool _success) {\n    if ((balanceOf(_account) == 0)&& (rewardAccount.earned(_account) == 0))throw;\n    uint reward = rewardAccount.earned(_account);\n    if (!rewardAccount.reward(_account))throw;\n    if (!_account.call.value(reward)())throw;\n    Withdrawal(_account, reward);\n    return true;\n    }\n```\n\nIn the code snippet above, you can see that an external call is made and immediately followed by a state update. It clearly did not adhere to best practices, which resulted in a severe and costly failure‚Äîa crucial element in what would later be known as the DAO Hack.\n\n## Proactive Solutions to Thwart Reentrancy Attacks\n\nThe Reentrancy Attack can be complicated, but its solution is surprisingly straightforward:\n\n> \"If you make an external call that can reenter the same function before you update some state, you are likely paving the way for a successful Reentrancy Attack.\"\n\nBy adhering to coding best practices and utilizing the numerous security tools available, we could drastically reduce the occurrence and the potential damage of these attacks.\n\n## Summing Up and Looking Ahead\n\nThe unfortunate persistence of Reentrancy Attacks indeed serves as a wake-up call. They continue to plague the digital financial world, stealing massive sums of money and causing significant disruption.\n\nBut as we continue to innovate and work towards a more secure Web 3, it's essential to take any setbacks as learning opportunities. An in-depth understanding of attacks like this one, along with the proactive application of recently developed solutions, will surely pave the way for a more secure future.\n",
          "updates": []
        },
        {
          "lessonId": "79da466e-ddef-4296-8fab-8c80cfcb34bf",
          "number": 22,
          "title": "Reentrancy: Recap",
          "slug": "reentrancy-recap",
          "folderName": "22-reentrancy-recap",
          "description": "",
          "duration": 3,
          "videoUrl": "yrxasLwJvpQ",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/22-reentrancy-recap/+page.md",
          "markdownContent": "---\ntitle: Reentrancy - Recap\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Unraveling Reentrancy Attacks in Ethereum Smart Contracts\n\nReentrancy Attacks within the blockchain ecosystem have become a considerable concern. These attacks exploit a vulnerability found predominantly in Ethereum smart contracts, causing significant damage and financial loss. This blog post hones in what a reentrancy attack is, how to identify one, and, most crucially, what you can do to effectively protect your smart contracts from falling victim to such an attack.\n\n![](https://cdn.videotap.com/fLgSr8bv86FfH9PCnTAk-12.55.png)\n\n## Understanding Reentrancy Attacks\n\nAt its most basic, a reentrancy attack appears as follows. An attacker begins by calling a victim's contract, which in turn calls some external contract. This external contract then circles back and calls the victim contract - repeating the process continuously. The critical flaw that makes this possible is a state change that isn't made before calling this external contract. This diagram provides a more nuanced view of the situation.\n\n![](https://cdn.videotap.com/bUHtSEcSIcBowtKkMcSw-31.36.png)\n\nThe victim deposits and immediately the attacker launches an attack, which calls back to the attack contract. This callback triggers a withdrawal, leading back to the attack contract, provoking another withdrawal, and so on. This recurring action is only possible because we neglect to update the state until the very end - instead of carrying out this crucial step before initiating any external calls.\n\n## Catching Reentrancy Attacks\n\nBeing a common attack vector, reentrancy attacks can be reproduced quite effortlessly. There are a multitude of tools that can help in detecting such risks, one of them being [Remix](http://remix.ethereum.org/), a powerful tool for Solidity programming. You'll find that it's quite straightforward to test and simulate reentrancy attacks using this platform. Static analysis tools such as [Slither](https://github.com/crytic/slither) are similarly handy in identifying these threats. Slither steps in when manual auditors make a slip ‚Äî this is why static analysis tools are so invaluable. However, bear in mind to only rely on powerful static analysis tools capable of catching Reentrancy issues.\n\n> \"If we screw up as manual auditors, Slither or some other static analysis tool can catch this.\"\n\n## Ways to Block Reentrancy Attacks\n\nDefense against reentrancy attacks can be approached in two ways. Firstly, you can use checks, effects, interactions to conduct the state change prior to making any external calls.\n\n![](https://cdn.videotap.com/T6NG2ok8Y9Hcf4Jmh3Kv-87.82.png)\n\nAlternatively, OpenZeppelin's non-Reentrant modifier can be used or some type of modifier (e.g., `if, locked`) which is also identified as a mutex lock in computer science.\n\n## Summing Up\n\nThis disturbing streak of reentrancy attacks that still plagues us today extends back to June 2016 with the Dow hack. It is distressing to note that 14% of all ETH in existence was threatened at the time, as evidenced by [this repo](https://github.com/pcaversaccio/reentrancy-attacks) managed by Pascal.\n\nHowever, despite the sobering reality, we are far better equipped today to detect and prevent these attacks. We have the knowledge, the tools, and the power to prevent the further plundering of Ethereum assets. Here's to a more secure future, where you'll never miss a Reentrancy attack ever again!\n\n> \"Really important attack. Glad you got it.\"\n",
          "updates": []
        },
        {
          "lessonId": "f8a232ac-d0a5-4f2e-b2f8-ec7dd5790aa4",
          "number": 23,
          "title": "Reentrancy: PoC",
          "slug": "reentrancy-poc",
          "folderName": "23-reentrancy-poc",
          "description": "",
          "duration": 8,
          "videoUrl": "f_kvO9E-F0U",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/23-reentrancy-poc/+page.md",
          "markdownContent": "---\ntitle: Reentrancy - PoC\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Exploiting the Reentrancy Bug: An In-Depth Guide\n\nUncovering vulnerabilities in smart contracts has emerged as a critical task, particularly with the rise of DeFi protocols. In this blog post, we will guide you through the process of exploiting one of these vulnerabilities known as the 'reentrancy bug.' For this, we'll use a fictional contract called 'Puppy Raffle' as our case study.\n\n## What is Reentrancy Bug and Why is it Dangerous?\n\n![](https://cdn.videotap.com/nWd247DHc5JaG5n6O8uq-37.66.png)\n\nA _reentrancy bug_ occurs when an external contract gets called before updating the state in a given function. This flaw is potentially destructive as it leads to a condition where the same function can be recursively invoked before the first execution is complete. In essence, it makes it possible for an attacker to drain all funds from the affected contract.\n\nNow, let's get to the heart of the matter and dive into how this reentrancy bug could be exploited in our case study, Puppy Raffle.\n\n## Implementing a Proof-of-Code for Reentrancy Attack\n\nInitially, we have the Puppy Raffle Test - `PuppyRaffleTest.t.sol`. Here, we'll take advantage of the existing refund test to carry out our exploit. We'll begin by copying the `refund test` and then refactor it to serve our needs.\n\n```js\n// Copy pasted refund test\ntestReentrancyRefund() { ... }\n```\n\nWe perceive a `playerEntered` modifier is already implemented. We could use this, but we'll opt to copy and paste it directly into our test function.\n\n```js\naddress[] memory players = new address[](1);\n```\n\nHere, only one player is being instanced. However, we plan to test multiple entrants to the raffle. Therefore, we will change it to include more players - in this case, four.\n\n```js\naddress[] memory players = new address[](4);\n```\n\n![](https://cdn.videotap.com/EsowklYmOJTJLU3Cxgzb-225.95.png)\n\n## Building our Attack Contract: ReentrancyAttacker.sol\n\nHaving completed our set up, we can now proceed to build our attack contract.\n\nIn our attack contract, we need to create a recipient or a `fallback` function that will re-enter into the affected contract.\n\n```js\nfunction() external payable { ... }\n```\n\nThis `fallback` function will only be triggered when the balance of the 'Puppy Raffle' contract is more than the `entranceFee`.\n\n```js\nif (address(puppyRaffle).balance >= entranceFee) { ... }\n```\n\nIn line with this, our attack contract will keep calling the `refund` function recursively until it has drained all the funds from the 'Puppy Raffle' contract.\n\nNow the attack execution is ready. We can create our malicious 'ReentrancyAttacker' contract and an attacker user with a sufficient balance to join the raffle. We will establish a starting and ending balance for both the 'ReentrancyAttacker' contract and the 'Puppy Raffle' contract.\n\nIf the attack is successful, the final balance of the 'Puppy Raffle' contract should read zero, and the 'ReentrancyAttacker' contract should have stolen all the funds.\n\n## Wrapping Up\n\nFrom our proof-of-code run, the attack was indeed successful. This reentrancy issue in 'Puppy Raffle' contract is evidently a major vulnerability, and one must be appropriately addressed in our audit report.\n\n> \"We have successfully written a Proof-of-Code (PoC) for reentrancy on this 'Puppy Raffle.' This is definitely going to be a high-risk vulnerability on our audit report.\"\n\nBy far, you've learned about the nature of a reentrancy bug and how to exploit it, making you a highly alert and more skilled blockchain developer.\n\nSo, take pride in yourself. This bug is a common and critical one; recognizing and fixing it takes your skills to another level.\n\nNow, let's head back to the 'Puppy Raffle' and carry on with our audit. So far, we have revealed a significant reentrancy issue. Keep your guard up; there's more to discover!\n",
          "updates": []
        },
        {
          "lessonId": "31709f46-91b8-4eb4-88bd-a14600106ae5",
          "number": 24,
          "title": "Recon: Continued",
          "slug": "recon-continued",
          "folderName": "24-recon-continued",
          "description": "",
          "duration": 5,
          "videoUrl": "V4TuGjGuCxU",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/24-recon-continued/+page.md",
          "markdownContent": "---\ntitle: Recon Continued\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Thoroughly Examining and Auditing Smart Contract in Slither\n\nWhile performing a manual audit of the smart contract of a Puppy Raffle application in Slither, we unearthed several areas that warrant a more in-depth investigation, such as functions, variables and interactions.\n\n![](https://cdn.videotap.com/bY22ZXsy75N3gZs0jFox-17.06.png)\n\n## A Close Look at Specific Functions\n\nIn this audit, we have done a thorough review of the `refund` function as well as the `enterRaffle` function. Let's now move our attention to understanding the other functionalities of how the Puppy Raffle works.\n\n### Reviewing the GetActivePlayer Function\n\nUpon reviewing the `GetActivePlayer` function, we discovered an informational issue. From a first glance, it appears to be a minor issue as it can lead someone to erroneously believe that their active player index is zero.\n\n```js\nfunction getActivePlayer() public {/* function logic*/}\n```\n\n### Unfolding the Select Winner Function\n\nNext, we are going to examine a major function called `selectWinner`. This function is designed to choose a single winner randomly and mint a new puppy token based on the entries kept in the `players` array.\n\n```js\nfunction selectWinner() public {/* function logic*/}\n```\n\nA cursory look at the function shows that the select winner function follows CEI (Check Effects Interaction) principle as it starts with a series of checks. A quick follow-up review confirms the function's adherence to the principle except for one section where it calls `Safe Mint`. However, we need to better understand what `Safe Mint` does to evaluate if the exception is justified.\n\n## Exploring Variables and Rules\n\nThe `selectWinner` function contains a built-in condition that requires at least four players to exist before a winner can be selected. Another condition that enforces temporal constraints is the `raffle_duration` paired with the `raffle_start_time`. Our review shows that the raffle duration is set at the deployment of the contract, and the raffle start time is set at the instant when the contract is deployed.\n\n```js\npublic int raffleDuration; // set during contract deployment\npublic int raffleStartTime; // set when contract is deployed\n```\n\nPreliminary inspection indicates that these setups seem correct, but we will need to validate their setting and interactions in the next phase.\n\n## Questioning the Randomness of the Winner\n\nThe real crux of the `selectWinner` function lies in the line that calculates the `winner_index`. This is achieved by taking an encoded value based on the message sender, block timestamp and block difficulty, and then applying a modulus operation with the player's length. This operation presumably provides a pseudo-random number, which in turn is used to select a winner.\n\n```js\nwinnerIndex =\n  keccak256(abi.encodePacked(msg.sender, block.timestamp, block.difficulty)) %\n  players.length;\n```\n\nHowever, this method of generating a random number raises a potentially critical concern ‚Äî weak randomness. This is a known area of potential exploit in blockchain wherein pseudo-random number generators can be manipulated, thus warranting further investigation.\n\n> _Note: \"Is the random winner really random?\"_\n\nOverall, our extensive drill-down into the `selectWinner` function and related variables has revealed several potential loopholes, including weak randomness, that need further examination to ensure the security and fairness of the Puppy Raffle Dapp.\n\nStay tuned for our upcoming posts where we will dive deep into understanding potential vulnerabilities, and continue examining the rest of the smart contract.\n",
          "updates": []
        },
        {
          "lessonId": "6b574a27-6e1f-4aa4-a421-8a51b18cdb90",
          "number": 25,
          "title": "Exploit: Weak randomness",
          "slug": "exploit-weak-randomness",
          "folderName": "25-exploit-weak-randomness",
          "description": "",
          "duration": 4,
          "videoUrl": "dAON44pV9z8",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/25-exploit-weak-randomness/+page.md",
          "markdownContent": "---\ntitle: Exploit - Weak Randomness\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Discovering Weaknesses in PRNG with Slither\n\nIn the diverse world of decentralized application development, we often encounter complex security challenges. One such is the vulnerability in pseudorandom number generators (PRNGs). Here, we'll delve deep into the specifics of the weakness in PRNG, discuss how to detect it using a tool called Slither, and provide secure alternatives.\n\n## Identifying the PRNG Weakness with Slither\n\nAs we initially dive into the topic, we'll use the Slither tool.\n\n![](https://cdn.videotap.com/7nugMPqDrdTJOkuQc2VL-17.86.png)\n\nFor those unfamiliar, Slither is an immensely useful Solidity static analysis framework that helps developers identify security vulnerabilities in their smart contracts. To put it to use, we'll use `slither .` for analysis.\n\n![](https://cdn.videotap.com/KVCSvBriSAdLW0iGaC85-26.79.png)\n\nProvide the necessary inputs, zoom in, and voila, Slither proficiently catches our weak PRNG code!\n\nUpon scrolling to the top, we come across the info detectors section, where the weakness is named as \"weak PRNG.\" Clicking on the link redirects us to the documentation, where we'll get an in-depth understanding of the issue.\n\n> \"Weak PRNG due to a module on block timestamp or block hash. These can be significantly influenced by miners, leading to a high degree of unpredictability.\"\n\nThus suggesting that not only is the PRNG weak, but it can also be tampered with significantly by miners, which should be avoided at all costs.\n\n## Diving Deeper into PRNG Weakness\n\nThe issue runs deeper than what it initially seems. PRNG in blockchain applications, to some extent, can be influenced or anticipated, which are signifiers for potential attacks.\n\nDo you remember [`sc-exploits-minimized`](https://github.com/Cyfrin/sc-exploits-minimized) from the previous tutorials? Let's revisit it to understand it better.\n\nOnce you're there, scroll down to 'weak randomness'. This is what we need for a better understanding of the weakness.\n\n![](https://cdn.videotap.com/WLZxtJUXvyxCOZKz6ptG-107.16.png)\n\n## Playing with the Weak Randomness\n\nLet's open the Sol file in Remix and poke around a bit.\n\nConsider this example.\n\n```js\ncontract WeakRandomness {\n    function getRandomNumber() external view returns uint256 {\n        return uint256(keccak256(abi.encodePacked(msg.sender, block.prevrandao, block.difficulty, block.timestamp)));\n        }\n}\n```\n\nThe above function generates a random number using `msg.sender`, `block.prevrandao`, `block.difficulty`, and `block.timestamp`. Here, the code hashes these values and wraps them into a uint256.\n\nSeems legit, right? Wrong!\n\nThe threat here is obvious to those experienced in blockchain security. These vital parameters can be easily manipulated or anticipated by miners, resulting in predictable 'random' numbers, which are vulnerabilities waiting to be exploited.\n\n## Real-time Exploits and Solution\n\nSeveral exploits have occurred in the past where miners were able to anticipate or influence the random number. If you use the same random number in the same block, it invariably leads to massive issues.\n\n![](https://cdn.videotap.com/pG215QeyShJvBxt7ocmk-174.14.png)\n\nChainlink VRF, a verifiable random function, is the solution to this issue. It ensures that random numbers generated on-chain are provably random, tamper-proof, and unpredictable.\n\n![](https://cdn.videotap.com/e5n2aLD8xI6u253dq8Va-183.07.png)\n\nTo wrap it up, blockchain is a complex and exciting space. Dealing with PRNG weakness is just one of many challenges developers face. Armed with knowledge and appropriate tools like Slither, we can tackle these challenges and develop secure, decentralised applications. Stay tuned for more insightful tutorials to bump up your blockchain coding prowess.\n",
          "updates": []
        },
        {
          "lessonId": "553ec8a3-8e89-4408-b1a0-df917a61e099",
          "number": 26,
          "title": "Weak randomness: Multiple issues",
          "slug": "weak-randomness-multiple-issues",
          "folderName": "26-weak-randomness-multiple-issues",
          "description": "",
          "duration": 4,
          "videoUrl": "VVOpvCw9-FA",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/26-weak-randomness-multiple-issues/+page.md",
          "markdownContent": "---\ntitle: Weak Randomness - Multiple Issues\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Breaking Down Blockchain Randomness: Security and Potential Pitfalls\n\nToday, we're going to delve into the intricacies of managing certain aspects of blockchain programming. Specifically, we will be discussing these three elements: Message Sender, Blocked ProgramDo, and Blocked Timestamp. These are key aspects when dealing with randomness in blockchain, which we will dissect, explaining their functionalities and potential security issues.\n\nLet's get started.\n\n## Deconstructing the Blockchain Components\n\n### 1. block.timestamp\n\nTo understand the concept of `block.timestamp`, refer to the repository's diagrams.\n\n![](https://cdn.videotap.com/96gVghjLA5xt6vAGyZ3W-23.74.png)\n\nA transaction on the blockchain has its timestamp that miners can manipulate. If a miner doesn't agree with the timestamp, they might hold onto the transaction until a more favourable timestamp occurs.\n\n> When dealing with Validator node issues, remember never to trust miners!\n\nA miner can also reject a transaction if the timestamp doesn't favour their needs. Manipulating the timestamp has become more challenging after the merge; yet, there are ways to tamper.\n\nOn non-Ethereum blockchain systems, miners sometimes have the power to adjust block timestamps by a few seconds. It might not seem much, but in the agile world of blockchain, these minor adjustments might lead to contract violations or aid in attaining a favourable random number.\n\n### 2. block.prevrandao\n\nA new Solidity component, **block.prevrandao**, replaced the block difficulty post the merge. It is used to randomly pick validators under the new system.\n\nFor more in-depth information, refer to EIP (Ethereum Improvement Proposal) [EIP 4399](https://eips.ethereum.org/EIPS/eip-4399).\n\n![](https://cdn.videotap.com/fhhVXSh7UyBBcLkTyLNK-63.32.png)\n\nHowever, it also bears security considerations. First, it's biased since it allows one bit of influence power per slot. A tweak in the security component can cause a shift from an originally intended number. Moreover, it opens doors to predictability since it originates from a previous random number.\n\nConsequently, caution is of utmost importance while using **prevrandao** if it can't be avoided.\n\n```js\npragma solidity ^0.5.0;\n\ncontract Example {\n    uint public myNum = uint(block.prevrandao);\n\n    function getPrevRandao() public view returns (uint) {\n        return myNum;\n        }\n}\n```\n\n### 3. msg.sender\n\nOur last element, **msg.sender**, can also be manipulated by the caller. If the randomness is generated from a field controlled by the caller, they can manipulate the field to get their favoured random number.\n\nA simple example can be hashing the `msg.sender`, where a caller can mine for addresses until they find one that gets them the random number they want. Add to that the deterministic nature of the blockchain, and it becomes evident that finding a random number inside the blockchain would lead to finding a deterministic number.\n\n```js\npragma solidity ^0.5.0;\n\ncontract Example {\n    address public addressVar = msg.sender;\n    function getSender() public view returns (address) {\n        return addressVar;\n        }\n}\n```\n\n## Beware of the Pitfalls\n\nThe crux of the matter is the blockchain, being a deterministic system, can't commit to genuine randomness. All generated random numbers can get influenced and adjusted, leading to potential security lapses. Using these elements for randomness is hence a poor practice and should be avoided at all costs.\n\nYou can also test this in Solidity's Remix or via the `sc-exploits-minimized` repository for further practice.\n\nWhile dealing with blockchains, one must always keep their eyes and ears open for potential security breaches. It's not an easy world to navigate, but with careful consideration and active learning, we can make it a safer place for everyone.\n",
          "updates": []
        },
        {
          "lessonId": "a783af65-794e-42cd-b1e3-74c9ce450915",
          "number": 27,
          "title": "Case Study: Weak Randomness",
          "slug": "weak-randomness-case-study",
          "folderName": "27-weak-randomness-case-study",
          "description": "",
          "duration": 7,
          "videoUrl": "KpWqBm2IE20",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/27-weak-randomness-case-study/+page.md",
          "markdownContent": "---\ntitle: Weak Randomness - Case Study\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Case Study: The Meebits Exploit of 2021\n\nIn today's post, we're going to delve into an intriguing case study that involves an exploit of an NFT project, Meebits, which occurred in 2021. This analysis will shed light on a real-world example of how weak randomness was exploited, resulting in a substantial loss of nearly a million dollars for the protocol.\n\nOur guest lecturer and fellow YouTuber, Andy Lee from Sigma Prime, is here to break everything down for us, from the details of the exploit itself to how it was eventually resolved.\n\n![](https://cdn.videotap.com/xkbChTamuPnibRHVXkei-35.55.png)\n\nRemember, periodically conducting post mortems like this greatly contributes towards honing your skills as a security researcher. Moreover, it complements the effort of strengthening the overall security of your projects and applications by acquainting you with the past exploits to forestall future vulnerabilities.\n\n## A Deep Dive Into The Meebits Exploit\n\nMeebits, created by Lava Labs (the brains behind CryptoPunks), was exploited due to insecure randomness in its smart contracts. By rerolling their randomness, an attacker was able to obtain a rare NFT.\n\nThe concept behind Mebits is simple. If you owned a CryptoPunk, you could mint a free Meebit NFT. The attributes of this newly minted NFT were supposed to be random, with some traits being more valuable than others. However, owing to exploitable randomness, the attacker could incessantly reroll their mint until they obtained an elusive NFT.\n\n## Key Steps to the Exploit\n\nLet's discuss how the attack unfolded. The attacker:\n\n1. Found the metadata revealing the valuable traits compared to the other available ones.\n2. Exploited the insecure randomness stemming from the smart contract, enabling the repeated rerolls of their mint.\n\nThe metadata disclosure in the contract was found on line 129, which led to an IPFS hash with a JSON Blob. This JSON Blob outlined the rarity of the types of Meebits, ranking from the rarest to the least rare.\n\n![](https://cdn.videotap.com/CEWoGF9o6n51CYYJGpOx-177.73.png)\n\nBesides, the Meebit Website provided further information on the rarity by using the token URL function. By entering the token ID, you could see the specific trait your Meebit had.\n\nFor instance, token 16647 had a 'visitor' trait type, currently ranking second in rarity.\n\n## Analysing the Mint Function and Attack Contract\n\nThe smart contract had an external function, `mintWithPunkOrGlyph`, that verified whether the caller owned a Crypto Punk or Glyph. Upon confirmation, the user was allowed to mint a free NFT. This function assigns a random index to the ID; this random index is then assigned to the owner who requested the Meebit NFT.\n\n![](https://cdn.videotap.com/bBOd0ojIlu3ppLIWpKQg-236.97.png)\n\n> \"To understand the exploitability, we need to consider the attack contract and its transactions.\"\n\nOn Etherscan, you can see the transactions where the attacker deployed a contract and repeatedly called a function on the attack contract until they succeeded in minting the NFT they wanted.\n\nThe attack contract is essentially a blob of bytecode, unlike the Meebits contract, which was verified. By putting this code into a bytecode decompiler, we can pinpoint how it was exploited.\n\n![](https://cdn.videotap.com/VDFDeR5qbb6lh1CXHZBw-308.06.png)\n\nThe attack function reveals that the contract calls `mintWithPunkOrGlyph`, and if the Meebit random index wasn't as per the user's wish, the transaction would revert, allowing the attacker to try again.\n\nOne can use Tenderly to trace what exactly transpired during the transaction process.\n\n## Conclusion of the Attack\n\nAfter a grueling six hours of continual calls, the attacker successfully minted the rare Meebit 11647, which held the 'visitor' trait, spending thousands of dollars on gas during this period.\n\nWe owe a big thanks to Andy Lee from Sigma Prime for compelling insights into this case study. It provides a stark reminder of the importance of constant vigilance and thorough examination when dealing with smart contracts and other cryptographic protocols. It also underscores the vital necessity to never underestimate the potential for exploitation, no matter how obscure.\n\nStay tuned for more intriguing case studies and analysis as we continue to dissect cybersecurity incidents in the crypto space!\n",
          "updates": []
        },
        {
          "lessonId": "dde6f9a7-4b37-4472-bfdc-0d0b894b01cb",
          "number": 28,
          "title": "Weak randomness: Mitigation",
          "slug": "weak-randomness-mitigation",
          "folderName": "28-weak-randomness-mitigation",
          "description": "",
          "duration": 1,
          "videoUrl": "uY3Q_sZG1lM",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/28-weak-randomness-mitigation/+page.md",
          "markdownContent": "---\ntitle: Weak Randomness - Mitigation\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# **Bringing Trustworthy Randomness into the Blockchain with Chainlink VRF**\n\nA prevalent challenge that many encounter in the blockchain space is finding reliable ways to generate random numbers off-chain. Lucky for you and I, this conundrum has a solution. In this post, we will delve into how the Chainlink Verifiable Randomness Function (VRF) provides a solution that furnishes verifiable and cryptographically credible random numbers. Primarily, it is decidedly the most popular tool and is widely trusted for its cryptographic guarantees.\n\nYou might be asking, \"Why is this such a major concern?\" So let's begin to unravel this issue.\n\n> \"Getting a random number off-chain is going to be an issue for us\"\n\nWhy is that so? It boils down to the pivotal concept of **trust** in the blockchain realm. Any kind of randomness we want to utilize will necessitate some sort of off-chain introduction, which can understandably feel scary.\n\n## Chainlink VRF: A Proven Solution\n\nSo how do we counteract this fear? The answer is Chainlink VRF.\n\n![](https://cdn.videotap.com/JDtC3sTSaBwZXHXKhNvg-26.1.png)\n\nIn essence, Chainlink VRF operates as a verifiable random number generator. What sets it above others is a series of cryptographic guarantees that enforce and ensure that the produced numbers are truthful and random.\n\nThis isn't conjecture. It's mathematical. Chainlink VRF integrates advanced cryptographic proofs that enable users to validate the process's integrity, thereby instilling an invaluable level of trust.\n\n## Diving Deeper into Chainlink VRF\n\nPotentially, you might not be familiar with Chainlink VRF initially. But don't worry, we've got you covered.\n\n![](https://cdn.videotap.com/eHq7O6rojE6kw9gbagQV-40.6.png)\n\nTo get started, make your way to [Chainlink Docs](https://docs.chain.link/docs/chainlink-vrf/). This comprehensive documentation provides an exhaustive breakdown of all things Chainlink VRF. Right from the basics to solve more complex issues, it has everything you need to know.\n\nAssuming this catches your interest, and you wish to dive even deeper, I‚Äôd highly recommend you to check out my Foundry course. This covers Chainlink VRF in exquisite detail.\n\n## Wrapping Up\n\nWhile the problem of generating verifiable random numbers off-chain may seem daunting at first, the solution with Chainlink VRF brings much-needed relief. It provides a trusted, mathematically proven means of bringing random numbers into the blockchain world and opens up a wealth of opportunities. The best part? Whether you're a novice or a veteran in this realm, the plethora of resources available through Chainlink Docs ensures that you‚Äôre well-equipped to tackle any challenge.\n\nRemember, it's not just about creating randomness. It's about creating randomness that we can trust and verify. And Chainlink VRF provides us with precisely that. So dive in, explore and experiment, and discover how this innovative solution can revolutionize your blockchain ventures.\n",
          "updates": []
        },
        {
          "lessonId": "3c4d644f-5c2f-4298-a398-ab81c8d9e0b9",
          "number": 29,
          "title": "Exploit: Integer overflow",
          "slug": "exploit-integer-overflow",
          "folderName": "29-exploit-integer-overflow",
          "description": "",
          "duration": 8,
          "videoUrl": "JoTkqR9AydE",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/29-exploit-integer-overflow/+page.md",
          "markdownContent": "---\ntitle: Exploit - Integer Overflow\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Smart Contract Debugging: Dissecting \"selectWinner\" Function\n\nHi there! Today we're diving once again into the depths of smart contract bugs, and we've stumbled on another one we think you might find interesting. We're dissecting the notorious `selectWinner` function and unsurprisingly, there's a lot more to be uncovered here than we originally thought.\n\nSo, grab a cup of coffee, put on your favorite debugging playlist, and let's get started!\n\n## Total Amount Collected: Why not Balance?\n\nThe following piece of the code confused us:\n\n```js\n// Computes the total amount collected\ntotal_amount_collected = len(players) * entrance_fee;\n```\n\nWe wondered, why not simply use `address.balance` instead? It seems like a more straightforward method to compute the total amount collected. Could there be an underlying reason for this approach? This is definitely a conversation for the team handling the project.\n\n## Deciphering the Prize Pool\n\n![](https://cdn.videotap.com/1eblPhxnIULZz5ABPoxP-135.7.png)\n\nMoving on, we interpreted an interesting metric ‚Äì the prize pool. The code below illustrates how it's computed:\n\n```js\n// Computes the prize pool\nprize_pool = (total_amount_collected * 80) / 100;\n```\n\nThe computation suggests the prize pool is set to be 80% of the total money, while the final 20% appears to be a fee. The question here is, \"Is the 80% allocation right?\" We couldn't find this in any documentation, so it's possible that there might be some arithmetic error we're yet to spot. We briefly checked if there could be a loss of precision. But we'll revisit that later.\n\n## The Enigma of Total Fees\n\nNext, we noticed some peculiar operations regarding total fees:\n\n```js\n// Update total fees\ntotal_fees += uint64(fee);\n```\n\nWhere `uint64(fee)` is computed as a fixed portion of some percentage amount. When we examined `total_fees`, we found it to be a uint64 variable that gets updated in `withdrawal_fees`. This implies that `total_fees` is the total amount the owner should be able to collect. But, there was a warning flag for us due to a strange casting operation happening here. The casting operation gave us an intuition of the possibility of an `integer overflow`, a classic error that doesn't surface in modern versions of the framework due to its built-in protection mechanisms.\n\n## Into the Abyss: Understanding Overflow Functionality\n\nArmed with our suspicion, we journeyed into the Smart Contract Exploits Repository to understand more about this overflow. The repository contains numerous arithmetic errors, including overflow, underflow, and precision loss.\n\n![](https://cdn.videotap.com/4IhOT3WnizauykVujmDa-262.93.png)\n\nUsing some sandboxed sample contracts, we devised methods to illustrate these errors in practicality. The `increment` function showed that adding anything to a variable that has reached its maximum value will cause the value to wrap back to the start, which results in an overflow issue.\n\nThis is a big deal in contract development and can be resolved to a large degree by removing the unchecked wrappers around your incrementing function calls. Consequently, we're able to limit the value to the maximum, preventing any overflow.\n\nHere's a quick illustration:\n\n```js\n// Initial function that causes an overflow\nfunction increment() public {\n    count++;\n    }\n```\n\nUpdating the function to avoid overflow:\n\n```js\n// Corrected function\nfunction increment() public {\n    require(count < max, \"Maximum limit reached\");\n    count++;\n    }\n```\n\nSimilar issues can be detected with `underflow` and `precision loss`. It's worth noting that the impact of precision loss has to be carefully evaluated. Sometimes, the loss is insignificant and won't affect the functioning of the smart contract. However, in certain use-cases, even the slightest precision loss can lead to significant deviations.\n\n## Proof Of Code: Making It Real\n\nIt's crucial to not only understand the bugs and possible errors but also to replicate these issues with a proof of code. Although we won't provide a complete walkthrough for writing a proof of code for the overflow issue (it's pretty straightforward), we encourage you to pause your reading here and take a moment to write one yourself.\n\nOnce you've done that, head to our repository and switch to the `audit_data` section. There you'll find a ready-made proof of code with which you can compare your own.\n\n# Finding Bugs: Are We Done?\n\nAs we continue to dig through the smart contract, we're fascinated by the array of bugs we're finding. However, it's pretty exciting! It's evident that there is a lot left to explore and debug, so let's keep delving deeper! And remember, while we may be finding lots of bugs now, our ultimate goal is to create code that is clean, robust, and secure against potential exploits.\n\nAnd that's it for today's bug hunt! Watch out for our next blog post where we delve into more detailed examinations and interesting discoveries. Happy debugging!\n",
          "updates": []
        },
        {
          "lessonId": "b9ba2a58-137e-4622-a91d-f0f28eff6c01",
          "number": 30,
          "title": "Integer overflow: Mitigation",
          "slug": "integer-overflow-mitigation",
          "folderName": "30-integer-overflow-mitigation",
          "description": "",
          "duration": 2,
          "videoUrl": "W-tv7-mze3o",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/30-integer-overflow-mitigation/+page.md",
          "markdownContent": "---\ntitle: Integer Overflow - Mitigation\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Optimizing Solidity Code: Fixes and Best Practices\n\nIn this section we will be focusing on how to optimize your solidity code by handling arithmetic issues, using newer solidity versions, and selecting appropriate sized unsigned integers.\n\n![](https://cdn.videotap.com/JQFvqTTQx9NSt5trIsy4-5.2.png)\n\n## Updating to Newer Versions of Solidity\n\nFirst on our agenda - Newer solidity versions. They are the very first fix we will be discussing. Given the critical importance of versioning, it's surprising how many audits reveal that projects are still on outdated solidity versions, leaving them susceptible to unchecked errors.\n\nBy updating your Solidity version, you mitigate the risk of unchecked arithmetic overflow or underflow errors. Current versions of Solidity use a more secure arithmetic model where operations will automatically revert on underflows and overflows, which makes it safer and more secure.\n\nSo, it's not just good advice‚Äîit's a fundamental step towards secure code.\n\n## Choosing the Right Size Unsigned Integer\n\nMoving onto our next topic, let's talk about choosing the right size for your unsigned integers. You might, for example, be using a uint256 (Unsigned integer 256bits) in a certain spot. However, in some instances, it might be worth opting for larger 'uints' or 'bigger uns' as I like to call them.\n\nChoosing the right integer type can significantly optimize your contracts' gas efficiency, as smaller integer types use less gas.\n\n> \"Why are you using a uint64? Don't do that. That's silly.\"\n\nIn my experience, oversized or undersized integer types is a common issue that arises in solidity audits. For example, using a uint64 when you're likely to end up surpassing that limit is a move that could potentially lead to disastrous results.\n\n## Checking Against Max Value Limits\n\nBut how do you identify this?\n\nNewcomers might rely on intuition or guesswork, when actually, a much more straightforward method is at our disposal. Tools such as Chisel, which come with your foundry, can help check if your program is using integers appropriately.\n\nA simple command `uint64 max` can give you the maximum value for a uint64. This then allows you to gauge if the values you're dealing with are within the specified range of uint64 and therefore, giving you the ability to decide if using a uint64 is judicious or ill-advised.\n\nSay, hypothetically if your protocol generates over 18 ETH in fees, it's going to surpass the uint64 limit, causing an integer overflow which could lead to severe consequences.\n\n![](https://cdn.videotap.com/rBscGeCrMNlRHNKG4K02-46.8.png)\n\nTherefore, it is crucial to be mindful of the ranges of each integer type to avoid such issues. Regularly auditing and checking your code for such issues, can save you countless hours of debugging and problem-solving down the road.\n\nIn summary, It's all about having the foresight to see potential problems and nip them in the bud.\n\n## Wrapping Up\n\nSolidity, the development language for Ethereum, is consistently evolving. By prioritising keeping our Solidity version up to date and diligently selecting our integer types, we can ensure that our code remains secure, optimized and bug-free.\n\nJust keep in mind, while this blog focusses on two main aspects of optimizing solidity code, it's just the tip of the iceberg. Solidity best practices cover a wide range of topics, and this blog should be considered as a drop in an ocean of knowledge that one should strive to acquire to become an expert solidity developer.\n\nBut for now, my dear reader, let's get comfortable with this information and slowly find our path to expertise. Until our next blog post, take care and happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "34856ce8-f62b-469b-bc59-c053b97d3e69",
          "number": 31,
          "title": "Exploit: Unsafe casting",
          "slug": "unsafe-casting",
          "folderName": "31-unsafe-casting",
          "description": "",
          "duration": 4,
          "videoUrl": "EPMK9X5-qYk",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/31-unsafe-casting/+page.md",
          "markdownContent": "---\ntitle: Unsafe Casting\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Unveiling a Code Overflow Issue: Dealing with Unsafe Casting in Ethereum\n\nHave you ever found yourself struggling with an obscure overflow issue in your code? Let's say you come across such an issue in a piece of Ethereum code that deals with fees. Well, I want to walk you through a discovery that could change the way you look at such a problem. Buckle up and let's dive in!\n\n## The Overflow Issue ‚Äì MAX Value\n\nNow, when you pull up your terminal, you may notice an overflow issue. What might this look like?\n\nHow about we illustrate with an example. For starter‚Äôs sake, let‚Äôs use our terminal's little chisel to display the max value for `uint` data type as such:\n\n```js\ntype(uint64).max;\n```\n\nThis will yield the maximum value that this data type can hold. You can copy this and run it again to verify. An integer with a max value of UN 64, for instance, would display as a series of numbers:\n\n```bash\n18446744073709551615\n```\n\nThis highlights the maximum value for uint64.\n\n![](https://cdn.videotap.com/fytpgvHqwMiVQT0IRTQM-49.5.png)\n\n## The Effect of Overflow on ETH Fees\n\nSo, what happens if an overflow occurs when 20 ETH of fees are collected? This is where the enigma unfolds. We can simulate this scenario with this code snippet:\n\n```js\nuint64 my64Uint = uint64.max\nlet twentyEth = uint256(20 * e^18)\n```\n\nHere, `uint64` holds the max.Unsigned 64-bit integer value and `ETH` holds the computed value of 20 Ethereum coins in their smallest unit, Wei.\n\n![](https://cdn.videotap.com/OH27oWqZxNCfkB6SimEB-81.png)\n\n## Danger of Casting ETH as uint64\n\nNext, we need to see what ensues when we try to cast our 20 ETH held in UN 256 as a UN 64. What does this casting do? Let's map it out.\n\n```js\nmyUint64 = uint64(twentyEth);\n```\n\nSurprisingly, after copying this value and comparing it with the previous value of my `uint64`, we notice that the new value seems reduced‚Äîtruncated to be exact. In actual representation:\n\n```bash\n1553255926290448384\n```\n\nThis demonstrates that casting `uint256` to `uint64` results in truncation of a lot of its values. How?\n\nOpening up a calculator to run `20 - uint64.max` reveals that the exact number is obtained. This shows that we have wrapped around the max value, which is an unsafe casting of this variable.\n\n![](https://cdn.videotap.com/XcTeQLGswCK42guJBqbp-130.5.png)\n\n## The Double Trouble ‚Äì Unsafe Casting\n\nDoubling up as an overflow issue, this also becomes an unsafe casting problem. You can‚Äôt just grab `uint256` and cast it into `uint64` without consequences. The losses incurred could be vastly significant‚Äîif the protocol is very profitable as anticipated, many fees would be lost with such a line of code.\n\nSurprisingly, this line of code shreds a ton of damages to the code base and is definitely a concern that‚Äôs worth calling out.\n\n## Conclusion: The Audit Report\n\nWith a keen eye for clogs in the code base, we can bring to light silent issues that otherwise stay hidden. In our code review adventure, we‚Äôve managed to unveil an overflow issue and unsafe casting from `uint256` to `uint64`. Let‚Äôs crown our discovery:\n\n> Audit unsafe cast of `uint64` of `uint256` to `uint64`.\n\nThis powerful discovery should feature prominently in any audit report! It shows us that unchecked habits‚Äîlike freely casting variables‚Äîcan lead to severe implications such as losses in fees. So the next time you're coding, keep an eye out for these subtle pitfalls!\n\nRemember, the devil's in the details. Until next time, stay curious and explore more!\n",
          "updates": []
        },
        {
          "lessonId": "0f511af4-595c-4b3e-bd92-dabb16222f66",
          "number": 32,
          "title": "Recon II",
          "slug": "recon-continued-2",
          "folderName": "32-recon-continued-2",
          "description": "",
          "duration": 11,
          "videoUrl": "9l_L7s-XtoI",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/32-recon-continued-2/+page.md",
          "markdownContent": "---\ntitle: Recon Continued 2\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Smart Contract Review: Select Winner & Withdraw Fees\n\nWe will be navigating through multiple big issues found in a smart contract. Specifically, for a function called `selectWinner` and later on, `withdrawFees`.\n\n## selectWinner\n\nAlright, jump in the war zone! We spotted two big glitches in the `selectWinner` segment. Not the greatest news, but I do have some documentation for you. My bad, let me guide you through these tricky terminologies.\n\nThe two issues were:\n\n1. Utilization of on-chain data hashes to generate random numbers.\n2. Resetting the players' array after the winner is chosen.\n\nTo break it down for you:\n\nFirstly, the issue with using the hash of on-chain data to generate random numbers is that it leaves our contract susceptible to manipulation. This is frowned upon in a blockchain environment that requires secure and non-tamperable algorithms.\n\nSecondly, clearing out the active players' array after a winner is selected was another significant problem. If this doesn't happen, new users could confront erroneous entries from previous rounds, thereby jeopardizing the next winner sequence.\n\nNow, what happens post-selection? We disburse 80% of the accumulated funds to the fortunate victor, and the remaining 20% is remitted to the fee address. Efficient, isn't it?\n\n> \"Generating unique and secure random numbers and regular reset of player arrays are crucial components of maintaining a fair and efficient lottery system.\"\n\n## Token ID\n\nSurprisingly, we stumbled over another considerable bug, bearing in the token supply section. The term 'Total Supply' was unresponsive when clicked at first. Therefore, scrolling through my project, I spotted the term multiple times in the code. It was linked to ERC721 token standard and indicated the number of token owners. So we concluded that the total supply also represents the token ID. However, we need to increment the ID to avoid its reuse.\n\n```js\nTotalSupply = tokenId++;\n```\n\n## Rarity Determination\n\nHere we held onto the similar unpredictable randomness issue. We, although, calculated the winner index differently for rarity selection of the newly minted NFTs. If its number is less than a common rarity, it is mapped as a random number, else it's rare.\n\nSo, great, we nailed another bug! Before moving on, we also set conditions for resetting the players' array, the raffle start time and reviewed its necessity. If these conditions aren't perfected, the lottery could potentially get stuck and never finish.\n\n![](https://cdn.videotap.com/7ck6k0hpIuydiM6GKGAa-460.86.png)\n\n## Withdrawing Fees\n\nNow, moving towards the `withdrawFees` section, we detailed how 20% of the funds were transferred to the fee address. This function can be activated by a different address than the owner. Wherein, the owner can alter the fee address if desired.\n\nDo remember, when we are sending money, we could possibly trigger another function. So we should be precautious. Upon questioning whether withdrawal of fees was difficult, considering the existing balance and total fees in the contract, and whether the winner's address smart contract could potentially fail, we recorded these as issues to be probed further.\n\n## Conclusion\n\nAll in all, while the intricacies of the blockchain are quite deep, going through this review should have allowed you to better understand some of its fundamental parts. I hope this blog was illuminating and helpful in navigating through the complex terrain of smart contract auditing. The bugs we discussed are by no means exhaustive, but remembering these few pitfalls can save a lot of debugging time in the future. Game on.\n\nRemember, the goal as a successful security researcher is to gain knowledge and experience from each review, and eventually, you will develop an intuition, a \"bug sniffer\". The more you review the code, the better you'll get at hunting bugs. Happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "019b4cd0-68fa-4a16-875c-f0918266a4fd",
          "number": 33,
          "title": "Exploit: Mishandling Of ETH",
          "slug": "exploit-mishandling-of-eth",
          "folderName": "33-exploit-mishandling-of-eth",
          "description": "",
          "duration": 3,
          "videoUrl": "U6KbdtD_VLA",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/33-exploit-mishandling-of-eth/+page.md",
          "markdownContent": "---\ntitle: Exploit - Mishandling of Eth\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Working with Smart Contracts: Addressing Potential Issues with ETH Transfers\n\nIn the world of smart contracts on Ethereum, there are a few areas which require our keen focus due to the implications they might have. We might face issues with fees getting locked, unexpected withdrawals, or transfers of funds. But through this article, we will place our focus primarily on the **require address**.\n\n#### Handling ETH and \"require address\"\n\nWhen dealing with smart contracts, specifically those involving Ethereum (ETH), there's often a delicate balance that needs to be maintained for handling transfers.\n\nOne crucial line of code that plays a critical role is `require(address(this).balance == totalFees)`. This condition checks to ensure the contract isn‚Äôt accidentally deducting funds from a raffle draw. In essence, it helps maintain an extra layer of cautiousness in automated transactions.\n\nA quick assumption might be, since this contract doesn‚Äôt have a receive or a fallback function, any attempts to send ETH to this contract would fail.\n\n#### An Attempted Test\n\nTo explore this assumption, let's create a new test in the next code block. We'll name it `testCantSendMoneyToRaffle()`.\n\n```js\nfunction testCantSendMoneyToRaffle() public {\n    address senderAddy = makeAddy(\"sender\");\n    vm.deal(senderAddy, 1 ether);\n    VM.expectRevert();\n    (bool, success) = payable(senderAddy).call{value: 1 ether}(\"\");\n    require(success);\n    }\n```\n\n![](https://cdn.videotap.com/TktbUtvsD0DdyS1GHOkN-69.09.png)\n\nThe `VM.expectRevert()` function call lets us skip the actual revert message. Then if we try to send 1 Ether to `senderAddy` address using the `call{value: 1 ether}` call, we anticipate a potential failure because that's what our initial assumption dictates. We capture this result in `success`.\n\nLet's try to run this test and see what we get.\n\n![](https://cdn.videotap.com/K4rV8gMLh0Uma7eqS3eg-92.12.png)\n\nThe test passed just the way we anticipated. This is because without a fallback or a receive function, Solidity rejects any incoming transactions, which in turn ensures we can't send any funds to the contract.\n\n#### Checking Balances With Smart Contracts\n\nThis successful test could lead us to believe that we are doing a fantastic job tracking our balances. That our smart contracts are capable of accurately keeping track of the amount of money they hold.\n\nLet's highlight this point with a quote:\n\n> \"So Solidity automatically says, hey, reject any transactions. Reject any money that comes in. So we should hypothetically then be doing a great job of keeping track of our balances. This contract should do a really good job of knowing exactly how much money is in here. However, that is not always the case.\"\n\n![](https://cdn.videotap.com/fZe2PQqfTrVFeqENHfi4-128.97.png)\n\n#### Exploring the Mishandling of ETH Exploit\n\nUnfortunately, mishandling of ETH is a broader category of exploits that programmers face. It is plagued with potential pitfalls and gotchas. Our tests above might have gone smoothly, but perfect solutions to avert these problems do not always exist. Hence, programmers are urged to exercise caution when working with ETH especially in the realm of smart contracts.\n\nTo get a more comprehensive understanding of this problem, check out this link: [`sc-exploits-minimized`](https://github.com/Cyfrin/sc-exploits-minimized). This resource will offer you an in-depth exploration of various ways ETH handling can go awry and what strategies could help mitigate these issues.\n\nIn conclusion, working with smart contracts requires a vigilant eye and a detail-oriented attitude to avoid common pitfalls and exploits. Always remember to test your assumptions and ensure you don't make costly mistakes.\n",
          "updates": []
        },
        {
          "lessonId": "2f8971e7-ff01-4196-b83f-a56ba0eb81fc",
          "number": 34,
          "title": "Mishandling of ETH: Minimized",
          "slug": "mishandling-of-eth-minimized",
          "folderName": "34-mishandling-of-eth-minimized",
          "description": "",
          "duration": 6,
          "videoUrl": "bjJIiGCwKg0",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/34-mishandling-of-eth-minimized/+page.md",
          "markdownContent": "---\ntitle: Mishandling of Eth - Minimized\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Exposing the Mishandling of Ethereum: A Deeper Dive into Smart Contract Exploits\n\nHello Ethereum enthusiasts, today's post is a deep dive into understanding risk and vulnerabilities associated with Ethereum, specifically the mishandling of Ethereum or ETH.\n\nWe'll walk through the exploration of a particular codebase we've frequently returned to - our sc-exploits-repository. Follow along as we explore and expose exploits related to the mishandling of ETH.\n\n> Be sure to have this repository on your bookmarks to facilitate easy navigation.\n\n## The Importance of Understanding ETH Breaches\n\nThe constant evolution and expansion of blockchain technology mean the occurrence of exploitations. In our sc-exploits-repository, notable examples of ETH mishandling have been categorized. Today we will look at a particular exploit - 'Vulnerable to Self Destruct'.\n\n![](https://cdn.videotap.com/9K1a9GtnKi7ohaku3tCP-47.6.png)\n\n[Mishandling of Eth Repo](https://github.com/Cyfrin/sc-exploits-minimized/tree/main/src/mishandling-of-eth)\n\nFor those who have difficulty in retrieving the codebase in remix, the code can be found right at the repository. Head to the top source and copy-paste the code into remix.\n\n## Analysing the Contract\n\nThe contract's primary function is to allow users to deposit their money and withdraw it later. There are several key factors to note:\n\n1. The variable **total deposits**\n2. A **mapping for deposits**\n3. A **deposit** function\n4. A **withdrawal function**\n\nTotal deposits variable and deposit function add and keep track of the value sent (in ETH) into the contract by the sender. The withdrawal function then allows for the removal of an amount set by the user from the account.\n\n```js\nfunction withdraw() public payable {\n    require(msg.value >= 1 ether);\n    totalDeposits = totalDeposits - msg.value;\n    }\n```\n\nTo ensure proper functioning, we have implemented an _assertion_ that checks that the address's balance is equivalent to the total deposits. This way, we know that accounting is done correctly inside the contract.\n\nHowever, we soon bump into a significant issue.\n\n## The Self-destruct Dichotomy\n\nThis issue arises on a relatively innocuous line - the self-destruct command. You may think that this function's straightforward task could not possibly harm the contract. However, in practice, this command can introduce a considerable vulnerability.\n\n```js\nfunction selfdestruct() public onlyOwner {\n    selfdestruct(owner);\n    }\n```\n\nFor your information, sending ETH directly to the contract will typically fail. This failure occurs because smart contracts must have a designated `receive` or `payable` function to accept ETH, providing an essential security mechanism.\n\nYet, this is where self-destruct proves to be a sword that cuts both ways. On the surface, self-destruct comes across as a necessary destruct function to delete contracts. Yet, it also transforms the contract into a potential target to force money (ETH) into, even bypassing regular checks and balances.\n\n## Misusing the Self Destruct Function\n\nTo demonstrate this, let's visualize a scenario:\n\n1. We deploy `SelfDestructMe` with one ETH.\n2. We then copy the target contract as the target and deploy `AttackSelfDestructMe`.\n3. We initiate the attack by sending one more ETH.\n\n![](https://cdn.videotap.com/gFO4YKELZcnyna0BEy0X-273.7.png)\n\nIn this scenario, the balance of ETH in the contract doubles, thereby defying the assertion that checks for equivalent balance with total deposits. As a direct consequence, this acts as a bug that blocks further withdrawals, resulting in a dysfunctional state.\n\nJeopardizing the withdrawal ability is significantly perilous as a contract's naturality lies in the inflow and outflow of money. The bug forces money into the contract, leading to the demise of the contract.\n\n## Recap and Additional Resources\n\nTo recap, the equation of the address balance equates to total fees, an internal audit, and ETH mishandling can result in a mishap on smart contracts. Such mishandling could be disastrous on withdrawal functionality, hindering users from recovering their investments.\n\nIn the sc-exploits-repository, a test case has been provided to examine and understand it further. Moreover, there is another example of ETH mishandling that you can explore. We recommend using the code examples in the [repository](https://github.com/Cyfrin/sc-exploits-minimized/tree/main/src/mishandling-of-eth) to learn more about this subject.\n\nJust as any coin has two sides, Ethereum too has pros and cons. Hence it's recommended to exercise caution when deploying contracts involving significant amounts of ETH. Happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "dd969938-351d-4952-af95-7ad356d5daaa",
          "number": 35,
          "title": "Case Study: Mishandling of ETH",
          "slug": "mishandling-of-eth-case-study",
          "folderName": "35-mishandling-of-eth-case-study",
          "description": "",
          "duration": 3,
          "videoUrl": "BXLAOreh0gM",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/35-mishandling-of-eth-case-study/+page.md",
          "markdownContent": "---\ntitle: Mishandling of Eth - Case Study\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Unraveling the SushiSwap Attack: A Case Study on ETH Handling\n\nIn this post, we will delve deep into an intriguing historical incident in the cryptosphere ‚Äì the infamous attack on the SushiSwap protocol due to poor handling of Ethereum (ETH). By understanding these real-world instances and the factors that facilitated these attacks, we can significantly upgrade our knowledge base and sharpen our defenses against potential intrusions.\n\nSo, let's get started on this intriguing journey!\n\n![](https://cdn.videotap.com/u8WMx76vvOAsmbCZXNQq-11.91.png)\n\n## Unveiling the Core Problem\n\nAt the heart of this notorious attack was [SushiSwap‚Äôs protocol flaw](https://samczsun.com/two-rights-might-make-a-wrong/) in managing ETH, the cryptocurrency powering the Ethereum network. This led to a situation where users' ETH got stuck, with no viable means of withdrawal.\n\nNotably, this exploit is a stark example of a broad category of bugs related to rudimentary ETH handling.\n\nIn question was a batch function embedded within this protocol. As a helpful tool, this function enabled users to initiate multiple calls within a single transaction. While this might sound beneficial, the problems arose when this feature was misused through the `delegateCall` command.\n\n## Understanding the DelegateCall Anomaly\n\nThis seemingly handy feature was precisely where the exploiter sneaked in.\n\n```javascript\n    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory successes, bytes[] memory results) {\n        successes = new bool[](calls.length);\n        results = new bytes[](calls.length);\n        for (uint256 i = 0; i < calls.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(calls[i]);\n            require(success || !revertOnFail, _getRevertMsg(result));\n            successes[i] = success;\n            results[i] = result;\n        }\n    }\n```\n\nWhat made this issue particularly intriguing and equally challenging to identify was its subtle occurrence. It involved a certain mishandling of message sender (`msg.sender`) and message value (`msg.value`).\n\nTo understand this better, let's plunge into the mechanics of the `delegateCall` command.\n\n> \"Inside a delegate call, message sender and message value are preserved across every iteration in the batch. This allows a user to batch multiple calls, committing ETH across each while reusing the message value - leading to free bids in the auction.\"\n\n## Recognizing the Exploit\n\nNow, let's look at how this vulnerability paved the way for an exploit.\n\nDuring the batch process, if any of the calls influenced the message value, that persistence would be retained for all subsequent events. This exploit meant that someone could potentially make multiple calls leveraging the same message value but only needed to send one ETH unit.\n\nTo illustrate, imagine wanting to send 100 transactions, naturally needing 100 ETH units. With this flaw, anyone could send these 100 batch transactions using just a single ETH unit. That's right. 100 potential transactions, but only at the cost of a single one. An alarming oversight indeed, with catastrophic implications for the protocol.\n\n![](https://cdn.videotap.com/FuftKRwJQsWu0I0yDN0Y-119.14.png)\n\n## Case Study: An Exceptional Learning Opportunity\n\nI earnestly urge you to take some time to review this [expansive case study](https://samczsun.com/two-rights-might-make-a-wrong/) associated with our course repository. This comprehensive assessment offers a fantastic insight into the peculiarities and oddities linked with ETH handling, and how it functions 'under the hood.'\n\nThese case studies provide us with an unmatched opportunity to acquire a deep understanding of the Ethereum blockchain's native token balance system. Although more often than not a robust system, it occasionally hosts bugs that are as interesting as they are complex.\n\nIn conclusion, as we traverse the cryptosphere, navigate intricate protocols, and deal with diverse cryptocurrencies like ETH, it‚Äôs essential to understand the possible vulnerability. Knowing past pitfalls and learning from them is our best defense against future threats.\n",
          "updates": []
        },
        {
          "lessonId": "85c941ab-17a5-4fb7-855f-ffcad2e2099d",
          "number": 36,
          "title": "Recon III",
          "slug": "recon-continued-3",
          "folderName": "36-recon-continued-3",
          "description": "",
          "duration": 7,
          "videoUrl": "J-y62QDKEAA",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/36-recon-continued-3/+page.md",
          "markdownContent": "---\ntitle: Recon Continued 3\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Manual Code Review: The Puppy Raffle Codebase\n\nHello folks, in our continuous journey to explore the world of code, let's dive into a manual code review of the Puppy Raffle codebase. We're going to sift through the codebase together and try to understand how it works, pointing out areas of concern.\n\n## Change Fee Address Function\n\nTo begin with, let's look into the `changeFeeAddress` function. This function ensures that only the contract owner can make changes to the contract's fee address. The modifier `onlyOwner` that is used in this function is sourced from the OpenZeppelin library. By inspecting these functions, it becomes apparent that they do perform the required tasks.\n\n```javascript\nrequire(owner == msg.sender);\n```\n\nSet the new fee address and check whether the fee address is used where it is supposed to. An event is then emitted.\n\nIt's worth noting that there may be some events missing from other functions, such as 'Withdraw Fees' and 'Select Winner'. This sparks a query for our manual audit of whether there are events missing elsewhere in the code that need to be added.\n\n## Active Player Function\n\n```javascript\n    function isActivePlayer() public view returns (bool) {\n        return activePlayers[msg.sender];\n    }\n```\n\nThe function above is supposed to return true if the message sender is an active player. On attempting to identify its use within the protocol, we realize it isn't utilized anywhere. In the face of this finding, we add it to our audit report emphasizing the unused function may not contribute much impact or likelihood but is a wastage of gas and redundant clutter in our codebase.\n\n## Base URI and NFT Stuff\n\n![](https://cdn.videotap.com/x2QzHSr5HPaTEkOKw0xW-194.4.png)\n\nNext up is our base URI function that's tied to the creation of SVG-based NFTs. This function is critical for anyone wanting to comprehend NFTs and their role within the Defi and Web3 ecosystems. Understanding how NFTs operate under the hood is crucial for any security researcher.\n\nThe function as we see it here is essentially a classic SVG. It has an override for OpenZeppelin's method, checks if a token exists and then event tickets are mapped to rarity levels.\n\n```javascript\nfunction tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n    require(_exists(tokenId), \"PuppyRaffle: URI query for nonexistent token\");\n    uint256 rarity = tokenIdToRarity[tokenId];\n    string memory imageUri = rarityToUri[rarity];\n    string memory rareName = rarityToName[rarity];\n    ...\n    }\n```\n\nThis function deserves a more in-depth exploration along with cross-checking and verifying aspects like Rarity levels, URI mapping, token Id's, among other things.\n\n## In Retrospect\n\nHaving swept over the codebase once, we notice several areas deserving of keen attention, for instance, the sparing use of state variables and event emitters. Despite the detailed walkthrough, the first pass through the Puppy Raffle codebase has thrown up a host of questions to be answered as part of our codebase review. As we explore these points, we might end up with even more questions or uncover potential vulnerabilities.\n\nTake the challenge and dive deeper into the codebase, explore it thoroughly until you get a complete understanding. You can start trying to answer the questions we've stirred up, or even better, stir up a few of your own. It's a fantastic opportunity to practise your debugging skills and understand the codebase better.\n\nAnd if you choose not to, that's okay too! There's always more to learn and more adventures to embark on, in the vast world of coding. Keep exploring!\n",
          "updates": []
        },
        {
          "lessonId": "7dddf0d6-a1fb-437a-89f6-fee77fd3a680",
          "number": 37,
          "title": "Answering our questions",
          "slug": "answering-our-questions",
          "folderName": "37-answering-our-questions",
          "description": "",
          "duration": 4,
          "videoUrl": "3MSO9NJ2j_0",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/37-answering-our-questions/+page.md",
          "markdownContent": "---\ntitle: Answering Our Questions\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Detailed Debugging Discussion: Answering Key Questions\n\nDuring my recent dive into a codebase, I was asked several key questions. In this blog post, I'm going to break down each question and provide my solutions. Let's begin our discussion.\n\n## The Players Array Dilemma\n\nFirst, the intriguing question of the players' array arose. It was essential to check if we ever reset the array. Our audit eventually led us to the bottom of the code where we found that indeed, the players' array was reset.\n\n![](https://cdn.videotap.com/kmOkBiTr178jCe2yOCNa-22.9.png)\n\n### Empty Array Scenario\n\nThe next question posed was, what happens when we have an empty array? Does this trigger an event? After thorough checks, I decided to include this scenario in my report for further audit.\n\n## When Player Is at Index Zero\n\nA scenario raised was anticipating the condition when the player is at index zero. Previous results indicated that if the player is at index zero, the function returns zero. This might confuse a player into thinking they're not active.\n\n![](https://cdn.videotap.com/HSNYhGEIwD2ytQEi2CeQ-49.61.png)\n\n### CEI Compliance in Audit Recommendations\n\nAll of this leads us to the question of whether the code adheres to Checks-Effects-Interactions (CEI) pattern. It turned out that it did not, consequently, suggesting a recommendation in the audit to adhere to CEI.\n\n> \"The CEI pattern is an important best practice in Solidity programming to avoid reentrancy attacks.\"\n\n## Duration and Start Time\n\nContinuing our examination, we explored if the duration and start time parameters are being set correctly. The code appeared to handle this correctly, effectively eliminating this query from our list of concerns.\n\n## Question of Balances and Fees\n\nAnother query was to contemplate why we don't just use `address(this).balance` for some of the fees. Why not, indeed? This interesting inquiry was marked down for further exploration in the audit.\n\n## Is the 80% Calculation Correct?\n\nMoving on, we examined a key calculation in the code that deals with 80% of a certain value. Our audit confirmed that this calculation was implemented correctly.\n\n> Always refer back to the documentation to validate the implementation.\n\nLooking deeper into this calculation, we discovered a possible arithmetic error which might cause some precision loss. A note was made to address this issue in the final report.\n\n## Keeping Track of Token Supply\n\nTo find out where the token supply total was incremented, we referred to the Open Zeppelin repositories', `SafeMint` function. If you're not familiar with this, I highly recommend checking out the OpenZeppelin documentation.\n\n![](https://cdn.videotap.com/6icrcHwg1yWjBbqusn4h-133.57.png)\n\n### Unfair Advantage with Transaction Reverts\n\nA worrying scenario might occur if a transaction picks a winner that we don't like, causing a gas war. This could create an unfair advantage in the system, making it a key point in the report follow-up.\n\n## Is Reentry Possible?\n\nOur debugging expedition dove deeper as we tried to verify if reentry was possible. The results indicated that it wasn't, but the advice was given to follow CEI nonetheless.\n\n## Issues with Smart Contracts as Winners\n\nThe potential of a smart contract with a failing fallback function winning was observed as an issue. This situation could result in the winner not receiving any money.\n\n### Withdrawal Difficulties\n\nThe inability to withdraw fees if there were players in the protocol was viewed as a significant problem. This hindrance could develop into an \"Miners Extractable Value (Mev)\" attack as well.\n\n## Mishandling of ETH\n\nWe then deduced that the code mishandled ETH. This bug resulted in losing accumulated ETH, making it a matter for our consideration.\n\n## Addressing Fee Addresses\n\nThe final question assessed the scenario of a fee address being a smart contract with a non-functioning fallback. We concluded that it's not a big issue since the owner can change the holder.\n\nAnd with that, all of our pressing questions were successfully answered! But remember, coding is an evolving process. Always revise, recheck and keep improving. Until our next debugging session, happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "5953da27-94eb-44a6-a7ec-250b4637ea5f",
          "number": 38,
          "title": "Info and gas findings",
          "slug": "info-and-gas-findings",
          "folderName": "38-info-and-gas-findings",
          "description": "",
          "duration": 5,
          "videoUrl": "WycVutSWjlM",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/38-info-and-gas-findings/+page.md",
          "markdownContent": "---\ntitle: Info and Gas Findings\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Boosting Code Quality with Solidity: An Audit Analysis\n\nIn our journey to mastering Solidity, we have encountered a few gaps and opportunities for improvement in our code quality, especially during private audits. This blog post will guide you through some key areas to call out in code during an audit: naming conventions, versioning, the risk of magic numbers, addressing supply chain attacks, and opportunities for gas optimization.\n\n## Naming Conventions: Clarifying Storage Variables\n\nOne of the easiest ways to improve code readability is to use clear naming conventions. In the codebase for our audit, the names of the storage variables were found lacking. A beneficial standard to maintain is adding a `\"s_\"` prefix to every storage variable name.\n\n```js\nuint256 public s_variableName;\n```\n\n![](https://cdn.videotap.com/HUA3lLveQmbRWkwQgBnq-36.53.png)\n\nEven though modifying the names of the storage variables wouldn't immediately cause a drastic change, it's one of our key recommendations for better readability and organization of the code.\n\n## The Risk of Different Solidity Versions\n\nContinuing with the code analysis, we found the use of different Solidity versions thanks to an indicator‚Äîthe caret (`^`)‚Äîplaced at the top of the code.\n\n```js\npragma solidity ^0.5.0;\n```\n\nWhile the caret signifies that any version compatible with `0.5.0` could be used, it's not a best practice. The ideal way is to stick with a single version of Solidity.\n\n```js\npragma solidity 0.5.0;\n```\n\nBy nailing down the exact version of Solidity, it guarantees compatibility and stability when running tests.\n\n![](https://cdn.videotap.com/q76csvaY6UkAse0ikj5X-97.42.png)\n\n## Ditch Those Magic Numbers:\n\nOur audit found hardcoded numbers (`80` and `20`) in the middle of the codebase. It's not desirable; these ‚Äúmagic numbers‚Äù create confusion as other developers would not understand why these numbers are there. We propose adding a descriptor that provides context.\n\n```js\nuint256 public constant prizePoolPercentage = 80;\nuint256 public constant feePercentage = 20;\nuint256 public constant poolPrecision = 100;\n```\n\nNow, rather than ambiguous magic numbers, we have self-explanatory constants which add meaning and readability to our code.\n_Note: 0 and 1 are often exceptions to this rule because of their ubiquitous use. However, you could still create constants for these as well._\n\n![](https://cdn.videotap.com/wIpzaZwE6d1VfGkBsRLt-146.13.png)\n\n## Defense against Supply Chain Attacks\n\nWhen using external libraries or contracts, it's crucial to know their security status and ensure they're free from vulnerabilities. In our code audit, we used the OpenZeppelin library; however, it's crucial to check disclosures for **each specific version** used.\n\n> You can refer to [OpenZeppelin‚Äôs security tab](https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories) to get bug bounty info and security disclosures.\n\nHere's an example of a security disclosure:\n\n_‚ÄúGovernor Votes Quorum Fraction: Updates to Quorum may affect past defeated proposals.‚Äù_\n\nIt's crucial to verify that none of the contracts used in your project, like Ownable or Address, are affected by the issues present in the specific version of OpenZeppelin used.\n\n![](https://cdn.videotap.com/YktdcyF0s9wvili0y7mu-207.02.png)\n\n## Gas Optimization Opportunities\n\nGas optimization is often reported as part of informational findings in an audit. For example, in our audit, we found that the `raffleDuration` variable is declared as a storage variable, even though it never changes.\n\n```js\nuint public raffleDuration = 100;\n```\n\nInstead, declaring it as an immutable variable would be more gas-efficient and a better practice.\n\n```js\nuint public immutable raffleDuration = 100;\n```\n\n![](https://cdn.videotap.com/CAyDqXFyoDcDU80R3SyW-255.73.png)\n\nRemember, compared to storage variables, mutable variables are cheaper to use and crucial for gas-efficiency in your smart-contracts. Would you like to deepen your understanding of Immutable vs. Storage variables? We recommend our [Foundry Course](https://github.com/Cyfrin/foundry-full-course-f23).\n\nAs a summary, enhancing code quality is not always about finding impactful bugs. It's also about refining your codebase to improve readability, maintainability, performance, and security‚Äîeven if the effects aren't immediately observable. In the long run, it makes your codebase robust, efficient and less prone to errors.\n",
          "updates": []
        },
        {
          "lessonId": "81cfb5f7-8d5b-44d1-abc6-860e8e2921c5",
          "number": 39,
          "title": "Pit stop",
          "slug": "pit-stop",
          "folderName": "39-pit-stop",
          "description": "",
          "duration": 2,
          "videoUrl": "miGzIKhbbAs",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/39-pit-stop/+page.md",
          "markdownContent": "---\ntitle: Pit Stop\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Wrapping Up Code Audits and Crafting Stellar Reports\n\nHaving navigated the vast sea of codebase, it's time to wrap it all up. We have two important tasks left on our plate ‚Äì exploring the Slither/Aderyn report and conducting some quality tests on the code. So let's dive right in, tie up these loose ends, and prepare a comprehensive report of our journey. Along the way, we'll demystify competitive audits, discuss their functioning, and learn how you can effectively participate in one.\n\n![](https://cdn.videotap.com/3YUaA6yxV7kah1I7OKcF-11.16.png)\n\n## Understanding Competitive Audits\n\nParticipating in a competitive audit requires the ability to comprehensively scrutinize code and identify loopholes. As we delve into this process, you'll get to grasp how you can submit a finding to a competitive audit platform. The real litmus test would be writing an audit report - and what better one to practice on than the Puppy Raffle?\n\n![](https://cdn.videotap.com/3301ntoHswP3rTI5NMHr-27.89.png)\n\n## Writing the Puppy Raffle Audit Report\n\nIn practice, writing a full report together may turn out to be a time-intensive endeavor. Hence, we won't always do this together. But fret not, it's an excellent practice to test your understanding of the audit process. And who better to guide you than me, Patrick?\n\nIf you'd prefer to write the report yourself and then compare it to mine, there's nothing stopping you. Remember, this is your opportunity to test yourself, gain insights, and hence prepare yourself for future competitive audits.\n\nYou can find our full report in Markdown within the 'audit data branch' of the repo, along with a PDF version. You will also find the output of our Aderyn and Slither reports there, in case you want to compare yours and ensure its correctness.\n\n> As a coder, if you aspire to delve into the nitty-gritty of competitive audits or just want to enhance your expertise on smart contract reviews, this is the place to be!\n\n## Crafting Your CodeHawks Security Portfolio\n\nWith the completion of these tasks and the report, you'll have another smart contract security review or audit under your belt. Add it to your GitHub repo, and boom - you've taken one solid step in building your CodeHawks Security Portfolio.\n\n![](https://cdn.videotap.com/pubzcvfWTx4aBwYlcul8-83.68.png)\n\n## Finishing Off with Slither and Aderyn\n\nThat said, we're not quite done yet. Let's finish running Slither and Aderyn, the two essential parts of our journey so far. Once we are done with these, we can then finally step into the realm of reporting, the summation of everything we've learned through this process.\n\nGet ready for the exciting final step - drafting an insightful report that reflects all the hard work we put in during the learning process. Let's do this together! Happy Coding!\n",
          "updates": []
        },
        {
          "lessonId": "7193c982-2dae-435b-bf60-f6848ca9b475",
          "number": 40,
          "title": "Slither walkthrough",
          "slug": "slither-walkthrough",
          "folderName": "40-slither-walkthrough",
          "description": "",
          "duration": 13,
          "videoUrl": "WOU8yw0ATBA",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/40-slither-walkthrough/+page.md",
          "markdownContent": "---\ntitle: Slither Walkthrough\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Slithering Through Code: The Power of Slither for Solidity Auditing\n\nWhenever you're developing a contract using the Solidity programming language (or indeed, any contract), thorough auditing is critical. One of the handiest tools for completing this process is **Slither**.\n\nLet's deep dive into the code and uncover the treasures this utility can offer us.\n\n## Starting From The Extremes\n\n![](https://cdn.videotap.com/NQHSIHFaGFwd07Cdj3aB-77.3.png)\n\nTo effectively dissect your code, it's beneficial to begin with the most extreme areas and then continue downwards. Going through an example, I started my process with a function named `withdrawFees` and investigated its command for sending ETH (Ethereum's primary cryptocurrency) to an arbitrary user.\n\n```js\nfunction withdrawFees...\n```\n\nThis line has been isolated by Slither as a potential problem. Here, Slither highlights that the `feeAddress` is an arbitrary user and there's a risk of malicious behavior. In other circumstances, this might be a significant issue, but I know that in this context, it's an intentional element. The developer designed this function so that the `feeAddress` can be manually reset if required.\n\n## Getting Up Close And Personal With The Documentation\n\nWhile the above example illustrates one instance where Slither can help, to truly benefit from this tool, it's crucial to dive into the [documentation](https://github.com/crytic/slither/wiki) and deepen your understanding.\n\nHere, you'll find extensive information about the severity ratings, confidence levels, and possible attack vectors associated with different vulnerabilities.\n\nRemember, while the high confidence level indicates a bug has likely been detected, a medium confidence level means it could be a false positive. Always cross-check your findings to insist on precision.\n\n> \"The severity is high, the confidence is medium here. Confidence being medium means that the tool is medium sure.\"\n\n## Slithering Around False Positives\n\nOne exciting feature of Slither is how you can customize its priorities. Specifically, if your audit reveals a facet of your code that Slither identifies as a potential issue, and you want to retain the feature, you can set Slither to ignore this issue during future audits.\n\nTo do this, simply follow the formatting in the Slither documentation.\n\n```js\n/* slither-disable-next-line arbitrary-send-eth */\n```\n\nBy incorporating this command directly into your code, you can ensure that Slither glosses over this line in further audits. This is a handy way of preventing critical function lines from repeatedly making noise in the audit reports.\n\n## And The Winner Is...\n\n![](https://cdn.videotap.com/9tgDlvKbmj5arMTdT1ql-425.15.png)\n\nMoving on to another common piece of Solidity code‚Äîthe `selectWinner` function. In this scenario, Slither identified a weakness in the PRNG (Pseudorandom Number Generator) being used. This tool is regularly used in Solidity contracts to simulate a fair lottery, but it's critical you use a robust PRNG to avoid potential exploitation. If a developer can predict the randomly selected winner, they can manipulate the result, which relegates the fairness of the lottery to a mere illusion.\n\n> \"Slither picked out the weak randomness as well. \"\n\nSlither can detect this particular issue automatically, allowing your team to correct the PRNG weakness straightforwardly, saving valuable time that manual review processes would soak up.\n\n## Praying On Libraries\n\nLibraries in Solidity are double-edged swords. They offer a wealth of functions and features, but they can be riddled with vulnerabilities that can exponentially increase your attack surface. Slither spares your security team the headache by scanning these areas of your contract and flagging any potential flaws.\n\nHowever, it's always prudent to verify that these libraries are doing exactly what they're supposed to and aren't presenting unnecessary risks.\n\n## Unchecked Events: A Low-Flying Concern\n\nOne advantage of auditing with Slither is its penchant for identifying unchecked events within your code. This issue usually flies under the radar in manual reviews, but unchecked events can lead to manipulation in the emitted information. While some might classify these as minor vulnerabilities, unchecked events can actually be exploited in multiple ways and interfere with important Ethereum ecosystem elements.\n\nFor this reason, I've developed a rule of thumb whereby if an event can be manipulated, omitted, or is incorrect, I usually categorize them as low-level issues. This rating is subjective, of course, but I believe that bringing them to the view helps in correcting them early.\n\n## Unearth Old Versions and Low-Level Calls\n\n![](https://cdn.videotap.com/jqNTpIqXL1SPGiYnAfl6-657.05.png)\n\nSlither isn't just a guardian against dangerous codes; it's also an adviser for better coding practices. The tool diligently points out outdated Solidity version usage, encouraging the adoption of up-to-date versions. Moreover, it raises an alarm on the usage of low-level calls, guiding the programmer towards safer coding habits.\n\nThis particularly aids in learning best practices from the community and serves as a yardstick measuring the overall code quality. Following such leads can be beneficial in the long run, not only for overall security but also for smoother audits.\n\n## Final Wrap\n\nThe somewhat tedious task of parsing through the entire slither output just goes to further underscore its utility. The resources saved in manual reviews can be better directed towards more sophisticated issues that require deeper investigation. This course is a boon not only for developers looking to hone their skills but also for audits aiming for a thorough review, thereby creating a more secure and reliable smart contract ecosystem.\n\nSlither is an auditor's companion, discovering vulnerabilities, suggesting fixes, and promptly sniffing out potential threats waiting to rear their heads in your codes. Are you ready to let the Slither work its magic on your codes?\n",
          "updates": []
        },
        {
          "lessonId": "3968e2b8-4bc5-445c-83f8-2841f2eb3ae3",
          "number": 41,
          "title": "Aderyn walkthrough",
          "slug": "aderyn-walkthrough",
          "folderName": "41-aderyn-walkthrough",
          "description": "",
          "duration": 3,
          "videoUrl": "CtUYMz09jjs",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/41-aderyn-walkthrough/+page.md",
          "markdownContent": "---\ntitle: Aderyn Walkthrough\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Enhancing Your Smart Contract Security with Aderyn\n\nLet's look at another powerful tool that makes auditing your smart contracts easier - Aderyn. This article sets out to show how this tool helps users identify specific issues in your contract, and the best part is that it generates a markdown report which you can quickly integrate into your final report.\n\nLet's delve in!\n\n## Benefits of Aderyn\n\nOne of the amazing features of Aderyn is that it creates a markdown report which you can easily copy and paste into your final report. After running Aderyn on your smart contract, you'll find an `report.md` file - a result of Aderyn's quick and thorough analysis.\n\n![](https://cdn.videotap.com/uMvxzTVuSfeiTlRIxGAA-27.68.png)\n\n## Key Findings Using Aderyn\n\nUpon previewing the report generated by Aderyn, you'll discover some really interesting insights about your smart contract. Here, I will discuss a few crucial issues highlighted by this tool.\n\n### Potential Centralization Risk for Trusted Owners\n\nOne of the most crucial issues brought to the forefront is the centralization risk. Any contract offering owner permission to make changes may present a potential threat. Owners could potentially leverage their power to manipulate the contract. However, in most cases, we may disregard this risk given the limited powers entrusted to the owner, involving just the alteration of the fee address.\n\n> \"Smart contracts are supposed to be these immutable, decentralized contracts. However, any time there is an ownership property, the owner could potentially do something malicious.\"\n\n### abi.encodePacked\n\nIn some situations, using `abi.encodePacked` with dynamic types when passing the result to a hash function like keccak256 could lead to low-level issues. Fortunately, this isn't as severe as it might sound, and can often be resolved by removing the contentious line altogether.\n\n### Missing Address Zero Checks and Undefined Functions\n\nAderyn is good at picking up simple programming slip-ups. For instance, it will flag when address zero checks are missing, which can occur when values are being assigned to address and state variables.\n\nAderyn also points out if there are any internal functions that aren't being utilised. A nifty solution to this is either marking these unused functions as external or removing them completely.\n\n### Use of Magic Numbers\n\nAderyn can detect the usage of magic numbers in your contract - a common poor programming practice. As seen below, \"80\" being used as a magic number was caught by the tool. It recommends using constant variables instead of literals, which aligns with good programming practices.\n\n![](https://cdn.videotap.com/2bVrCC34nMU5Ved8C7bz-110.71.png)\n\n### Events Missing Indexed Fields\n\nThe final point brought to attention by Aderyn was the lack of indexed fields in events. This can be easily resolved by adding an index field to your events, which can improve the search efficiency.\n\nThe comprehensive markdown report generated by Aderyn also provides a detailed breakdown on each of the identified issues, as well as additional information relating to possible attack vectors.\n\n### Leverage Aderyn for Simplified Reporting\n\nIn essence, Aderyn is an effective tool for auditing smart contracts and makes reporting straightforward. You can simply copy-paste its analysis into your report, making it a compelling part of your smart contract auditing toolkit.\n",
          "updates": []
        },
        {
          "lessonId": "f012efb6-1547-4ce9-add5-cfcf024f0730",
          "number": 42,
          "title": "Test coverage",
          "slug": "test-coverage",
          "folderName": "42-test-coverage",
          "description": "",
          "duration": 1,
          "videoUrl": "wdtO4YOCTFs",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/42-test-coverage/+page.md",
          "markdownContent": "---\ntitle: Test Coverage\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Enhancing Code Coverage For Better Audit Results\n\nAre you looking to pass an audit with your code? If so, code coverage is an essential metric you need to pay attention to. Code coverage, as the term suggests, indicates how much of your code is being tested through your test cases. Getting the right code coverage can be the difference between code that's reliable and durable and code that's prone to bugs and eventual system breakdowns.\n\nLet's walk through my most recent analysis.\n\n## Code Review: Aderyn and Slither\n\nI recently reviewed two applications: Aderyn and Slither. After completing the review, it was time to study their code coverage.\nLet's delve deeper into the specifics and dissect how much of the code was actually \"covered\" under the tests.\n\n## Forge Tool for Calculating Code Coverage\n\nTo measure the code coverage, I used Forge, a widely recognized tool for just this purpose. The result was not as expected.\n\n```bash\nforge coverage\n```\n\n![](https://cdn.videotap.com/H1yW7XuzYltnhAiHdcLP-13.37.png)\n\nThe outcome was somewhat disheartening.\n\nWhat did the above result imply? It screamed out loud, \"Ta DA, it's pretty bad\". In simpler words, the code coverage was in a pitiful state.\n\n> **NOTE:** In an ideal world, code coverage should ideally be near or at 100%. No stone should go unturned!\n\n## Audit types: Private Audit vs Competitive Audit\n\nHere comes the tricky part - audits. Depending on the type of audit, the levels of code coverage required can change.\n\nFor a **private audit**, the level of code coverage obtained would necessitate classifying it as purely informational. It directly translates to \"Hey! You need better test coverage.\" In simple words, it highlights the area of improvement for the developers to get a higher success rate during audit approval.\n\nFor competitive audits, code coverage doesn't usually play as significant a role. However, that doesn't mean it‚Äôs entirely negligible.\n\n![](https://cdn.videotap.com/9BEXZYZjamdFNyvfe0tl-28.8.png)\n\n## The Need for Higher Code Coverage\n\nDiscussing this further, with the code base's simplicity, particularly for apps like Aderyn and Slither, maximum code coverage should be relatively easier to achieve. But the reality depicted a gloomy picture.\n\nThis code coverage was somewhat \"abysmal\", as I put it mildly.\n\nAny code coverage below the acceptable limit indicates that sections of the code are not covered in the tests. This means that there is code which, when executed, does not have any tests that can confirm its correctness.\n\nConsidering the existing code base's simplicity, providing a comprehensive test coverage should not be a daunting task. With some additional effort, this can easily be improved, thereby making your applications more resilient and robust.\n\nIn conclusion, if your code coverage is lacking, it's time to dive back into your tests and ensure they're comprehensive. Remember, code coverage is not only a noteworthy aspect during audits but also plays a crucial role in the overall performance and uninterrupted functioning of your application. So, get back to testing, and happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "605f8320-1990-46eb-9a42-8ec0f0b978a5",
          "number": 43,
          "title": "Phase 4: Reporting primer",
          "slug": "phase-4-reporting-primer",
          "folderName": "43-phase-4-reporting-primer",
          "description": "",
          "duration": 3,
          "videoUrl": "4cDUHJ2srSM",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/43-phase-4-reporting-primer/+page.md",
          "markdownContent": "---\ntitle: Phase 4 Reporting - Primer\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# How to Execute a Time Bound Security Review and Write an Effective Report\n\nIn security research, we know that the nitty gritty of reading and tinkering with code is just part of the big picture. At some point, you have to compile your findings and deliver a report that fully explains your work and its implications. To paraphrase a well-known off-color joke about necessary functions, everybody's got to do it, like it or not! So let's talk about how to do it well, and yes, even relish the process.\n\n## Achieving Closure\n\nOnce you are reasonably satisfied with the code inspection phase, it's time to evaluate the data and summarize your findings into a clear, concise, and convincing report.\n\n> It's the end of our code review and our job now, is to report our findings effectively. This is pivotal to our work as a security researcher and we should strive to do it right.\n\n![](https://cdn.videotap.com/rURmYlf7Mj8v8mjNSpls-34.png)\n\n## Venturing into Competitive Audits\n\nOne of the first steps post-review would be to perform a competitive audit. Here, we will compare our findings to those of other security researchers, providing us perspective and reassurance about our work.\n\n> Doing a competitive audit can supercharge our careers. It reinforces our learning and encourages us to be better. We will prepare a submission detailing our findings.\n\n## Writing a Comprehensive Report\n\nWe will then delve into the crux of our task - the full report for the Puppy Raffle code we've been working on.\n\n> It's not enough merely to discover bugs‚Äîsuccessful discovery and exploitation often depend on being able to write a convincing report that shows why a bug must be fixed. Failure to do so could cost you a potential bounties or even your standing in the industry.\n\n## The Art of Writing a Proof of Concept\n\nIn this journey, we will also be writing a lot of Proof of Concepts (PoCs). This is vital to your ongoing development as a security researcher, so practicing along is highly recommended.\n\n![](https://cdn.videotap.com/7JHE8CMtsqxXQyAAdWxB-97.14.png)\n\n## Pause to Reflect and Recover\n\nIf this has been a whirlwind so far, don't worry‚Äîyou're not alone. I've packed your brain with loads of information, and it's now time to take it slow. As a thumb rule, it's best not to over-exert yourself. Doing so might lead to cognitive overloads and information fatigue.\n\n> Take a pause; let the information sink in by giving your brain a well-deserved break. Go for a walk, do some push-ups, call a loved one, or perhaps pick up a book. Keep things varied to optimize your learning process.\n\nTake at least a 20-minute break before returning to your task. You're doing a brilliant job and you're almost at the finish line ‚Äì a comprehensive report of your security review.\n\n## Girding up for Section Five\n\nRemember, this is not the end of the road. Following the report compilation and submission, you're slated to dive into DeFi. This next section is what promises to boost your audit portfolio and take your skills to the next level.\n\nIn a nutshell, navigate this process at your own pace. The goal is to ensure an effective, in-depth review, and create a report worth its weight in gold. Absorb the learning, take timely breaks, and come back rejuvenated to deliver a stellar report.\n\n> And always keep in mind: you're not just bug hunters, you're also bug salesmen. Being able to sell why a bug is important to fix is a crucial skill for success in this field.\n\nSee you on the flip side!\n\n-Cheers!\n",
          "updates": []
        },
        {
          "lessonId": "ecc11bfc-759f-4cd7-9056-9de865bdbb07",
          "number": 44,
          "title": "What is a competitive audit?",
          "slug": "what-is-a-competitive-audit",
          "folderName": "44-what-is-a-competitive-audit",
          "description": "",
          "duration": 5,
          "videoUrl": "GzxUGMlw340",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/44-what-is-a-competitive-audit/+page.md",
          "markdownContent": "---\ntitle: What is a Competitive Audit?\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Understanding Competitive Audits in Software Security: A Deep Dive\n\nWelcome to another enlightening post about software security. Gone are the days when only a single person or firm conducted audits for a codebase. It's time we talked about competitive audits‚Äîa game-changing yet relatively underexplored area of software security!\n\n## What's a Competitive Audit?\n\nUnlike private audits, a competitive audit is based on a unique principle: put your code base out to the public and invite them to compete in spotting as many bugs as possible.\n\n\"Competitive audits are a little bit different from private audits because the main focus is actually going to be on bugs as opposed to a private audit, where we're talking about increasing the code quality, test coverage, et cetera. In a competitive audit, you get paid if you find bugs, and if you find bugs, you win money.\"\n\nAn exciting example of a completed competitive audit is the BeedleFi protocol from CodeHawks.\n\n![](https://cdn.videotap.com/1TB4kKK5zsjQEFuoczfL-53.14.png)\n\nWhen you view the final report and click on one of the findings, you will notice a list of users who submitted this issue. Remember that these are not just any users‚Äîthey are bug-finders who actually make a living out of this. Clicking on a profile will lead you to their credentials and past contributions.\n\n## How Do Competitive Audits Work?\n\nNow onto the real catch: how is the payout determined? Each competitive audit platform has its unique way of determining the compensation, basing it on factors such as the gravity and uniqueness of the bug found.\n\nFrom the CodeHawks docs, we learn that the payouts are currently determined as medium-risk shares and high-risk shares‚Äîmore bugs located by the same person or group, less the pay-out per bug. The idea behind this could be interpreted as an incentive towards spotting more unique bugs, making the whole process more competitive and efficient.\n\n![](https://cdn.videotap.com/77H0xz2GOS14nGEknd09-97.43.png)\n\nThis framework works as a sybil resistance mechanism, so that one auditor doesn't submit under multiple names the same bug to get more money.\n\n> \"If you go to the CodeHawks documentation, there's actually some examples given a prize pot, who finds what bugs and how much they'd actually get paid out, if you want to know exactly how it works.\"\n\n## The Quality of Competitive Audits\n\nQuality-wise, competitive audits are off the charts! Contest summaries often report findings including high, medium, and low-risk vulnerabilities, as well as gas informational findings. The fact that smart contract security platforms are now resorting to competitive audits is proof of their effectiveness in spotting as many bugs as possible.\n\n![](https://cdn.videotap.com/C5hTu21ZmxEPmmnMP7gn-159.43.png)\n\nBut you don't just stop at audits. Valorizing your skills and building a solid career in the field is very much possible. Security researchers such as Hans and Pashav have started their journeys as competitive auditors and are now expert auditors.\n\n## Why Should You Consider Competitive Audits?\n\nIf you aspire to start your journey in smart contracts security and auditing, then remember: competitive audits are the best way! They offer an enriching learning experience and real opportunities to win money.\n\nMoreover, competitive audits platforms like CodeHawks provide career-building opportunities where you can level up your skill and expose your competence to a wide range of potential clients.\n\nA fun way to start this journey can be opting for CodeHawks' \"First Flights\"‚Äîa program designed to help you dive into the world of competitive auditing through easy, small code bases, like the Puffy Raffle.\n\n\"Competitive audits are a great way to learn and grow as a security research searcher, because oftentimes doing security reviews is very daunting, time-consuming. These are much quicker, much faster, and you learn so fast.\"\n\n![](https://cdn.videotap.com/kr2xo5Oi0O71dQUU9I1q-221.43.png)\n\nThere's a clear path to growth with competitive audits: once the competition is over, you're able to view the final report, see all the findings that you missed, and use it as learning for your next venture. Competitive audits are undoubtedly the best way to always stay on top of your game.\n\nGet ready to dive in because your road towards a top-notch software security auditing career starts here! Stay tuned for our next update on the latest trends in software security.\n",
          "updates": []
        },
        {
          "lessonId": "9c485ab8-c99e-4dec-8dfc-267bdf536d45",
          "number": 45,
          "title": "Codehawks",
          "slug": "codehawks",
          "folderName": "45-codehawks",
          "description": "",
          "duration": 3,
          "videoUrl": "WQj6Gw8bMLc",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/45-codehawks/+page.md",
          "markdownContent": "---\ntitle: CodeHawks\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Starting Your Flight in Bug Hunting: An Easy Guide\n\nHello, everyone! Today, let's dive into the process of participating in your first code auditing competition, or as we like to call it - First Flight. Also, it's the perfect time for you to put your bug-finding skills to the test, thanks to an ongoing 'First Flight' code review competition. So, without further adeui, let's kick things off.\n\n## Your Ticket into the Flight\n\nFirst Flight is about to take off and it's time for you to be a part of it. Right now, the event 'Puppy Raffle' is offering you a fantastic opportunity to dive in and try your luck at finding the odd bugs in the code. Not only does this give you a chance to compete, but you also stand the chance to submit your first finding!\n\n![](https://cdn.videotap.com/TJBOFC6kVtUDQe7zHlIz-17.47.png)> _\"Since an exciting First Flight competition is going on - 'Puppy Raffle', why not use the write-up which we previously went over and input our first bug-findings?\"_\n\n## Making the Leap\n\nBe it the desire to learn, or the adrenaline pushing you to compete in a live, critical audit where real stakes are involved - the choice is yours. Remember, live contests are more challenging because they aren‚Äôt expected to have any bugs in the codebase. But if you're looking for a stepping-stone to level up your skills, these First Fights are just the thing for you.\n\n## How to Participate in Your First Flight\n\n**Signing Up on The Platform**\n\nTo participate in a First Flight, you need to sign up for the CodeHawks platform.\n\nFollow the simple steps below:\n\n1. Navigate to CodeHawks\n2. Click on 'Become a Hawk'\n3. You have a variety of options to sign up with. We're going to use MetaMask, but feel free to choose what suits you.\n4. After signing in, create your profile. A wallet address is required since CodeHawks pays out in USDC on the Arbitrum chain.\n5. Discord is the primary communication hub where you can ask sponsors questions. Telegram can be ignored.\n6. If you wish for people to reach out through Twitter, LinkedIn, or Github, ensure to link them.\n7. After filling up the details, hit 'sign up'.![](https://cdn.videotap.com/B7E2KwVjnd1XFN3KOGF0-96.07.png)\n8. Once done, a verification mail is sent to you, and once the email is verified, you're all set to participate.\n\nWith these steps, your registration on the platform is completed, and you‚Äôre ready to start participating.\n\n**Engaging with Your First Flight**\n\nNow that you're signed up, navigate to the 'Puppy Raffle' First Flight, scroll down to the competition details, and start exploring!\n\nHere, you will find all relevant data, including payouts, statistics, details about the First Flight - everything you need to participate effectively.\n\nEnjoy the journey of embarking on your First Flight and gaining those valuable bug-hunting skills. We wish you the best of luck in finding those pesky bugs and the amazing opportunity to submit a finding. Happy hunting!\n",
          "updates": []
        },
        {
          "lessonId": "90ec3130-455a-483a-b279-35da3f014021",
          "number": 46,
          "title": "Submitting a competitive audit finding",
          "slug": "submitting-a-competitive-audit-finding",
          "folderName": "46-submitting-a-competitive-audit-finding",
          "description": "",
          "duration": 4,
          "videoUrl": "JfdwciPRsd8",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/46-submitting-a-competitive-audit-finding/+page.md",
          "markdownContent": "---\ntitle: Submitting a Competitive Audit Finding\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# How to Submit Findings in a Competitive Audit on CodeHawks\n\nWe've come a long way in this guide, and now it's time to learn how to submit your findings in a CodeHawks competitive audit. As you follow along with me in learning the ropes, remember that your write-ups need to demonstrate your skills and abilities as a security researcher. The better quality they are, the more chances you stand to earn additional rewards.\n\n## Start Your Finding Submission\n\nLet's start by submitting a finding. Turn your attention to the provided page with the message, \"You have no findings for this contest.\"\n\n![](https://cdn.videotap.com/tBS5umL1xzaBq36apSkD-26.91.png)\n\nYou'll see a very familiar setup. Navigate to the Findings page and extract your title, which you'll paste into the \"Title\" field. At this stage, there's no need to add prefixes or suffixes to your title; keep it plain and simple.\n\n## Root Cause, Impact, and Severity\n\nNext, deal with the root cause and the impact of the severity of the issue. Take for instance, if the severity is about looping through a player's array to verify duplicates, it could result in a potential denial of service attack. Per our guidance before beginning the audit, if you labeled this as a medium, make sure to maintain that consistency in this report.\n\n## Insert GitHub Links\n\nYou'll also need to provide GitHub links that are precisely related to the code base where your finding is located. For example, if the finding is within the \"for loop,\" direct the judges to the exact repo. Let me explain how to do this:\n\nReturn to the ‚ÄúFirst Flights‚Äù section and view the repo. Navigate to \"SRC puppy raffle\" and find the duplicate loop. By clicking on this line, you can hit \"Copy permalink,\" and then paste this in the respective 'GitHub' field in your CodeHawks contest review. That specific link stands as the relevant link in the code base for the contest.\n\n## Submit Findings in a Compelling Fashion\n\nWe're now at the stage where we finalize and submit the findings. The CodeHawks contest review is divided into several sections, including: summary, details, impacts, tools used, and recommendations. In order to ensure a robust submission, consider copying and pasting your write-up into the respective sections. If you have conducted a diff (difference) at the end of the audit, this information can also be included.\n\nBefore hitting \"Submit finding,\" you can hit preview to see how your submission will be displayed. Ensure it's appropriately aligned, grammar checked, and conveys your findings clearly, before submitting.\n\nAfter pressing \"Submit finding,\" you will be redirected to your report. Here, you can view and modify your submission as needed. When the competition ends, your report will be sent directly to a panel of judges for evaluation.\n\n## Rewards for Quality Write-ups\n\nIf you display excellent knowledge and skills in your write-ups, you might stand the chance of earning an additional bonus as part of CodeHawks's \"selected report.\"\n\n> Remember: The quality of your submission is paramount. An outstanding write-up could earn you a bonus prize payout. So, go ahead and show us how fantastic your write-ups can be!\n\nVisit past contests and selected findings to glean knowledge on how to make your submissions standout.\n\n## Building Your Portfolio\n\nAll your findings can be added to your portfolio, a perfect way to showcase your abilities as a security researcher. You can easily access your findings by visiting 'My Findings' in your profile. Take pride in your work and keep building that portfolio!\n\n## Wrap Up\n\nAt the end of the competition, the judges will review all submissions and findings, ranking them based on merit. In some instances, platforms might engage the community in the judging process. Keep an eye out for numerous opportunities coming up on CodeHawks, as this platform supercharges your journey into becoming the best smart contract security researcher.\n",
          "updates": []
        },
        {
          "lessonId": "c7def483-fe9d-4db3-bcd1-33aa4330af86",
          "number": 47,
          "title": "Reporting templates",
          "slug": "reporting-templates",
          "folderName": "47-reporting-templates",
          "description": "",
          "duration": 3,
          "videoUrl": "T2l1Fo7cy74",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/47-reporting-templates/+page.md",
          "markdownContent": "---\ntitle: Reporting - Templates\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# The Art of Writing Github Audit Reports\n\nWelcome to this informative guide on creating top-notch GitHub audit reports. If you‚Äôve been following our series of report-writing tutorials, then you're at the right place to take a deeper dive!\n\n## Utilizing Our Audit Report Templates\n\nFirstly, let's start by exploring our wonderfully diverse GitHub repository. You may recall this same audit report templating repo _\"password store\"_ from our previous tutorial.\n\nHowever, besides this, there are numerous other templates in the repository that can be of great use. Feel free to pick any according to your needs or project requirements.\n\n> ![](https://cdn.videotap.com/cAA0qGJ4X5O0Aj9Q0RNF-26.2.png)\n\n## The Power of Audit Repo Cloner\n\nNow, some of you might remember our good friend, the _\"Audit Repo Cloner\"_. This handy tool developed by our enthusiastic Cyfrin team, takes clone of a repo and prepares it automatically for Cyfrin audit report generation. In order to streamline our audits, instead of amassing all of our findings on a markdown, we use issues or projects on the repo and generate the entire report directly from GitHub.\n\n## The Report Generator Template\n\nWithin our arsenal, we also have a powerful ally called _\"Report Generator Template\"_. Forked from Spearbit, this phenomenal codebase performs a myriad of functions such as:\n\n1. Fetching all issues from a repository.\n2. Arranging them according to severity.\n3. Generating a single markdown file.\n4. fusing the markdown file into a latex template.\n5. Alongside producing a PDF version of the entire report.\n\nTherefore, knowing how to manoeuvre through our repository, using the correct tools efficiently, and utilizing our audit report templates is essential.\n\n## The Importance of Collaborative Audit Reports\n\nWhen collaborating with your team, instead of attempting to merge everyone's markdown notes together, you may prefer to add issues directly, inputting your findings there. In this way, not only does teamwork become straightforward but also these tools can automatically generate the report from the issues, reducing the effort required.\n\nLearning to write audit reports in this manner is a step towards mastering report-writing. However, since we're still honing our skills, we'll continue writing in one markdown file and then generate them with the help of our audit report templating codebase.\n\n![](https://cdn.videotap.com/Qf7EAUCbvffD1C79xCLb-100.43.png)\n\n## Mastering the Art of Report Writing\n\nSince report writing is an indispensable skill for auditors, it's time to practice writing an audit report. Not every audit will require a meticulous report; sometimes a simple Markdown summary of your findings will suffice. But as part of your training, you must not neglect to practice and perfect your writing skills.\n\n## Leveraging Proof of Codes\n\nAnother critical factor to remember is proving your findings with corroborating codes, known as _'Proof of Codes'_. These are extremely vital, particularly in competitive audits. A finding without accompanying proof could be easily dismissed or overlooked in favour of findings that offer clear validations. Thus, developing clear and concise _Proof of Codes_ is key to succeeding in both competitive and private audits.\n\nIn summary, compiling an impactful audit report necessitates familiarity with tools like Audit Repo Cloner and Report Generator Template. Integrating these with prudent collaboration and judicious use of templates can lead to seamless report generation. Lastly, let's not forget the importance of providing strong _Proof of Codes_ to give validation and weight to our findings.\n\nI hope this guide fills you with newfound confidence and propels you towards creating expert-level GitHub audit reports. Good luck with your journey! Keep auditing and keep improving.\n",
          "updates": []
        },
        {
          "lessonId": "813dc962-8458-4d4d-9a82-8abf3d92639e",
          "number": 48,
          "title": "Reporting: Floating pragma",
          "slug": "reporting-floating-pragma",
          "folderName": "48-reporting-floating-pragma",
          "description": "",
          "duration": 2,
          "videoUrl": "cfbv95INyKY",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/48-reporting-floating-pragma/+page.md",
          "markdownContent": "---\ntitle: Reporting - Floating Pragma\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# A Step-by-Step Guide to Auditing Code from Your Search Bar\n\nWelcome to our step-by-step guide to auditing code from your search bar. Today we'll dive into the nuances of auditing, showing you exactly how we utilize the **@audit** tool to rewrite sections of a code base.\n\nFollow along as we jump into the details, sharing how you can take **@audit** findings, turn them into a comprehensive write-up, and even grade the findings based on severity. By the end of this guide, you'll have a clear understanding of the code auditing process and how to leverage it in your own projects.\n\n## Getting Started\n\nWe're going to kick off with a simple search query. In the search bar, we're looking for \"@audit.\" We'll scour the code base for any instance of \"@audit,\" creating a thorough write-up on each finding we uncover.\n\n### Our First Audit Result\n\nOur first instance of @audit involves an issue with using **floating Pragma**, which our Aderyn tool has already flagged in the **report.md** file.\n\nLet's take a look at this further.\n\n```js\n//@Audit: Info - Use of Floating Pragma is bad. Solidity Pragma should be specified, not wide.\n```\n\nSo what does this mean? In layman's terms, it suggests that solidity pragma should be explicitly articulated rather than left vague or wide. This isn't necessarily a critical issue (it doesn't pose a direct and immediate threat), but it's still worth addressing.\n\n![](https://cdn.videotap.com/MjcMkBDMLsjt5BWWw3v6-25.97.png)\n\n## Categorizing the Audit Result\n\nEvery audit result requires categorization based on potential impact. In our case, this floating Pragma issue is relatively minor. While some people assign it a 'low' level of importance, I prefer to label it 'informational.'\n\nIt's crucial to keep in mind that the classification of findings is subjective, open to interpretation based on the auditor's knowledge and understanding of the code base's architecture and dependencies, as well as its potential impact on the overall system.\n\nIn our audit data, we'll document our finding accordingly.\n\n![](https://cdn.videotap.com/VduK8PC4shE7VwpBA65s-44.86.png)\n\n## Building a Database of Findings\n\nAfter documenting the initial finding, we won't stop there. We'll want to compile a more robust database of audit results.\n\nWe'll return to the **Password Store audit** we worked on previously and extract both the \"finding layout\" and the \"report layout.\" We then create a new folder (let's name it **Audit Data**) and paste these layouts there.\n\nNow we have a structured template to work from for our code audits‚Äîin essence, saving time and maintaining consistency in our work.\n\n## Wrapping up the Audit\n\nAs we go through the process, we'll mark each `@audit` instance, noting that a report has been written based on the findings.\n\nIt's satisfying to physically (or digitally) tick off tasks as they are completed, providing that sense of achievement and progress. We're not just identifying issues; we're systematically working through them and documenting our findings for future reference and action.\n\n> \"...the objective code auditing is not just to identify potential vulnerabilities but to provide developers with an understanding of these weaknesses to produce more secure code in the future.\"\n\nAfter a thorough audit, not only will we have a detailed report of the current state of the code base, but we'll also have a blueprint for improving code security and quality moving forward.\n\nIn conclusion, the power of a simple tool such as the search bar, coupled with a little knowledge and understanding, can be leveraged to provide comprehensive and granular insights into a code base. Happy auditing!\n",
          "updates": []
        },
        {
          "lessonId": "a347c526-6e3d-4572-a6ff-f4d920f10680",
          "number": 49,
          "title": "Reporting: Incorrect solc version",
          "slug": "reporting-incorrect-solc-version",
          "folderName": "49-reporting-incorrect-solc-version",
          "description": "",
          "duration": 2,
          "videoUrl": "5Z2pLdZflQU",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/49-reporting-incorrect-solc-version/+page.md",
          "markdownContent": "---\ntitle: Reporting - Incorrect Solc Version\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Reviewing Code with Solidity 0.7: The Pros and Cons\n\nAs a developer, you‚Äôre probably curious about why you should use a newer version of Solidity, like 0.8.18. Let‚Äôs explore the impact and the benefits.\n\n## Understanding the Impact\n\nFirst, it‚Äôs important to address the question, ‚ÄúWhat‚Äôs the impact?‚Äù The answer is not as straightforward as one might expect. The impact is not substantial in the sense that using an outdated version of Solidity like 0.7 won't drastically damage or otherwise hinder your code.\n\n![](https://cdn.videotap.com/edaCgFvPOqTsobkSJ0ml-8.43.png)\n\nHowever, upgrading to a later version could potentially improve your codebase significantly, making it more efficient and less prone to bugs. So, no significant negative impact, but likely a considerable positive one if you opt to upgrade.\n\n> \"Optimizing a codebase isn't about making massive changes all at once, but implementing small, incremental improvements that together make a difference.\"\n\n## The Findings\n\nLet's delve deeper into our findings. In our analysis of various codebases, we have identified several areas where Solidity 0.8.18 has advantages over 0.7.\n\n1. Better error handling: Coding is often an exercise in problem-solving, particularly when those problems involve unanticipated errors. Solidity 0.8.18 offers improved error handling, saving you time on debugging and issue resolution.\n2. Enhanced security: Security is paramount in any coding project, big or small. The later version of Solidity comes with added security features that minimize potential threats.\n3. Greater efficiency: As with any updated version of a programming language, Solidity 0.8.18 is designed to perform tasks more efficiently than its predecessor. This could translate into faster execution times and a smoother user experience.\n\n## Sugguested Actions\n\nGiven these findings, our recommendation is simple: Using an outdated version of Solidity is **not** recommended. Please use a newer version like 0.8.18.\n\n![](https://cdn.videotap.com/qRzJlT3UnClcrxWDMVnm-50.59.png)\n\nIn transitioning to Solidity 0.8.18 from 0.7, here are some next steps:\n\n- Make a backup of your existing codebase.\n- Install Solidity 0.8.18 on your computer (Here's a handy [installation link](https://docs.soliditylang.org/en/v0.8.18/installing-solidity.html)).\n- Begin updating your scripts one by one. Start with non-critical scripts to test the waters before you get to more crucial parts of your code.\n\n## Further Improvements\n\nFor further suggestions, we can borrow from the [Slither Documentation](https://github.com/crytic/slither). Slither, a Solidity static analysis framework, offers many resolutions to common coding issues. You can directly apply their tactics to your code to make it better.\n\nTo add to the report based on our findings, we've reformatted and used some points directly from Slither.\n\nAfter applying these actions, you should be able to note the enhancements in your Solidity code. From our experience, it's always better to keep up to date with newer versions of such languages, and Solidity is no exception.\n\n## Conclusion\n\nIn conclusion, while using an outdated version like Solidity 0.7 may not have a massive negative impact, upgrading to the newer version, like Solidity 0.8.18, can make your coding life a whole lot easier and more efficient. Happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "1a7e975c-377d-4962-a28d-e9f95e774968",
          "number": 50,
          "title": "Reporting: Unchanged state variables should be immutable or constant",
          "slug": "reporting-unchanged-state-variables-should-be-immutable-or-constant",
          "folderName": "50-reporting-unchanged-state-variables-should-be-immutable-or-constant",
          "description": "",
          "duration": 2,
          "videoUrl": "EkpnQmJ3rdY",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/50-reporting-unchanged-state-variables-should-be-immutable-or-constant/+page.md",
          "markdownContent": "---\ntitle: Reporting - Unchanged State Variables Should Be Immutable Or Constant\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Ethereum Smart Contracts: A Gas Optimization Audit\n\nKeeping a keen eye on your smart contracts' gas usage can significantly improve your decentralized application's performance. When conducting an Ethereum smart contract audit, one aspect we should never overlook is **gas optimization**.\n\nIn this post, we'll go over an audit focused on gas optimization. By the end, you'll understand why specific variables in your smart contract need to be set as constant or immutable and learn how it affects the gas usage and elevates your smart contract's efficiency.\n\n![](https://cdn.videotap.com/w2OveccwS4ZLVJV3AAGV-5.63.png)\n\n## Defining the Audit Scope\n\nWe'll start our audit with a neat organization. First, we'll craft a Findings section‚Äîan overview of the areas we intend to audit.\n\n```markdown\n| Gas (g) | Status | Description ||---------|--------|-------------|| G1 | | || G2 | | |\n```\n\nG1 refers to checking for the use of constant or immutable variables, a standard we will adhere to throughout the audit.\n\n## Diving into Audit Findings\n\n'Mutable or constant?'‚Äîthat's the first question we'll broach. Answering it lets us decide which state variables should be declared **constant** or **immutable**.\n\n```markdown\n| Gas (g) | Status | Description ||---------|--------|-------------|| G1 | Unchanged | State Variables - constant or immutable |\n```\n\nFor instance, when auditing a contract regarding a raffle, we came across a variable `raffleDuration`. As it's a duration that, logically, wouldn't change throughout the contract's lifecycle, it should be declared as immutable.\n\nHere's an example:\n\n```js\nuint256 public immutable raffleDuration;\n```\n\nHere, we'll note in our audit findings:\n\n```markdown\n| Gas (g) | Audit Findings ||---------|----------------|| G1 | `raffleDuration` for the 'Puppy Raffle' should be marked as immutable. |\n```\n\nNow, we'll have to justify our decision. Hence, a brief description should be included in our audit findings:\n\n> \"Reading from storage is much more expensive than reading from a constant or immutable variable.\"\n\nWe mark this down as written and let's move forward.\n\n_NOTE: One should remember throughout an audit, chances are more similar instances may be found later. Always be on a watchful lookout._\n\n## Recheck for Constant Variables\n\nOur next audit target is a seemingly innocuous but incredibly significant feature of any smart contract‚Äînecessary constants.\n\nWhen re-auditing the same 'Puppy Raffle' contract, we found three variables that should ideally be declared as **constant**:\n\n```js\nstring public constant rareImageURI;\nstring public constant legendaryURI;\n```\n\nNow, we'll update our audit findings table:\n\n```markdown\n| Gas (g) | Audit Findings ||---------|----------------|| G2 | `rareImageURI` and `legendaryURI` should be marked as constant. |\n```\n\n```markdown\n**Remember:** Keeping your variables as constant when possible not only optimizes gas but also augments security by keeping those variables unchangeable.\n```\n\n## Conclusion\n\nConducting an audit with a focus on gas optimization is integral for your Ethereum smart contracts. It not only saves your users from paying exorbitant gas fees but also enhances your DApp's performance significantly. While `constant` and `immutable` are two powerful tools to achieve this, they're not the only ones. Nonetheless, we hope that this blog post has given you a good start on your gas optimization journey. The key is always to question‚Äîif a variable should indeed be changeable or not. A written plan always helps, just like our findings table here!\n\nHappy auditing and optimizing!\n",
          "updates": []
        },
        {
          "lessonId": "87a6e0ce-8924-4e56-93f5-c290141ba586",
          "number": 51,
          "title": "Reporting: Zero address check",
          "slug": "reporting-zero-address-check",
          "folderName": "51-reporting-zero-address-check",
          "description": "",
          "duration": 1,
          "videoUrl": "0S3h9kk3fXI",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/51-reporting-zero-address-check/+page.md",
          "markdownContent": "---\ntitle: Reporting - Zero Address Check\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Info Check - The Importance of Proper Checks in Blockchain Development\n\nOne of the most common pitfalls when developing on the blockchain, perhaps even in general software engineering, is a lack of thorough checking mechanisms. This can be particularly problematic when dealing with addresses, more specifically, the zero address, in Ethereum. This omission could lead to significant implementation issues and can be an easy target for bad actors. While working through a recent debug session, I noticed an absence of this critical check in the logic. This blog post serves as a document of my findings and the process I used to uncover them.\n\n![](https://cdn.videotap.com/v36vdsgvIfzkWCRrdOOE-1.88.png)\n\n## **The Sight of an Omission: Info Check for Zero Address**\n\nDuring the debugging session, my screening tool spotted an information check for a line that read something along the lines of 'info check for zero address'. Under normal circumstances, this could simply mean that there's no current data for that specific address. However, in the context of our application's logic, it was an indication of an important missing check, perhaps left out unintentionally during development.\n\nHere's the scenario described in the code:\n\n```js\n// code snippet to illustrate the scenario\nfunction transfer(address _to, uint256 _value) public returns (bool success) {\n    require(_value <= balanceOf[msg.sender]);\n\n    balanceOf[msg.sender] -= _value;\n    balanceOf[_to] += _value;\n\n    emit Transfer(msg.sender, _to, _value);\n\n    return true;\n    }\n```\n\nIn this step, ideally, a check should exist to ensure that the `_to` address is not the zero address (0x0). However, the existing check was missing, which is a cause for concern considering the importance of the check in smart contracts.\n\n## **Documenting the Finding**\n\nSo, what was my next step? Documentation. To ensure that I could come back to it later, I recorded this discrepancy in my findings list. Using a simple system of classification - numbering each finding and using an alphabetical prefix to denote the severity (Critical, High, Medium, Low, Informational), I named this finding `I3`, marking it as 'Informational'. This system, though seemingly simple, is invaluable for maintaining structure and clarity in error tracking and resolution.\n\n```markdown\n# Findings- C1: ... (sample critical finding)\n\n# I3: Missing Check for Zero Address in transfer functionThe transfer function does not check if `_to` address is the zero address. This could lead to tokens being mistakenly sent to the zero address and becoming irretrievable.\n\n    - File: contracts/Token.sol- Line number: 45- Recommendation: Add `require(_to != address(0))`\n```\n\n## **The Power of Copy-Paste Outputs**\n\n![](https://cdn.videotap.com/QeCT6VzhyrWrblKQYKrv-28.24.png)\n\n> \"The beauty of software engineering tools is their ability to make the developer's life easier with low-effort but high-value features such as copy-pasting outputs.\"\n\nBy just hitting 'copy' and 'paste', I was able to efficiently record the finding under the correct classification. This critical feature mitigates stress in the debugging process by allowing for quick and easy error tracking and resolution. It is even possible to directly link the output to the spot in the code where the issue was found, making the process of referring back to the findings and resolving them even more streamlined.\n\n## **In Conclusion**\n\nIn summary, this experience goes to show that even an 'informational' issue like a missing check for zero address can have far-reaching impacts if left unattended. However, the efficient use of debugging tools and a system for documenting findings can help a developer navigate through this complex process with relative ease. Therefore, it is always beneficial to consider, develop, and improve upon these efficient strategies for debugging. The power they wield often lies hidden in plain sight.\n",
          "updates": []
        },
        {
          "lessonId": "b05095c5-9cdf-4737-8c9e-1c9c3d6b7156",
          "number": 52,
          "title": "Reporting: Storage variables in loops should be cached",
          "slug": "reporting-storage-variables-in-loops-should-be-cached",
          "folderName": "52-reporting-storage-variables-in-loops-should-be-cached",
          "description": "",
          "duration": 2,
          "videoUrl": "dUhuByzlt10",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/52-reporting-storage-variables-in-loops-should-be-cached/+page.md",
          "markdownContent": "---\ntitle: Reporting - Storage Variables In Loops Should Be Cached\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Blog Post: Optimizing Gas Usage in Smart Contracts\n\nDeveloping decentralized applications (DApps) or working with smart contracts can sometimes be a harrowing task, especially when you consider the cost implications of interacting with the blockchain. One of the most vital and significant components when working with DApps and smart contracts is understanding gas - the internal pricing for running a transaction or contract in Ethereum. There are ways to optimize gas usage in smart contracts, and we will go over one of those ways today.\n\n## Why is Gas Important?\n\nGas in Ethereum isn't just about managing fees ‚Äì it's a fundamental part of the network's protocol. It's the fuel of the Ethereum Virtual Machine (EVM) - the decentralized computer that powers the network. Needless to say, gas management plays an essential role in the development and optimization of your smart contracts.\n\n## Revising Storage Access in Your Smart Contracts\n\nIn this post, we're diving into the issue of excessively reading from storage in your smart contracts. Auditing your contract, we recommend an enhancement in the way you might be accessing variables in a loop. This is often reported as a gas usage finding.\n\n> \"Storage Variables in a loop should be cached. Reading from storage constantly rather than memory is less gas efficient.\"\n\nHere is an informed approach to tackle this: Instead of continually reading from storage, cache your variables instead.\n\n## A Detailed Walkthrough\n\nLet's take an example, where we denote our storage variable as `G2`. This variable should be cached, but before caching it, we should check if its value is not double but triple.\n\nHaving ensured our variable meets the requirements, we can now see how to cache our storage variable.\n\n1. First, we need to create a diff.\n\n   - A `diff` is a representation of changes between two sets of data. It is commonly used in version control systems to show the changes between two commits.\n\n2. Now, let's grab the original line, and paste it into our diff. Here, we're trying to replace an inefficient line of code with a more optimized one. The diff set should look like this:\n\n   ```diff\n   + uint256 playersLength = players.length;\n   - for (uint256 i=0; i < players.length -1; i++){\n   + for (uint256 i=0; i< playersLength - 1; i++){\n   -  for (uint256 j=i+1; j <players.length; j++){\n   +  for (uint256 j=i+1; j <playersLength; j++){\n         require(players[i] != players[j], \"PuppyRaffle: Duplicate Player!\")\n      }\n   }\n   ```\n\n## Why Diff?\n\nEvery time you call the original line of code (`players.length`), you're reading from storage as opposed to memory. Reading from memory is more gas efficient and thus helps optimize your contract better.\n\nThe diff simply provides a clear way of visualizing the change we made, and it helps communicate the optimization proposed.\n\nIn conclusion, by reducing the constant reading from storage and instead caching variables in a memory, we optimize gas utilization, making smart contracts more efficient.\n\nFollowing such simple steps in your Smart Contract development will force you to think about optimization from the get-go, which is an excellent best practice to embed into your workflow. Smart contract optimization is a deep, complex field, with much to explore and learn. The deeper you go, the more intricate nuances you'll uncover!\n\n![](https://cdn.videotap.com/k6t5NpVGN2ClB6xkBj6O-74.45.png)\n\nRemember, when it comes to Ethereum, gas is more than the cost of doing something. It's the very bread and butter of the operations of your smart contracts. The more effective you are with using gas, the better your contracts will be. With the focus on performance and optimization, high gas costs can be a thing of the past! Happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "aa20a390-002b-4fb2-b7fe-10459f334b3c",
          "number": 53,
          "title": "Reporting Findings We'll Cover Later",
          "slug": "reporting-findings-we'll-cover-later",
          "folderName": "53-reporting-findings-we'll-cover-later",
          "description": "",
          "duration": 1,
          "videoUrl": "V9FlfOo4lAA",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/53-reporting-findings-we'll-cover-later/+page.md",
          "markdownContent": "---\ntitle: Reporting - Findings We'll Cover Later\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Decoding MEV Attack Vectors in Blockchain Audits: An Overview\n\nLet's delve into an intriguing topic that has been making waves in the cryptocurrency and blockchain world: Miner Extractable Value (MEV). In this detailed walkthrough, we'll be breaking down MEV, focusing on a specific function that is vulnerable to an MEV attack. However, we're not going to tackle this attack vector head-on just yet. Instead, we will revisit this at a later point in the journey - specifically, in section 7.5.\n\n## Understanding MEV and Its Relevance in Our Audit\n\nMiner Extractable Value (MEV) is a measure of the profit a miner (or validator, more generally) can make through their ability to arbitrarily include, exclude, or reorder transactions within the blocks they produce. This kind of attack vector, while crucial to understanding blockchains' dynamics, is a rather complex topic; one that deserves its exclusive focus.\n\nSo, even though the refund function that's part of the audit does indeed cater to an MEV attack vector, this article will momentarily set it aside. It's crucial to note that the art of audit involves identifying specific findings and coming back to them for comprehensive reviews ‚Äì and that‚Äôs precisely what we'll do with this MEV instance.\n\n## The Intricacies of an Audit: Findings and Interpretations\n\nNow, let's address some of the findings that have popped up during this audit.\n\n> \"There are some findings that we're going to come back to and there are going to be some findings in this report...\"\n\nIn the realms of an audit, numerous findings can surface - some straightforward, others more intricate. It isn't uncommon to unearth certain findings that aren't immediately dealt with. Rather, they're documented to be thoroughly analyzed at a later stage. In our case, the MEV attack vector related to the refund function is such a finding.\n\n![](https://cdn.videotap.com/35BUNzg5F3kXUPMFBbwg-20.67.png)\n\n### The Art of 'Temporarily Skipping' in Audits\n\nHaving highlighted the presence of an MEV attack vector in the refund function, we're going to write it as 'skipped' for our current discourse. To the uninitiated, this might seem like a casual bypass; however, this is a strategic step in decomposing the complexities of a blockchain audit.\n\n![](https://cdn.videotap.com/p2tZttDRmeYG6uyTFwF2-24.11.png)\n\n```markdown\n// mev attack vector identified// Temporarily skipping - will return to in section 7.5\n```\n\nAn extract from our audit report, showcasing the \"skipped\" MEV attack vector needing future attention.\n\nTo sum it all up, this introductory overview of the audit has laid some groundwork on understanding MEV and how it intertwines with our audit. We've identified the existence of an MEV attack vector in the refund function, but instead of delving deeper, we've marked it for further analysis down the line. Keep in mind that this is just an initial glimpse into the labyrinth that is blockchain audits. Stay tuned for in-depth details as we unravel each twist and turn in upcoming posts. Till then, happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "a8dc1aa0-fbfd-4f90-bf52-13a07322c785",
          "number": 54,
          "title": "Reporting Reentrancy",
          "slug": "reporting-reentrancy",
          "folderName": "54-reporting-reentrancy",
          "description": "",
          "duration": 8,
          "videoUrl": "tafpE_PVN6Q",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/54-reporting-reentrancy/+page.md",
          "markdownContent": "---\ntitle: Reporting - Reentrancy\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Decoding Reentrancy Attacks: An Insightful Audit of the Puppy Raffle Refund\n\nHello everyone! Today, we'll be delving into understanding and documenting a reentrancy attack using the Puppy Raffle refund function. More and more, this kind of vulnerability rears its head in the world of smart contracts. It might sound like a complex piece of machinery, but strap in, grab a coffee, and we'll break it down for you.\n\n## The Impact Assessment\n\nHold your hats folks, this one's a whopper! I ran a test and discovered I could call the `refund()` function repeatedly, effectively siphoning money out of the contract the whole time! The impacts are significant. By exploiting this vulnerability, I could effectively drain the entire contract of funds. In terms of assessment, this is a high on both the Impact and Likelihood scales.\n\nLet's unravel this!\n\n## Exploring the Vulnerability: Puppy Raffle Refund\n\n![](https://cdn.videotap.com/o0EiNXj1ffsPqR9o05L4-50.52.png)\n\nHere's our culprit, the Puppy Raffle `refund()` function. In its bare form, it does not follow the prescribed pattern of **Checks-Effects-Interactions** that defends against reentrancy. As a result, it enables participants to drain the contract balance.\n\nVery interesting! Allow me to point out the core issue. The Puppy Raffle `refund()` function first makes an external call to the sender‚Äôs address (`msg.sender`). Following that, it updates the Puppy Raffle `Players` array. The flaw lies in this sequence of operations, leading to our famous reentrancy vulnerability.\n\n## Play by Play: Exploiting the Vulnerability\n\nAs a malicious participant, you could sneakily have a fallback receive function that calls the Puppy Raffle `refund()` function again, claiming multiple refunds. This process repeats until the contract balance runs dry.\n\nHere's a quick rundown of the potential exploit sequence:\n\n1. You, as the malicious participant, enter the raffle.\n2. You set up a contract with a fallback function that calls `puppyRaffle.refund()`.\n3. You call `puppyRaffle.refund()` from your shady contract, draining the contract balance.\n\n## Proof of the Concept: Testing the Vulnerability\n\nNow that we understand the mechanics, let's do a dry run. Here's the detailed methodology for our test case. Mind you, for the sake of a rigorous demonstration, I'll go ahead and showcase the full test suite.\n\n```markdown\nSUMMARY=====\n\n1. A user enters the raffle (Credits to ChatGPT for the idea).\n2. Attacker sets up a contract with a fallback function that calls `puppyRaffle.refund()`.\n3. Attacker enters the raffle.4. Attacker calls `puppyRaffle.refund()` from their attack contract, draining the contract balance.\n   CODE=====\n```\n\n## Mitigating the Attack\n\n![](https://cdn.videotap.com/xXoG7dcQXxHHyvPl96re-370.48.png)\n\nTo seal this vulnerability, the `puppyRaffle.refund()` function should update the `Players` array _before_ making the external call. It's also advisable that we move up the event emission due to an associated audit loophole.\n\nHere's a quick diff to illustrate the required changes:\n\n```diff\n    function refund(uint256 playerIndex) public {\n        address playerAddress = players[playerIndex];\n        require(playerAddress == msg.sender, \"PuppyRaffle: \"Only the Player can refund.\");\n        require(playerAddress != address(0), \"PuppyRaffle: \"Player already refunded or is not active.\");\n+       players[playerIndex] = address(0);\n+       emit RaffleRefunded(playerAddress);\n        payable(msg.sender).sendValue(entranceFee);\n-       players[playerIndex] = address(0);\n-       emit RaffleRefunded(playerAddress);\n    }\n```\n\nVoila! We have successfully written up an audit for this reentrancy attack.\n\nThe world of smart contracts is an exciting jungle, and maintaining awareness of potential vulnerabilities is crucial. By understanding the nitty-gritty of attacks such as reentrancy, we can better prepare and safeguard our virtual currency. Stay tuned for more deep dives like this one!\n",
          "updates": []
        },
        {
          "lessonId": "565e190d-95f9-4d4f-9091-637e52e2c61c",
          "number": 55,
          "title": "Reporting: getActivePlayerindex",
          "slug": "reporting-getActivePlayerIndex-incorrect-for-edge-case",
          "folderName": "55-reporting-getActivePlayerIndex-incorrect-for-edge-case",
          "description": "",
          "duration": 5,
          "videoUrl": "ZMk0q50dCyA",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/55-reporting-getActivePlayerIndex-incorrect-for-edge-case/+page.md",
          "markdownContent": "---\ntitle: Reporting - getActivePlayerIndex Incorrect For Edge Case\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n## Error: Index Zero\n\nLet's kick things off with `getActivePlayerIndex`. For some context: **if a player is at index zero, 'puppy raffle' returns zero too**. You might ask, so what? Well, here's a thing: playing with indexes can often get dicey and bring unexpected results.\n\n> \"If the player is at index zero, it'll return zero and a player might think they are not active.\"\n\nInteresting, right? And now to discuss **how impactful this finding is**. To get a full picture, let's try and see some potential outcomes.\n\n## Gauging The Impact\n\nDoes this issue cause any funds to be lost? Well, not so much. It does, however, impact the protocol rather severely. When players see that they are not active, they may try to enter the lottery again, which can be wasteful.\n\n![](https://cdn.videotap.com/niK93K7C7GGxiHEpocIL-74.4.png)\n\nConsidering the possible outcomes, we shall term **the potential impact of this as low to medium**. The tricky thing here is to assess the likelihood of this happening, given its unexpected nature.\n\n## Assessing the Severity\n\nThe severity can be considered low or even medium. But since no funds are at stake and the user can check storage where they are in the array, it's more like a good-to-have fix rather than a downright severe issue.\n\nThe subjective nature of this assessment comes into play here and different perspectives might find different solutions to be fit. However, let's move on to the course of action we would recommend.\n\n## Reporting and Fixing The Problem\n\n> \"I would argue that this is a low. I think it would be understandable if somebody said it was a medium.\"\n\nHaving reported the issue, we now set out to explain it like we would to a five-year-old.\n\n> `L1 puppy raffle getActivePlayerIndex returns zero for nonexistent players and for players at index zero, causing a player at index zero to incorrectly think they have not entered the raffle.`\n\nExplicit and enlightening, to say the least!\n\n## Show the Proof\n\nHow about we create a small proof of concept? The player enters the raffle, their index returns zero and they think they haven't entered correctly due to the function documentation. They may waste gas trying to reenter the raffle.\n\n## Navigating the Fixes\n\nNow the million dollar question: How do we fix this? We have a few possibilities at our disposal:\n\n- Revert if the player is not in the array, instead of returning zero.\n- Reserve the zero position for any void.\n- Return an int -1 if the player is not detected in the activity.\n\nAll these solutions would work well depending on the specific conditions of the protocol, and can ensure an enhanced user experience and optimized protocol efficiency.\n\n## Wrapping Up‚Ä¶\n\nBy addressing this single issue on the 'puppy raffle', we've only scratched the surface of smart contract auditing's complex and fascinating world. However, we hope that this post has illuminated some critical aspects of the process and demystified how auditors assess and address potential issues. Stick around for more insights!\n",
          "updates": []
        },
        {
          "lessonId": "9b6aa31f-a11a-43d3-ac79-5361ac447c50",
          "number": 56,
          "title": "Reporting: Should Follow CEI",
          "slug": "reporting-should-follow-cei",
          "folderName": "56-reporting-should-follow-cei",
          "description": "",
          "duration": 2,
          "videoUrl": "zk84OU8mvlU",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/56-reporting-should-follow-cei/+page.md",
          "markdownContent": "---\ntitle: Reporting - Should Follow CEI\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Adopting Clean Code and CEI in the \"Puppy Raffle Select\" Function\n\nAnyone who's ever dealt with code understands the importance of best practices, clean structures, and simple conventions. Sometimes, we find these guidelines drift into a gray area, where adherence can be somewhat subjective or optional. However, it doesn't diminish their importance; the overall goal remains ensuring our code remains readable, maintainable, and efficient. This is precisely the case with the PuppyRaffle `selectWinner` function in our codebase, which has some room for improvement in following the Checks, Effects, Interactions (CEI) practices.\n\n## The Dilemma with Puppy Raffle Select Winner function\n\nThis discussion primarily revolves around how the function \"Puppy Raffle Select Winner\" seems to neglect some CEI practices. While the function operates as intended, its implementation could potentially conflict with the defined best practices. This doesn't necessarily impact the function's operation, but it's always fruitful to keep our code clean and properly structured.\n\n## Diving into the Code\n\nLet's take a look at how our current implementation could be improved:\n\n![](https://cdn.videotap.com/5fiDVN8c36MOJEsywdT0-39.47.png)\n\nYou'll notice some discrepancies if you compare this with standard Clean Code and CEI practices. Even though this wouldn't impact the functionality, it is considered best practice to ensure your code is always clean and follows CEI. Such subtleties can make a significant difference when it comes to the maintainability and readability of your code.\n\n> \"And this is where it gets a little bit subjective. What does it mean to keep the code clean and to follow CEI?\"\n\nNOTE: Even the perception of keeping your code clean and following CEI can vary across developers. However, in the end, it circles back to improving readability, maintainability, and efficiency.\n\nTo rectify this, let's modify the code and run a diff:\n\n```diff\n-   (bool, success) = winner.call{value: prizePool}(\"\");\n-   require(success, \"PuppyRaffle: Failed to send prize pool to winner.\");\n    _safeMint(winner, tokenId);\n+   (bool, success) = winner.call{value: prizePool}(\"\");\n+   require(success, \"PuppyRaffle: Failed to send prize pool to winner.\");\n```\n\n![](https://cdn.videotap.com/T19Kp2sgscV3fxvFNW9I-56.73.png)\n\nAnd voila! You can now easily spot the changes made to align the implementation with CEI.\n\n## Wrapping up\n\nIn conclusion, adhering to best practices, like keeping your code clean and following CEI, is a route towards more manageable, efficient, and readable code. While occasionally you might encounter situations where these guidelines appear less crucial or even slightly subjective, there's always room to improve your code's structure and format.\n\nAs Robert C. Martin puts it:\n\n> \"Indeed, the ratio of time spent reading versus writing is well over 10 to 1. We are constantly reading old code as part of the effort to write new code. ...Therefore, making it easy to read makes it easier to write.\"\n\nImplementing these practices will not just enhance your code quality but also, subsequently, level up your coding skills.\n",
          "updates": []
        },
        {
          "lessonId": "c4b25549-967f-4ff6-81b5-314786b4f966",
          "number": 57,
          "title": "Reporting: Weak Randomness",
          "slug": "reporting-weak-randomness",
          "folderName": "57-reporting-weak-randomness",
          "description": "",
          "duration": 6,
          "videoUrl": "a8m8x4Vj1Bk",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/57-reporting-weak-randomness/+page.md",
          "markdownContent": "---\ntitle: Reporting - Weak Randomness\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Auditing Randomness in Blockchain Protocols: A Deep Dive\n\nIn the world of decentralized applications and blockchain protocols, randomness plays a critical role in creating fair outcomes. Platforms relying on randomness mechanisms like lottery games tend to be prone to vulnerabilities. In this article, we'll discuss the common weaknesses related to randomness and their impact on the functionality of the protocol.\n\n## Auditing the Process of Randomness\n\n![](https://cdn.videotap.com/A0C1NmhbMJhDQtFHw3eb-29.91.png)\n\nWhile auditing a recent protocol, we encountered a significant flaw in the system: The randomness involved wasn't verifiably random. This observation led us to assess a variety of variables, namely the impact and the likelihood of this flaw affecting the protocol.\n\n> \"The impact of a non-verifiably random number in a protocol can be high. The winner could be predicted or altered, which can significantly undermine the protocol's integrity.\"\n\nThe likelihood of this happening is also high because individuals, motivated by self-interest, will likely try to exploit this vulnerability to cheat the system. Therefore, we rated the potential impact and likelihood both high, placing the issue at a high severity level.\n\n## Unearthing the Root Cause and Impact\n\n![](https://cdn.videotap.com/K1jaGIVHSOnaSRtPUtcD-99.69.png)\n\nReentrancy stood out as another significant issue we encountered during the audit. However, the primary focus of this article revolves around weak randomness, a common security flaw in many blockchain protocols.\n\nWeak randomness in 'Puppy Raffle' gives users an influencer role, allowing them to predict or alter the winner. This prediction is based on a simple susceptibility - hashing the message sender, block timestamp, and block difficulty together leads to a predictable final number. The outcome isn't truly random, providing malicious users with an opportunity to manipulate values or predict them in advance to influence the raffle results.\n\nThis vulnerability also exposes another potential threat - front running. Users clever enough to see they aren't the winner may choose to call router functions and disrupt the functionality of the protocol further.\n\n## Impact and Inaccurate Randomness\n\n![](https://cdn.videotap.com/6sKiQi1LSBNokBJRuCbW-149.53.png)\n\nThe dangers of weak randomness are magnified in scenarios where users can influence the raffle winner, thus winning the prize money or getting access to the rarest puppy. The problem amplifies when bad randomness also effects the rarity of the puppies, making the entire raffle worthless if evolved into a gas war.\n\nWe'll combine these two issues arising from inaccurate randomness - the raffle winner and the puppy rarity - into one. They have unique root causes but the same dysfunctionality resultant from the weak randomness at play.\n\n## Proof of Concept\n\nUnderstanding these vulnerabilities isn't enough. We also need to establish a concrete proof of concept:\n\n1. Validators predicting block timestamp and block difficulty can significantly manipulate their participation.\n2. Users can modify their message sender value, making their address the preferred one to determine the winner.\n3. Transactions, such as select winner, can be reverted by users if the result doesn't meet their satisfaction.\n\nIn this case, creating proof of concept would require fuzzing the message sender, manipulating it to a preferred outcome.\n\nAlso noteworthy is a common attack vector - using on-chain values as seeds for randomness. The solution requires a reform of the randomness mechanism used in the protocol.\n\n## Recommended Mitigation\n\nA cryptographically verifiable random number generator, such as [Chainlink VRF](https://docs.chain.link/docs/get-a-random-number/), could substantially mitigate such issues.\n\n## Wrapping Up\n\nThe audit, evaluation, and subsequent steps we discussed underline the essential nature of randomness in blockchain protocols. At the same time, they also highlight the need for robust mechanisms to ensure the implementation of fair and unpredictable randomness.\n\nIn the dynamic and rapidly evolving blockchain space, keeping up with security vulnerabilities, understanding them and formulating comprehensive mitigation strategies, is of utmost importance.\n",
          "updates": []
        },
        {
          "lessonId": "afad0ae1-70b3-498c-af87-b23de07534ff",
          "number": 58,
          "title": "Reporting: Magic Numbers",
          "slug": "reporting-magic-numbers",
          "folderName": "58-reporting-magic-numbers",
          "description": "",
          "duration": 2,
          "videoUrl": "KDh-jSmIOgA",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/58-reporting-magic-numbers/+page.md",
          "markdownContent": "---\ntitle: Reporting - Magic Numbers\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n## Unraveling the Magic Numbers: An Informational Audit\n\nMoving on, I bumped into the mystery of _magic numbers_- a term you would be familiar with if you've had your fair share of headaches debugging code.\n\nUsing magic numbers in coding is discouraged. Not because of daunting supernatural powers they wield, but due to the confusion they bring. Seeing number literals scattered in a codebase is like seeing Latin text in a historical mystery novel: intriguing, but mostly confusing.\n\nFor those that don't know, a _magic number_ is\n\n> \"A direct usage of numeric literals (ex: 5, 100, -3) in your code that does not have any direct explanation or reasoning behind it.\"\n\nWhile auditing, here's what some typical magic numbers in a codebase look like:\n\n```js\nuint256 prizePool = (totalAmountCollected * 80 ) / 100;\nuint256 fee = (totalAmountCollected * 20) / 100;\n```\n\nTo give an idea of what it's all about, let's put it out simply:\n\n![](https://cdn.videotap.com/ivNThteq2BkoEFoA1o4y-54.71.png)\n\nIt's always more readable and also quite a bit kinder to the next person (or your future self decoding the code), if the numbers used in the code are given a meaningful name. Let's see a more appropriate way to handle these numbers:\n\n```js\nuint256 public constant PRIZE_POOL_PERCENTAGE = 80;\nuint256 public constant FEE_PERCENTAGE = 20;\nuint256 public constant POOL_PRECISION = 100;\n\nuint256 prizePool = (totalAmountCollected * PRIZE_POOL_PERCENTAGE) / POOL_PRECISION;\nuint256 fee = (totalAmountCollected * FEE_PERCENTAGE) / POOL_PRECISION;\n```\n\nAlthough it might result in a slightly more verbose code, but who doesn't prefer meaningful verbosity over silent ambiguity?\n\n## Summing Up\n\nSo remember, while performing an audit, you don't need to eat everything that's on your plate in one go. Prioritize what needs immediate attention and what doesn't. Being a little bit lazy in an informational, private audit like addressing balance (if you're good with the protocol) is not a big deal, as long as it doesn't harm the codebase in the long run.\n\nHowever, when it comes to magic numbers, them being informational doesn't make them less important. Always avoid unexplained constants in the code. Name your numbers, make your code readable and let the person reading your code thank you, rather than wanting to throw their computer out the window in frustration!\n",
          "updates": []
        },
        {
          "lessonId": "1423bd4e-6f88-4869-8ddf-cc8d3f83720f",
          "number": 59,
          "title": "Reporting: Integer Overflow",
          "slug": "reporting-integer-overflow",
          "folderName": "59-reporting-integer-overflow",
          "description": "",
          "duration": 8,
          "videoUrl": "u0uhp2NIhs0",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/59-reporting-integer-overflow/+page.md",
          "markdownContent": "---\ntitle: Reporting - Integer Overflow\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Understanding Integer Overflow in Puppy Raffle - A Deep Dive\n\nIn the dynamic world of programming and security, an auditor's job seldom runs out of thrill. A significant part of the role involves identifying and reporting issues that have a potential to cause considerable harm in the future.\n\nIn a recent security audit, we found two major issues ‚Äî **integer overflow** and **unsafe casting**. Our team dedicated a significant amount of time to understand these, and what follows is our detailed report on the audit findings.\n\n![](https://cdn.videotap.com/tTiu8L4Bi8vsuicWvE2t-27.83.png)\n\n## Issue 1: Overflow\n\nLet's jump straight into the iter details of the overflow issue.\n\n### Severity\n\nWhen we did an impact analysis, we discovered that if this specific overflow issue occurred, wealthy reserves could be lost. As any venture (or anyone, for that matter), we hate losing money. Hence, we rank the impact of this issue as \"high\".\n\nThe likelihood of this happening might be a tad bit lower, ranging between \"low\" - \"medium\". However, given our stake in wanting the protocol to thrive and rake in lots of fees, our argument would tilt the scale towards \"medium\".\n\nShould this overflow happen when the raffle is being globally used, the severity would shoot up drastically. For the sake of this report, let's assume this scenario. The inference drawn, therefore, is that this issue carries high severity.\n\n![](https://cdn.videotap.com/A4rPHxYf6JE5lHcKRsPu-92.77.png)\n\n### Root Cause\n\nThe root cause can be traced back to the **integer overflow in the Puppy Raffle**. Due to this overflow, the total fees get wiped out, which means we lose money. In older Solidity versions (prior to 0.8.0), integers are subject to **integer overflows**. An example of how this could play out can be demonstrated through the following code block. Here, we increment myVar by 1 after it has reached its maximum limit.\n\n```javascript\nmyVar = typeof myVar(64).max;\n// 'myVar' reaches limit\nmyVar = myVar + 1;\n// 'myVar' is incremented by 1 and wraps back to 0, causing overflow\n```\n\n![](https://cdn.videotap.com/VNP7SHlx2E2aTLHNFAWN-148.43.png)\n\n### Impact\n\nIn the context of our Puppy Raffle, the 'Select Winner' function is responsible for accumulating total fees for the fee address to collect later via the 'Withdraw Fees' function. But if 'total fees' overflows, the amount that the fee address could collect would be incorrect, causing fees to be permanently stuck in the contract.\n\nHere's a proof-of-concept to better understand how this could happen. Let's consider a raffle scenario with four players. If we can get 89 more players to join a new raffle, we can see the overflow playing out. The simplistic theory behind the number 89 is that the number of additional participants required to trigger an overflow in this context calculatively comes out to be 89.\n\nAfter the raffle concludes, the 'totalFees' should ideally add up correctly. However, due to the overflow, the 'totalFees' end up being far less than the actual value, which is the sum of the previous 'totalFees' and the newly added fee.\n\n#### Note:\n\n```markdown\nThis overflow is particularly critical as once these 'total fees' overflows, the balance in the contract escalates to a point where it surpasses the limits of uint64. In that event, the 'Withdraw Fees' function fails (as balance != totalFees) and the trapped fees will never be retrievable.\n```\n\n![](https://cdn.videotap.com/cDvBxAfeGdyCJqDHfe8B-250.47.png)\n\n### Mitigation\n\nWe propose the following strategies:\n\n1. Upgrade to a newer version of Solidity.\n2. Use a `uint256` type instead of `uint64` for `puppyRaffle` total fees.\n3. Utilize the SafeMath library of OpenZepplin for Solidity v0.7.6.\n4. Remove the balance check from `puppyRaffle` withdraw fees function.\n\nAn example mitigation strategy would be:\n\n```diff\n-   totalFees = totalFees + uint64(fee); // The line to be removed\n+   totalFees = totalFees.add(fee); // After mitigation using OpenZepplin's SafeMath library\n```\n\n## Issue 2: Unsafe Cast\n\nThe second issue that was uncovered in the audit was an unsafe cast.The details of this issue have been built into another report as the problem is closely related to the overflow problem described in this report.\n\nIn a nutshell, we now have a better understanding and a mitigation plan for the overflow issue in the Puppy Raffle, addressing an integral issue we had discovered in the audit. Such audits, though complex, provide a platform to demonstrate the real value an auditor brings ‚Äî ensuring the robustness of systems and detecting vulnerabilities before hitches can occur.\n\nWell, that brings us to the end of our auditing adventures for this time. This was an interesting dive into the pit of overflow and casting vulnerabilities in the Puppy Raffle code, wasn't it?\n\nStay tuned for more such technical adventures.\n\n![](https://cdn.videotap.com/aUhVkP3XVtdb20yd5YkC-426.72.png)\n",
          "updates": []
        },
        {
          "lessonId": "de5044e6-06ff-4e3c-b117-292bf5babb9b",
          "number": 60,
          "title": "Reporting: Smart Contract Wallet Reverts Winning",
          "slug": "reporting-smart-contract-wallet-reverts-winning",
          "folderName": "60-reporting-smart-contract-wallet-reverts-winning",
          "description": "",
          "duration": 5,
          "videoUrl": "YdrTAjzHSjM",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/60-reporting-smart-contract-wallet-reverts-winning/+page.md",
          "markdownContent": "---\ntitle: Reporting - Smart Contract Wallet Reverts Winning\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n## Understanding The Issue\n\nWhen it comes to the risky and uncertain world of audits, people can often revert the transaction until they achieve a win. Yes, you got it right. We discussed this topic lightly in our previous talks about randomness; they can be seen as two contrasting findings merged into one.\n\nAn intriguing part to note here is that the winner might not get the money if their fallback is messed up. You're thinking the right way if you consider it as a finding; because it most definitely is one!\n\n## The Impact: Medium\n\nLet's delve into the impact of this scenario. Suppose someone wins the lottery but has no fallback function. Or worse, if the winner is a smart contract and they forget to add a fallback or receive function. In such cases, that transaction would simply revert, which is obviously not the end of the world.\n\nHowever, another person could simply enter and win the lottery. Although this might seem like a simple solution, it could potentially waste a lot of gas. What if most people who entered the lottery were all using smart contract wallets? The process of selecting a winner could possibly take an excruciatingly long amount of time.\n\n#### Breaking Down the Impacts\n\nThe situation becomes dire when we consider the instances when manipulations for the winner selection come into play. This issue could seriously hamper the functionality of the protocol leading to a significantly hard start to a new lottery game. The reversion due to all the smart contract wallets makes the situation worse.\n\nThis slightly expensive process isn't easy to deal with, mainly because it needs a lot of users who aren't aware of this problem. So, we can safely classify this impact magnitude as medium.\n\nIn essence:\n\n> The function, intended to reset the lottery, could revert multiple times thereby making the reset of a lottery a challenging task. This situation could lead to a severe disruption in functionality. Moreover, winners would end up not receiving their payout, and their money could be taken by someone else.\n\n## Detailed Write-up\n\nFor those looking for a quick way to understand all that's happening, this write-up is here to help. We have classified this finding as a 'medium-impact' issue.\n\nThe major problem occurs when smart contract wallet raffle winners without a receive or fallback function block the start of a new contest. This problem arises if the winner, who happens to be a smart contract wallet, rejects payment. This situation can lead to the lottery not restarting.\n\nHowever, users can easily call the winner function again, and non-wallet entrants could still enter. But it could increase the cost significantly due to the duplicate check, and consequently, resetting the lottery becomes a challenging task.\n\n## Proposed Mitigation Techniques\n\nThough this situation sounds bleak, there are ways in which this issue can be mitigated. For instance, the protocol could avoid smart contract wallet entrants. That said, this isn't recommended because, for instance, we would still want multisigs to be compatible with the protocol.\n\nA plausible recommendation here would be to create a map of addresses to payout amounts, enabling winners to pullout the funds themselves with a new 'claim prize' function. Essentially, we are shifting the responsibility of claiming the prize to the winner, a method referred as 'pull over push'.\n\nThis method is particularly efficient and considered as a best practice. By pulling their money out, users avoid any issues that arise from money being pushed to them, such as reversion.\n\nThis audit discovery has been an intriguing journey, one that has strengthened our understanding of blockchain verification and smart contracts. Stay tuned for more!\n",
          "updates": []
        },
        {
          "lessonId": "24ea49ec-c15f-46d4-8f90-6830938e381d",
          "number": 61,
          "title": "Reporting: Mishandling Of ETH",
          "slug": "reporting-mishandling-of-eth",
          "folderName": "61-reporting-mishandling-of-eth",
          "description": "",
          "duration": 2,
          "videoUrl": "2LyvvOxGqKI",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/61-reporting-mishandling-of-eth/+page.md",
          "markdownContent": "---\ntitle: Reporting - Mishandling of Eth\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Extracting Value in Smart Contracts: MEV, Mismanagement, and Griefing\n\nHey, there! Have you ever wondered about some nuisances involved when interacting with smart contracts, like Miner Extractable Value (MEV), mishandling of ETH, or griefing attacks? Well, you're in the right spot! In this blog, we'll explore these issues, which even though we've touched on already, warrant a deeper dive. Disclaimer: This post won't be a comprehensive guide on MEV, as that's a topic for another time.\n\n![](https://cdn.videotap.com/NqCVyQXfwU8fKONZhudq-4.23.png)\n\n## Miner Extractable Value (MEV): A Brief Introduction\n\nFirst off, we need to understand that well-engineered smart contracts have provision for fees. These fees act as incentives for miners to prioritize transactions. But in scenarios where users compete for these fees, it gets trickier. Fees withdrawal can become challenging if there are active players. This is what we refer to as _Miner Extractable Value (MEV)_. It means that miners can choose transactions based on the fees they might earn from them, giving them significant power.\n\n```markdown\nNote: I'll provide a thorough write-up on MEV in a future post. So, stay tuned!\n```\n\n## ETH Mishandling: Unintended Barriers\n\nNext, let's talk about ETH mishandling that often stems from imperfectly written smart contracts. Imagine a line of code in a smart contract that creates needless complications. We've got an example here to demonstrate what we mean.\n\nIn an (admittedly poor) implementation of a raffle system, if someone calls `enterRaffle`, a certain amount of ETH gets locked. The issue arises when the contract checks for exact equality; if the values aren't directly equal, the function will fail, making it incredibly hard for this person to withdraw fees.\n\nClearly, this makes for terrible user experience, as well as poor contract design. It's a glaring example of a line that needs to be pulled out to enhance the contract's reliability and usability.\n\n## Griefing Attacks: Watch Out!\n\nUsers could also just be jerks and not let you withdraw your money. Just instantly enter the raffle every time a new raffle starts, right? That would suck. And you'd never be able to get your money out. So uncool.\n\nAll these issues become painfully obvious when thoroughly auditing a smart contract and with practice you'll get better at spotting them.\n\n![](https://cdn.videotap.com/Zw8G2tXiZWXa0p4wmsR7-67.66.png)\n\n## Wrapping Up\n\nThere you have it! A quick tour through some common problems you might encounter when working with smart contracts. Yes, the rabbit hole goes a lot deeper, but we've covered some good ground here. Keep the conversation going and share your experiences in the comments! Remember, we're in this together ‚Äî let's turn those bug-infested lines of code into flawless protocols.\n\nAnd don't forget, I'm prepping a dedicated MEV post ‚Äî watch out for it soon. Thanks for reading!\n",
          "updates": []
        },
        {
          "lessonId": "9fd225bc-0235-4198-9c75-dfa5996e307d",
          "number": 62,
          "title": "Reporting: Missing Events And Remove Dead Code",
          "slug": "reporting-missing-events-and-remove-dead-code",
          "folderName": "62-reporting-missing-events-and-remove-dead-code",
          "description": "",
          "duration": 2,
          "videoUrl": "IBlx6kEs5AA",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/62-reporting-missing-events-and-remove-dead-code/+page.md",
          "markdownContent": "---\ntitle: Reporting - Missing Events And Remove Dead Code\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n## Highlighting Missed Events\n\n![](https://cdn.videotap.com/zp5mNIar5lB4Y3OaVHnR-8.png)\n\nWhen implementing state change in a code framework, it's absolutely necessary to emit appropriate events for accurate tracking. However, there are instances when this isn't done, leading to missed events.\n\n```markdown\nI6: State changes are missing events\n```\n\nA plethora of tools are available in the bustling code-tools market that can help us keep track of these events. Yet, sometimes, they slip through the cracks.\n\n![](https://cdn.videotap.com/GMx8kM6vB9arnwQhLFYV-20.png)\n\n> \"Anytime you change the state, you really want to emit an event.\" - A friendly piece of advice from any competent code auditor.\n\n## Indices and their Mysterious Absence\n\nRenowned programming expert, Darren In, also sparked an interesting conversation about the absence of index fields for events. This could potentially be a significant point to include in our audit report.\n\n```markdown\nI6(a): Events are missing index fields\n```\n\nThese findings, along with meticulous details, are included in the comprehensive audit report located in our trusty GitHub repository.\n\n![](https://cdn.videotap.com/W1YshpXSv8o0UmmhuNi1-38.png)\n\nThough I won't be jotting down the specifics about this finding in this blog, I ensure you that it's well-detailed in the report.\n\n## The Ghost Code\n\nNow, we move onto a curious scenario. We stumble across a function called `isActivePlayer` only to discover it‚Äôs just sitting idly in our code - not being used at all. This infamous phenomenon, dear readers, is referred to as \"dead code\".\n\nIt‚Äôs like a phantom, haunting our codebase, and it can be effortlessly picked up by popular code-analysis tools. One we found effective was `Slither`.\n\n```markdown\nI7: Function ‚ÄúisActivePlayer‚Äù is never used and should be removed.\n```\n\nYou may have been deceived into thinking that dead code is harmless, but, in fact, it can affect computational performance by causing wastage of resources or increasing execution time. Hence, dead code can impact gas optimization in blockchain applications, or be just an informational note that triggers an urge to tidy up the code.\n\n![](https://cdn.videotap.com/Q7TwomNJdyWc4hcSJeU1-54.png)\n\nI'll let you in on an insider tip - explaining what impact our ghost code might have on our overall framework reinstates the necessity and urgency of removing it.\n\n## Parting Words\n\nOur journey through this maze of debugging might have been a rollercoaster ride or a walk in the park - I guess we'll never know until we adventure again!\n\nBut that's the beauty of debugging, isn't it? It constantly keeps us on our toes, helping us uncover hidden doors to knowledge. Until next time, happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "8c41603b-156e-45b6-b603-b16525403bdf",
          "number": 63,
          "title": "Adding The Audit To Our Portfolio",
          "slug": "adding-the-audit-to-our-portfolio",
          "folderName": "63-adding-the-audit-to-our-portfolio",
          "description": "",
          "duration": 6,
          "videoUrl": "WHv5aiE05Eo",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/63-adding-the-audit-to-our-portfolio/+page.md",
          "markdownContent": "---\ntitle: Adding The Audit To Our Portfolio\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Turning Your Audit Writeup to a PDF: A Guide\n\nIn our last session, we journeyed through the process of auditing, identifying issues and documenting them in a simple writeup. But now, we're not just done yet, we are going to elevate the sophistication of this documentation by making it a professional looking audit report. So, why don't we take that writeup, turn it into a PDF, and then pop it in our portfolio for the world to see? Let's dive in!\n\n## Preparation Steps\n\nFirstly, in case you want to add more detail or want to write up some of the issues I glossed over, navigate to the audit data branch, go into the audit data folder, and add in your missing pieces. You can test your writing skills there.\n\n![](https://cdn.videotap.com/rGjBIrugIYzuJVsGkbGc-45.29.png)\n\nMoving on, navigate to our audit data folder. Now, we are going to fetch and add some components to our report like the PDF logo. You can also use the Cyfrin logo (just copy paste it into your own files) or you can add whatever image you deem fit.\n\nYour findings are to be added to a Markdown file like `report.md`. If unsure about structure, refer to an example Markdown file.\n\n![](https://cdn.videotap.com/bsXkFfHK0gAQJNqbyNYr-79.26.png)\n\n## Creating the Markdown File\n\nNext, grab the whole thing and paste it into a new file named `reportformatted.md`. Modify the placeholder fields to fit your data (for example, change the date to November 1, 2023), the packages field, the auditors, etc.\n\nFor fields like the 'Protocol Summary' and 'Audit Details', feel free to copy information from the README file or from actual data in the original audit data branch.\n\nFor the 'Executive Summary' field, here's a chance to experience a bit of fun. Write something engaging yet professional such as, _I loved auditing this. Brilliant code base. It was fascinating to decipher Patrick's intentionally arcane code!_\n\n## Compiling the Data\n\nWhen done, it's time to fill in the 'Issues Found' field. Here's a little trick: Go back to your findings and count the different types of issues categorized based on severity - high, medium, low - and type - gas issues, info issues, etc.\n\n![](https://cdn.videotap.com/XsF2knmP2jeZvg1FuKHO-158.52.png)\n\nFor instance, if you found three high, three medium, one low, seven info, and two gas issues, these amounts to a total of 16 findings. Interestingly, in an actual audit environment, this is greatly impressive.\n\n## Formatting the Document\n\nContinue by ensuring your issues are properly formatted in your Markdown file. Now, your document should look ready and well outlined, albeit sprinkled with some odd pandoc characters.\n\nFinally, we're going into the README to add our findings. Make sure you have the `pandoc` and `Logopedia` packages installed. To compile your markdown document into a sleek PDF, run this command in your audit data folder:\n\n```bash\npandoc report_formatted.md -o report.pdf --from markdown --template=eismogel --listings\n```\n\n![](https://cdn.videotap.com/0ZjWWIEWR93EgxbPKJGG-237.77.png)\n\nRunning this should generate a beautiful looking PDF with all the valuable findings from the audit effort.\n\n## Showcasing Your Work\n\nAt this point, you can marvel at your work and offer yourself some well-deserved congratulations. What next? Time to showcase this piece. Navigate to your GitHub profile, grab the file, add that PDF and the Markdown file to your profile.\n\nThe beauty and professionalism of an audit report exhibit your skill and finesse to potential clients or employers. So, building a portfolio on GitHub, like large audit firms do, increases your visibility and proves that your expertise is no fluke.\n\n> In the world of auditing, reports are regarded as trophies. They serve as a testament to your experience and expertise. So, always remember to display them proudly.\n\n![](https://cdn.videotap.com/2Pk62x098E14kLH3rsap-328.35.png)\n\nTo wrap up, this guide has shown you how to take your simple writeup and turn it into an impressive audit report in the form of a well-structured PDF. Congratulations on this milestone! You've done phenomenal work and you're one step closer to becoming a seasoned auditor. Remember this is your portfolio, so call it as you wish and don't be shy to show off your accomplishments. After all, the world is waiting to see them!\n",
          "updates": []
        },
        {
          "lessonId": "a94fec74-bad9-491f-bf90-8e96ceeb6f83",
          "number": 64,
          "title": "Exercises",
          "slug": "exercises",
          "folderName": "64-exercises",
          "description": "",
          "duration": 5,
          "videoUrl": "rhg5N8zjkFw",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/64-exercises/+page.md",
          "markdownContent": "---\ntitle: Exercises\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Harnessing the Power of Protocol Auditing and Security: A Deep Dive\n\nIn the vast, ever-expanding universe of Web3, auditing and security are two paramount pillars that reinforce the strength and dependability of our digital arena. It's an extensive journey and, yes, it may involve a lot of moving parts. But remember, while you may find it overwhelming at times, your heroic efforts in protocol auditing are protecting the glorious realm of Web3 from malicious attackers.\n\nIn today's post, we'll dig deeper into the world of codebase auditing, explore classic exploits, and guide you through some exercises that can help bolster your skills. So grab your gear, and maybe a double scoop ice cream for the ride, because we're diving in!\n\n![](https://cdn.videotap.com/JkvEJbq7u3RlIes0Sb61-20.74.png)\n\n## Training Grounds: Exploits Minimized Git Repository\n\nTo hone your skills, you must first be appropriately trained, and what better place to begin than the `exploits minimized git repo`?\n\nThe repository offers a treasure trove of coding examples, challenges, and exploits, such as reentrancy, mishandling of ETH, weak randomness access controls, and much more. If you need a sandbox to play around and experiment, Remix is embedded into the repository for your convenience. This extensive library of exploits will help you familiarize yourself with the intricacies of potential vulnerabilities and enable you to secure your code better.\n\nYou can find a link to [`Remix`](https://remix.ethereum.org/).\n\n### Ethernaut: Codebase Challenges Levelled Up\n\nIf you enjoy the thrill of gamification, Ethernaut offers an exciting alternative to practice your skills. Although it requires a decent understanding of JavaScript, the platform builds a compelling and engaging structure around learning exploits.\n\n![](https://cdn.videotap.com/pcyARKhhtGvEJQvH4MaI-69.14.png)\n\nThe game hosts a diverse catalog of codebase challenges and allows you to practice different exploits in an interactive way. Considering starting with 'Hello Ether' to get the hang of the platform's interaction. However, if JavaScript is not your forte, you can still interact with the contracts on Etherscan or Forge.\n\nYou can access `ethernaut` [here](https://ethernaut.openzeppelin.com/).\n\n### Damn Vulnerable DeFi: Real-life Challenges\n\nA step-up from Ethernaut, the damn vulnerable DeFi (DvDeFi) platform, hosts a selection of real-world DeFi-related challenges, that simulate possible vulnerabilities in DeFi protocols.\n\n![](https://cdn.videotap.com/Z24KmWHF5WMJZtrT8KiH-103.71.png)\n\nThough these challenges may be more complex than Ethernaut's, they offer an invaluable perspective into scenario-based exploits and understanding how to shield against them. Each challenge's context and contracts are explicitly provided, which you can either execute directly on Hardhat or copy-paste into Forge and try to crack.\n\nAccess `Damn Vulnerable DeFi` [here](https://www.damnvulnerabledefi.xyz/).\n\n> \"DvDeFi challenges replicate real-world security scenarios, granting you a near-authentic experience of interacting with and fortifying protocol vulnerabilities.\"\n\n### Case Studies: Learning from Real-world Attacks\n\nFor a comprehensive understanding of how these exploits take place, we can learn a ton by studying examples of real-world attacks. A curated list of reentrancy attacks, compiled by Pascal, provides a deep dive into various case studies and how these incidents unfolded in reality.\n\nAccess the `Case Studies` [here](https://github.com/pcaversaccio/reentrancy-attacks).\n\n## In Closing\n\nWith your newfound tools and knowledge, it's time to dive in and start practicing. Good luck, ethernauts, and remember, the digital realm you protect is entirely worth your dedication and effort.\n",
          "updates": []
        },
        {
          "lessonId": "245558bd-9ab1-4fb1-a429-07d8623e5d3c",
          "number": 65,
          "title": "Solodit",
          "slug": "solodit",
          "folderName": "65-solodit",
          "description": "",
          "duration": 3,
          "videoUrl": "kYJbU8dIQFs",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/65-solodit/+page.md",
          "markdownContent": "---\ntitle: Solodit\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Level Up Your Security Game with Solodit\n\nAnybody who aims to excel in competitive audits and enhance their grasp of Web3 security should pay attention. The secret tool you need to get an edge? It's called Solodit, a phenomenal hub that collates all security reports in one place. Whether you're a budding researcher or a seasoned auditor, Solodit can help you stay on top of your game.\n\n![](https://cdn.videotap.com/9jUjFBlxSuhDXx6ob1Uv-17.43.png)\n\n## Solodit: Knowing the Powerhouse\n\nLet's understand what makes Solodit a favorite tool for top competitive auditors. Picture this: Hans Friese, the top auditor for the first half of 2023, amassing an impressive figure of approximately $130 million. How did he reach this level of expertise? His winning strategy was to learn from other auditors and their reports. He used Solodit to expand his knowledge, which solidified his position as the world's number one competitive auditor (pun intended).\n\nSolodit brings the latest and greatest security findings under one roof, positioning itself as an unbeatable resource for aspiring auditors and security enthusiasts. It lets you follow the trail of other auditors, helps you keep up with the latest, and allows you to stay one step ahead of potential attackers.\n\n> \"Solodit is a 100% must-do for people who want to get better at security and especially for those who want to excel at competitive audits. Studying the latest and greatest findings is the way you're going to stay ahead of the game and continue to keep the attackers at bay.\"\n\n## Getting Started with Solodit\n\nSign up on Solodit to kickstart your journey to becoming a master security researcher. You will be greeted with an intuitive interface with a findings search index. Say you need to explore high reentrancies ‚Äì you can do a search and find related reports from other auditors. In short, Solodit serves as your one-stop solution to learn from the pros.\n\n![](https://cdn.videotap.com/a9jxnlI8mzpdQV3RFFii-95.86.png)\n\n## Digging Deeper: Features Overview\n\nOne of the most valuable features of Solodit is the aggregated reports from smart contract auditing firms and competitive audits. It helps you kickstart your day by browsing the latest and greatest reports from other auditors.\n\nThe audits page within the tool shows you ongoing contests, a timeline view of competitive audits in operations such as the Viper compiler, the Steadyfi, and more. You can easily dive into any of these competitive audits.\n\nA feature that deserves a special mention is the search for different bug bounties. It's no secret that finding and patching bugs can be quite rewarding. Solodit makes it easy for you to search for bug bounty programs, check their ratings, and understand how lucrative they might be.\n\n![](https://cdn.videotap.com/l6kCWJDKA8WMasYYpsMV-139.43.png)\n\nThe platform also includes a leaderboard tracking top competitive auditors. You might even catch Hans there! The leaderboard is a great way to measure your progress against others in the auditing field.\n\nLastly, with the added feature of note-taking, Solodit stands out from other tools. You can jot down notes about your findings or valuable insights from other people's reports. This personalized knowledge repository can help you enhance your skills as a smart contract security researcher.\n\n## The Bottom Line\n\nBecoming a successful security researcher or a leading smart contract developer requires continuous learning. Solodit provides a unique platform that allows you to effortlessly learn, compete, and evolve as a professional in the sector. Consider it as your personal go-to learning and resource tool for staying abreast of industry developments. If you aspire to lead in the world of smart contract security, signing up for Solodit is a no-brainer.\n",
          "updates": []
        },
        {
          "lessonId": "a5810a91-3839-4aa1-8bc3-f235e17d4ff8",
          "number": 66,
          "title": "Wrapping Up",
          "slug": "wrapping-up",
          "folderName": "66-wrapping-up",
          "description": "",
          "duration": 2,
          "videoUrl": "K9vSvvqmQls",
          "rawMarkdownUrl": "/routes/security/4-puppy-raffle/66-wrapping-up/+page.md",
          "markdownContent": "---\ntitle: Wrapping Up\n---\n\n_Follow along with this video:_\n\n## \n\n---\n\n# Celebrating Your Accomplishments and Preparing for the Next Challenge in Crypto-Audit\n\nHooray for you! You have successfully completed your puppy raffle audit. If you're wondering what's next, you're in the right place. Let's not keep that excitement to ourselves.\n\n## Post a Tweet About Your Achievement\n\n![](https://cdn.videotap.com/IWZnrLvTfiL85XHWN2bU-13.04.png)\n\nGo ahead and share your success on Twitter. There's no better way to share the news than a straightforward, cheerful tweet. If you're not sure how to compose your tweet, don't worry. I got you covered.\n\n> \"Celebrating your wins publicly not only helps you keep track of your progress but also encourages others to keep going.\"\n\n## Try Farcaster: A Web3 Social Media\n\nAs you continue your foray into the crypto-space, why not check out a more Web3 focused social platform? I'd recommend signing up for [Farcaster](https://www.farcaster.xyz/), a new venture into decentralized social media. It's an exciting area to explore alongside your security auditing work.\n\n## Do a CodeHawks First Flight\n\nNow that you have a puppy raffle audit under your belt, it's a great time to embark on a CodeHawks First Flight. These missions are designed specifically for someone like you‚Äîsomeone who understands security, knows Solidity, and wants to start working on fast-paced, competitive audits and expand their skill set.\n\n![](https://cdn.videotap.com/sMsQtEf4Y3DDqWTXFU5d-60.85.png)\n\nThe great thing about CodeHawks First Flights is that they can be quick to start and complete. Jump in and try any active first flight. If you're in a competitive mood, you can even attempt a full competitive audit. But no pressure, if you'd rather wait and focus on deepening your understanding of DeFi security, rest assured there are some powerful DeFi security review sessions coming up soon.\n\n## Commend Yourself for The Milestone Achieved\n\nRegardless of what you choose to do next, take a moment to pat yourself on the back. You've made it this far and it's no small feat. You've gotten a real feel for what it's like to be a security researcher‚Äîdiving into code bases, writing reports, looking for vulnerabilities, and spotting potential bugs based on past experiences.\n\nRemember, in this field, repetition is the name of the game. The more audits you carry out, the more skilled you will become.\n\n```js\nconsole.log(\n  \"Congratulations on getting this far! Now, go enjoy some ice cream.\"\n);\n```\n\n## Looking Ahead\n\n![](https://cdn.videotap.com/Rh51wSen1dPnlsxoPHB8-95.62.png)\n\nHaving savored your victory, get ready for the next level of challenges. Find us in our next section, where we'll delve deep into invariants and DeFi with T-Swap. So far, it's been fun and games, but we're about to broadly level up your skill set.\n\nUse this break to tweet or cast about your experiences, then gear up for the upcoming section. I'm excited to see you back here soon! Until then, continue celebrating, and remember - every success in crypto-audit is another leap forward in this world of blockchain and decentralized ledger technologies.\n\nBye for now, and see you soon in Section Five!\n",
          "updates": []
        }
      ]
    },
    {
      "sectionId": "a5e8a426-8db9-4b0e-934e-6dfdabf202c4",
      "number": 5,
      "title": "TSwap",
      "slug": "tswap",
      "folderName": "5-tswap",
      "lessons": [
        {
          "lessonId": "e420cca9-92f8-48e4-ae32-33c55034fed8",
          "number": 1,
          "title": "Introduction",
          "slug": "introduction",
          "folderName": "1-introduction",
          "description": "",
          "duration": 5,
          "videoUrl": "3_dZJDTzM1g",
          "rawMarkdownUrl": "/routes/security/5-tswap/1-introduction/+page.md",
          "markdownContent": "---\ntitle: Introduction\n---\n\n_Follow along with this video:_\n\n\n\n---\n\n# Unveiling Invariance and DeFi in Security Auditing: An Interactive Exploration\n\nHappy to have you back in the exciting world of Security and Auditing. So, you‚Äôve made it through the delightful puppy raffle, you have ideally signed up for Codeox and might have sprung into your first few flights or even explored a contest. That's awesome! You'd certainly be exuding more confidence about your security and auditing journey. But there's a lot more to unfold and absorb.\n\n## Entering Section Five: Invariance and Introduction to DFI T-SWAP Audit\n\nIn our detailed Git repo related to this course, when you scroll down, Section Five, Invariance and Introduction to DFI TSWAP Audit, will catch your attention. Making your journey a slight bit more interesting this time, we are moving onto another walkthrough security review. This time around, we will approach the task differently.\n\n![](https://cdn.videotap.com/y4z5tLc5N9gtADQGQSGP-43.5.png)\n\n## A Glimpse of What‚Äôs to Come\n\nDo not rush into the contracts yet, there‚Äôs plenty to learn before that! We will cover a lot in this section, a prime focus will be on 'Invariance'. Though we've touched upon invariants in the Foundry Course, we never really delved into their significance, and when it comes to security, that's when you realize how crucial they are.\n\nAs a budding security researcher, it‚Äôs critical to understand and appreciate the weight that invariance carries. You'll learn to identify bugs without even looking at the code in-depth. Of course, this shouldn't be your only strategy in a security review, but through this session, we're demonstrating how critical and potent it can be.\n\nWe will be wielding an array of powerful tools, such as stateful fuzzing and fuzzing invariance. If you‚Äôre unfamiliar with freepy, don't worry, we will explore that as well.\n\n![](https://cdn.videotap.com/vxJBy007OWXoaJWFjk6V-97.88.png)\n\n## Dive Deeper into DeFi\n\nDeFi experienced a surge in popularity recently. For those unfamiliar, DeFi, or decentralized finance, refers to financial services that are available on a public decentralized blockchain network. It eliminates the need for intermediaries and allows for a more open financial system.\n\nDespite the intricacy, DeFi is relatively straightforward to grasp. With patience and perseverance, you will understand it. It's a concept that can seem daunting initially due to the complex terms used. In reality, most of the concepts are based on basic math.\n\nWe will dissect the Uniswap Protocol or the T swap protocol, a Decentralized Exchange in DeFi, and demystify it for better understanding. As we dive into the security review, we will use a myriad of robust tools to hack into the system.\n\n> \"A little progress each day adds up to big results.\"\n\nThis quote embodies the essence of our entire journey here. By the end of this section, you will have practically audited an entire Uniswap V1 in the audit data folder.\n\n![](https://cdn.videotap.com/v1Dx6md72HKpatpU5PgM-195.75.png)\n\n## A Bag Full of Exploits and Tooling\n\nAfter diving under the hood of DeFi, we're going to learn a slew of new hacking techniques and tools. These include exploring esteemed toolkits like Echidna Foundry, examining concepts like consensus mutation testing and differential testing, and studying properties and exploits such as Weird ERC-20s callbacks, rebates, reentries, and core invariant breakings.\n\nThe prime focus for this session will be on understanding DFI and Invariance. Roughly going to the end of this section, you will have the experience of practically auditing the first-ever Uniswap created (Uniswap V1), commodities with a few of the bugs that I stumbled into during my journey.\n\n## Get Set Go!\n\nWith everything I've shared with you, brace yourself for a thrilling juncture in Security and Auditing. Let's put on our thinking caps, get our VS code and popcorn ready, and dive right into T Swap. Together, we will crack the code and delve deeper into the world of DeFi.\n",
          "updates": []
        },
        {
          "lessonId": "8cd1ab7c-5005-41ec-93c7-86d7fb7b41a0",
          "number": 2,
          "title": "Phase 1: Scoping",
          "slug": "phase-1-scoping",
          "folderName": "2-phase-1-scoping",
          "description": "",
          "duration": 9,
          "videoUrl": "OtgqBI33gCI",
          "rawMarkdownUrl": "/routes/security/5-tswap/2-phase-1-scoping/+page.md",
          "markdownContent": "---\ntitle: Phase 1 - Scoping\n---\n\n_Follow along with this video:_\n\n\n\n---\n\n## Cloning the Repo\n\nFirst things first, let's clone the repository into our security course directory as usual. Opening the repository link in a new tab, we copy the URL and perform a standard `git clone`. Let's paste this into our command line\n\n```bash\ngit clone https://github.com/Cyfrin/5-t-swap-audit\n```\n\nThis opens the 5 TSWAP audit into its own unique folder‚Äîan essential process for good workflow and code organization. To verify that all is well and we are on the correct branch, we run `git branch`.\n\nAs expected, we are on the main branch. This serves as our starting point for this eye-opening security review.\n\n![](https://cdn.videotap.com/3aVlKcGZ2t6Didb1YvL3-95.09.png)\n\n## Extensive Onboarding: Why It's Key\n\nAs we revisit the well-known Puppy Raffle, whose initial setup used basic onboarding, we delve into the importance of extensive onboarding, particularly for a TSWAP audit.\n\nThrough this review, you'll realize why taking the time to answer extensive onboarding questions is so crucial. The information collected in this process becomes a treasure trove for any security review‚Äîmore so if questions are as painstakingly detailed as possible. That's why you want to gather as much information as possible, get your fingers everywhere credible!\n\n## Gathering the Important Data\n\nOur onboarding sheet collects basic information such as the website URL, which could have a wealth of information. It also enforces the absolute necessity of associated documentation‚Äîa critical pillar for achieving any successful code review.\n\nFor our TSWAP audit, the README file plays a pivotal role as our most accessible source of documentation. We also capture the point of contact, white paper, and commit hash.\n\nOn a regular audit, we'd swap branches to the commit hash to ensure we're working on an identical codebase through the command `git checkout \"[paste commit hash here]\"`. In this tutorial, however, we'll stick with the main branch.\n\n## Checking Codebase Size and Interactions\n\nOur TSWAP repository has two contracts in scope: Pool Factory and TSWAP. A scroll through the SRC shows that these are the only contracts in action, with a SLOC (Source Lines of Code) of 374. This figure, being double the size of our previous Puppy Raffle review, gives us a mental image of review duration based on code length and complexity.\n\nWe head into uncharted waters with a crucial question: How many external protocols does the code interact with? Though new to this discourse, you'll discover the answer's importance in due course.\n\n## Test Coverage: A Total Nightmare\n\nA cursory look at the test coverage (a dismal 41%) sets off alarm bells. By delving into the README file and running `make` on our command-line interface‚Äîwatching as it triggers installations‚Äîwe can see the extent of the test coverage‚Äîthe bedrock of any software project.\n\n![](https://cdn.videotap.com/CsI8uiOgGgscAECYBaRW-297.16.png)After a round of `forge coverage`, we cringe at the test coverage results. A low coverage figure, such as the 40% and 37% for functions and branches respectively that we are staring at, is a bright red flag for bugs galore!\n\nOnce this alarming discovery is made, we must revert to the main branch using the commands `git stash` and `git checkout main`. We must also run `make` to commence another series of installations.\n\nNo sooner are these installations done that we return to business‚Äîour comprehensive onboarding documentation.\n\n## Scope, Scope File and Building Protocol Context\n\nOur review scope is now clear: the Pool Factory and TSWAP. With commands `make scope`, and `make scope file` we generate an output and file that are incredibly compatible with pandoc‚Äîa documentation generation tool we love.\n\nNow that the scope is clarified, we delve deeper into protocol understanding. Here, we ask questions like whether the project is a fork of an existing protocol, or if it uses rollups. Such queries, though seemingly unrelated to the immediate task, bear great significance later in the course.\n\nIn our case, our protocol is a new standalone rather than a fork of an existing one (Uniswap V1 for this instance). It doesn't use rollups or have multi-chain functionalities. It operates exclusively on Ethereum, sans the use of oracles or zero-knowledge proofs. It does interact with ERC20 tokens though, a factor you will get a clear understanding of once we delve into the protocol explanation.\n\n## More Onboarding Questions\n\nDuring protocol onboarding, it's essential to engage in a deep and meaningful conversation with the protocol team about protocol risks. Questions about rogue protocol admin capturing fees, inflationary deflationary ERC20, fiat transfer tokens, and rebasing tokens will often receive dismissive or uninformed responses.\n\nProtocols will often deny known issues or prior audits, as seen in our onboarding document. These points, however, form a vital part of building context resources, hence their import.\n\nThe README file plays a crucial role in this process but often falls short in providing adequate information. At this point, you'd reach out to the protocol team requesting walkthroughs, explainer videos, charts, or even a blog post‚Äîanything to build up an adequate information base.\n\nRemember, the developers of a protocol always possess more context than you'll ever get from code alone. Thus, asking them questions will accelerate your understanding. While it's critical to trudge through the codebase independently, reaching out when stuck can lead to faster solutions.\n\nNotwithstanding, remember to use the protocol team's time wisely and avoid asking basic questions like \"what's UN 256\". Your questions should reflect a deep understanding of the protocol and be geared towards obtaining further understanding.\n\n## Wrapping Up\n\nOur extensive onboarding not only prompts critical questions but also provides ready answers where possible. Obtaining answers to 'rec test' questions and understanding their post-deployment plans is easier when conducting a private audit. However, in a competitive audit setting, this information might not come as readily.\n\nIn summary, this T-SWAP audit tutorial shows just how comprehensive and detailed a security review can be. From cloning repositories and capturing enormous amounts of data to conversing with the protocol team about potential risks‚Äîevery stage carries its weight of importance. So, buckle up, ask questions, and dig into those reviews with gusto!\n\nKeep an eye on this space, and let's explore more interesting protocols next time.\n",
          "updates": []
        },
        {
          "lessonId": "cc17642d-b651-4008-9c54-9c65032f9a91",
          "number": 3,
          "title": "Primer On This Review",
          "slug": "primer-on-this-review",
          "folderName": "3-primer-on-this-review",
          "description": "",
          "duration": 2,
          "videoUrl": "VCkuWCykYWg",
          "rawMarkdownUrl": "/routes/security/5-tswap/3-primer-on-this-review/+page.md",
          "markdownContent": "---\ntitle: Primer on This Specific Review\n---\n\n_Follow along with this video:_\n\n\n\n---\n\nWelcome, committed developers! If you've successfully traversed the onboarding phase of your latest project, not without its fair share of glitches, but overall a positive experience, let's now sail into the realms of uncharted territory. Here's where we dig deeper into documentation and imbibe the magic potion of protocol invariants. Sound unfathomable? Stay hooked!\n\n_\"Understanding a protocol's invariants is as crucial as security review itself, and it's possible to do one without opening any code.\"_\n\nSo buckle up for an intriguing journey of dissecting documentation, decoding protocol invariants, and their role in devising robust test suites.\n\n## **Unveiling Documentation**\n\nDocumentation serves as a treasure trove of virtues to get a deeper understanding of the codebase. Let's take a tour of the pertinent areas that call for focus and elaboration. Crystal clear documentation eases the complex process of security review, but‚Äîto our dismay‚Äîthat's not always the case.\n\nAt times, documentation may not do absolute justice in illustrating intricate processes or mechanisms. For these instances, we need to bolster comprehension using self-explanatory diagrams and choreographed video lessons.\n\n## **Impact of Base Protocols: Case of Uniswap**\n\nOur discussion takes a fascinating turn as we move onto the trading phenomenon of decentralized exchanges. The protocol under our scanner, TSwap, derives its inspiration from the Uniswap Protocol.\n\n![](https://cdn.videotap.com/40hr7aunyYjpIPhaqrYe-49.68.png)\n\n[Learn more about Uniswap here](https://docs.uniswap.org/)\n\nBy analyzing TSwap, you inadvertently learn a great deal about Uniswap. It will unveil underlying concepts such as Automated Market Makers (AMMs) and decentralized exchanges.\n\nThe significance of comprehending these principles becomes the focal point when conducting a _Decentralized Finance (DeFi) Security Review_. The term \"Raffle,\" if familiar, would sound synonymous in this context. The rule of thumb? Know about raffles if dealing with a raffle, understand decentralized exchange when handling a decentralized exchange!\n\n## **Exploring Protocol Invariants**\n\nNow, before plunging into the nitty-gritty of devising foolproof test suites, let's lay the groundwork and comprehend _protocol invariants_.\n\nProtocol invariants typically refer to properties in a system that remain unchanged irrespective of the sequence of operations. Essentially, during the security review of a codebase, it's vital to define and verify the protocol invariants.\n\n## **Testing the Waters: Prepping for Test Suites**\n\nIn the world of coding, defining and understanding protocol invariants occupies a paramount position before the creation of test suites. It devolves chaos into order, aligns our vision, and sets into motion a trajectory that ultimately leads us to the wonderland of our retrieved goal.\n\nTo sum up, navigating the labyrinth of code security review gets simpler if you devote sufficient time understanding the nuances of documentation, the influence of base protocols and the pivotal role of protocol invariants before crafting test suites.\n\nIn the words of a seasoned developer,\n\n> \"Understanding the precepts before jumping into action can make the journey less cumbersome and the destination more rewarding.\"\n\nSo let's make that journey, let's begin the rewarding read and understanding the documentation.\n",
          "updates": []
        },
        {
          "lessonId": "50ec6e20-7dd2-4a15-954f-67be45ea239d",
          "number": 4,
          "title": "What is a DEX?",
          "slug": "what-is-a-dex",
          "folderName": "4-what-is-a-dex",
          "description": "",
          "duration": 3,
          "videoUrl": "ujVitVpzdJo",
          "rawMarkdownUrl": "/routes/security/5-tswap/4-what-is-a-dex/+page.md",
          "markdownContent": "---\ntitle: What is a DEX?\n---\n\n_Follow along with this video:_\n\n\n\n---\n\n# The Ultimate Guide To T-SWAP &amp; Decentralized Exchanges\n\n## Getting Started\n\nAre you familiar with the concept of decentralized exchanges or DEXes? Well, T-SWAP is a promising project and an upcoming player in this space. T-SWAP is meant to be a permissionless way for users to swap assets between each other at a fair price. What else does T-SWAP aim to do, you ask? Well, let's unravel its offerings.\n\n## The T-SWAP in a Nutshell\n\nImagine you're a user with ten USDC (a stablecoin pegged to the US dollar) and you want to buy WETH (Wrapped Ether, an ERC20 equivalent of Ethereum). T-SWAP essentially allows for this transaction to occur. In simple terms, a user starts with ten USDC and zero WETH, use T-SWAP to make a swap, and they will end with zero USDC and some WETH.\n\nYou can think of T-SWAP as a decentralized asset token exchange similar to popular platforms such as Coinbase or Robinhood. But it's not just another cryptocurrency exchange, it is powered by the concept of decentralization, offering a cutting-edge alternative to traditional exchanges.\n\n![](https://cdn.videotap.com/iTNZThQG62yyusiLZJVT-35.77.png)\n\n## Diving into Decentralized Exchanges (DEXes)\n\nA quick visit to DeFi llama, a popular site that tracks decentralized finance protocols, will give you an idea about the variety of DEXes in the market. From Uniswap, Curve, Balancer to SushiSwap, each of these platforms have unique code bases and different pros and cons.\n\n> \"DEXes are a revolutionary approach to asset exchange, veering from the centralised norm and offering an autonomous, often peer-to-peer, trading experience.\"\n\nT-SWAP, much like many of these exchanges, is also classified as an Automated Market Maker (AMM). If you are confused or intrigued at this point, don't sweat it. Here is an article on Chainlink Labs that provides a detailed walk-through of the AMM concept.\n\n## Introducing Automated Market Makers (AMM)\n\nDecentralized exchanges such as T-SWAP operate differently from traditional order book exchanges. This is where the concept of AMMs comes in. It makes use of asset pools rather than an order book for asset exchange.\n\nRemember, diving into the world of DEXes and AMMs can initially be challenging, but also immensely rewarding. So take the plunge, and happy learning!\n",
          "updates": []
        },
        {
          "lessonId": "dea61563-14e6-4c88-935e-4cbdc977f46a",
          "number": 5,
          "title": "What is an AMM?",
          "slug": "what-is-amm",
          "folderName": "5-what-is-amm",
          "description": "",
          "duration": 10,
          "videoUrl": "CDMlzkJmKwQ",
          "rawMarkdownUrl": "/routes/security/5-tswap/5-what-is-amm/+page.md",
          "markdownContent": "---\ntitle: What is an AMM & How AMM works?\n---\n\n_Follow along with this video:_\n\n\n\n---\n\n# Understanding Automated Market Makers: A Deep Dive into Decentralized Finance\n\nDecentralized finance is gaining popularity as the world turns towards blockchain technologies for secure, transparent financial transactions. Central to DeFi's attraction is the Automated Market Maker (AMM), a unique trading model that is reshaping our understanding of trading mechanisms. However, to grasp this concept effectively, let's first refresh our understanding of the traditional order book style of exchange.\n\n## The Traditional Order Book Style of Exchange\n\nImagine that you want to trade on Coinbase or Robinhood. Here's what that process might look like:\n\n1. You come to the exchange and say, \"Hey, I want one WETH (Wrapped Ethereum) for ten USDC.‚Äù\n2. You place an order that goes onto what's known as an 'order book.'\n3. Another user sees your trade and decides they're interested.\n\nIf the other user has one WETH and zero USDC, they might think your trade is reasonable and decide to take it. The system identifies these matched orders and facilitates the exchange. User A gives ten USDC to the system, which gives it to User B, and vice versa.\n\nThis model is commonly used by large, centralized exchanges; however, it does present a few challenges:\n\n- Every exchange transaction using Ethereum costs 'gas' (i.e., the cost of computation). This can rack up significant costs for users and could potentially deter people from using the platform.\n- With this style of exchange, a lot of computation work occurs behind the scenes. This complexity can hinder its full implementation on a decentralized platform like Ethereum.\n\nSo, knowing these limitations, Ethereum decided on an alternate approach.\n\n![](https://cdn.videotap.com/e4EULmEIKYejqgjYxvO4-189.76.png)\n\n## Enter the Automated Market Maker\n\nRather than placing orders and matching them as in an order book exchange, an AMM operates on the principle of liquidity pools.\n\nLet's visualize this using an example:\n\n1. Assume two giant pools of money or 'liquidity pools' exist ‚Äî one with 100 WETH and the other with 1000 USDC.\n2. User A wishes to buy one WETH with his ten USDC.\n\nAt this stage, a specific mathematical function comes into play:\n\n- The system calculates the ratio of WETH to USDC in the pools which is 1000 USDC / 100 WETH = 10.\n- So, the 'mock price,' as we are calling it, is 1 WETH = 10 USDC.\n\nNow, if User A wants to take one WETH out of the pool, he must ensure the correct ratio is maintained. So he puts ten USDC into the USDC pool, and only then can he take out one WETH.\n\n![](https://cdn.videotap.com/NDFbEb030FC4DlLUCFdR-355.8.png)\n\nThis alters the ratio in the pools. There are now 1010 USDC and 99 WETH. Recalculating, we see the ratio is now 1010/99 = 10.2. One WETH now amounts to 10.2 USDC - an increase of 0.2 USDC from the last transaction. By simply completing the transaction, User A has managed to move the market and change the price of WETH. This essentially resembles market dynamics breath the concept of supply and demand; as demand for an asset increases, so does its price, and vice versa.\n\n![](https://cdn.videotap.com/csLNwV1pl8cFQGODANry-379.52.png)\n\nThis same principle applies when User B wants to trade. They can keep changing the ratios by adding or subtracting amounts in these pools to trade their preferred amount, given that the ratio always is maintained. This AMM model is known as a 'constant product market maker,' a type of AMM that maintains a constant product of the quantities of the two assets.\n\nThe following code block presents an example of how this might be implemented programmatically:\n\nThis demonstrates how an AMM operates in a simple and efficient manner, bypassing the traditional challenges of an order book model. But, it is important to remember that this simple example doesn't capture the complexity and potential risks associated with real-world AMMs.\n\nAMMs are just one aspect of DeFi that is pushing the boundaries of what is possible in finance, allowing individuals to gain control over their financial interactions. However, it‚Äôs crucial to understand that, like any financial system, it comes with its own set of risks and challenges. Remember, your capital is always at risk when investing.\n\n_‚ÄúThe fascination of DeFi lies in the infinite possibilities it brings to the world of finance, pushing boundaries and creating opportunities.‚Äù_\n",
          "updates": []
        },
        {
          "lessonId": "08b67262-6849-4a51-b128-5a890f5b25a5",
          "number": 6,
          "title": "Liquidity Providers",
          "slug": "liquidity-providers",
          "folderName": "6-liquidity-providers",
          "description": "",
          "duration": 11,
          "videoUrl": "KcFGNXYagvM",
          "rawMarkdownUrl": "/routes/security/5-tswap/6-liquidity-providers/+page.md",
          "markdownContent": "---\ntitle: Liquidity Providers - Why AMMs have Fees?\n---\n\n\n\n---\n\n# Untangling Decentralized Finance: Understanding Automated Market Makers (AMMs)\n\nWelcome back to our deep-dive into the bustling world of decentralized finance. Today, we're unraveling the complexity of Automated Market Makers (AMMs) like Uniswap and Sushiswap, explaining how they facilitate trades and generate fees for liquidity providers. Let's get started!\n\n## What Makes An AMM Work?\n\nThe heart of an AMM like Uniswap resides in its liquidity pools. For simplicity, let's take an imaginary pool that contains 1000 USDC (United States Digital Coin) and 100 WETH (Wrapped Ether). This pool facilitates trades: for instance, someone could exchange 10 USDC for 1 WETH.\n\nBut there's more to it: after the trade, there's a new balance in the pool. With one WETH taken out and 10 USDC added, we now have 1010 USDC and 99 WETH.\n\nIMPORTANT: Remember, almost all AMMs also extract a small fee for each transaction, say, 0.3%. So, to trade 1 WETH, one might actually need to send 1.03 WETH, with the 0.03 WETH fee either going to its designated spot or staying within the pool.\n\nNow, you might be wondering if there's a loophole that allows you to make infinite money by continuously trading, but allow us to dash your dreams. AMMs have mathematical safeguards in place to prevent such abuse.\n\n## The Role Of Liquidity Providers\n\nWho funds these pools full of digital currencies, you ask? Enter the Liquidity Providers (LPs), the unsung heroes of the AMM system. They supply the assets to the protocol so individuals can perform swaps.\n\nWhen an LP adds their funds - for example, 1000 USDC and 100 WETH - they gain ownership of the pool equivalent to their share of total funds, which is represented by Liquidity Provider Tokens (LP Tokens).\n\nSo, by investing their assets into the protocol, LPs not only gain ownership but also earn a share of the transaction fees generated from the trades.\n\n## More About LP Tokens And Fees\n\nLet's investigate further into the LP Tokens and their relationship with fees. Say, a new liquidity provider, C, enters the pool with half of what A and B initially put in, essentially 500 USDC and 50 WETH. This, in turn, increases the total assets in the pool to 2500 USDC and 250 WETH.\n\nIn return for their contribution, liquidity provider C receives LP tokens. How many?\n\nWell, we can calculate that by taking the ratio of the funds they've added to the total funds, in this case, 0.2 (or 20%). Multiplying this by the total LP Tokens, we deduce that liquidity provider C will receive 50 LP Tokens, granted their contribution.\n\nConsequently, we now have a total of 250 LP Tokens in circulation. At this juncture, we also have a pool of 2500 USDC and 250 WETH ready for trades.\n\n## How Fees Make Money For Liquidity Providers\n\nThe burning question now is: How do liquidity providers make profits? The answer lies with the transaction fees mentioned earlier.\n\nEvery trade results in a fee that slightly adjusts the ratio of assets in the pool. For instance, if a user trades 10 USDC for 1 WETH, they're also charged a fee (0.3 USDC in our example), which changes the pool balances to 2510.3 USDC and 249 WETH.\n\nWhen a liquidity provider chooses to withdraw their funds, they can redeem their LP tokens for an amount of each pool asset proportional to their LP tokens. So, if Liquidity Provider C withdraws their 50 LP Tokens (representing a 20% stake), they'll get back their original investment plus their earned fees.\n\nLet's crunch some numbers:\n\n```markdown\n# Assuming 1 WETH is equivalent to 10 USDC\n\n# Initial Deposit: 500 USDC and 50 WETH\n\n# Amount Withdrawn: 502.6 USDC and 49.8 WETH\n\n# Equivalent to: 498 USDC + 502.6 USDC = 1000.6 USDC\n\n# Profit: 1000.6 USDC - 1000 USDC = 0.6 USDC\n```\n\nIt's by these accruing transaction fees that liquidity providers gain returns on their investments. The more trades executed, the more fees generated and the more money they make, providing an explanation regarding why so many are lured towards becoming liquidity providers.\n\n## Wrapping Up\n\nAt a high level, this is the underlying mechanism of an automated market maker like Uniswap. It might seem complex or counterintuitive at first, especially given the novel concepts and the involvement of mathematical models. But with some involvement and time, I assure you, it all starts making more intrinsic sense.\n\nIn the end, it's about providing liquidity, facilitating exchanges, and earning fees - all in a decentralized manner on the blockchain.\n\n> \"Decentralized finance might seem mesmerising at first, but when you dive into it, you realize it's all about providing liquidity, facilitating exchanges, and earning rewards ‚Äì all in a decentralized way on the blockchain.\"\n\nStay tuned for more deep-dives into the ever-evolving world of decentralized finance!\n",
          "updates": []
        },
        {
          "lessonId": "3a439ac2-6269-4ca3-9152-8fc65b99a683",
          "number": 7,
          "title": "How AMMs Work",
          "slug": "how-amms-work",
          "folderName": "7-how-amms-work",
          "description": "",
          "duration": 5,
          "videoUrl": "p779dDo6tFs",
          "rawMarkdownUrl": "/routes/security/5-tswap/7-how-amms-work/+page.md",
          "markdownContent": "---\ntitle: How AMMs Work Recap\n---\n\n\n\n---\n\n# Understanding Automated Market Makers, T-SWAP and Uniswap\n\nCramming a ton of concepts into one learning session can be overwhelming. But let's decode the concepts of T-SWAP or Uniswap, and how Automated Market Makers (AMMs) operate and differ from traditional order books.\n\n## Reviewing Traditional Order Books\n\nIn typical exchanges, a user may propose a trade, for instance, as wanting 1 ETH for 10 USDC. This proposal gets placed into an order book. Users are then able to propose their own trades or to accept others' proposals. This method is how a traditional centralized exchange operates, using the order book methodology.\n\nHere's a basic example:\n\n> \\[ User1: TRADE PROPOSAL ‚Äî 1 ETH for 10 USDC \\]\n\nHowever, a lot happens behind the scenes in this model. Orders are being matched, and with an extensive list of orders in their order books, this process can be highly gas-consuming, involving multiple transactions on the centralized exchange.\n\n**IMAGES HERE**\n\nThe challenge with decentralized finance (DeFi) is this model's costs. If many transactions lead to significant gas spending and if you have to wait for someone to accept your trade, it could take quite a few blocks. So, the question is ‚Äî how can we manage costs and keep trading to one transaction?\n\n## Introducing Automated Market Makers (AMMs)\n\nEnter AMMs, a solution to the above problems. Instead of an order book, we work with giant pools of money and utilize the ratio between these pools as the assets' price. To take money out of one pile, you need to put equivalent ratio into the other pile. This concept is known as the AMM, more specifically, the constant product market maker or constant product formula.\n\nAlso, each swap that users make on their smart contract collects an added fee. These fees incentive people to create and contribute to these money pools as liquidity providers actually make profit from these accumulated fees with more trades people make.\n\n## Understanding T-swap and Uniswap\n\nBoth [Uniswap](https://uniswap.org/) and T-swap use the AMM model. Uniswap, for instance, has gone through several iterations (v1, v2, v3 with v4 currently in progress), each slightly different but fundamentally based on the AMM's principles.\n\nWhen learning a protocol, consider taking a hands-on approach. Connect to the protocol through a secure wallet and test out transactions.\n\n> **NOTE:** The 'Discussions' tab, Piranha IO, the Ethereum Stack Exchange, Discord, and Telegram are invaluable resources for understanding novel solutions that developers and protocol creators are cooking up. Get comfortable asking questions, especially when conducting a private audit.\n\nWith time, the process becomes more navigable, allowing you to understand the protocols and begin tinkering with the code.\n\n## Building Context and Better Understanding AMMs\n\nLet's explore further. If unclear, don't sweat it. It's okay to not get everything right away ‚Äî continue to ask questions and gradually everything will fall into place.\n\nBrowse through the Git repo associated with the current section, go to the audit data branch, and take a good look at the accompanying diagrams. They will offer a good visual understanding of how these concepts interlock.\n\nTo better understand AMMs and keep up with the evolving world of DeFi, keep probing, keep asking questions, keep building context. No one method is a silver bullet ‚Äî the best way to learn is the way that works for you.\n\n> \"The more you work with it, the more sense it'll make.\"\n",
          "updates": []
        },
        {
          "lessonId": "82992418-cc58-44f2-834d-3a3450284f54",
          "number": 8,
          "title": "TSwap Recon Continued",
          "slug": "t-swap-recon-continued",
          "folderName": "8-t-swap-recon-continued",
          "description": "",
          "duration": 3,
          "videoUrl": "s0OdASrF98Q",
          "rawMarkdownUrl": "/routes/security/5-tswap/8-t-swap-recon-continued/+page.md",
          "markdownContent": "---\ntitle: T-SWAP Recon Continued\n---\n\n\n\n---\n\n# Decoding the AMM Swapping Process using Pool Factory Contracts\n\nIn our last conversation, we delved into the complexities of the AMM (Automated Market Maker) swapping process. This blog post builds on that foundation, unravelling other critical sections and explaining how a pool factory contract fits into the picture.\n\n![](https://cdn.videotap.com/KhZyFmTzPcrusQqCBOsj-8.05.png)\n\n## Diving into a Pool Factory Contract\n\nAt its core, the protocol begins as a pool factory contract, which you can use to create new pools of tokens. Glancing through the audit data branch, you'll notice the `poolfactory.sol` that includes this `Create Pool` function. This function is responsible for forming these AMM pools, hallmarking a major component of our swapping process.\n\n```js\nfunction createPool(address tokenA, address tokenB) external returns (address pool) {\n    // ...\n    return pool;\n}\n```\n\nMade it more evident, when we zoom into the `poolfactory.sol`, it's seen that various token pairs can be created. For instance, there's a USDC WETH pool being created with the `Create Pool` function. Yes! You just don't create pools; it's also about combining different token pairs to form these pools.\n\n## Understanding the Logic behind Pool Contract\n\nThe contract used to create new pools ensures that each pool token adheres to the correct logic. Nonetheless, the real allure of these pool contracts comes alive with each T swap pool contract.\n\nTo highlight this point, I navigated the SRC, where I found the `create pool` function in play (highlighted in the `poolfactory.sol`). This function sprung my curiosity, and I began exploring it more.\n\nTo my delight, I discovered that the function seemingly calls this new TSWAP pool function. Though information-dense, the sequence makes sense as the `Create Pool` function is being called to create a new pool contract.\n\nAfter investing some time into exploring the process, I realized that each TSWAP contract operates as an exclusive exchange between two specific assets, as originally depicted in our early diagram with ne ERC 20 and the WETH token.\n\n## Bridging the Gap via Pools and WETH\n\nThe magic of WETH lies in its ability to specifically provide pools with the power to allow users to freely swap between an ERC 20 having a pool and WETH (Wrapped Ether). With a sufficient number of pools created, they enable an easy hop between supportive ERC 20s.\n\nIf this sounds like a challenge, consider this; if I possess USDC, I could swap from USDC to WETH. Then, switching from WETH to Link becomes feasible because there's likely going to be a USDC WETH pool and a Link WETH pool.\n\nNow, let‚Äôs explain the process with an easy example,\n\n> User A has ten USDC. They want to swap it for die. So, they swap their ten USDC for WETH in the USDC WETH pool. They then swap their WETH for die in the Dai WETH pool.\n\nIt falls into place now, doesn't it? Every pool designates a unique pair between some tokens and WETH. Not only does it provide functionality for swapping but also gives developers insight into the two functions enabling the swap process.\n\nAt the higher level, this is how swapping works, and playing around with the sample codes will only enrich your understanding of the process.\n\n## Role of Liquidity Providers\n\nHopefully, this article provided you with useful insights into the process of pool creation, swapping, and the essence of LPs. However, there's much more to explore and understand, and it's fascinating to see how these different components intricately work together to enable seamless AMMs.\n",
          "updates": []
        },
        {
          "lessonId": "7e94a8f8-45d8-4500-a442-c6405637fc5c",
          "number": 9,
          "title": "Invariant & Properties Introduction",
          "slug": "invariant-&-properties-introduction",
          "folderName": "9-invariant-&-properties-introduction",
          "description": "",
          "duration": 3,
          "videoUrl": "K6OtIxq3j7g",
          "rawMarkdownUrl": "/routes/security/5-tswap/9-invariant-&-properties-introduction/+page.md",
          "markdownContent": "---\ntitle: Invariant & Properties Introduction\n---\n\n\n\n---\n\n# Demystifying Core Invariants in Blockchain Protocols\n\nDiving deep into the world of Blockchain, I thought to explore something fundamental yet intriguing: the concept of **invariants**. Invariants form the bedrock of most blockchain protocols, a feature you will encounter in almost every protocol ranging from ERC 20s to ERC 721s. Understanding this critical element is vital for anyone looking into the inner workings of these protocols.\n\nIn this blog, we'll cover invariants thoroughly while also touching on how to inspect them properly. We'll hope to do so by investigating the TSWAP protocol and its core invariant. Create a hot beverage, loosen up, and let‚Äôs probe these invariants together!\n\n## What are Protocol Invariants?\n\nInvariants, in blockchain terms, are properties or conditions within a system that remain unaltered regardless of the actions carried out within the system. They are dynamic rules ensuring the system's safety, and they play a pivotal role in designing tokens in blockchain protocols.\n\nFor instance, various types of tokens like ERC 20, ERC 721, or ERC 626 have numerous invariants to their names. Each ERC 20 has 20 properties or invariants while an ERC 721 has 19. As you'll discover later in this course, ERC 626 tokens, which we'll cover in the _Vault Guardians_ section, boast of whopping 37 properties.\n\nTo get a hang of these properties, you can pay a visit [here](https://blog.trailofbits.com/2023/10/05/introducing-invariant-development-as-a-service/), at the _Trail of Bits repository_. This repository neatly lays out the invariants of an array of tokens.\n\n## TSWAP Protocol and Invariants\n\nNow, let's turn our gaze towards the TSWAP protocol. If you explore the protocol, you'll encounter the gift the developers have graciously provided: the core invariant.\n\nHowever, it's noteworthy to understand that sometimes developers may not correctly establish the invariant. In such cases, the onus falls on us, the _Security Experts_, to ensure accuracy. While the developers hand you the necessary details, understanding and breaking down the invariants becomes a task of paramount importance.\n\nUnfortunately, many developers do not fully grasp their own created invariants. Bearing this in mind, you might come across instances where you need to discern the invariants by referring to the documentation. Therefore, it's crucial for every developer to understand invariants better or properties.\n\n## Invariants and Fuzz Testing\n\nAs we've already laid some groundwork on invariants, let's now head towards a deeper understanding of them by considering fuzz testing.\n\n> ‚ÄúFuzz testing or fuzzing is a method for discovering coding errors and security loopholes in software, networks, or operating systems by inputting massive amounts of random data to the system in an attempt to make it crash.‚Äù\n\nI've brought together a series of fuzz testing videos which we will delve into dipping our toes into the in-depth understanding of invariants and fuzzing.\n\nBut before that, if you are an alumnus of the **Foundry Course**, you may already have a basic understanding of fuzzing. Nevertheless, a refresher would surely help as we dig deeper into the concept with a more in-depth pedagogical approach.\n\nIn the next phase, we will examine a quick informative video to enhance our understanding of invariants and the varied tactics to evaluate them, with a specific focus on fuzz testing.\n\nBuckle up, recalibrate your focus, and let‚Äôs take this enlightening journey on understanding the invariances better. After all, there's no better time to learn something new than right now. Stay curious!\n",
          "updates": []
        },
        {
          "lessonId": "cfdd384a-8605-435d-a4e6-54a8423bfef7",
          "number": 10,
          "title": "Stateful And Stateless Fuzzing",
          "slug": "stateful-and-stateless-fuzzing",
          "folderName": "10-stateful-and-stateless-fuzzing",
          "description": "",
          "duration": 3,
          "videoUrl": "bSu42OoX-8A",
          "rawMarkdownUrl": "/routes/security/5-tswap/10-stateful-and-stateless-fuzzing/+page.md",
          "markdownContent": "---\ntitle: Stateful and Stateless Fuzzing to Test Invariants\n---\n\n\n\n---\n\n# Mastering Fuzz Testing to Secure Your Code\n\nAh, contracts written, tests conducted ‚Äî time to ship your code, right?\n\nWrong.\n\n![](https://cdn.videotap.com/tSLOq12UEqMlEKM1ZYUu-34.65.png)\n\nThe answer is a straightforward no, as your code can easily fall prey to a flash loan attack. This post will guide you through the complex but fascinating world of Fuzz Testing and how it can help you safeguard your code from unexpected exploits.\n\n## The Notorious Flash Loan Attack\n\nIn essence, a flash loan attack could jeopardize your whole system, regardless of how well you've written or tested your code. As intriguing as it may sound, this breach results from already prepared and unthought-of scenarios that lack appropriate tests.\n\n> \"Most of the time, hacks will come from a scenario that you didn't think about or write a test for.\"\n\n## Enter: Fuzz Testing\n\nFuzz testing (also known as fuzzing) is a robust fix to cope with these random yet deadly exploits. It involves supplying random data to your system with an aim to break it ‚Äî just like relentlessly trying to pop a balloon until it finally gives in, serving as a metaphor for our system code here.\n\nSounds a bit odd, huh? Why would we want to break our own system?\n\n![](https://cdn.videotap.com/EkFB4lChiHAsfS8axMsP-150.16.png)\n\nGlad you asked. Here's where the concept of invariants or properties of a system come into play. These are the untouchable rules or the inviolable conditions in our system that should always hold true. For instance, in a function that mandates our variable outcome to always be zero, this condition would be our invariant.\n\n## Testing: Unit Test vs. Fuzz Test\n\nConsider our function called `doStuff` which accepts an integer as an input parameter and promises to always return zero.\n\nThis code passes a single data point, calls the function and then asserts that the variable `shouldAlwaysBeZero` is indeed zero. With such a test, our function seems to be covered for the given data input.\n\n### - Fuzz Test:\n\nHowever, what if the data input is different? What if it‚Äôs two, causing `shouldAlwaysBeZero` to become one and thereby breaking our invariant?\n\nIn this Fuzz test, we replace the manually selected data in the original unit test parameter with randomized data (commenting out the previous line of code). When you run a test here, the program will automatically randomize the data, resulting in different examples.\n\nRunning the aforementioned unit test will pass, but running the equivalent Fuzz test will actually highlight where our system fails. It'll show an output where it says \"assertion violated\" and provide the data and arguments that caused the fail, all by randomly throwing data at our function.\n\nThat said, it's important to understand that Fuzzers won‚Äôt cover every single possible input, hence, understanding how your Fuzzers pick the random data is a crucial skill to develop.\n\n## Moving on to Stateful Fuzzing\n\nA Fuzz test is usually a stateless fuzz test, meaning the state of the previous run is discarded for the next run. However, in some cases like our example, we need the outcome of the previous run to influence the next one. For this, we bring in Stateful Fuzzing.\n\nStateful Fuzzing is where the ending state of our previous fuzz run is the starting state of the next fuzz run. For example, instead of creating a new instance of our contract for each test run, we use the same contract and perform multiple operations on it.\n\nWe can use Foundry's invariant keyword to perform stateful fuzzing, but first, we need to import the `STD invariant` contract, let Foundry know which contract to call random functions on, and then, write our invariant.\n\nUpon running this test, we will finally discover a sequence where our assertion fails, providing us with the information to adjust our code accordingly.\n\nWhile fuzzing with Foundry, an important distinction to keep in mind is between fuzzing or stateless fuzzing and invariants or stateful fuzzing.\n\n## Embedding Fuzz Testing into Your Routine\n\nIn a real-world setting, your invariant might not be as simple as our example. It could look something like ensuring new tokens minted are less than the inflation rate or creating a lottery game where there should only be one winner. Although fuzz testing isn't a substitute for expert manual review, it is certainly a critical tool to thwart vulnerabilities in your code.\n\nFinally, we hope you've gained a solid knowledge of the basics of fuzz testing. Fear not, you're not alone in your journey. At [cyfrin](https://www.cyfrin.io/), we use invariants during our audits to identify vulnerabilities that are frequently difficult to catch purely with manual reviews.\n\nStay tuned for our next post where we'll delve into the advanced fuzzing techniques and help you become a fuzzing pro. Together, let's strive to make Web 3.0 even better! Happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "453797a9-269f-4b55-a04d-42e759298e40",
          "number": 11,
          "title": "Stateless And Stateful Fuzzing Practice",
          "slug": "stateless-and-stateful-fuzzing-practice",
          "folderName": "11-stateless-and-stateful-fuzzing-practice",
          "description": "",
          "duration": 5,
          "videoUrl": "Zo6viGz-NzM",
          "rawMarkdownUrl": "/routes/security/5-tswap/11-stateless-and-stateful-fuzzing-practice/+page.md",
          "markdownContent": "---\ntitle: Stateless and Stateful Fuzzing Practice Introduction\n---\n\n\n\n---\n\n# Proficiency in Invariant Tests and Fuzzing Tests: Professional Insights and Practicum\n\nHello everyone, today we delve deeper into the intriguing world of invariant tests and fuzzing tests. Buckle up as we gear up to break some contracts by exploring these tests, intentionally leaving the code unexamined for now. Our curiosity piqued? Let‚Äôs get into it!\n\n## Diving into Code Bases\n\nWe can‚Äôt help but sneak a peek into the code now, can we? Since we are here, let's analyze this exemplary TSWAP pool code base.\n\n![](https://cdn.videotap.com/9DXkrFHNdYGt3CJIJuAh-39.png)\n\nIt's filled with a plethora of comments, functions, and other intricate elements - it's enough to make the most seasoned of us a tad bit overwhelmed. Amongst us is the pool factory that stands minimal. We notice that the primary responsibility of pool factory is to create pool functions. Isn‚Äôt it interesting to note the stark contrast between TWSAP pool code base and pool factory?\n\n## What About the Security Review Test?\n\nGood question! We‚Äôll get there, but remember, we are just humans, and the chance for errors and omissions is high. We might fail to spot certain defects during the manual review of the security test. This is precisely why leveraging automated tools as much as possible for these reviews is essential. Trust me, the experiences we collect from the practice of working with these tools are going to be invaluable.\n\n## Plunge into Fuzzing: Stateless and Stateful\n\nIn this chapter, we will focus on working with **stateless** and **stateful** fuzzing along with some advanced strategies. These techniques have personally worked wonders for me in competitive audits. My method has been to comprehend a protocol's invariant without really examining the code base, write an invariant test suite, and voila ‚Äì bugs are unveiled effortlessly.\n\nThere are also other fuzzers to explore. Take the [Echidna Fuzzer](https://github.com/crytic/echidna) by the Trail of Bits team, for instance. Famed for being a smart fuzzer and powered by 'Slither', it is a fantastic tool indeed. Another outstanding option is the [Consensys Fuzzer](https://github.com/Consensys/diligence-fuzzing). This is a paid corporate cloud fuzzer and hence we won't be able to provide a walkthrough for it. [Foundry](https://github.com/foundry-rs/foundry) is yet another promising candidate with built-in fuzzing.\n\nHere is the content that these READMEs possess:\n\n- An understanding of what invariants are\n- A better insight into the different strategies we plan to employ to break invariants and discover vulnerabilities.\n\nI strongly recommend that you go ahead, pause this session, and thoroughly read through this. Trust me, understanding it now will make it easier when we get into the hands-on segment.\n\n## Breaking Invariants: The Game Begins\n\nLet's now move forward to the fun segment ‚Äì you will write code along with me and understand every snippet. I assure you that by the end of this, you will have become an invariant testing pro. This mastery over the subject will help you discover vulnerabilities quicker and more effectively.\n\nFirst, in your code base, find the Invariant Break folder and remove it. Yes, you heard it right ‚Äì remove it! Doing so is a sure-shot way to ensure you are not merely copy-pasting but genuinely understanding every piece of code. Let's start with stateless fuzzing.\n\nOnce we are through with learning these strategies for fuzzing, we'll return to our Uniswap code base and familiarize ourselves with its 'x times y equals k' core invariant. We'll then try to break it and uncover bugs without examining the code base and solely understand the invariants.\n\nSo let's gear up and set out on this exciting and insightful journey of breaking invariants and fuzzing, navigating through this incredible world of coding and contracts. Let's learn, practice, improve, and ultimately ‚Äì strive towards becoming super badasses in smart contract testing and auditing.\n\n> \"The only way to learn a new programming concept is by writing programs.\" - Dennis Ritchie\n",
          "updates": []
        },
        {
          "lessonId": "de00c65e-7aa4-4e9c-bafb-c8df31aff63a",
          "number": 12,
          "title": "Stateless Fuzzing",
          "slug": "stateless-fuzzing",
          "folderName": "12-stateless-fuzzing",
          "description": "",
          "duration": 9,
          "videoUrl": "X_YD4P0HL1U",
          "rawMarkdownUrl": "/routes/security/5-tswap/12-stateless-fuzzing/+page.md",
          "markdownContent": "---\ntitle: Stateless Fuzzing\n---\n\n_Follow along with the video:_\n\n\n\n---\n\nToday, we'll be navigating through the SC exploits minimize codebase, focussing specifically on the `Invariant Break`. We aim to understand, practice, and discuss the power of stateless fuzzing, an essential tool in the world of software testing. Rest assured, we will also provide a minimized example to clarify how it works.\n\n## What is Stateless Fuzzing?\n\nStateless fuzzing, often referred to simply as fuzzing, is a technique where random data is supplied to a function to break some invariant or property. Remembering our discussion from the video of continuously attempting to pop a balloon serves as an apt analogy. It's all about continuously providing different inputs to a function until it breaks. If you have a function with an invariant that it should never return zero, then fuzz testing might just be the answer.\n\n## Breaking the Invariant: Writing the Test Case\n\nWith our codebase ready, and ourselves aware of the functionality we are testing. We need to write the test case to break it. Let's create a new folder named `Invariant Break` to prepare for our first stateless fuzz test. Naming the test `statelessfuzzcatchestest.sol`, we focus on catching the bug automatically using fuzz testing.\n\nThis test is more than just a unit test which checks the invariant once. With fuzzing, we apply various random numbers to the function and see if it breaks the invariant or not. The beauty of this strategy is that we can detect issues that can be missed out on during manual checks or basic unit tests.\n\n![](https://cdn.videotap.com/3SkpmLCCBFnsZH2yqkEW-412.31.png)\n\n## Setting the Fuzz Options\n\nLet's take a moment to understand the fuzz options. The number of runs determines the number of different balloons (inputs) we use in a stateless fuzz option. So we need to carefully adjust this value to ensure we're checking for as many edge cases as possible. Another crucial property is the seed, which, when kept the same, will offer the same inputs instead of random ones. This can be extremely helpful in debugging.\n\n![](https://cdn.videotap.com/BjOp2RCvRkPDt2VcD5fL-453.54.png)\n\nWith the fuzz options set, our test is ready to run. After a few runs, the test should fail, meaning our fuzz test has successfully caught the bug‚Äîgreat job on creating your first fuzz test. But what if it doesn't fail? Well, you may need to increase the number of runs or change the seed. With randomness at play, there's never a 100% guarantee that you'll catch the bug in a particular run. This makes the fuzzing process a bit of hit or miss, but the advantages outweigh this con, as it helps to ensure the robustness of your functions.\n\nSeeding different values and number of fuzzing runs directly impact how thoroughly the test cases are checked. Adjust these values according to your specific needs, cover as many alleyways as possible - fuzz it till you dust it off! But remember, it's crucial to analyze the balance between the number of runs, seed selection and performance of your testing.\n\n## Wrapping Up Stateless Fuzzing\n\nIn conclusion, stateless fuzzing is a powerful tool for catching bugs where you expect a specific invariant. However, it's important to remember its limitations, such as being stateless and so not being able to pick up on issues caused by interactions between different functions. It's also a tool reliant on randomness, which means you can never be sure you've explored every possible scenario. Yet it remains a swift and highly efficient method for bug hunting.\n\nIn the upcoming sections, we'll move forward from stateless fuzzing to touch upon more complex and exciting testing methodologies. Until next time, happy fuzzing!\n\n> ‚ÄúIt‚Äôs not at all important to get it right the first time. It‚Äôs vitally important to get it right the last time.‚Äù - Andrew Hunt and David Thomas\n",
          "updates": []
        },
        {
          "lessonId": "34e42011-1e07-4f7a-ba66-cffd239fa490",
          "number": 13,
          "title": "Where Stateless Fuzzing Fails",
          "slug": "where-stateless-fuzzing-fails",
          "folderName": "13-where-stateless-fuzzing-fails",
          "description": "",
          "duration": 11,
          "videoUrl": "y756f57f49o",
          "rawMarkdownUrl": "/routes/security/5-tswap/13-where-stateless-fuzzing-fails/+page.md",
          "markdownContent": "---\ntitle: Where Stateless Fuzzing Fails\n---\n\n\n\n---\n\nHello readers, today, we're diving into the realm of stateful fuzzing. If you've been following our development journeys on smart contracts, you already know about stateless fuzzing. Stateless fuzzing, as we've discussed before, starts every fuzz run from scratch.\n\nBut with stateful fuzzing, things get a bit more exhilarating! Upon each pass of stateful fuzzing, the outcomes from the previous run become inputs to the next run.\n\n### Defining Stateful Fuzzing\n\nSounds interesting? Let's illustrate using a simple example.\n\nImagine you have a balloon. You do one thing to try to pop it, say, drop it. If it doesn't pop, instead of grabbing a new balloon, you apply another action on the same balloon, like kicking or squeezing it.\n\nThe same theory applies to our smart contracts. We call a function on our contract, change its state, and then repeat the process on the **same** contract. Quite unlike stateless fuzzing, where you start with a fresh state at every run!\n\n#### Running the Fuzz Test\n\nAfter ensuring everything is set, we‚Äôre now ready to run our fuzz test on this. Perhaps by making 1000 runs initially.\n\nDid it find a bug? No. You may be tempted to increase iterations to say, 10,000, then 100,000 or maybe even to a million runs! But listen, no matter how long you wait for the fuzzer to finish running, it will **never find the bug**\n\nThis is because the initial value was mounted at one and the balloon (contract state) you created is still at one, having slipped back to its initial state with each run. The only time it could return zero, breaking our invariant, is when the value changes to zero. Therefore, the contract's state must change.\n\nThis is precisely what a stateful fuzz test can find for us!\n\n> _‚ÄúTalk is cheap. Show me the code.‚Äù_  \n> _- Linus Torvalds_\n",
          "updates": []
        },
        {
          "lessonId": "c8b0a51e-b8f1-410b-9d57-1c56ccb99a22",
          "number": 14,
          "title": "Fuzzing Where Method 1 Fails",
          "slug": "fuzzing-where-method-1-fails",
          "folderName": "14-fuzzing-where-method-1-fails",
          "description": "",
          "duration": 18,
          "videoUrl": "Rw3xyAHeB10",
          "rawMarkdownUrl": "/routes/security/5-tswap/14-fuzzing-where-method-1-fails/+page.md",
          "markdownContent": "---\ntitle: Stateful Fuzzing Where Method 1 (open) Fails\n---\n\n\n\n---\n\nWelcome back fellow learners! We are on this exciting journey together to lay the foundation of Smart Contract Security Testing. What have we learned thus far?\n\n## Stateless Fuzzing vs Stateful Fuzzing\n\nWe discovered that stateless fuzzing was not effective in detecting bugs in functions which require more complexity, such as `changeValue` - a function which updates a contract's state.\n\n```js\nfunction changeValue(uint256 _value, uint256 _multiplier) public {\n    value = _value * _multiplier;\n}\n```\n\nIn this case, we employed a mechanism known as stateful fuzzing. With this method, we can catch much more subtle and nuanced bugs by accounting for contract state changes during fuzzing.\n\nHowever, we encountered a hiccup when we were dealing with an integer overflow issue. We had to set the `failOnRevert` to `false` for our fuzzing test to work! That's because `myValue` could be a huge number, larger than a `uint256` can hold, causing an overflow.\n\nDespite these hurdles, we soldiered on and made it this far. Now, it's time to graduate to an even more complex scenario - fuzzing a vault contract!\n\n## Breaking The Invariant With Stateful Fuzzing\n\nSo, let's start by attempting to break this invariant using stateful fuzzing.\n\nFirstly, we'll set up the test contract and import our dependencies, including the token mocks that will be used.\n\nNext, we'll create a token array and launch the tokens to be supported by our token vault. We will then set up the user who'll be interacting with the vault and provide them with a starting amount of tokens.\n\nFinally, we compose the fuzzing test itself. We begin by pranking the user, effectively manipulating their available tokens. We then perform the withdrawal operation of both types of tokens from the vault. Eventually, we assert that the user's token balance has not changed after the deposit and withdrawal operations.\n\nThe critical learning here is that we should always be able to withdraw the same amount we've deposited - this assertion must not fail!\n\n## All That Glitters Is Not Gold\n\nAlas, it appears that we celebrate too soon. On running this test, it's clear that we've run into an issue - our deposit function fails!\n\nWhen this happens, a good practice is to turn on the verbose logs ( -vvv flag) to see what's happening beneath the hood. We quickly detect the root cause - our fuzzer was making deposit attempts with unsupported tokens.\n\nToo much randomness in fuzzing can be just as detrimental as not enough randomness. We also notice that we never made the approve call for the ERC20 tokens, which was necessary for a deposit operation. Our fuzz test was essentially doomed from the start!\n\n## TL;DR\n\nIn this blog post, we discussed the progression from stateless to stateful fuzzing for smart contract testing. While stateless fuzzing is fantastic for catching some easy bugs, it falls short in detecting bugs in the case of more complex functions.\n\nStateful fuzzing overcomes these limitations, but it comes with its own set of challenges, like dealing with integer overflows. The takeaway here is the importance of finding the goldilocks zone of randomness while fuzzing - too little or too much can skew our test results!\n",
          "updates": []
        },
        {
          "lessonId": "4a94be28-9b2e-49ca-a666-7eac99cf2d6d",
          "number": 15,
          "title": "Stateful Fuzzing Method 2",
          "slug": "stateful-fuzzing-method-2",
          "folderName": "15-stateful-fuzzing-method-2",
          "description": "",
          "duration": 14,
          "videoUrl": "kB3CIfSXetc",
          "rawMarkdownUrl": "/routes/security/5-tswap/15-stateful-fuzzing-method-2/+page.md",
          "markdownContent": "---\ntitle: Stateful Fuzzing Method 2\n---\n\n_Follow along with the video:_\n\n\n\n---\n\n# Working with Smart Contracts Using Foundry: Setting up Handlers and Invariant\n\nIn this digital world where cryptocurrencies like Bitcoin, Ethereum, and others are trending, it's essential to understand how to use and create smart contracts. This article will guide you on how to create two new contracts utilizing Foundry; a known blockchain testing framework. The contracts to be created are `handler.t.sol` and `Invariant.t.sol`.\n\nComing along, we will also explore how to work with the `fail on revert` function.\n\n## Setting up the Handler Contract: `handler.t.sol`\n\nHandling smart contracts could be complex, especially if you're a beginner. However, with Foundry, we can manage our function calls to focus on vital operations for our code base, resulting in a less error-prone contract.\n\nConsider the idea that we have two types of users in our system; one who can deposit and another, withdraw. This simplification gives us a better sense of controlling bugs by ensuring an easier flow of interactions. Consequently, the `fail on revert` option should ideally be set to true. This validation will allow us to confirm the validity of our tests.\n\nWhen set to false, if our fail on revert test passes, it presents no valuable insight because there are too many pathways for the fuzzer to follow, potentially calling irrelevant functions. Although starting with the fail on revert set to false can be a suitable starting point, the intention should always be to work towards getting it set to true.\n\nNow, to the creation of our `handler.t.sol`. This particular contract will be set up as the intermediary for restricting the `handler stateful Fuz catches` contract.\n\nThrough the handler, we will instruct our Foundry and `Stateful Fuzzing Test Suite` to correlate with the `handler stateful Fuz catches` contract appropriately. We are essentially telling the Foundry when to call deposit, to approve, mint, and have the tokens. Likewise, when to call withdraw; all these with precise guidelines on avoiding explosive function calls.\n\nIn the handler contract, specific lines are written for the 'ERC20 token' and the 'USDC token'. Here's what the snippet looks like:\n\nThis handling setup focuses on 'deposit' and 'withdraw' functions thus curbs randomness and gives our fuzzer more accurate paths to follow, thereby giving correct and more reliable test results.\n\n## Setting up the Invariant Contract: `Invariant.t.sol`\n\nThe `Invariant.t.sol` involves creating the invariant test. Here, unlike in the handler contract `handlerT.sol`, we are particularly interested in an invariant that interacts with the handler contract and not the actual contract.\n\nTo begin setting up `Invariant.t.sol`, start by importing the handler with a line of code that looks like this:\n\nConsequently, instead of fuzzing the actual contract, we are going to fuzz the handler in a process that is easier and more sensible. The logic is that we want our transactions handled in a way that makes sense and thus the adoption of the `fuzz selector` as seen in the code below:\n\nThis instructs the contract that the selectors and the target address to be used are those outlined in the handler.\n\n## In Conclusion\n\nSetting up the `handlerT.sol` and `Invariant.t.sol` contracts helps break down the complexity of dealing with smart contracts. By implementing these contracts, we have given Foundry a framework to follow that makes its function calls more logical and less random. Therefore, we no longer have to deal with reverts, and we can focus better on our tests, making our iterations more meaningful and insightful.\n\nRemember, the best way to become proficient at handling smart contracts is repetition. Practice by trying these methods out on your old code bases, which should help you improve your coding skills and understanding of stateful fuzzing. You don't have to become an expert all at once; take small steps and ask questions when you face roadblocks.\n\nAll being said, smart contracts could save significant time, reduce the risk of manual errors, and thus revolutionize the way we perform secure transactions. Learning how to work with them will not only keep you relevant but also give your work an edge.\n\n> Note: This article assumes that you have a basic knowledge of smart contracts Foundry and programming. It might be helpful to do a bit of reading if you're not familiar with these topics.\n\nHappy coding!\n",
          "updates": []
        },
        {
          "lessonId": "2b9d46bd-50a3-4def-8595-618c46346854",
          "number": 16,
          "title": "Debugging Fuzz Sequences",
          "slug": "Debugging-Fuzz-Sequences",
          "folderName": "16-Debugging-Fuzz-Sequences",
          "description": "",
          "duration": 7,
          "videoUrl": "QmiE6_Vf_9E",
          "rawMarkdownUrl": "/routes/security/5-tswap/16-Debugging-Fuzz-Sequences/+page.md",
          "markdownContent": "---\ntitle: Debugging Fuzz Sequences\n---\n\n\n\n---\n\n# Invariant Testing, Fuzzing, and a Weird ERC-20 Exploit\n\n## Introduction\n\nHello, folks! In this blog post we'll embark on an exciting journey of executing invariant testing using a fuzzer. We will encounter misconfigurations, understand the output generated, identify the source of confused states (yes, we're going to meet a weird ERC20 token variant!), and unveil the importance of writing good tests, especially when dealing with external contracts.\n\nReady? Let's get started!\n\n## The Initial Fuzzing Scenario\n\nThe first thing we need to do is run our fuzzer, which is already configured to a contract, in our case, the \"Mock USDC.\" We have coded a fuzzer test, `forge test --mt`, that we'll apply here.\n\n**_Code to be inserted:_**\n\n```shell\nforge test --mt name-of-test\n```\n\nAs we eagerly anticipate a successful test run...\n\n### Problem Identification: The Fuzzer‚Äôs Anarchy\n\n![](https://cdn.videotap.com/dJ9d44aCK4jLbP02SRGT-77.81.png)\n\nUnfortunately, things don't turn out as planned. The fuzzer is attempting to interact with every possible edge, not just the \"handler\" contract we intended to speculate. To tether its leash back, we explicitly identify the target contract.\n\nAfter the amendment, another run of the test is conducted.\n\n### Signalling Errors: The Test Output\n\nRun again, we are greeted with an error message from a call to `withdrawYield` (ERC20).\n\nThe output isn't clear, but running the command `-VVV` (very, very verbose) may shed light on the error. The detailed output points fingers at an \"insufficient balance,\" raising questions why our fuzzer-guided users are struggling to withdraw tokens they own.\n\nAttempting to better understand this scenario, we consciously decide to ignore the revert conditions. However, the issue persists, generating a mountain of output data.\n\nA new strategy is formulated to drop ‚Äòthe seed‚Äô controlling the fuzz, re-running the test in search of more comprehensible output.\n\n## Deep Dive: The Problematic ERC20 Token\n\nAnalysis of new output traces reveal that the `depositYield` function is also encountering a revert condition. A comparison of the pre and post-amendment data validates the improvement acquired through the fuzz restriction.\n\nThe error persists through multiple test runs, so we opt to investigate the contract code, revealing nothing out of the ordinary in the `withdrawToken` function, a likely suspect. Maybe the issue lies within the token itself?\n\nA scrutiny of `yieldYear20` also reveals nothing amiss, except one: a custom error message.\n\nThe error signals a lack of balance, an oddity since the user‚Äôs balance should align with the deposit amount. But it's the fine print that throws a spanner in the works.\n\n## Unraveling the Truth: A Sinister Token\n\nLooking further into the `yieldYear20` token, we notice an eccentric mechanism: for every 10 transactions, a 10% fee is deducted and transferred to the owner. Smelling a rat, this erratic behavior is the root of the violation of our invariant.\n\n### An Unexpected Result: Violation of the Invariant\n\nHere‚Äôs what unfolds: after back-to-back deposit and withdrawal transactions of the `yieldYear20` tokens, the 10th transaction deducts this 'fee,' dispatching 10% of tokens to the owner's contract. This act violates our invariant, which demands that users can always withdraw the exact balance fraction amount.\n\n## Importance of a Well-Written Test Suite\n\nLuckily, our top-notch stateful fuzzing test suite spotted the anomaly. It showcased the significance of having well-detailed tests, especially when external contracts, such as tokens, are involved. This informal audit brought attention to a significant pitfall potential, ‚ÄúWeird ERC-20 tokens.‚Äù\n\n### Wrap Up: Invitations, Exploitations, and Auditations\n\n‚ÄúCongratulations for digesting this massive chunk of knowledge! Don't fret if you're perplexed; it's a lot to take in, especially without hands-on practice. But remember, Rome wasn't built in a day!\n\nThe key takeaway here is the importance of writing detailed test suites, accurately capturing potential anomalies that could break our system. As for our journey, you've just witnessed the first exploit of this session, the \"Weird ERC-20 Tokens,\" a concept we will explore in-depth in coming sessions.\n\n> ‚ÄúTo iterate is human, to recurse, divine.‚Äù ‚Äì L. Peter Deutsch\n\nHaving unraveled the problem, we're now geared up for the final leg of our expedition, auditing the ‚ÄòT-Swap protocol.' Stay tuned, as exciting discoveries await!\"\n",
          "updates": []
        },
        {
          "lessonId": "f69e22bd-9912-4545-812b-1a44744e6120",
          "number": 17,
          "title": "Fuzzing Recap",
          "slug": "fuzzing-recap",
          "folderName": "17-fuzzing-recap",
          "description": "",
          "duration": 2,
          "videoUrl": "d4VI69rhcfg",
          "rawMarkdownUrl": "/routes/security/5-tswap/17-fuzzing-recap/+page.md",
          "markdownContent": "---\ntitle: Fuzzing Recap\n---\n\n\n\n---\n\n# Mastering the Art of Fuzzing: Stateless, Stateful, and Weird ERC 20 Exploits\n\nIn this blog post, we're going to dive into the exciting world of `fuzzing`. Hang in there and get ready to uncover the intricacies of stateless fuzzing, explore the intriguing concept of stateful fuzzing, programmatically exploit the Weird ERC 20, and navigate the maze of manual bug finding in your codebase.\n\n## A Quick Recap: All About Stateless Fuzzing\n\nSo, what did we just uncover? We got to grips with the powerful tool called `stateless fuzzing`. Stateless fuzzing offers invaluable aid to developers as it tests a system with a series of random inputs, shreds through layers of errors, helps to uncover bugs in a codebase, and optimizes system performance.\n\nHowever, stateless fuzzing does have a downside. Its efficiency falls abruptly when it comes to `stateful fuzzing`. Why? Because stateful fuzzing isn't just about pounding a codebase with random inputs. It's more like a well-choreographed dance sequence, requiring precise steps and accurate timing.\n\n_\"Stateless and stateful fuzzing holds the same end goal: to identify and fix bugs and vulnerabilities in a codebase. However, they approach this goal from different perspectives.\"_\n\n## The Handler Method: Bridging the Gap between Stateless and Stateful Fuzzing\n\nBut here's the shimmering light at the end of the tunnel: the handler method. This handy little method functions as a proxy that enables us to call our contract and achieve a more nuanced stateful fuzzing strategy, especially when dealing with complex contracts.\n\nIn simple terms, the handler method allows us to make our randomness `less random`. This directed randomness enables stateful fuzzing to probe more effectively into a codebase's vulnerabilities.\n\nIt helps the fuzzer go down paths that make sense, ensuring a more efficient and targeted fuzzer run.\n\n![](https://cdn.videotap.com/imecUt1GioVaw6WCZCUs-33.1.png)\n\n## Teasing the Weird ERC 20 Exploits\n\nNext, we dipped our toes into the Weird ERC 20 exploit. While we didn‚Äôt dive deep into this topic, consider it your cliffhanger, your incentive to keep learning! We‚Äôll be exploring the Weird ERC 20 in detail soon enough. It's an exploit you definitely don‚Äôt want to miss because it is a crucial tool to test more advanced code contracts.\n\n_\"In the world of coding and security breaches, the 'weird ERC 20' presents itself as a fascinating challenge and a riveting exploit that aids in uncovering deeper vulnerabilities within the code.\"_\n\n## Looking Forward: The Road Ahead with TSWAP and Manual Review\n\nWith this newly acquired knowledge, next on our agenda is to apply these techniques to `TSWAP` and run stateful fuzzing tests. After we've done that, we'll dive headlong into the fascinating world of manual reviews.\n\nThe manual review process can seem tedious, especially since it involves hunting down bugs without any automation. But rest assured, it‚Äôs an amazing learning journey that adds tremendous value to your skillset as a developer.\n\n## Take-A-Break Strategy\n\nAfter this whirlwind tour of fuzzing, exploit, and reviews, you‚Äôve made it so far and gained quite a bit of expertise! Peeling back layers of codes, vulnerabilities, and in-depth testing strategies can be mentally taxing, which is why it's important to give your brain some downtime.\n\n_\"Learning is a marathon, not a sprint; don't forget to hydrate, take breaks, and recharge yourself.\"_\n\nFeel free to take a short break, stretch a bit, go for a walk or do anything you find relaxing. When you‚Äôre ready, we'll reconvene and continue our descent into the rabbit hole of coding exploits and vulnerabilities, enriched, refreshed, and ready for more.\n\nUntil then, congratulations once again and see you after your well-deserved break!\n\nStay tuned for more fuzzing and coding action in the next blog entry!\n",
          "updates": []
        },
        {
          "lessonId": "193a4e62-8f2e-41e3-bfaa-9d9006564d17",
          "number": 18,
          "title": "Weird Erc20s",
          "slug": "weird-erc20",
          "folderName": "18-weird-erc20",
          "description": "",
          "duration": 4,
          "videoUrl": "8R_aOSqE0zI",
          "rawMarkdownUrl": "/routes/security/5-tswap/18-weird-erc20/+page.md",
          "markdownContent": "---\ntitle: Exploit - Weird ERC20s (These are a menace to Web3)\n---\n\n\n\n---\n\n# Exploring the Weird World of ERC-20 Smart Contracts: Security, Oddities and Auditing\n\nIn this blog post we'll delve into one of the most interesting parts of the decentralized area - ERC-20 Smart Contracts and their intricate aspects. We‚Äôre going to go back to the `cipher` security and auditing full course on GitHub and explore more about a special section named **TSWAP**, specifically _section five_.\n\n## Tackling the ERC-20 Quirks\n\n> _Remember, it's the stuff we don't know that keeps us up at night._\n\nOne weird instance that we are going to discuss today is about `ERC-20 fee on transfer token`, which was part of the `SC_exploits`. When testing this token, it was found that for every ten transactions, a fee was being charged. This might seem innocuous, but this little oddity has the potential to destabilize numerous protocols.\n\n![](https://cdn.videotap.com/AepJ0CJaMiwbHLC1x4GC-49.5.png)\n\n## The Anomalies of ERC-20 Tokens\n\nERC-20 Tokens come in all shapes and sizes. Here's a glimpse into some of the variants and potential problems that lurk in the shadows:\n\n1. **Reentrant tokens**: These ERC-777s seem harmless, but even a simple transfer of these tokens can lure you into a pit of reentrancy attacks.\n2. **Missing return values**: Some tokens don‚Äôt return a boolean on ERC-20 methods. For transactions requiring a status check, this can be a potent problem.\n3. **Fee on transfer**: Some tokens sneak in a fee on every transfer while others can start doing so in the future.\n4. **Upgradable tokens**: These tokens, like USDC, could morph into anything over time.\n5. **Rebasing tokens**: These tokens magic away your balance by meddling with different contracts.\n6. **Tokens with blocklists**: Some tokens put restrictions on certain transacting parties.\n7. **Low/high decimals**: Token numbers can go from unusually low to abnormally high, causing calculation mishaps.\n8. **Multiple token addresses**: These tokens exist in more than one places at once.\n\n## Dealing with ERC-20 Tokens Anomalies\n\n![](https://cdn.videotap.com/4oHWptmu7liSgxFnB37w-170.5.png)\n\nERC-20 Tokens are an external smart contract that one must treat with a level of wariness. While integrating with them, you must be fully aware of the token‚Äôs characteristics.\n\nBlockquote:\n\n> _Playing in the world of ERC-20s without complete information is like dancing on a live minefield._\n\nA cagey approach to interacting with ERC-20s can be the difference between a successful dApp and a failed project.\n\n![](https://cdn.videotap.com/fnsDlRcZfomWTHFt6MFT-214.5.png)\n\nIn conclusion, if you are aspiring to be a top-flight builder of powerful smart contracts. This website is an excellent guide to understanding and gaining expertise in the world of smart contracts. It serves as both a practical tool and an in-depth manual to secure smart contracts.\n\nAnd remember, \"The first step to great security is being aware about all the unknowns!\".\n",
          "updates": []
        },
        {
          "lessonId": "6a0f18c4-814b-4633-b5b4-003b101496a7",
          "number": 19,
          "title": "Writing Stateful Fuzz Test Suite",
          "slug": "writing-stateful-fuzz-test-suite",
          "folderName": "19-writing-stateful-fuzz-test-suite",
          "description": "",
          "duration": 1,
          "videoUrl": "cb7oAfVJNLI",
          "rawMarkdownUrl": "/routes/security/5-tswap/19-writing-stateful-fuzz-test-suite/+page.md",
          "markdownContent": "---\ntitle: Writing Stateful Fuzz Test Suite\n---\n\n\n\n---\n\n# Unearthing Invariant Bugs in T Swap: An In-Depth Look at Stateful Fuzzing\n\nIn the world of code development, testing isn't just a good practice ‚Äì it's essential. This article provides a holistic perspective on a recent exploration into T Swap's codebase, observed practices, and the application of stateful fuzzing test suites.\n\n## Understanding T Swap: The Prelude\n\nBefore we delve into our primary focus, let's backtrack and recap.\n\nWhile sifting the codebase, it was evident that T Swap is well-grounded in underlying unit tests. However, the presence of specific entity, a certain critical invariant, led to a realization about the absence of something integral.\n\n> \"If the codebase has unit tests but no stateful fuzzing test, should we be concerned?\"\n\nOur answer to this turned out to be a resounding yes. It was a hint pointing towards the potential issues nestled within the T Swap system. Identifying these areas for improvement was not held within the realms of SRC ‚Äì it was staring right at us.\n\n## The Task at Hand: Writing an Invariant Test Suite\n\nStepping back to our main branch, we essentially locked eyes with an important discrepancy. Our codebase recognized its unit tests yet failed to host stateful fuzzing tests. And thus, the mission was clear. We were mandated to write the stateful fuzzing test suite and slightly so, expected to discover bugs in the process.\n\nThe task involved working directly with the T Swap's codebase, devising an automated stateful fuzzing invariant test suite. We believed that by accomplishing this, we would be able to unmask potential bugs within the system.\n\n## The Rollout: A Zero Manual Review Approach\n\nIn a paradigm shift from conventional methods, we decided to go zero manual review - a method entirely run by an automated test suite. While this may seem daunting, the focus was to write an automated test suite that will identify the bugs without human interference.\n\nHowever, to validate our automated test suite's competence, we decided to undertake a modest amount of manual review. This was a complimentary step to ensure the robustness of our newly coded test suite.\n\nAfter exacting the plan, we were ready to run our test suite and examine the results.\n\n## In Summary\n\nUsing hints from the T Swap's system peculiarities and their own testing protocols, we realized that there was an absence of an integral part of test coverage ‚Äì stateful fuzzing tests. A thorough exploration of this deficiency led us to write an automated invariant test suite, supplemented by a hint of manual review.\n\nThe goal was to find bugs with minimum manual intervention, and guess what? We did find some. So, stay tuned for the next part of this journey as we dissect the bugs and understand how to rectify them!\n\nRemember at all times, coding might be art, but testing is a science!\n",
          "updates": []
        },
        {
          "lessonId": "661fbd6d-5f1e-4b21-9330-9836857077d7",
          "number": 20,
          "title": "Constant Product Formula Explained",
          "slug": "constant-product-formula-explained",
          "folderName": "20-constant-product-formula-explained",
          "description": "",
          "duration": 9,
          "videoUrl": "H-FiRXkfNFo",
          "rawMarkdownUrl": "/routes/security/5-tswap/20-constant-product-formula-explained/+page.md",
          "markdownContent": "---\ntitle: Constant Product Formula Explained\n---\n\n\n\n---\n\n# Unraveling the Math in Uniswap's X \\* Y = K Invariant\n\n> **\"The main thing we want to keep in mind is the ratio of tokens should always stay the same.\"**\n\nUniswap, a popular decentralized exchange protocol, leverages a relatively simple mathematical principle to ensure that the balance within the pool maintains a certain ratio. At the core of its mechanism is the invariant formula: X \\* Y = K, which is held constant throughout all trading activities. However, when fees are factored in, the invariant technically increases, leading to a somewhat complex equation which we'll dissect further in this blog post.\n\nSeeing all the math involved, you might feel a bit overwhelmed, but hang tight, as we take a deep dive into the intricacies of the math and algebra involved. If you are someone with a keen interest in mathematics and decentralized finance, strap yourself in as we journey down this Uniswap mathematical express.\n\n## X \\* Y = K, The Magic Invariant Equation\n\nOur first step is to grasp the magic invariant equation, X \\* Y = K. Our code base operates on an invariant principle where the token balance of X times the token balance of Y should always equal the same constant, K.\n\nHere is the equation:\n\n```ruby\nX * Y = K\n```\n\nThe token balance of X times the token balance of Y after a swap operation should still equal the same constant K, regardless of the asset swapped. Let's illustrate the idea using an example:\n\nGiven we have a Uniswap pool of Ethereum (WETH) and USD Coin (USDC), and a trader makes a swap operation ‚Äî removing some WETH to add some USDC ‚Äî the balance ratio should remain constant to prevent the trader from manipulating the price to their advantage.\n\n![](https://cdn.videotap.com/7AR7AuVGUkohvd6xDQ8G-119.24.png)## Simplifying The Equation\n\nThe X \\* Y = K equation might seem a straightforward invariant, but implementing it as an assertion in the codebase can be challenging. But don't worry ‚Äî to ease the process, we need to simplify this equation to a form where we can explicitly say the change in token balance must always follow a certain formula.\n\nWe'll simplify the equation using algebra to a format suitable for ‚Äústateful fuzz testing‚Äù. Don't feel pressured if you don't follow every step; you can still hold on to the principle that checks out.\n\nHere‚Äôs the process of simplifying the equation using algebra:\n\n1. Starting with the core equation and its variant:\n\n```ruby\nX * Y = K (core equation)X * Y = (X + ‚àÜX) * (Y - ‚àÜY) (With changes ‚àÜX and ‚àÜY in X and Y)\n```\n\n![](https://cdn.videotap.com/QHzVQA2HNb4hbKJl7pYc-220.14.png)2. Using the FOIL (First Outer Inner Last) algebraic method to simplify the equation:\n\n```ruby\nX*Y - X*‚àÜY  = X*Y + ‚àÜX*Y - ‚àÜX*‚àÜY\n```\n\n3. X\\*Y appearing on both sides of the equation:\n\n```ruby\n-X*‚àÜY  = ‚àÜX*Y - ‚àÜX*‚àÜY\n```\n\n4. Isolate the change in X (denoted as ‚àÜX):\n\n```ruby\n‚àÜX * Y - ‚àÜX * ‚àÜY = X * ‚àÜY\n```\n\n5. Factor out ‚àÜX:\n\n```ruby\n‚àÜX * (Y - ‚àÜY) = X * ‚àÜY\n```\n\n6. Solve for ‚àÜX:\n\n```ruby\n‚àÜX = (X * ‚àÜY) / (Y - ‚àÜY)\n```\n\nAnd there you have it! We've simplified the equation from X \\* Y = K, down to ‚àÜX = (X \\* ‚àÜY) / (Y - ‚àÜY) ‚Äî an equation we can use in our fuzz test!\n\n![](https://cdn.videotap.com/q4fjlDbGWHwTtzGV6qC4-467.79.png)## Wrapping Up and Next Steps\n\nWe did some crafty algebra to break down X \\* Y = K to a simplified equation. Remember, the formulas we were dissecting are vital for the Uniswap protocol to maintain a balanced token ratio, hence they are also vital for us when creating our stateful invariant testing suite.\n\nDon't despair if the blocks of algebra seems difficult to understand because all the math we've covered will be included in the associated Github repo. If you're more comfortable with visual diagrams or need a deeper explanation of mathematical techniques, [Chat GPT](https://chat.openai.com/) can be very helpful.\n\nFor those who wish to take an even deeper dive into the formal verification of the X\\*Y=K market maker model, the respected paper on [Runtime Verification](https://runtimeverification.com/) goes into detail about how the formula works from a formal perspective.\n\nThanks for reaching this part, keep up the good work, and see you in the next blog post!\n",
          "updates": []
        },
        {
          "lessonId": "d8649b57-9977-4a49-9b40-fd74a03c43b1",
          "number": 21,
          "title": "Invariant.t.sol",
          "slug": "invariant-t-sol",
          "folderName": "21-invariant-t-sol",
          "description": "",
          "duration": 17,
          "videoUrl": "kW17nSlpptA",
          "rawMarkdownUrl": "/routes/security/5-tswap/21-invariant-t-sol/+page.md",
          "markdownContent": "---\ntitle: Writing T-Swap a stateful fuzz test suite - Invariant.t.sol\n---\n\n\n\n---\n\n# Testing Smart Contracts with Invariants\n\nHey there, in this blog post, we're going to walk through how to audit a smart contract using invariant testing. Specifically, we'll use the TSWAP contract codebase. By the end of this tutorial, you'll have a grasp on writing invariant test suites in Solidity.\n\n## Overview\n\nLet's imagine you're tasked with a private audit. You're supposed to help someone stay secure. It's an awesome feeling when you come back with an audit report together with an invariant test suite. As we'll see in this tutorial, it's essential not to dive into looking at the code base before writing testing essentials. So yes, we're going to find bugs without even viewing the code base. Sounds crazy, right? Buckle up!\n\n## Setting Up The Codebase\n\nWe'll start by setting up our file structure. In our working environment, let's create a new folder called _invariant_. In this folder, we're going to house two Solidity (.sol) files. The files will be named `invariant.t.sol` and `handler.t.sol`, respectively.\n\nOnce we've set this up, we're ready to start writing our tests.\n\n## Building Our Invariant\n\nWe'll begin with writing `invariant.t.sol`. We need to start defining our tests by first constructing the 'invariant'.\n\nBuilding up `handler.t.sol` will require us to dig deep into the codebase. However, we can get away with developing `invariant.t.sol` a little bit blind. It allows us to commence testing without scrutinizing the entire contract.\n\n## Constructing Mock Tokens\n\nWhile preparing our test environment, we realize that our contract is interacting with the WETH token and a particular poolFactory. These factories take in WETH tokens as an input parameter. Therefore, as part of our setup, we're going to create mock tokens.\n\nLet's create another directory named _mocks_ where we will create some mock tokens. We will need one file called `ERC20Mock.sol`:\n\nWe then proceed to create an `ERC20Mock`, which derives from `ERC20` token.\n\nThis way, we prepare a simulated environment where the tokens we will use do not have actual value, which is critical for safe and responsible testing.\n\n## Writing The Handler\n\nWith our tests set up, our next step is to write the handler. While we could write asserts directly in our invariant, the cleaner approach is to compute these in the handler. This way, our assert becomes a one-liner:\n\nThis way, we can ensure that our logic holds, regardless of the varying input parameters. In developing more complex software or systems, invariants play a crucial role in enforcing correctness.\n\n## Conclusion\n\nWell, it's been a long post! Whew. But there you have it, you now have a good grasp of writing invariant tests for your smart contracts. Remember, practice makes perfect and don't shy away from puzzling your brains. It's part of the fun in blockchain development. Keep practicing!\n",
          "updates": []
        },
        {
          "lessonId": "a5b53fd9-50f1-46d1-bcbe-11ff65fd418f",
          "number": 22,
          "title": "Handler.t.sol",
          "slug": "handler-t-sol",
          "folderName": "22-handler-t-sol",
          "description": "",
          "duration": 18,
          "videoUrl": "dka-nbF0HYY",
          "rawMarkdownUrl": "/routes/security/5-tswap/22-handler-t-sol/+page.md",
          "markdownContent": "---\ntitle: Writing T-Swap a stateful fuzz test suite - Handler.t.sol, Deposit Function\n---\n\n\n\n---\n\n# Breaking Down DeFi Audits with Invariant Testing\n\nIn this deep dive into DeFi audits, we will be covering a wealth of material ranging from DeFi to invariant testing. Do remember that we're dealing with complex topics, so if things are not making perfect sense, take a breather, and continue at your own pace. You're doing great by simply trying to digest this sizable chunk of advanced concepts.\n\n## Building a Handler\n\nLet's start with the task of building our handler. A common technique that comes in handy when addressing large problems is to break the problem down into smaller segments. We're taking this approach with our handler development.\n\nIn our contract, a constructor will create a TSWAP pool. Now, we need to test an invariant that the change in `X` (token balance) is equal to the expected change in `X`.\n\nWithin our handler, we'll want to implement at least two main functions: a deposit function and a swap function. For the purposes of this tutorial, we‚Äôll focus on `deposit` and `swapExactOutput` functions as a starting point.\n\n## Decoding Function Documentation\n\nOne advantage we have while trying to understand these functions, is that the documentation is quite helpful. If there were no docs, we'd be wading through the code itself, which could be much more time-consuming.\n\nTaking `swapExecOutput` for example, the function documentation illustrates its working as follows:\n\n> swapExecOutput figures out how much you need to input, based on the output you want to receive. For instance, if you want ten output tokens of WETH and you're inputting DAI, the function will calculate the amount of DAI needed to get you the desired WETH and execute the swap.\n\nSuch explanations in the documentation significantly facilitate understanding of the code, thus contributing to making the auditing process relatively less time-consuming.\n\n## Keeping Notes\n\nWhile working through the process, it's good practice to keep notes or record findings, especially when there are missing parameters as we've noticed in the `swapExecOutput` function. Let's do this to maintain an audit trail for future reference.\n\nHere‚Äôs a simple note example:\n\n> Notes:Audit findings:Missing param in NatsSpec, missing deadline param in `swapExecOutput`. Also, remember to check with the protocol team for any documentation for better audit efficiency.\n\n## Setting up Core Handler Actions\n\nBack in our handler, we want to focus on two primary actions, at least to start: depositing and swapping.\n\nTo perform a deposit, we need access to the tokens. For swapping, we're likely to use `swapExactOutput`. We'll begin by implementing these, and gradually build from there. By writing a Fuzz test suite to execute these actions, we will not only be contributing to better code quality, but also making the protocol safer.\n\nLet's begin with creating our deposit function.\n\n## Constructing the Deposit Function\n\nOur deposit function begins by defining our tokens, in this case, WETH and Pool tokens.\n\nWith the availability of these tokens, we can proceed with determining the amounts for tokens to deposit, ensuring we set reasonable amounts to avoid overflow errors. The quantity of WETH to deposit will dictate the corresponding change in the Pool tokens.\n\nOnce we execute the deposit, we compare our expectations (expected delta) with the actual changes in the Pool and WETH tokens.\n\nWe are effectively done with our deposit function, but we didn't sign up to only handle deposits; we're here to test the swap invariant.\n\n## Building the Swap Function\n\nThe auditing process includes verifying code and ensuring that invariants hold through operations like swaps. That's part of what we're trying to achieve here, which brings us to create our swap function.\n\n> \"Remember, the bigger the vulnerabilities you uncover, the bigger the improvements you can make, ultimately contributing to the overall safety of DeFi protocols and the blockchain ecosystem.\"\n",
          "updates": []
        },
        {
          "lessonId": "03eddcf6-15bb-43fb-8686-ce58db4c094f",
          "number": 23,
          "title": "Handler Swap Function",
          "slug": "handler-swap-function",
          "folderName": "23-handler-swap-function",
          "description": "",
          "duration": 12,
          "videoUrl": "hsoPWni-s5Y",
          "rawMarkdownUrl": "/routes/security/5-tswap/23-handler-swap-function/+page.md",
          "markdownContent": "---\ntitle: Handler.t.sol - Deposit Function\n---\n\n\n\n---\n\n# Testing Uniswap's Token Swap Function\n\nIn this post, we're going to thoroughly explore the function which swaps a pool token for `WETH` along with the underlying math involved. In Uniswap, `WETH` is short for Wrapped Ethereum, a token that represents Ether 1:1, enabling it to adhere to the ERC-20 standard.\n\n## The Swap Function and Its Logic\n\nFirstly, we bind `outputWETH` between 0 and `UNI_64_MAX` to provide a more realistic transaction range. We don't want all the money in the pool to be swapped out. This would be logically unfeasible and destructive for liquidity, hence we return if `outputWETH` exceeds the pool balance.\n\n## Delving into the Math Underlying the Function\n\nIn order to ascertain the pool token amount that must be minted or burnt based on `outputWETH`, we employ the following mathematical derivation.\n\nIn the `TSWAP` pool, there is a function called `getInputAmountBasedOnOutput`, which yields the `delta_x`. Without going into the specifics of this formula, let's understand why it works with a bit of simple algebra.\n\n> _\"It's in understanding how to manually solve these equations that you understand the importance and workings of the smart contract functions we work with.\"_\n\nWe utilize this function on the `TSWAP` pool to get the `poolTokenAmount` which is our `delta_x`.\n\n## Updating Starting Deltas\n\nThe reason for the `-1 * _outputWETH` is because the pool is losing `WETH`, hence making the `deltaY` negatively inclined. We comfortably say that it is the `expectedDeltaY`.\n\n## Minting Pool Tokens for Swapping User\n\nHere, we commence by creating a new person `address swapper`. This is the person performing the swap with the pool. If the swapper doesn't have enough pool tokens for this swap, we mint the difference along with one additional token just to be explicit.\n\n## Actual Token Swap\n\nThis is where the actual token swap occurs. We begin a new transaction under the swapper's address. This transaction includes approval for the pool to manage their pool tokens, with no limit set (`UNI_256_MAX`), with the `swapExactOutput` function called to perform the swap.\n\n## Finalizing Swap and Updating Ending Deltas\n\nAfter completing the swap, we simply update our ending deltas and calculate the actual deltas. The actual deltas are simply the initial balances subtracted from the final balances.\n\n## Conclusion\n\nThe entire handler function, `swapPoolTokenForWETH`, crafts a transaction, conducts a swap on the pool and calculates expected and actual balance changes to ensure the protocol behaves as expected.\n\nThe process can feel challenging when dealing with mathematical equations, but abstraction makes it easier. We've constructed our handler focussing on the process more than the math. This handler allows easier stateful fuzzing tests, ensuring the safety and security of anyone interacting with the pool.\n\nThis testing framework aids in understanding how these token swapping protocols are designed and behave, giving us more confidence in the robustness of Uniswap's smart contracts.\n",
          "updates": []
        },
        {
          "lessonId": "19a75983-8466-48de-9cb8-bc84bd3981ae",
          "number": 24,
          "title": "Final Invariant And Tweaks",
          "slug": "final-invariant-and-tweaks",
          "folderName": "24-final-invariant-and-tweaks",
          "description": "",
          "duration": 3,
          "videoUrl": "tLGNJ-cfGAg",
          "rawMarkdownUrl": "/routes/security/5-tswap/24-final-invariant-and-tweaks/+page.md",
          "markdownContent": "---\ntitle: Final Invariant & Tweaks\n---\n\n\n\n---\n\n# Diving into Invariants: Writing Tests in Coding\n\nIn this blog post, we will uncover the steps to set up tests for an invariant in our code. Precisely, we will write a simple test and furthermore guide you through the setup for our handler.\n\n## Writing the Test\n\nAfter establishing our invariant, it's time to proceed to writing a basic test. This test could be as simple as asserting that the actual `Delta X` from our handler should equal the expected `Delta X`. Here is how we could write this test.\n\n```python\nassert handler.actualDeltaX == handler.expectedDeltaX\n```\n\nThough I must confess, I often prefer writing `assertEqual` as it usually provides more detailed information, you can certainly opt for our above statement which succinctly accomplishes the task.\n\nThe actual test, however, functions in rudimentary terms to ensure that our expected delta is aligned with the actual delta in the handler.The expected delta is assigned using the function `Y times X equals K`, which calculates the expected deltas. We then compare the computed deltas to the actual deltas.\n\n## Setting Up the Handler\n\nNow, let's dive into actually setting up the handler, which calls for us to move up a bit, retracing our steps.\n\nTo initiate the handler setup, we need to first import it. This can be done using the following code:\n\n```python\nimport handler from 'handler.t.sol'\n```\n\nAfter successfully importing the handler, we can create a new handler using the `new` keyword. This handler takes the parameter as `poolBytes for Array memory`.\n\n> Note: All the variables used above can be replaced depending on the specific needs of a project.\n\nIn conclusion, we have seen how easily we can write the basic structure of a test and set up our handler. The ease at which we can perform these tasks simplifies our coding endeavors and ensures more stable code in the long run.\n\nRemember, while writing tests, our ultimate goal is to ensure that our code behaves as we expect it to under different circumstances. After all, in the words of a wise coder, \"Code without tests is bad code.\". Make space for tests the next time you code and watch the number of errors drop significantly.\n",
          "updates": []
        },
        {
          "lessonId": "e455fe14-0139-4841-a296-19d5c9c27b3b",
          "number": 25,
          "title": "Debugging The Fuzzer",
          "slug": "debugging-the-fuzzer",
          "folderName": "25-debugging-the-fuzzer",
          "description": "",
          "duration": 8,
          "videoUrl": "tLcpqejwHo8",
          "rawMarkdownUrl": "/routes/security/5-tswap/25-debugging-the-fuzzer/+page.md",
          "markdownContent": "---\ntitle: Debugging the Fuzzer\n---\n\n\n\n---\n\n# Debugging Your Code the Way a Pro Would Do It\n\nIn today's lesson, we'll dive into a realistic process of debugging, using live examples and explaining how to overcome certain coding hurdles.\n\nTypically, I spend a large chunk of my work hours debugging unexpected failures in code scripts, and I thought it would be valuable to share my experience with you.\n\nOften, you'll need to rerun your code, alter variables, and cross your fingers, hoping you'd not receive the same error. Debugging is intriguing and requires a keen eye for detail.\n\n## Debugging a Program\n\nHere is a practical example of how I discovered, investigated, and resolved errors in a program, step by step.\n\n![](https://cdn.videotap.com/YQdEYI0P1ab2zx1GvZnZ-68.11.png)\n\n### Step 1: Testing the Code\n\nAs expected, the program failed. The error notably pointed out that the `TSWAP pool must be more than zero`. From my experience, such failures are usually attached to some misconfigured variables or misplaced logics.\n\nIn this case, when checking back on the `handler`, there was a deposit function configured with zero - a value that must certainly be greater than zero.\n\nI then had to ask myself, what seemed to be the `minimum deposit`?\n\n### Step 2: Debugging Interlude\n\nI discovered something crucial here - the `minimum WETH liquidity`. This was the `minimum deposit amount` I should've assigned instead of zero.\n\nUsing this newly found information, I decided to replace the zero value in the `bound` function with this minimum deposit amount and then reran my test.\n\nIt appeared that the function `get input amount based off output` had been assigned the zero value, as was previously the case. Here we had to replace the zero with `pool. Get minimum WETH deposit amount` to avoid similar complications.\n\n### Step 3: Learning and Debugging\n\nI intentionally ran into these issues because it's an inevitable part of the coding process and learning experience. Debugging requires a skill to easily navigate through logs - It's a practice I find effective in learning code structure.\n\nAt this point, the `assertion` seemed to hit a snag. The immediate response was an `actual Delta X` being zero while on the right hand side, it was a large number. The inconsistency in values raises the question - where did I go wrong?\n\nTurns out, there was a small but significant mistake in the addressee in my code. It had mistakenly been set to `address this`, when it should have been `address pool`.\n\n### Step 4: The Resolution\n\nOnce that was rectified, it seemed like we were getting somewhere. The code was now giving a different error, an indication that we were making progress. However, I noticed there was a significant variance between the left and right side values - almost a clear doubling.\n\nThe key question now was whether my code was the problem or there was an `invariant` that was actually broken. Debugging requires such critical thinking to diagnose the root cause of errors.\n\n_SECTION OF CODE TO INSERT HERE_\n\nIt turned out I had made an incorrect assignment in the `handler`. The `Delta X` was supposed to be the `pool token amount` calculated earlier. This led to an unexpected elevation in the `outbound WETH` size, causing the script to keep reverting.\n\nTo solve this, I had the `bound` function call on the `WETH balance of the address pool`, as opposed to it being manually large.\n\n#### Handling Debugging Challenges\n\n> \"In debugging, there's a lot of trial and error, and it's okay. You're going to encounter a few challenges on your first try but with perseverance and keen attention to detail, you'll find a way to resolve these errors\".\n\nAfter making the necessary alterations and rerunning the tests, the program finally passed. This means the code was safe and no bugs were found.\n\n## Conclusion\n\nEven after successfully debugging, remember that your code is always subject to possible future errors. But now armed with the skills and patience to debug, you are better prepared to face any challenge that comes your way.\n\nStay creative and keep debugging!\n",
          "updates": []
        },
        {
          "lessonId": "1633a5de-6dcd-40c1-9afb-5a03f74b36e4",
          "number": 26,
          "title": "One Last Huzzah",
          "slug": "one-last-huzzah",
          "folderName": "26-one-last-huzzah",
          "description": "",
          "duration": 10,
          "videoUrl": "TznxX0j3tG8",
          "rawMarkdownUrl": "/routes/security/5-tswap/26-one-last-huzzah/+page.md",
          "markdownContent": "---\ntitle: One Last Huzzah\n---\n\n\n\n---\n\n# Unveiling the Power of a Stellar Stateful Fuzzing Test Suite\n\nEver experienced one of those situations when you felt like capitulating because nothing seems to work? Only to find that, against your better judgment, you gave one last attempt and everything fell into place? That's exactly the kind of journey we are about to hop on. What started as a simple methodical troubleshooting transmogrified into an exploration of the ever-useful, indispensable tool ‚Äì the stateful fuzzing test suite.\n\n## EQ. X vs. Y Test Runs\n\nSometimes, when we're stuck with a challenging bug and can't seem to point out why it exists, we need to remain resolute and alter our approach. This was exactly the case when I was working with a piece of code and an assertion failed.\n\nChanging our test from X to Y and modifying the stats gave a rather perplexing output - the core invariant seemed to be breaking.\n\n## Spelunking Through the Log Files\n\nLike seasoned detectives, we read through the log files for some answers. This particular log file was teeming with `deposits` and `swaps`, a lot of balance adjustments, and, in the last section, things seemed to head south. Something was going awry in the last swap which led to an unexpected disparity between the left and right results.\n\n> \"...usually there's a lot of alpha in this last section, like what happened in this last swap, which caused this to get way out of whack because everything was fine right beforehand...\"\n\nWhile digging further into the function call in the `handler`, my attention was drawn to multiple `transfers` being emitted - one more than was expected.\n\n## Unearthing the Rogue Code\n\nUpon close inspection of these transfers, I discovered some discrepancies:\n\n1. There was an unusual `transfer` from the `TSWAP pool` to the `swapper`\n2. Subsequently, another weird `transfer `was being emitted from the `swapper` to the `TSWAP pool`\n3. Then again, there was another `transfer` from the `TSWAP pool` to the `swapper`\n\nNeedless to say, this wasn't what I was expecting. Recognizing that my stateful fuzzing tests were pointing towards a peculiarity, I decided to dive deep into the code base.\n\n## AHA - The Bug!\n\nAs I ventured into the low-level swap function, I unraveled the mystery - I discovered we'd included an extra incentive in the swap function where for every 10 swaps, an extra token is awarded to the user.\n\nThis was the heart of the issue. It was resulting in the protocol breaking because:\n\n- There was an unexpected increase in the swapper's balance\n- For any fee transfer token, the internal function would transfer excessive tokens, thus breaking the protocol invariance\n\nIt dawned upon me that the violation of the protocol invariant, in this case, the `XxY=K formula` was generating this bug.\n\n## Significance of Stateful Fuzzing tool\n\nDespite all these findings, it was the fruit of a good deal of work. Finding the code-breaking bug involved meticulous editing and testing using the stateful fuzzing tool. However, it was unequivocally worth it.\n\nManual review, despite its efficiency, can be laborious to discover all bugs. Therefore, it becomes essential to leverage automation as a means to make our jobs simpler. That's where the role of stateful fuzzing comes to the forefront. It allows us to comprehend protocol invariants on a superior level while giving us an inexpensive way of finding bugs and breaking protocols.\n\nIt's pivotal to understand how this powerful tool works, even if you're unable to grasp the complexities of the TSWEAP handler.\n\nUltimately, the ability to discover potential bugs by writing an effective test suite is an indispensable instrument in your toolkit. Once the protocol's invariance is identified and it is discovered that no tests are being run for it, it is a clear indicator that a bug lurks somewhere around. For instance, for a codebase comprising 10,000 lines of code, conducting an audit could consume abundant resources, but a stateful fuzzing test suite can accomplish the task in a day or two.\n\n## Learning and Adaptation\n\nThrough this experience, I understood that weird ERC-20s, rebase, and fee-transfer tokens can disrupt our protocols. These conditions, along with our naive incentive for swappers, can violate protocol invariance, causing a breakthrough for bugs. It underlines the importance of knowing the specifics of the tokens we are working with - their advantages, drawbacks, and the protocol invariants they obey.\n\nUltimately, establishing a protocol invariance pattern in the writing of functions or applying checks using the \"checks, effects, interactions\" paradigm can be the game-changer in reinforcing your code against bugs.\n\nIn all, spending a bit of time setting up the stateful fuzzing test suite can help you detect bugs early, maintain your invariances and ensure the code you wrote stays robust, performant, and error-free.\n",
          "updates": []
        },
        {
          "lessonId": "1063c7cf-05a5-4a46-80e2-d7fab3690a3a",
          "number": 27,
          "title": "Notes On Invariants",
          "slug": "notes-on-invariants",
          "folderName": "27-notes-on-invariants",
          "description": "",
          "duration": 4,
          "videoUrl": "YiVP2LrSzQk",
          "rawMarkdownUrl": "/routes/security/5-tswap/27-notes-on-invariants/+page.md",
          "markdownContent": "---\ntitle: Notes on Invariants and other Types of Tests\n---\n\n_Follow along with the video:_\n\n\n\n---\n\n# Welcome to the World of Invariants and Fuzzing Tools\n\nHi all! We've been on quite a journey together, haven't we? We've had our brains whipped into a frenzy learning how to effectively use fuzzing tools and, yes, there were certainly times when we delved into confusing territories. However, we also learned how these powerful tools can help us discover and break invariants, quickly identifying issues in protocols. In this post, we'll build upon these foundational skills, diving deeper into an exploration of ERC20s, core invariants, and much more!\n\n## Unraveling the Mysteries of ERC20s\n\nThe world of ERC20s can often seem daunting and puzzling, but do not fret, we're here to unravel its mysteries. We have only just scratched the surface of understanding these tokens in our sessions, but expect to see more of them popping up as we progress through our course.\n\n## Defining Core Invariants and Breaking Them Down\n\nEqually important to our exploration are, of course, core invariants. These are rules that remain unaffected regardless of the system state. Now, if you're still scratching your head over the term \"freepy\" (or CEI, as others might call it), think of it as a practice of implementing pre and post-checks to uphold certain invariants.\n\nTo illustrate this, let's look at two protocols - Uniswap and Euler. The former has an intact core invariant embedded within its codebase; the Euler protocol, unfortunately, does not. This lack of an invariant was a significant contributor to the much-talked-about Euler hack that happened recently.\n\n## Exploring Different Testing Tools and Approaches\n\nWhile our journey has already spanned areas of forge fuzzing, stateful fuzzing, and invariants, there are still a few facets we're yet to traverse. Say, for example, `Echidna`. In case you're unfamiliar with it ‚Äì it's a powerful fuzzing tool that pairs excellently with Foundry Fuzzing Consensus's paid tool.\n\nMutation and differential testing, on the other hand, didn't make the cut for our workshop, so we will discuss them briefly here.\n\n> Mutation testing involves modifying parts of the code to evaluate if these changes break any existing tests.\n\nLet's turn to the git repo attached to this tutorial for reference. Under `audit_data`, you'll find a 'test' folder with a note about differential testing. Also, there is a differential folder where you can perform fuzz testing against the output of `uniswap`.\n\nFor mutation testing, imagine altering `Tswappool.sol` in various ways, such as deleting a line, swapping out math, or changing a greater-than operator to a less-than. The objective here is to ensure your tests catch these errors.\n\nThrough this practice, you can evaluate the effectiveness of your testing framework. While we didn't perform any mutation testing in our session, it's a valuable tool you should consider implementing.\n\n## Driving the ‚ÄòSolodit' Train\n\nWe're gearing up to dive into `Solodit` in the upcoming sessions. With `Solodit`, we can learn from historical findings, uncovering a wealth of insights from the peculiarities of ERC-20s to the importance of preserving invariants.\n\nParsing through the archives of `Solodit`, you'll discover numerous examples of how weird ERC-20s have caused problems. Try a simple search for 'invariants' on Solodit, and you'll unearth a treasure trove of invariant findings, spelling out a wealth of knowledge and learning opportunities.\n\n## Wrapping It Up!\n\nTo sum up, we've done a ton of work together; we've navigated unchartered territories, explored protocols, learned about testing and more. On this journey, we've embraced the weirdness of ERC20s, the intriguing world of invariants, and a handful of robust testing tools.\n\nStay tuned for more exciting stuff coming your way! Remember, we're learning together, we're growing together, and, most importantly - we're making the future of protocols safer, together. Until next time, happy learning!\n",
          "updates": []
        },
        {
          "lessonId": "413b0bcc-889f-4c1c-a23e-07cda2063929",
          "number": 28,
          "title": "Recon: Manual Review Introduction",
          "slug": "recon-manual-review-introduction",
          "folderName": "28-recon-manual-review-introduction",
          "description": "",
          "duration": 2,
          "videoUrl": "agaMBAv-M0o",
          "rawMarkdownUrl": "/routes/security/5-tswap/28-recon-manual-review-introduction/+page.md",
          "markdownContent": "---\ntitle: Recon Manual Review Introduction\n---\n\n\n\n---\n\n# Manual Review of TSwap Pool: A Deep Dive\n\nHey, awesome reader! Welcome back to the blog. In the previous posts, we've talked all about tools, code inspections, and automated reviews. However, there's one aspect that invariably remains at the core of the process - the manual review. So, let's grab a cup of coffee and plunge together into the manual review of the TSwap pool!\n\n## The Unreplaceable Manual Review\n\nHere's the thing about manual reviews. This bad boy can find bugs that no static analyzers, no automated systems, and no testing suites can.\n\n> Remember, never underestimate the power of the human eye when it comes to code.\n\nEvery line of code is a potential pitfall and the manual review is our best chance at spotting those tricky bugs that can slip through all those automated testing suites. Yeah, we've come a long way with our tooling approach. But, nothing, I repeat **nothing**, replaces the manual review.\n\n## The Saga of the Under_Swap\n\nLet's recount a bit of our journey. We've written a port, we've had some type of high, and we have the curious case of the `under_swap` that breaks invariants. Yes, we spotted the issue with our fuzzing test suite. So, kudos to us!\n\nBut let's not stop at that, shall we? There could be an entire universe of other issues lurking in the code base. Sure, we could write more tests, more automated checks, more everything. But, we've reached the point where it's time to dig in with our manual review.\n\nRemember,\n\n> Automation is great, but manual code review is the secret sauce that makes everything click!\n\nSo, are you ready to walk through the code base with me?\n\n## Prepping Up For The Manual Review\n\nBefore we dive in, make sure you're comfortable. Have a cuppa joe if that's your jam. Maybe take a break if you haven't yet. Because we're going on a bug hunt! It's not just about spotting the bugs. It's about understanding why they happened. It's about writing down our findings and submitting the report. It's about replaying the process again and again.\n\n> Remember, repetition is the mother of skill.\n\nYou might be thinking, \"Patrick, buddy, this is so boring! Do we really have to...?\" Yes, you do! This is exactly what you need to become a better developer, a better tester, a better debugger. It's the detail, the persistence, the grit that turns you from a coder into a **code warrior**.\n\n## Performing the Manual Review\n\nAlright, it's time for the main event. Let's roll our sleeves up, put our debug glasses on, and let‚Äôs do the manual review.\n\n# Wrapping up the Manual Review\n\nIn the manual review, we'll be going through the codebase, and document our findings. You're not alone and we will be doing this together. In the later sections, we can be a bit more breezy. But right now, this is where the magic happens. Write the report with me. This is your story. Your journey into the bowels of the codebase. The monsters you fought, the bugs you squished.\n\n# Conclusion\n\nSo, what are you waiting for? Let's get cracking! This is gonna be an exciting journey! Stay tuned for our next blog post where we'll be sharing insights from our manual review, documenting our process and achieving our goals step by step, bug by bug. Remember,\n\n> The best way to find your skills is to lose yourself in the code.\n",
          "updates": []
        },
        {
          "lessonId": "2a1b2266-87e2-4546-a62d-6e495dc424d3",
          "number": 29,
          "title": "Slither",
          "slug": "t-swap-manual-review-slither",
          "folderName": "29-t-swap-manual-review-slither",
          "description": "",
          "duration": 2,
          "videoUrl": "Fh4QjDiHhyY",
          "rawMarkdownUrl": "/routes/security/5-tswap/29-t-swap-manual-review-slither/+page.md",
          "markdownContent": "---\ntitle: T-Swap Manual Review Slither\n---\n\n\n\n---\n\n# An In-Depth Guide to Manual Review in Solidity\n\nIn this blog post, we'll be taking a deep dive into the process of manual review in Solidity. We'll be using a comprehensive set of tools including Make Slither and Solidity itself to conduct our review.\n\nBefore we jump into this, it's vital that we kick start the process by running our review tools.\n\n> _For context, our group has a well-configured Slither that's ready to use, in addition to a Makefile with Make Slither, which also looks pretty good._\n\n### Analyzing Slither's Output\n\nWalking through the console output, we find mentions of potentially uninitialized variables. The Pool Factory, s_pools, and s_tokens are flagged by Slither as never being initialized.\n\nIn the lines regarding Pool Factory and useContext functions, there are mentions of methods like `createPool` and `getPool`. It seems like the `S_Pools` and `S_Tokens` data mappings are not getting initialized. Let‚Äôs delve deeper into this.\n\nAlthough these data mappings trigger an error, it's unlikely to be a major issue. The error arises because Slither expects that our `S_Pools` mapping could be empty at some point and we're performing checks on it. However, this behavior is fine and exactly what we want.\n\nThe same applies to `S_Tokens`.\n\n> **Key point:** A useful feature of Solidity is that querying a mapping for a non-existent element returns a zero value, not an error.\\*\n\n### Identifying Potential Issues\n\nThe console output also flags a missing zero check - something that could lead to problems. We're not performing a zero address check in our constructor, which is not ideal.\n\n```javascript\nconstructor(address _token) public {\n    require(_token != address(0));\n    token = Token(_token);\n}\n```\n\nSo, an important note in your audit should be the lack of a zero address check in the constructor. Fortunately, Slither has already proven to be quite useful in finding potential issues.\n\n### Dealing with Reentrancy\n\nTowards the end of Slither's report, we're alerted to a potential reentrancy in the `T_SWAP pool swap` function.\n\n![](https://cdn.videotap.com/1Zwcjq5wz3Hy0mGdOPrV-83.14.png)\n\nWhile this function prompt is green (indicating it's not necessarily a problem), we need to understand the scenario better to evaluate its implication fully. Browsing through contract interactions and function call patterns can help us figure out if this is a legitimate reentrancy issue or a false positive.\n\nFinally, Slither alerts that different versions of Solidity are being used. Not an ideal situation, but not critical either, particularly if the primary working versions are intact. But hey, thanks for the heads-up, Slither.\n\n### Wrapping Up\n\nAll things considered, using tools like Slither for a manual review of Solidity code can reveal potential, and sometimes subtle, issues. Leveraging these tools creates a smoother and more efficient analysis process. Stay curious, stay alert, and keep probing. Your diligence will pay off in the form of solid, bug-free, and highly secure code.\n",
          "updates": []
        },
        {
          "lessonId": "745dc32d-27a5-4ac4-9d49-43bcf15e78c8",
          "number": 30,
          "title": "Aderyn",
          "slug": "manual-review-aderyn",
          "folderName": "30-manual-review-aderyn",
          "description": "",
          "duration": 2,
          "videoUrl": "PiA6B_W9jbE",
          "rawMarkdownUrl": "/routes/security/5-tswap/30-manual-review-aderyn/+page.md",
          "markdownContent": "---\ntitle: Manual Review Aderyn\n---\n\n_Follow along with the video:_\n\n\n\n---\n\n# Introducing the New Version of Aderyn, an Essential Audit Tool\n\nHello, code enthusiasts! Today, I'm going to do a quick run through a unique code auditing tool: Aderyn. Since I've started filming, we've been doing incredible stuff with the script, and there's a lot to share with you! The tool has recently undergone some upgrades, and in this post, we'll be checking out what we can do with the updated version of Aderyn. Let's dive in!\n\n## Installing Aderyn and First Run\n\nAs the first step, I went on to update Aderyn using `cargo install Adarin`. This installs the new version for us. With this modification, you can perform a quick audit just by executing the command `aderyn a` - simple but powerful. Still, an old method, `Aderyn`, works just fine if you're comfortable with it.\n\n## The Audit Report: Understanding the Issues\n\nOn opening the `report.md`, you'll notice a list of issues. Most of these are NC (Non-Crit) issues. These aren't crucial, but addressing them can improve your code's performance and readability.\n\n#### Unused Internals\n\nMy Aderyn installation flagged some functions that are not used internally. So, marking them as `external` would be ideal, like the TSWAP pool line 307 issue. The piece of code here isn't used internally, marking it public is a waste of gas.\n\n```bash\n@audit info, this should be external\n```\n\n#### The Literals vs Constants Debate\n\nAderyn pointed out another common issue - the use of literals instead of constants on TSWAP pool line 303. Essentially, magic numbers should not be just literals - they should be defined as constants.\n\n```bash\n@audit info magic numbers. These should not be defined as constants.\n```\n\n### The Index Field Dilemma\n\nWe also stumbled onto an 'event missing index fields' on TSWAP pool line 62. Now, this is a tricky one. While many people prefer having events indexed, I belong to the group that believes in fewer indexed fields. Therefore:\n\n```bash\n@audit info. Three. Events should be indexed if there are more than three params.\n```\n\nRemember, this is more subjective and up to your coding preferences.\n\nBut we've done quite well so far with the audit, discovering issues and remedying them with Aderyn.\n\n## Wrap Up: The Power of Automated Code Auditing\n\nThe beauty of having an automated script like Aderyn lies in its ability to uncover even the minutest issues which could otherwise be overlooked. Even though some of us might prefer manual code reviews, tools like Aderyn offer a great starting point for clean, optimized code.\n\nThis hands-on auditing process can be a fun, engaging way to discover new improvements, ensuring your code performs better and is more maintainable.\n\n> Remember, quality isn't an act, it's a habit.\n\nOn those wise words from Aristotle, let's wrap up and get back to more code improvements in our next post. Happy coding until then!\n",
          "updates": []
        },
        {
          "lessonId": "044e8cae-6cec-4e70-a27c-c595969403af",
          "number": 31,
          "title": "Pool Factory",
          "slug": "pool-factory",
          "folderName": "31-pool-factory",
          "description": "",
          "duration": 6,
          "videoUrl": "o59mcbKpAGg",
          "rawMarkdownUrl": "/routes/security/5-tswap/31-pool-factory/+page.md",
          "markdownContent": "---\ntitle: T-Swap Manual Review PoolFactory\n---\n\n\n\n---\n\n# A Deep Dive into Smart Contracts: Unraveling Pool Factory and TSWAP Pool\n\nIn this post, we're exploring the Tincho methodology of reviewing smart contracts, through which we'll address an audit of two solidity contracts: pool factory and TSWAP pool. For those new to the land of contracts and Solidity, don't worry! We'll break things down in an accessible way.\n\n## Spot the Import: Pool Factory\n\n![](https://cdn.videotap.com/rzbl0Otqs4FSU2qtnoIs-26.08.png)\n\nInitially, the pool factory has a couple of imports. The interesting one is the IERC 20 forged import. Although the forge interface isn't something I heavily engage with, it catches my eye and is worth deeper exploration some other time. Apart from the IERC 20, we have the import for our second character today‚Äì TSWAP pool.\n\nThe pool factory is the infrastructure of this system because it deploys and launches the pools. In simple terms, it's the bedrock on which every pool stands.\n\nUpon reviewing, we encounter two error messages - \"Pool already exists\" and \"Pool does not exist.\" These are indicative of conditions for pool creation.\n\n```javascript\nif (poolExists) {\n  revert(\"Pool already exists\");\n}\n```\n\nThe contract checks if a pool already exists during creation, thus preventing any duplications.\n\n## The First Bug\n\nOn further delving, it appears the second error message is not used anywhere. This was discovered after a quick code audit. This is our first discovery of a bug - a redundant error message that can be expunged from the code. This certainly won't make or break the system but highlights the fact that some cleaning up and code review could be beneficial.\n\n## Deciphering the Mappings\n\nThere are a couple of private mappings - `tokenTopool` and `poolTotoken`. They allow backward and forward retrieval of pool-token associations. The WETH token is immutable as it pairs with every token.\n\nAmong events, the `poolCreated` is noticeable and appears to be the main event.\n\nConcerning the external functions, `createPool` takes the spotlight as the major function.\n\n## Event Details and Function Understanding\n\nWe've added an informational constructor setting the WETH token and now we can deep delve into the `createPool` function which stands out as the key player here.\n\nThe `createPool` function gets a token address that is mapped to the WETH, forming a token-pool pair. If a pool with this token address is tried to be created again, the system will revert with the error message that the pool already exists.\n\nFurthermore, this function also encompasses the naming logic for the pools.\n\nThe system is retrieving the name of the ERC 20 token and appending it to the word \"TSWAP\" to name the liquidity token. The liquidity token represents the shares of the token given to the LPs (Liquidity Providers).\n\nApart from the naming convention, it's also noteworthy to point out the symbol logic ‚Äì\n\nTo improve user experience, we suggest the token symbol to be used instead of the full token name to avoid unnecessarily lengthy symbols.\n\n## Analyzing Pool Sub-Creation\n\nNext, we initiate pool sub-creation with the respective pool token, WETH token, and the newly created symbol and name.\n\nOn successful pool creation, we add the pool to our list, map it back, emit an event, and finally, return the address of the new pool.\n\n## So... How's The Pool Factory Looking?\n\nFollowing our analysis, the pool factory contract seems to be well-structured, with only a few informational findings on the radar. It is certainly worth a checkmark in the `notes.md`.\n\n```markdown\n- [x] Pool Factory : Looks Good\n```\n\nIn our next chapter, we'll proceed to the TSWAP pool and continue breaking it down. Stay tuned for more straightforward smart contract analysis!\n",
          "updates": []
        },
        {
          "lessonId": "df6d9679-5824-4702-9984-c2b97153e180",
          "number": 32,
          "title": "Manual Review: Swap Pool",
          "slug": "manual-review-swap-pool",
          "folderName": "32-manual-review-swap-pool",
          "description": "",
          "duration": 3,
          "videoUrl": "vHmtJrRpNYA",
          "rawMarkdownUrl": "/routes/security/5-tswap/32-manual-review-swap-pool/+page.md",
          "markdownContent": "---\ntitle: T-Swap Manual Review T-Swap Pool\n---\n\n\n\n---\n\n# Dissecting Uniswap v1 and TSWAP - An In-Depth Security Review\n\nWelcome to this thrilling exploration of the TSWAP pool which gets us to the heart of Uniswap v1. By the end of this piece, you will have an in-depth understanding of Uniswap in its most rudimentary form. Let's delve right into the Uniswap TSWAP pool code and grasp what makes it tick.\n\n## TSWAP in High-Level Review\n\nContrary to what one might expect, the TSWAP pool codebase is impressively user-friendly. Not only is it detailed and transparent, but it is also an ERC20 token, which rings a bell for most blockchain enthusiasts. Being a liquidity token, this characteristic intuitively aligns with its purpose.\n\n## The Safe ERC20 Library\n\nAn additional feature that gives the TSWAP an edge is the usage of the Safe ERC20 library. The primary function of this library is to safely transfer from accounts.\n\nThe Safe ERC20 library comes in handy as a shield against some of the abnormal (and occasionally detrimental) ERC20 occurrences that we might encounter in the later stages of this article.\n\n## Immutable State Variables in TSWAP\n\nTSWAP comes packed with some immutable state variables, such as `Iweth token` and `pool token`, which make perfect sense considering the nature of smart contracts.\n\nEvery contract is bound to have at least two tokens, and these variables stand as unwavering constants for these tokens.\n\n## The WETH Liquidity Feature\n\nAnother intriguing aspect of TSWAP is the WETH liquidity feature, a concept we gleaned from the invariant test suite. If you want to deposit WETH, you have to deposit at least a specific amount known as the WETH liquidity.\n\nOf course, the question that follows is whether this hard-coded determinant is too high, or whether there's a chance something unusual could be going on here.\n\n> \"With coding, it's crucial not to take anything at face value.\"\n\n## Swap Count and Swap Count Max\n\nNext up on our review is the rather peculiar `swap count` and `swap count max`. Their existence can be attributed to an issue we discovered during our stateful fuzzing test suite. From the anomaly, we observed a quirky operation where the protocol gives out extra money after every ten swaps. This random and seemingly unnecessary function seems to break the protocol's expected behavior.\n\n## About Events and Modifiers\n\nTSWAP presents several events that we already have some audit notes about. It also includes modifiers such as `revert if deadline passes` and `revert if zero`. After analyzing these in detail, it is clear that these functions are named aptly.\n\nThe `revert if deadline passes` function reverts if the deadline is less than the current timestamp, which makes perfect sense.\n\nSimilarly, `revert if zero` checks if the account balance is Zero. If it is, the function reverts.\n\n## The Role of the Constructor\n\nLastly, it's worth revisiting the constructor where it may be valuable to add some audit information.\n\nThere's a check for a zero address, but this isn't a pressing issue. For naming conventions, the token names in the constructor seem pretty straightforward.\n\nThis blog post is a deep dive into the codebase of TSWAP. Understanding the dynamics of this liquidity token can inform the design and understanding of other pools within the DeFi ecosystem.\n",
          "updates": []
        },
        {
          "lessonId": "0ffde298-59c3-420d-830d-ab01703ad521",
          "number": 33,
          "title": "Using The Compiler As Static Analysis Tool",
          "slug": "using-the-compiler-as-static-analysis-tool",
          "folderName": "33-using-the-compiler-as-static-analysis-tool",
          "description": "",
          "duration": 6,
          "videoUrl": "fmLWDJFFIyg",
          "rawMarkdownUrl": "/routes/security/5-tswap/33-using-the-compiler-as-static-analysis-tool/+page.md",
          "markdownContent": "---\ntitle: Using the Compiler as Static Analysis Tool\n---\n\n\n\n---\n\n# Diving into Liquidity Addition and Removal Functions\n\nToday, we're delving into the crux of adding and removing liquidity in cryptocurrency pool systems. We'll take a look at the deposit function code from a fictional cryptographic liquidity pool project.\n\nFor those following along, let's do a simple `toggle word wrap` in your favorite code editor so you can view the code more efficiently. If you need the code, you can find it in the associated GitHub repository within the `audit data` folder.\n\n## The Deposit Function\n\n![](https://cdn.videotap.com/86AjU9W56rzzt6USwvmh-25.png)In the relevant code we've got, we run into aspects related to liquidity providers. The deposit function revolves around the liquidity providers' actions in the pool system.\n\nLooking at the function, you'll notice it calls for a certain amount of `wes` (Wrapped Ether). Following the liquidity pool model, when a user deposits funds, they're given liquidity tokens in return. These tokens represent the user's share in the pool.\n\n### Delving Into the Parameters\n\nThere are's an array of parameters involved in the function. Let's break down a few significant ones:\n\n- The `minimum liquidity tokens to mint`: This parameter signifies the quantity of liquidity tokens created, derived from the amount of `wes` the user deposits. However, there's a minimum limit to ensure the user is aware of what they will receive.\n- `Maximum pool tokens to deposit`: Mirroring the earlier parameter, this signifies the maximum number of pool tokens the user is prepared to deposit. This value again is derived from the deposited `wes`, allowing users to gauge how much USDC they should contribute to the liquidity pool.\n- `Deadline`: VC Code gives us a heads up here with the `Unused function parameter`, warning. Surprise! The deadline parameter isn't implemented in this function. Herein lies a potential bug we'll delve into shortly.\n\n## Analyzing the Bug\n\nThe unused `deadline parameter` seems small at first, but it becomes a severe issue upon closer inspection. The deadline parameter is meant to determine when a transaction needs to be completed. If it's unimplemented, the deadline set by a depositor could pass without stopping the transaction, causing unexpected actions on the part of the user.\n\nThis high impact, high likelihood bug results in deposits proceeding when they're expected to fail ‚Äì a clear and severe disruption to functionality.\n\n```markdown\n# Audit Finding: High\n\n# Impact: High, Severe disruption of functionality\n\n# Likelihood: High, Deadline is ignored, leading to transacions being processed beyond the stipulated deadline.\n```\n\n### Unveiling More Bugs\n\nCloser analysis of compiler warnings revealed two other interesting bugs.\n\nThis bug crops up in our deposit function where `pool token reserves` is ignored. The ignored reserves could have been used to do some internal calculations. It seems the developers started some math, then decided to use a function instead, resulting in ignored variables and wasted gas.\n\n```markdown\n# Audit Finding:\n\n    InfoIssue: line of code declaring `pool token reserves` is not used, leading to gas wastage.\n```\n\n- `Unused Function Parameter: Swap Exact Input`\n\nIn this function, an unused `output` parameter shows up, which isn't a major red flag. The impact here seems low since this function seems to only be used externally and this output might not be used elsewhere in the project. The only issue is the return of 0 where it could be another value that might be more meaningful. However, this impact could be more if it's being used elsewhere.\n\n```markdown\n# Audit Finding:\n\n    LowIssue: The `output` parameter returns zero and is never used, which might not accurate reflect the output value.\n    Likelihood: High, always the case. But overall impact is low.\n```\n\nIn conclusion, running a simple compiler check helped us discover several notable bugs. A key takeaway for developers here is the value of regularly checking for and resolving compiler warnings. Time to go ahead and patch up these issues before they turn into severe problems!\n\nStay tuned for more explorations into cryptocurrency programming and keep those bugs at bay!\n",
          "updates": []
        },
        {
          "lessonId": "304981cc-4718-42ed-b1cd-b4231cfe923e",
          "number": 34,
          "title": "Add Liquidity",
          "slug": "add-liquidity",
          "folderName": "34-add-liquidity",
          "description": "",
          "duration": 8,
          "videoUrl": "ql_0nR3Za8E",
          "rawMarkdownUrl": "/routes/security/5-tswap/34-add-liquidity/+page.md",
          "markdownContent": "---\ntitle: T-Swap Manual Review T-Swap Pool - Add Liquidity\n---\n\n\n\n---\n\n# Deep Dive into Cryptocurrency Smart Contract Deposits\n\nIn today's post, we're going to perform a deep-dive into the world of cryptocurrency smart contracts, specifically focusing on the deposit function. We'll be performing a detailed audit of a contract and identifying potential flaws.\n\nWe'll start off with the deposit function and eventually move our way down to analyze all aspects of the contract line-by-line. So, let's dive in!\n\n## Analysing the Deposit Function\n\nLet's take the state of the contract where we're trying to determine how much should be deposited.\n\nIf `WETH` is zero in the contract, we encounter a scenario where it reverts. We also have a condition where if the `WETH` deposit is less than a minimum defined _WETH liquidity deposit_; again a revert scenario.\n\nAnother thing to note is that we probably don't need the emission of the minimum `WETH` because it is, in a sense, redundant. It would be more effective as _audit info_. To put it simply, any user could look up the contract and see what the minimum `WETH` value is.\n\nNext, there are two potential scenarios that initiate heating up the deposit function. These are:\n\n1. If it's a user's first deposit (also called the initial funding of the protocol)\n2. If the user has already deposited\n\n## Exploring Internal Functions\n\nWithin the deposit function, it looks like it's calling an internal function, so let's go and check what that does.\n\nHere, we interpret `weth_to_deposit` as the amount of `WETH` a user is going to deposit, `pool_tokens_to_deposit` as the number of pool tokens they're going to deposit, and `liquidity_tokens_to_mint` as the number of liquidity tokens they're planning to mint.\n\nGiven it's a sensitive function, it's marked private, meaning it can only be invoked within the contract. Inside this function, it seems like we mint the amount of `liquidity_tokens_to_mint` to the `msg.sender`.\n\nThere's also an event trigger called `Liquidity Added`. However, a closer look reveals an audit issue as the parameters are in the wrong order.\n\n```js\nemit LiquidityAdded(msg.sender, pool_tokens, WETH)\n```\n\nThe correct code should look like this:\n\n```js\nemit LiquidityAdded(msg.sender, WETH, pool_tokens)\n```\n\n> Always make sure to check if the events are correctly emitted with the right parameters. This kind of mistake is not a high risk but it's important to avoid confusion.\n\n## Checks and Interactions\n\nAfter validating the event, we conduct some checks and interactions. It's good to see the external transactions happening towards the end of the function, which adheres to the Checks-Effects-Interactions (CEI) pattern.\n\nThe next steps include transferring the tokens from the `msg.sender` to the smart contract, and then updating the state variable `LiquidityTokensMinted`.\n\n```code\ntransferFrom(msg.sender, address(this), ...);...liquidityTokensMinted = weth_to_deposit;\n```\n\nIdeally, we would want to follow the Checks-Effects-Interactions paradigm regularly to streamline the function operations.\n\n## Updating Liquidity and Deposit Checks\n\nOnce the contract is warmed up and receiving liquidity, it's time to perform some checks and balances.\n\nFirst, we crunch the numbers on how many pool tokens should be deposited based on the `WETH` balance. If we calculate too many pool tokens to deposit, the function reverts.\n\nNext, similar checks are performed for liquidity. If the calculated `LiquidityTokensToMint` is less than the minimum, the function again reverts.\n\nAnd voila! If everything goes well, the deposit function works smoothly.\n\n## Concluding Thoughts\n\nWhile auditing a smart contract, thoroughness is essential. The deposit function in our example had a high-severity issue where the deadline was being ignored, but function-wise, it looked solid.\n\nRemember, the aim is always to leave notes with our thoughts anywhere possible and follow up at a later stage if doubt persists.\n\nJoin me in the next blog post as we examine the `addLiquidityMintAndTransfer` function!\n",
          "updates": []
        },
        {
          "lessonId": "5463ab36-f44b-4399-99aa-2504d0b3a9f5",
          "number": 35,
          "title": "Remove Liquidity",
          "slug": "remove-liquidity",
          "folderName": "35-remove-liquidity",
          "description": "",
          "duration": 8,
          "videoUrl": "Ulr_b-0WjmM",
          "rawMarkdownUrl": "/routes/security/5-tswap/35-remove-liquidity/+page.md",
          "markdownContent": "---\ntitle: T-Swap Manual Review T-Swap Pool - Remove Liquidity\n---\n\n\n\n---\n\n# Understanding the Liquidity Withdrawal Process of the TWSAP Protocol\n\nHaving covered the deposit process in TWSAP protocol pools, we're going to look at the other side of the equation - the **withdrawal process**. This is equal to removing the liquidity from the pool as demonstrated in the diagram below,\n\n![](https://cdn.videotap.com/IWZarXmiBGXntt9p7Y16-13.14.png)\n\nFundamentally, we are going to burn LP tokens in exchange for the underlying money. In other words, the liquidity tokens used in the pool are destroyed to get the invested capital back out.\n\n## Understanding Key Concepts\n\nLet's break down some key concepts:\n\n1. **Liquidity tokens to burn:** This refers to the number of liquidity tokens that a user wants to burn. The user gives their LP tokens and in return, they receive their money.\n2. **Minimum WETH:** This is the minimum amount of WETH the user is expecting to withdraw.\n3. **Minimum pool tokens:** These are the pool tokens that a user wishes to withdraw.\n4. **Deadline:** This is the timeframe the user sets for the withdrawal.\n\nAt first glance, these might seem like strange terms but their true value will become more significant when we touch on miner extractable value (MEV) later in the course.\n\nAfter digesting these concepts, we check for the withdrawal deadline. In the code, there is an `if` condition which reverts the transaction if deadlines are not met.\n\n```js\nif (deadline < block.timestamp) {\n  revert();\n}\n```\n\n## Burning the Liquidity Token\n\nNext, we proceed to burn the liquidity token. You might be wondering if this is an external function. However, this burn function is actually part of the TSWAP pool, inherited from the ERC20 smart contract.\n\nAfter burning the tokens, we then emit an event and proceed with the transfer of funds.\n\n## Understanding the Magic Numbers and Fees\n\nLooking further into the code, we come across certain numbers that seem a bit random. We're dealing with functions like `getOutputAmountBasedOffInput` and `getInputAmountBasedOffOutput`.\n\nIf we dive into the calculations of these functions, we can see that these \"magic numbers\" i.e., 997 and 1000, are factored into the formula. A peek into it reveals that a fee of 0.3% is deducted from the user's returns every time they swap.\n\nNow it's time to reveal the secret behind these magic numbers! If you see these 997 and 1000 used in your code, know that they represent the 0.3% fee!\n\n## Issues and Solutions\n\nHowever, there's a slight discrepancy in the two function calculations. The `getInputAmountBasedOffOutput` function shows a different fee (0.913%) due to the denominator being 10,000. This could result in users getting charged excessively when they swap, leading to high impact and likelihood.\n\nThis calls for more accountability in handling these magic numbers. Instead of hardcoding them into the formula, they can be defined once at the top of the code as a private constant. This ensures that constants are consistent across the protocol - reducing room for error and enhancing code security.\n\n> \"The best coding practices are not just to embellish your codebase. They serve the purpose of enhancing the security and predictability of your code.\" - John Doe, Senior Software Engineer.\n\n## Concluding with the Swap Function\n\nOur journey doesn't end yet! Next up is the **swap function**, one of the essential functions in any DeFi protocol. Stay tuned for exploring its intricacies in the next blog post!\n\n## On the Importance of Natspec\n\nBefore we go, it's worth flagging that an essential element is missing from our important functions - the **Natspec**. Natural Specification (NatSpec) is an Ethereum standard introducing rich, multi-line comments in the code which greatly aids readability and understanding. For crucial functions like the swap function, you must include NatSpec to improve the code's legibility!\n\nAnd that is all for the withdrawal process folks! Stay tuned for the next exploration into the TSWAP protocol. Make sure to check back for more DeFi insights and breakdowns!\n",
          "updates": []
        },
        {
          "lessonId": "5b22e4c5-85d5-4ad2-a192-c62bf7f03271",
          "number": 36,
          "title": "Exact Input",
          "slug": "exact-input",
          "folderName": "36-exact-input",
          "description": "",
          "duration": 6,
          "videoUrl": "jou1PCLlwFI",
          "rawMarkdownUrl": "/routes/security/5-tswap/36-exact-input/+page.md",
          "markdownContent": "---\ntitle: T-Swap Manual Review T-Swap Pool - Swap Exact Input\n---\n\n\n\n---\n\n# Unraveling Swap Exact Input and Output in Ethereum Smart Contracts\n\nThe language of Ethereum smart contracts, Solidity, can be complex and daunting, especially when dealing with functions like \"Swap Exact Input\" and \"Swap Exact Output\". Let's walk through how these functions work, what they're designed to do, and some critical points to look out for.\n\n**Understanding \"Swap Exact Output\"**\n\nThe \"Swap Exact Output\" function provides a useful, straightforward way of determining how much input is required for a specific output. In essence, this function works out how much you would need to exchange to receive your desired amount of tokens.\n\nIn practical terms, let's assume you're swapping or selling DAI to buy WETH, or wrapped Ether. Here, the '\"Swap Exact Output\" function calculates how much DAI you'd need to input to get the exact amount of WETH you want.\n\n**What about \"Swap Exact Input\"?**\n\nAlong the same lines, you could infer that \"Swap Exact Input\" does just the opposite; it determines how much output you'd receive for a definite input. Essentially, this is the function you'd apply if you have a particular amount of tokens you'd like to swap with an expectation of the amount of tokens you will receive.\n\nBut what happens if your output is less than the one WETH you expect? The function logs an error message, typically something along the lines of \"TSWAP pool output too low\", and reverts the transaction.\n\n**The Role of \"Deadline\"**\n\nA crucial part of swapping tokens is setting a deadline for when the transaction should expire. This timestamp, defined in the function, reverts to zero if the deadline fails.\n\n![](https://cdn.videotap.com/CP5x1AoZaOQRK8ROhjOo-190.47.png)\n\n**Auditing Swap Function**\n\nA key function to scrutinize during smart contract auditing is the swap function. In theory, this function should maintain the protocol invariant (x\\*y = k), but in some contracts, you might spot a discrepancy that defies this key principle. Any \"extra\" tokens appearing can violate this rule, consequently causing potential vulnerabilities.\n\n> \"After every 10 swaps, we give the caller an extra token for an extra incentive to keep trading on TSWAP.\"\n\nThis statement flags a potential breach. A good practice in smart contracts is to incorporate invariant checks in functions, basically a `require` statement that validates the invariant hasn't been violated.\n\nTo sum up, \"Swap Exact Input\" and \"Swap Exact Output\" play a vital role in token swaps. By understanding how these functions work, smart contract developers and auditors can uncover potential pitfalls and ensure efficient, secure trading experiences.\n",
          "updates": []
        },
        {
          "lessonId": "b9890373-b756-4e32-9d8f-a3c2da5b5e63",
          "number": 37,
          "title": "Exact Output",
          "slug": "exact-output",
          "folderName": "37-exact-output",
          "description": "",
          "duration": 3,
          "videoUrl": "tbf65EMdqNI",
          "rawMarkdownUrl": "/routes/security/5-tswap/37-exact-output/+page.md",
          "markdownContent": "---\ntitle: T-Swap Manual Review T-Swap Pool - Swap Exact Output\n---\n\n\n\n---\n\n# Swapping Exact Output on Uniswap: A Deep Dive\n\nHello world! Welcome to another dive into the deep, deep ocean that is Uniswap. Today, we'll be examining another function, `swapExactOutput`. This is the reverse of `swapExactInput`, and you'll find, as we explore farther, that there are exciting and potentially scary quirks in how this function operates.\n\n## Understanding `swapExactOutput`\n\nIn the case of the `swapExactInput`, as the name suggests, we decided the input token amount beforehand and asked the system to provide us with the corresponding output.\n\nIn the `swapExactOutput`, the tables turn. We're going to define the output we'd like to receive. We don't provide any 'minimum input' ‚Äì this comes across as odd at first glance, as we might expect to be able to set a max input cap. Sounds interesting, right?\n\nHere's a simple example. Let‚Äôs say I want ten WETH (Wrapped Ether) as my output and I'm paying using DAI (a stablecoin). When the function gets executed, it figures out how much DAI you need to input to receive the pre-defined ten WETH output.\n\nWe pretty much understand how it operates since we've already dissected its sibling, `swapExactInput`. We saw previously an issue relating to high fees, which seems to persist in this function.\n\n## Delving Deeper into `swapExactOutput`\n\nAs we know, the devil's often in the details. One crucial conditional from the `swapExactInput` function is missing in `swapExactOutput`. We had previously a safeguard ‚Äì the output amount should be more significant than the minimum output amount. Now, there's seemingly no protective clause.\n\n> Safety reminder! Always put in place protective clauses like a 'minimum output' or 'maximum input' to avoid catastrophic losses.\n\nNow, let's ponder over an example:\n\n```shell\nYou want ten WETH as output, and your payment method is DAI.\n```\n\nConsider a scenario where you request this swap. Before the transaction is confirmed, a massive trade occurs, shifting the price enormously. Suddenly, your desired output of ten WETH requires an astronomical input of (exaggeration for effect) ten bajillion DAI.\n\nWithout an upper limit on the input DAI spent, in instances of sudden, significant price movement, a user could end up experiencing an unexpected dent in their wallet.\n\n## The Solution: Max Input Amount\n\nAlong with the 'minimum output amount' in `swapExactInput`, it would be a sensible approach to add a failsafe - a 'maximum input amount. This way, users won't unpredictably run out of their funds during extreme market volatility.\n\nSuch a preventative measure safeguards users against excessive spending due to price fluctuations. Safeguards become all the more important considering possible MEV (Miner Extractable Value) attacks - a topic we plan on visiting later.\n\nSo there we have it! A seemingly smooth-functioning condition, with an underlying potential issue. We have struck yet another goldmine; we discovered another bug in the wild ecosystem of Uniswap. We'll be diving into the world of MEV soon, so stay tuned and keep exploring!\n",
          "updates": []
        },
        {
          "lessonId": "0013aa21-7bd4-4174-a785-13501384bb59",
          "number": 38,
          "title": "Sell Pool Tokens",
          "slug": "sell-pool-tokens",
          "folderName": "38-sell-pool-tokens",
          "description": "",
          "duration": 2,
          "videoUrl": "wnIByWj8Jr0",
          "rawMarkdownUrl": "/routes/security/5-tswap/38-sell-pool-tokens/+page.md",
          "markdownContent": "---\ntitle: T-Swap Manual Review T-Swap Pool - sellPoolTokens\n---\n\n\n\n---\n\n# Understanding the Functionality of Selling Pool Tokens in Ethereum\n\nWelcome to another exciting blog post where we'll dive deeper into the intricate functions of DeFi or Decentralized Finance and specifically, Ethereum pool tokens. In one of my recent code explorations, I came across an interesting function ‚Äì the Sell pool tokens. It had a unique wrapper function apparently designed to help users sell their pool tokens in exchange for WETH (Wrapped Ether). Let's take a closer look at this function and try to unravel what it does.\n\n## Sell Pool Tokens Wrapper Function\n\nThe function, at its core, seems quite simple.\n\nBasically, the function accepts an input of the pool token amount from the user. Then it calls another function - `SwapExactOutput()`. The parameters for this function are the amount of pool tokens to sell and the amount of WETH to be received by the caller.\n\nHowever, don't get too comfortable with the simplicity as the devil is in the details.\n\n## The SwapExactOutput Function\n\nThe SwapExactOutput function accepts three parameters:\n\n1. Input: Pool Tokens\n2. Output: WETH Tokens\n3. Deadline: Date and Time at which transaction is invalid\n\nThe \"Input\" which is the pool token has other variants notably \"Pool token PT\" and the \"Output\" typically represents the WETH Token amount in the Block.\n\nThe function essentially works by swapping the exact output amounts of the pool tokens to the amount of WETH by the caller.\n\nDespite the simplicity of the process, there could be flaws that exist not due to Solidity (the coding language), but because of business logic issues.\n\n## Spotting the Business Logic Issue\n\nIn our case, the SwapExactOutput function seems to have a logic flaw. It appears to be running on backward logic. Instead of an output of WETH tokens, the initial setup of the function gives an output of pool tokens. A quote from my code review captures this error perfectly:\n\n> \"So we have pool token is going to be what? Pool token is going to be the input, right? So this is going to be the pool token PT. And then we have the wet token is going to be the...the alpha token is going to be the wet token. So this should be the WETH token amount. Oh, no, this is the pool token amount. At audit, this is wrong, right? And again, this isn't like a solidity issue. This is just like a business logic issue. It's a whoops. You put the wrong thing in here.\"\n\nThis could lead to incorrect results. It would seem like instead of `SwapExactOutput`, the function `SwapExactInput` should have been used. Rather than using `Pool token`, the `Min WETH to receive` should have been used for a more accurate result.\n\n## Final Thoughts and Correction\n\nIn the exciting world of DeFi, sometimes it's not just about the Solidity. Business logic also plays a key role in the successful operation of smart contracts and functions. In our case, the logic error led to backward results. Remember, the function's purpose was to initialize trading from pool tokens to WETH tokens. However, due to this business logic flaw, it was providing results of pool tokens instead.\n\nSo there you have it, another interesting piece of code examined and explained. Coding, like any language, allows for fascinating narratives to unfold if we know how to read it.\n\nUntil next time, happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "e2fcfcbe-13b3-462e-a71d-c14dc086ce96",
          "number": 39,
          "title": "Checking The Last Few Functions",
          "slug": "checking-the last-few-function",
          "folderName": "39-checking-the last-few-function",
          "description": "",
          "duration": 2,
          "videoUrl": "wd3MQiBP-HE",
          "rawMarkdownUrl": "/routes/security/5-tswap/39-checking-the last-few-function/+page.md",
          "markdownContent": "---\ntitle: T-Swap Manual Review T-Swap Pool - Checking the last few functions\n---\n\n\n\n---\n\n# Understanding Swap: A Deep Dive into Pool Tokens and WETH\n\nIn this post, we're going to drill down into a topic that's obscure for many: Pool tokens and WETH in a Swap setting. We've already touched on these aspects a little, but they are so critical to more significant parts of DeFi that they deserve their own dedicated discussion.\n\n## Pool Tokens, Liquidity, and the WETH Equations\n\nIn a Swap context, one of the fundamental functions is what we call `getPoolTokensToDepositBasedOffWETH`. You might recall that we've discussed this function before. It operates based on a core DeFi mathematical concept: `X * Y = K`.\n\nAs a refresher, `K` is a constant value, while `X` and `Y` represent the pool balances of two cryptocurrencies, say ETH and DAI. The function's purpose is to maintain the constant `K` during a swap, which keeps the market prices stable.\n\n## Peeling Back the Layers of the Liquidity pool\n\nApart from the `getPoolTokensToDepositBasedOffWETH` function, another intriguing aspect of the system is the `totalLiquidityTokenSupply`. This term is just a more verbose way of expressing the total supply of liquidity tokens in the pool. The function, shown below, can be called to retrieve this information:\n\n## Understanding Swap Prices\n\nAn essential pair of functions that we encounter are `getPriceOfOneWETHInPoolTokens()` and `getPriceOfOnePoolTokeninWeth()`.\n\nThe first, `getPriceOfOneWETHInPoolTokens()`, calls a separate function `getOutputAmountBasedOffInput()`, which takes one WETH as input and returns the resulting number of pool tokens.\n\nIn conclusion, understanding Swap contracts, particularly those involving Pool Tokens and WETH, entails delving into these intricate details. By deploying functions like `getPoolTokensToDepositBasedOffWETH` and `getPriceOfOnePoolTokeninWETH`, users can interact seamlessly with the DeFi ecosystem.\n\nAnd as we always say:\n\n> \"The true art of coding is not in just writing code, but also in understanding other's code.‚Äù\n\nSo don't hesitate to study every function and each line of code, for they are your stepping stones to mastering DeFi and the entire world of blockchain!\n",
          "updates": []
        },
        {
          "lessonId": "b631cfe3-f3b8-4a7c-b997-d8dc7526c695",
          "number": 40,
          "title": "Phase 4: Reporting",
          "slug": "phase-4-reporting",
          "folderName": "40-phase-4-reporting",
          "description": "",
          "duration": 5,
          "videoUrl": "s9B-GVWF-2s",
          "rawMarkdownUrl": "/routes/security/5-tswap/40-phase-4-reporting/+page.md",
          "markdownContent": "---\ntitle: Phase 4 Reporting   The first few Informationals\n---\n\n\n\n---\n\n# Decoding a Code Audit Session: Understanding the Process\n\nHello, readers!\n\nToday, we'll take a deep dive into some lessons learned from a thorough code review session. Without further ado, let's get the ball rolling!\n\n## Step 1: Reviewing the Code Base\n\nTo start off, we took an initial sweep through a code base - our first chance to spot errors, find potential areas of improvement, and generally see how things stack up.\n\n\"_Are we done yet?_\" you might ask. Well, not quite. Just like any meticulous auditing process, it's essential to ask questions as they pop up. For instance, if a variable appears to be used from its initial state, it's worth asking, \"**If it's empty, how does it warm up?**\"\n\nIt's also critical to loop back to any points of confusion or curiosity you see. Got that one lingering question begging for an answer? Mark it down, note it for later and see what comes out of a second, or even a third, look-through.\n\n## Iterative Passes: A Beginner's Best Friend\n\nHere's the clincher: you don't have to get it all on the first pass. We only had one run since we're still in the process of learning, and that's perfectly okay. Here's a simple yet crucial piece of advice:\n\n> Never hesitate to go back for another pass if you feel unsure or if there are questions left unanswered.\n\nAt the end of the day, the goal is to build a clear understanding, and rushing might just lead us away from that objective.\n\n## Step 2: Reporting Findings\n\nWith our checks and observations noted down, it's time to dive into some report writing. For the purpose of maintaining good organization, I created a new file for our findings, cleverly named \"Findings MD,\" and put it in a newly created \"audit data\" folder.\n\n```markdown\nNew File - > findings.md -> audit data folder\n```\n\nLet's break down how we can structure this report.\n\n### The Grouping of Discoveries\n\nStarting with the first finding, in our example, we found an error that wasn't actually used at all - a classic case of surplus code. Considering its nature, we classified this as an \"Informational\" finding. This categorization allows us to flag potentially important data points without necessarily marking them as critical faults or errors.\n\n```markdown\nInformational Finding: Unused Error\n```\n\nWith the help of a bookmarked layout from a previous project, the otherwise tedious task of finding organization become a simple copy-paste job.\n\n```markdown\nFinding Layout -> Copy Layout -> Paste in New File\n```\n\n### Adding Detail to Findings\n\nThe key to a helpful report lies in its detail. For the very first finding, we established a lack of use for a certain pool factory and suggested its removal. This was done by manually inserting '-pool factory' to indicate its extraneous existence.\n\n```markdown\n- Pool Factory (This is not used and should be removed)\n```\n\nSimilarly, all information points were individually detailed under their respective headers, ensuring an informative but clean look to the report.\n\n```markdown\nI2 - Lack of Zero Address ChecksI3 - Symbol, Not Name\n```\n\nAs a bonus, we even added a section for the \"Weird ERC 20\" occurances, which don't have a dedicated audit tag but are no less vital to note.\n\nAnd there you have it. The layout's simplicity and clarity make complex ideas digestible and easy to understand.\n\n## Conclusion\n\nUltimately, the code audit is a practice in thoroughness, attention to detail, and iterative learning. Along the way, you'll encounter a host of ruinous bugs, confusing variables, and, yes, even a \"Weird ERC 20\" here and there. But the key takeaway should always be this:\n\n> Always be willing to make multiple passes, make detailed notes, and never shy away from asking questions. Only then you will fully unlock the true potential of a code audit.\n\nIn the end, just know that with each pass you take, each note you make, each error you find ‚Äî you're becoming a better coder for it. Good luck, and happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "7f782e36-a559-45fe-aa75-6baba2effdae",
          "number": 41,
          "title": "Reporting: Missing Deadline",
          "slug": "missing-deadline-write-up",
          "folderName": "41-missing-deadline-write-up",
          "description": "",
          "duration": 4,
          "videoUrl": "TNljQB4bPbM",
          "rawMarkdownUrl": "/routes/security/5-tswap/41-missing-deadline-write-up/+page.md",
          "markdownContent": "---\ntitle: Missing Deadline Write up\n---\n\n\n\n---\n\n# Addressing Deadlines in TSWAP Pool Deposits\n\nToday, we dive deep into an issue that has surfaced in blockchain tech involving TSWAP, a liquidity pool. The problem here is just like the proverbial time bomb that ticks regardless of one's awareness, in this case, an unused deadline set for pool transactions, which allows for the completion of transactions past the stipulated deadline. We will discuss the issue in detail, the impact it could potentially have, and offer a possible solution. So, let's roll!\n\n## The TSWAP Pool Deposit Deadline Issue\n\nAt the center of the storm is an issue where deadlines, when set, are unused in TSWAP pool deposits. If someone sets a deadline(let's say they plan to set it to execute the next block), paradoxically they could still deposit even after that deadline, resulting in a deadline dispute.\n\nThe TSWAP pool's function for deposits is missing a functionality check for deadlines. This lapse has graspable consequences, leading to transactions being completed even after the deadline.\n\n## Breakdown of the Issue\n\nThe heart of this problem lies within the transaction **deposit function**. This function accepts a **deadline parameter**, as according to the documentation. The purpose of this parameter is to set a deadline to complete a transaction. However, this parameter is never utilized, which leads to unfortunate outcomes.\n\nTransactions that aim to add liquidity to the pool may be executed at unexpected times and under unpredictable market conditions, where the deposit rate may not be favorable. This issue can also make these transactions susceptible to MEV(Maximal Extractable Value) attacks.\n\nHere, the impact could be that transactions get sent when market conditions are not ideal for deposit, even in the presence of a deadline parameter.\n\n## Proof of Concept, and Potential Solution\n\nWe could illustrate the issue in a more demonstrable manner by writing a 'Proof of Concept' here, but we'll dive into more about 'Proof of Concepts' in later content.\n\n```markdown\n- Consider making the following adjustment to the deposit function.- We'll grab this entire function here:\n- Include a revert if the deadline has passed.\n```\n\nThis revision will cause the function to halt and revert if the deadline is exceeded.\n\nAs you can see in the preview, we've successfully included a revert function for an exceeded deadline, marking a critical step towards a viable resolution.\n\n## The Medium versus High Debate\n\nAn intriguing query came about while attending to this dilemma: is the urgency of this a high or just a medium?\n\nDiscussing the impact of the issue offers some clarity. A likelihood of transactions being executed when market conditions are unfavorable does exist, even in the presence of a deadline parameter. However, remember that this is purely a deposit, not a swap.\n\nWe're still acquiring liquidity tokens that signify ownership of the pool. Even if everyone else exited the pool, we'd still have these tokens. Consequently, it could be argued that this issue qualifies as 'medium' in terms of urgency and risk, rather than 'high'. One cannot explicitly overlook the fact, but under the abovementioned circumstances, it's fair to categorize this as a medium.\n\nIn conclusion, deadlines exist for a reason and respecting them within the blockchain world, quite like in the real world, ensures smooth transactions and user trust. Ignoring them, as seen in this TSWAP pool deposit issue, can lead to unwanted complications with potentially damaging impacts. Always stick to deadlines, folks!\n",
          "updates": []
        },
        {
          "lessonId": "317d8851-ad4e-4b30-b518-58065007ed9f",
          "number": 42,
          "title": "Reporting Continued",
          "slug": "reporting-continued",
          "folderName": "42-reporting-continued",
          "description": "",
          "duration": 10,
          "videoUrl": "kzuDQPMV9hw",
          "rawMarkdownUrl": "/routes/security/5-tswap/42-reporting-continued/+page.md",
          "markdownContent": "---\ntitle: Reporting Continued\n---\n\n\n\n---\n\n# Audit Deep Dive: Understanding Smart Contract Vulnerabilities\n\nWhen it comes to auditing smart contracts, there are a lot of nitty-gritty details that one needs to pay attention to in order to prevent possible vulnerabilities.\n\nThroughout this detailed walkthrough, we're going to focus on the process of identifying issues within code, their potential impact, and proposed solutions.\n\nBut before we dive in, let's address some essential concepts:\n\n- **Constants**: These are unchanging variables that are quite common within code and should always be treated as such.\n- **Informationals**: These are facts or pieces of data provided in the code intended to be helpful, but if not emitted correctly, they can cause confusion.\n- **Audit comments**: These serve as notes during code reviews, particularly useful when something needs to be addressed later.\n\n## Highlighting the Importance of Reporting\n\nDuring an audit, it's important to report anything that could potentially refactor the code to improve its overall quality. One simple way is to state \"reported\" whenever we encounter any issues in the code.\n\n## Understanding the Importance of Code Layout\n\nThe code layout plays a crucial role in readability, maintainability, and usability. It is not uncommon to suggest relocating a section of code (such as ‚Äòaudit info‚Äô) that might provide more clarity in another position.\n\n## Liquidity Add Misstep\n\nAt one point in our code, we encountered an instance where 'liquidity added' was incorrectly ordered. Missteps such as these could lead to the emission of incorrect data. To provide clarity:\n\nLiquidity added has parameters out of order.The root cause is the TSWAP pool.The event has parameters out of order, causing the event to emit incorrect information.\n\n## Severe Impact Issues\n\nWe found two severe issues during our audit:\n\n1. **Order of Parameters Issue:**\n\n   In the function `addLiquidityMintAndTransfer`, a liquidity added event is emitted, but the values are logged in the wrong order:\n\n   When the `liquidity added` event is emitted in the `add liquidity mint and transfer` function, it logs values in an incorrect order. The pool tokens to deposit value should go in the third parameter position, whereas the WETH to deposit value should go second.\n\n2. **Fee Calculation Error:**\n\n   The `getInputAmountBasedOnOutput` function was found to have an incorrect fee calculation, which causes the protocol to take too many tokens from users:\n\n   The `get input amount based on output` function in the TSWAP pool is intended to calculate the amount of tokens a user should deposit given an amount of output tokens. However, the function currently miscalculates the resulting amount when calculating the fee.\n\nBoth of these issues cause a significant detriment to the users and need immediate addressing.\n\n## Power of Writing Proof of Codes\n\nWriting 'proof of codes' is a crucial skill that every auditor should have. It helps not only in proving the existence of issues but also in testing the codebase for other potential vulnerabilities. For example, a 'proof of code' was written for the incorrect fee calculation issue to highlight how much the protocol takes as fees and the actual value.\n\n## Impact of Small Code Errors\n\nEven small errors or inconsistencies in the code can have large implications and result in incorrect information being disseminated. Such was the case with the `Swap exact input` function, where an incorrect return value was always being given(0) irrespective of the actual values.\n\nIn conclusion, auditing requires a keen eye for details, significant knowledge of smart contract coding, and a thorough understanding of possible vulnerabilities. Avoiding magic numbers, maintaining consistency in reporting, and having proficiency in writing 'proof of codes' are all crucial factors to conducting a successful audit.\n\nWe hope that this detailed walkthrough gives you perspective and jumpstarts your journey towards becoming a proficient smart contract auditor!\n",
          "updates": []
        },
        {
          "lessonId": "13054677-68a6-44cc-aa34-d9eafe463071",
          "number": 43,
          "title": "Reporting: No Slippage Protection",
          "slug": "no-slippage-protection",
          "folderName": "43-no-slippage-protection",
          "description": "",
          "duration": 8,
          "videoUrl": "TSXuFFB0kVE",
          "rawMarkdownUrl": "/routes/security/5-tswap/43-no-slippage-protection/+page.md",
          "markdownContent": "---\ntitle: No Slippage Protection Write up\n---\n\n\n\n---\n\n## Mitigating Slippage Impact in DeFi Protocols\n\nThe topic for today's post revolves around a crucial aspect of DeFi (Decentralized Finance) transaction executed through protocols like MetaMask. Specifically, we will be focusing on `slippage` and how a lack of protection can adversely affect the user experience.\n\n### What is Slippage and why should it concern you?\n\nIn a nutshell, slippage occurs when the execution price of a transaction is different from when the transaction was originally created. This can be due to market volatility causing rapid price changes. High slippage can result in a user receiving fewer tokens than anticipated, or, conversely, paying more than expected for a specified quantity of tokens.\n\n> If you're new to smart contracts, think of slippage like unwanted change in your transaction, which you'd prefer not to experience.\n\nBoth situations can be distressing for users, and are likely to negatively impact the trust and usability of the protocol.\n\n### Why Slippage Protection is Crucial\n\nFrom the risk perspective, we'd label this as `High` due to the potential impact. Despite the likelihood being categorized as medium to high, the severity of the potential financial loss warrants its high-risk status.\n\nAn interesting gateway to delve into this topic is through the study of `swap exact input` and `swap exact output` functions in smart contracts and their associated slippage protection measures.\n\nTake, for example, **TSWAP pool swap exact output** that lacks slippage protection. If market conditions change while a transaction is waiting to be processed, this lack of slippage protection could lead to users receiving far fewer tokens than expected.\n\nA practical manifestation would be when a user attempts to swap 10 WETH (Wrapped Ether) for DAI (a stablecoin pegged to USD). The user is expecting to get a minimum of 100 DAI, but due to the lack of slippage protection, they might end up receiving less than 100 DAI if the price of WETH depreciates before the transaction is completed.\n\n### How to Guard Against Slippage\n\nA smart contract's code can be revised to include slippage protection. This precaution will ensure that the tolerable maximum or minimum amount is strictly adhered to, despite any sudden market price changes for the involved tokens.\n\nThe way to do this is through implementing a maximum input or minimum output parameter, effectively giving a safety net for users to not receive less or pay more than expected.\n\nThe `maxAmountIn` serves as a limit for how much the user is willing to spend, introducing a safety parameter within the code.\n\n### The Importance of a Proof of Concept (POC)\n\nHaving a POC helps a lot when trying to communicate potential risks to a protocol. To illustrate, here's a simple scenario:\n\n- User initiates a `swapExactOutput` for 1 WETH (WETH=1000 USDC) with input token as USDC and output token as WETH.\n- No maximum input amount allowed, transaction is pending in mempool.\n- Market price of WETH skyrockets to 10,000 USDC.\n- User completes the transaction but is charged 10,000 USDC instead of the expected 1,000 USDC.\n\nThis excessive charge to the user occurs due to no slippage protection. Creating a POC for this scenario will not only help protocol developers understand the implications but also provide a pathway to tackle the problem.\n\nHaving a max input amount parameter ensures that users can predict how much they spend on the protocol.\n\n### Wrapping Up\n\nWhile some might argue that the user could approve fewer tokens or reject the transaction, the reality is that these aren't foolproof solutions. Protecting against slippage is critical for maintaining user trust and enhancing the protocol's usability.\n\nUnderstanding slippage and how it affects your transaction can provide significant benefits and prevent unexpected loss. The control it provides the trader can be the difference between a `successful transaction` and a `bad experience`.\n\nAlthough our focus here was on setting it to high, remember that the risk severity of every case varies, and one could always argue **contextual flexibility** based on each unique situation.\n",
          "updates": []
        },
        {
          "lessonId": "6705c7ca-1ec8-4953-b7b8-e3e9e13a17f2",
          "number": 44,
          "title": "Reporting: Sell Pool Tokens",
          "slug": "sell-pool-tokens-write-up",
          "folderName": "44-sell-pool-tokens-write-up",
          "description": "",
          "duration": 4,
          "videoUrl": "YtYnkciULlk",
          "rawMarkdownUrl": "/routes/security/5-tswap/44-sell-pool-tokens-write-up/+page.md",
          "markdownContent": "---\ntitle: sellPoolTokens write up\n---\n\n\n\n---\n\n# Unraveling Smart Contract Bugs: 'Sell Pool Tokens' Woes\n\nIn the chaotic and fast-paced world of blockchain programming, errors aren't just inconvenient; they can cost money. A lot of money. One notorious mistake often found in the wild is related to token swapping - that is, exchanging tokens within a liquidity pool. Today, we're diving into one high severity bug associated with a `sellPoolTokens` function.\n\nThe nature of this bug means the token swapping feature doesn't operate as expected, causing users to receive an incorrect number of tokens during transactions. Let's delve into this troublesome gaffe further.\n\n## What's Going on with 'Sell Pool Tokens'?\n\nThe `sellPoolTokens` function is designed to enable users to efficiently sell pool tokens and receive Wrapped Ether (WETH) in return. Users specify how many pool tokens they're prepared to sell via the `poolTokenAmount` parameter.\n\nHowever, this function has a miscalculation issue with the swapped amount, directly linked to the incorrect function call. The current `sellPoolTokens` function calls the `swapExactOutput` function, but it should call `swapExactInput` instead. Why is this a problem? Because users specify the precise input tokens volume, not the output.\n\n> \"Users will swap the wrong amount of tokens, which is a severe disruption of protocol functionality.\"\n\n## Breaking Down the Proof of Concept\n\nThe proof of concept for this takes form in pseudo code, illustrating the botched token swap during a `sellPoolTokens` call. We'd typically piece together a proof-of-code here to further demonstrate this issue practically.\n\n## Addressing the Bug: Recommendations for Mitigation\n\nTo tackle this damaging bug, the proposed mitigation strategy is restructuring the implementation to deploy `swapExactInput` instead of `swapExactOutput`. This, however, demands a modification to the `sellPoolTokens` function to accommodate a new parameter dubbed `minWETHtoReceive`.\n\nBut wait, there's more! Area for improvement exists beyond this immediate bug fix. It would be prudent to introduce a deadline to the function as no deadline currently exists. This is a crucial topic for later exploration in the blog series, particularly when we delve into Miner Extractable Value (MEV). For the time being, though, we'll set this to one side.\n\nThe `sellPoolTokens` bug is, rather deceptively, a compelling example of how small errors can disrupt the functionality of decentralized protocols dramatically. By presenting the concept and outlining potential solutions, we hope to contribute to more robust, secure, and user-friendly DeFi platforms.\n\nLet's keep debugging!\n",
          "updates": []
        },
        {
          "lessonId": "3bed02c1-41e4-4860-bbe7-ff32160fa6ac",
          "number": 45,
          "title": "Reporting: Invariant Break & PoC",
          "slug": "invariant-break-write-up-and-poc",
          "folderName": "45-invariant-break-write-up-and-poc",
          "description": "",
          "duration": 9,
          "videoUrl": "nakLPgo5twk",
          "rawMarkdownUrl": "/routes/security/5-tswap/45-invariant-break-write-up-and-poc/+page.md",
          "markdownContent": "---\ntitle: Invariant Break Write up and PoC\n---\n\n\n\n---\n\n# Fuzz Testing: The Key to Proof of Code\n\nThis blog post is going to take you on a journey through the layers of code to uncover the details of proof-of-the-coding process, with an emphasis on fuzz testing.\n\n## Fuzz Testing: What it is and why we need it?\n\nAccording to the [Software Engineering Institute](https://resources.sei.cmu.edu/asset_files/WhitePaper/2016_019_001_466377.pdf) at the Carnegie Mellon University, fuzz testing (or simply fuzzing) is an automated dynamic testing approach that generates and runs many random inputs to a target program. It's efficient and does a great job at highlighting potential errors, but the use of fuzz tests as proof of code is problematic.\n\n> \"This is because the sequences that they generate can be quite complex and hard to understand - not to mention, they may not necessarily lead to the most efficient code. It can be downright baffling, especially for less experienced developers.\"\n\nAs a workaround, we need to take the output of the fuzz test and mold it into a more reader-friendly format. The goal here is to convert the fuzz test output into a unit test that clearly illustrates how the protocol should rectify the issue.\n\n## Creating a Universal Proof of Code\n\nLet's illustrate this by trying to rectify a protocol invariant error.\n\nThe fuzz test, in this case, shows that it only takes **ten swaps** to break the invariant. Hence, our next step is creating a **new unit test** to replicate these swaps.\n\n## Decoding the Fuzz Test Output\n\nTo better understand the issue at hand, frame a `testInvariantBrokenProof` function based on the fuzz test output.\n\nCreate a sequence of swaps, replicating the fuzz test output. Start with performing only one swap to verify that the code correctly detects a deviation from the norm. Remember to keep verifying the result at each step.\n\nIf all runs smoothly, increase the number of swaps. In this example, we increment it to **nine swaps**.\n\n## Reflect, Retest, Report!\n\nAfter the completion of your revised unit test, it's time to document the results.\n\n_\"Always start your report with a detailed description of the issue at hand. Explain the root cause, provide a description, and elaborate the impact it can cause. This helps provide a comprehensive understanding of the problem.\"_\n\nOnce that is complete, present your Proof of Concept, diligently highlighting all steps and intricacies of your solution. By this point, you should have a detailed and well-stated report laid out.\n\n## Wrap Up!\n\nOne of the last yet crucial parts of the report is to provide potential mitigation strategies. They could include removing the incentive or keeping it, but accounting for a change in the protocol invariant. Regardless, it is essential to offer actionable recommendations that work best not only at maintaining the protocol's functionality but also at preventing potential breaking of their core invariant.\n\nBy breaking it down into digestible pieces and providing both context and clear instruction, we can transform the cryptic output of fuzz tests into a proof of code that every team member can readily understand.\n",
          "updates": []
        },
        {
          "lessonId": "5b32ca72-ccda-4365-a1b5-59ecfa62371e",
          "number": 46,
          "title": "Reporting: Weird Erc20",
          "slug": "writeup-weird-erc20",
          "folderName": "46-writeup-weird-erc20",
          "description": "",
          "duration": 4,
          "videoUrl": "uRah95okGiY",
          "rawMarkdownUrl": "/routes/security/5-tswap/46-writeup-weird-erc20/+page.md",
          "markdownContent": "---\ntitle: Write up Weird ERC20 You Try This\n---\n\n\n\n---\n\n# Unveiling the Mystery of Tokens while Penning an Audit Report for TSWAP\n\nCracking the codes and giving insight into the deep trenches of developmental methods, we're all set to discuss and dig into the topic of tokens. For us, ERC20s proved to be peculiar to work with, challenging some of our pre-established perceptions and notions. We're going to rewind a little and talk about the one crucial aspect we didn't happen to discuss in detail, the token matter.\n\n## Unpacked: The Token Hidden Conundrum\n\nAn interesting observation was that we didn't host this test on a TSWAP pool. Let me take you back to our chapter on the TSWAP pool. This episode demonstrated our swap function falling apart, breaking the invariant as an extra transfer was conducted in the process.\n\n> Blockquote: Diving into this will reveal that the fee-on-transfer tokens echo the same effect, transmitting extra tokens. Remember, when the fee-on-transfer tokens come into play, they pose a threat to the protocol invariance, demanding attention.\n\n## Transparency - The Token Assassins\n\nHere's an interesting fact - in the TSWAP audit GitHub repository associated with this course, we unfolded some significant details.\n\n```markdown\nGo to - Audit Data -> README -> Bottom Page\n```\n\nThis process reveals two audits previously conducted for the Uniswap v1. Further venturing into the Uniswap v1 audit report fashioned by Consensus Diligence, we found several issues with websites and liquidity.\n\nThe v1 of Uniswap suffered a condition where the liquidity pool could be hijacked by certain tokens, for instance, ERC777.\n\n> Think of these tokens as smoke and mirrors. If these tokens paved the way for reentrancies on the transfer, the liquidity could be drained, leaving us high and dry. The introduction of these strange ERC20s into the original Uniswap v1 caused series of issues for protocols.\n\n## The TSWAP Paradox\n\nWhat's worth noting is that these confusing ERC20s are a significant issue in DFI. They can be a handful to work with due to their distinct characteristics. It might seem enticing if they were all similar, but alas, that's not the case. This issue tends to pop up often, particularly in competitive audits, as many protocols are oblivious to this aspect.\n\n## Drafting the Audit Report\n\nIn our discoveries, our conclusive medium (not fully penned down) anticipates additional exploration and experimentation from you. Accept the challenge and bask in the experience of creating proof codes and get playful with the process.\n\nSurprisingly, you'll come across these familiar ERC20s repeatedly. It almost feels as though they're playing peekaboo, secretly popping out at the most unexpected times.\n\n## Conclusion\n\nThere's a great deal of satisfaction in unlayering these complexities and jotting down findings. The ordeal of wielding together an audit report surprisingly paves the way to add more to our developmental platter. The report initiates the process of understanding and recognising the challenges and solutions in protocol handling, making the world of tokens and audits a little less complicated and a lot more intriguing.\n",
          "updates": []
        },
        {
          "lessonId": "fdca1d04-2481-4cbb-8657-27747fa56f3d",
          "number": 47,
          "title": "Creating Pdf For Your Portfolio",
          "slug": "creating-pdf-for-your-portfolio",
          "folderName": "47-creating-pdf-for-your-portfolio",
          "description": "",
          "duration": 4,
          "videoUrl": "JEhPE3k7wGM",
          "rawMarkdownUrl": "/routes/security/5-tswap/47-creating-pdf-for-your-portfolio/+page.md",
          "markdownContent": "---\ntitle: Creating the PDF for your Portfolio\n---\n\n\n\n---\n\n# Building an Audit Report: A Step by Step Tutorial\n\nBecoming proficient in creating an audit report involves mastering certain techniques. Throughout this post, you'll learn how to create an audit report tailored to your unique needs using available resources and Markdown tools.\n\n![](https://cdn.videotap.com/y8C5WoYeGfIBalrcsQSJ-11.25.png)\n\n## Step 1: Importing Files\n\nBefore we venture any further, we must first import the files we need. For instance, we've previously used a logo PDF file in our audit data folder, which you can easily repeat. Scope out your directories for relevant files before you start crafting your report.\n\n## Step 2: Leveraging the Audit Report Template\n\nDon't start creating your report from scratch! Utilize available templates to help guide you in building an informative and detailed review. You can find a well-crafted audit report template on our course page. To get the template, go back to the course, scroll upwards until you come across the template.\n\nSimply copy the content from the raw version of the template and paste it into your new file called 'Report Template MD'.\n\n## Step 3: Tailoring the Report\n\nHaving a template is splendid, but personalizing it to suit your audit changes the game. Let's rename the report template to '2020 311 one' and let's call it 'TSWAP audit MD'.\n\nFeel free to insert the findings of your audit into the document. Let's add findings, a summary of the issues discovered and any recommendations you may have under the sections provided in the template.\n\n> _Remember your findings should be as descriptive and detailed as possible to provide the most value._\n\nTo enhance your portfolio even further, spend some time writing up explanatory notes and if you had collaboration during the audit process, feel free to add their findings as well.\n\n## Step 4: Updating the Details\n\nTaking the time to update information accordingly is definitely vital. You might need to add audit details, scope, and list the issues you encountered. To visualize some parts of your report, say the risk classifications, you can include charts. Simply grab any chart you find illustrative enough and paste it into the report.\n\nFor example, you can provide the severity level of the identified issues found during your audit. We're going to say we found four high-risk issues, two of medium risk, and two of low risk. Informational issues can be many.\n\n## Step 5: Finalizing and Converting the Report\n\nHaving updated the details, now is the perfect time to finalize your report. Set the report title, include your name(s), add protocol summary, risk classification, and audit scope details.\n\nTo convert the markdown file into a professional-looking PDF document, we can use [pandoc](https://pandoc.org/getting-started.html), a very useful document converter.\n\nAnd voila! Your PDF audit report is generated and ready for presentation, filled with detailed findings and code snippets.\n\n![](https://cdn.videotap.com/gTjSzByU5kxK3CrXUbph-174.38.png)\n\n## Step 6: Displaying Your Report\n\nWith the diligent work done, it's time to share your accomplishment to the world. Update your GitHub with the audit report or include a new report in your portfolio. Constantly creating and adding audit reports boosts your portfolio and betters your skills.\n\nA job well done! By completing this tutorial, you've learnt to create a detailed, personalized audit report. Incredibly, through conducting audits, you've also gained substantive knowledge of DeFi protocols.\n\nRemarkably, as we go through smart contracts- like the T-swap contract, a variation of Uniswap, you also gain substantial understanding of decentralized exchanges at the fundamental level.\n\nTaking on real-world tutorials like these not only equip you with practical auditing skills but also provide you with a strong foundation in the fast-growing field of Decentralised Finance (DeFi).\n\n> \"We're not just teaching you how to conduct audits. We're also teaching you DeFi along the way. Very sneaky, aren't we?\"\n",
          "updates": []
        },
        {
          "lessonId": "64901db8-395b-4ac7-a32c-a884c6189d02",
          "number": 48,
          "title": "Recap",
          "slug": "recap",
          "folderName": "48-recap",
          "description": "",
          "duration": 8,
          "videoUrl": "ORI4w4DY1J4",
          "rawMarkdownUrl": "/routes/security/5-tswap/48-recap/+page.md",
          "markdownContent": "---\ntitle: Recap\n---\n\n\n\n---\n\n# DeFi Security Auditing ‚Äì A Recap\n\nHey there! If you've been with us from the start of our series on DeFi Security Auditing, congratulations on reaching this point! This is going to be a recap encompassing everything you've learned so far in the course. In case you missed out on something, don‚Äôt worry, let's walk through them again.\n\n## Protocol Invariants ‚Äì Your Secret Weapon\n\nFirst and foremost, we realized that understanding protocol invariants is crucial in locating bugs hidden in our code bases. We don‚Äôt even need to explore the code base deeply or conduct a tedious manual review. We found how we can write an invariant or a stateful fuzzing test suite, which pointed out a bug in the swap function ‚Äì a process without any manual review.\n\nIn essence, the tooling, particularly stateful fuzzing, is a powerful mechanism for bug detection.\n\n## Unfolding the AMM Mystery\n\nWe touched upon the underlying fundamentals of an AMM, or Automated Market Maker, and what a DEX (Decentralised Exchange). Even though the T-Swap audit revolves around a fictitious protocol, its foundation is based on Uniswap and follows exactly the same X times Y equals K principle.\n\nWe learned that the AMM works without an order book. It simply uses token pools, and to extract tokens from one side, tokens need to be added to the other side, maintaining the balance. Everyone is on the lookout for a platform where every swap transaction means money in their purses.\n\n## Understanding the Uniswap Protocol\n\nBoiling down the core mechanisms of the Uniswap protocol, X multiplied by Y equals K is the mathematical model where K is a constant, ensuring the token ratio remains unchanged. Every time you wish to take a token, you need to provide an equivalent amount back.\n\nDealing with a protocol like an AMM where math is the crux of the system, the importance of invariants is highlighted.\n\n## Identifying Client Requirements\n\nEarlier, the absence of illustrative graphs and even the lacking of documentation for some functions made working somewhat daunting. But over time, we've learned that we need to function hand-in-hand with the protocol. They always have the inside story, and understanding their needs is indispensable.\n\nOur comprehensive client onboarding document illustrates this point, particularly the section about T-SWAP having onboarded. We learned that onboarding our protocols and obtaining as much information as possible is of utmost importance.\n\nA case in point would be their low test coverage, an issue we'd definitely want them to address. They churn out multiple ERC20s. And if you don't know by now, ERC20s are pretty wacky. Understanding this helps to architecturally protect the protocol from the peculiarities of these ERC20s.\n\nWe also learned that it's not advisable to work with any and every ERC20. Instead, a restriction list or documentation indicating potentially problematic tokens (like rebasing tokens, fiat transfer tokens, reentrancy tokens) is a good practice. Hence, an extensive onboarding document and deep client interaction can take you a long way.\n\n## Keeping Invariants in Check\n\nOur journey took us through understanding what protocol invariants are ‚Äì they represent those attributes of the system that must always remain constant. We learned to write fuzzing or stable fuzzing tests to go hand in hand with them.\n\nReferencing the Freepy model where protocol invariant checks are directly embedded into the system, Uniswap stands as a good example of such a system. In stark contrast was the Euler finance attack, where the absence of an invariant check led to their exploit. But people do differ on nomenclature, some prefer to call it CEI and pre and post-checks.\n\n## Diving into DeFi\n\nThe constant product formula X \\* Y = K, oft-used in many DeFi protocols, particularly AMMs, is a powerful tool. For more adventurous explorations into the realm of DeFi, DeFi Llama is a great resource.\n\nHaving said that, we were also introduced to other beneficial tools like stateful and stateless fuzzing, Echidna consensus, and other fuzzers. Although mutation or differential testing didn't make it onto the list, they're definitely on the cards for future lessons.\n\n## Deciphering Solidit\n\nSolidit presented itself enormously useful, allowing us to cross-check if an issue has been previously pointed out by someone else. It helps us to learn about new findings and also verify if we're on the right track.\n\n## Welcome to A World Of Weirdness\n\nNo, we're not stepping into a horror movie. Welcome to the world of ERC20s, where weird is the new normal, and this trend doesn't seem to be fading. But not to worry ‚Äì Trail of Bits has provided a handy checklist to make sure you're making the right choices. There's also a master list naming all the weird ERC20 tokens ‚Äì a post-apocalyptic catalog if you'd wish to call it so.\n\n## Concluding Thoughts\n\nIf you‚Äôve accompanied us this far, give yourself a round of applause. It's remarkable progress considering the level of understanding you now hold. You've essentially audited the Uniswap codebase and are now fully equipped to delve into the world of security, undertake competitive audits, bug bounties, or even get hired!\n\nNevertheless, we recommend you complete the course to further enrich your learning. Pat yourself on the back for your achievement, take a well-deserved break, and get ready to tackle some challenges ahead.\n",
          "updates": []
        },
        {
          "lessonId": "2183b4e7-d6f9-4d3b-ba24-179fa1df2c95",
          "number": 49,
          "title": "Exercises",
          "slug": "exercises",
          "folderName": "49-exercises",
          "description": "",
          "duration": 3,
          "videoUrl": "-oBnbA3-QCw",
          "rawMarkdownUrl": "/routes/security/5-tswap/49-exercises/+page.md",
          "markdownContent": "---\ntitle: Exercises\n---\n\n\n\n---\n\n# Exciting Dive into Smart Contract Fuzz Testing and Learning Techniques\n\n### Exploring Tint's Code Error\n\nThe other day, Tint was kind enough to share a fascinating gist that truly piqued my interest. It contained a small snippet of a code base that had one glaring issue. Of course, it was not just the issue itself that caught my attention, but more so what this issue represented - an exciting opportunity to start honing your smart contract fuzzing skills with Foundry.\n\n![](https://cdn.videotap.com/cVgMHZy43EUCFjsPdVYm-15.24.png)\n\nThe scenario offered by this code base is straightforward. It features a registry contract that permits callers to register by paying a predetermined fee in ETH. If the caller sends too little ETH, the execution reverts. However, if they send too much ETH, the contract obliges by returning the extra funds.\n\nLooking at the unit test reports, everything seems perfect- right? But hold your horses; there's a twist. Your challenge is to write at least one fuzz test via the registering contract. This fuzz test must correspond to the brief specification above and capable of detecting a bug in the register function.\n\nAlways remember to undertake this task before moving ahead. Why? Because it can remarkably hone your fuzz test writing skills.\n\n### Amplify Learning with Social Media\n\nAmidst this coding, let's spice things up with a tad bit of tweeting. Don't be confused, it's a part of the process. Remember, as a security researcher (focus on the 'researcher'), you aim to excel at researching and comprehending issues. Go forth, dive into Solidity and learn something unique.\n\nYou can start with something as straightforward as reentrancy. As a topic we've repeatedly discussed and will continue to, there's a wealth of knowledge to be extracted. Find examples of different reentrancy attacks- perhaps the highs. Choose a crazy reentrancy attack, learn about it, break it down and share your learning on Twitter.\n\n> _\"One of the best ways to learn is something called the TeachBack Method, where if you teach something back to somebody, that is a great way to learn.\"_\n\n### Take a breather\n\nNow seems like an excellent time to grab a cup of coffee and unwind for a bit.\n\nIf you haven't yet signed up for [codehawks](https://codehawks.com), now's the time! We have exceptional first flights lined up that will give you the confidence boost you need.\n\n![](https://cdn.videotap.com/08R5XEP6FtKgKciMJKrm-101.6.png)\n\n### Coming up next...\n\nBrace yourself for Section Six with Centralization Proxies and Oracles featuring the intimidating Thunder loan audit. We will also cover Boss Bridge before moving on to tackling the Vault Guardians Boss codebase.\n\nSo, gear up, recharge your brains with a coffee break, and let's dive into the world of smart contracts!\n\nSee you soon folks.\n",
          "updates": []
        }
      ]
    },
    {
      "sectionId": "e0cddd25-1df1-4c9f-af68-53e33c616bad",
      "number": 6,
      "title": "Thunder Loan",
      "slug": "thunder-loan",
      "folderName": "6-thunder-loan",
      "lessons": [
        {
          "lessonId": "9666c162-de47-4243-b6b9-cf754d78d588",
          "number": 1,
          "title": "Introduction",
          "slug": "introduction",
          "folderName": "1-introduction",
          "description": "",
          "duration": 6,
          "videoUrl": "FZ11HdxqMjU",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/1-introduction/+page.md",
          "markdownContent": "---\ntitle: Introduction\n---\n\n\n\n---\n\n# Deep Dive into Security Testing with the Thunder Loan Audit\n\nWelcome back to your favorite security course repository! I trust you've spent some time on that fuzzing exercise because this lesson is going to be a _real deep dive_ into security testing. We've already learned tons of tools and skills, and now it's time to really apply and hone those skills as we dig into _Section Six: Thunder Loan Audit._\n\n## The Context: Thunder Loan Protocol\n\nLet's begin by git-cloning this lesson's code fro Github.\n\n![](https://cdn.videotap.com/iLoskdCcOE28WEUkiXTF-68.76.png)\n\nThis richly detailed protocol we'll be auditing has a fantastic logo - a frog with a thunder bolt on its chest standing over a pile of money. However, beneath this cool exterior, there lies a multitude of bugs waiting to be smoked out. This protocol also gives us a detailed experience of two of the most important DeFi protocols in the world, _Aave and Compound_, as it's majorly based on these.\n\n## DeFi, Borrowing, and Lending\n\nThese protocols are the crux of DeFi borrowing and lending, a fundamental financial concept in the DeFi universe. Whilst auditing the Thunder Loan protocol, we'll naturally delve a bit into understanding Aave and Compound.\n\n## Pricing Information and Oracles\n\nWe had a touch on this in the Puppy Raffle exercise. However, here we delve deep into the significance of sourcing accurate pricing information for assets and how to ace this process effectively as we interact with Oracles.\n\n> \"A lot of people use \\[upgradable contracts\\]. We need to know how to keep them secure.\"\n\n## Upgradable Contracts\n\nFor the first time, we'll be interfacing with an upgradable contract, a common feature in the wild world of Web 3. Now, whether or not these contracts are optimum is up for debate, but their usage is indeed undeniable.\n\n## Multifaceted Proxies\n\nWe are not going to be delving deep into the multifaceted proxy, also known as _the diamond standard_, but we're definitely going to talk a bit about its functionalities and distinctive features.\n\n![](https://cdn.videotap.com/bnzGy4zQOk9RwQjEXVOh-189.08.png)\n\nMoreover, we'll be learning about another brilliant tool called the **Upgrade Hub**. This tool comes in handy for discerning which contracts have been upgraded and which upgrades might be construed as rug pulls. By inserting a contract address, you'll be able to view its complete upgrade history, appearing similarly to git diffs.\n\n> \"Upgrades are highly sensitive in the Web 3 world. This \\[Upgrade Hub\\] is a great place to learn about and work with proxies and view their history.\"\n\n## Centralization and Defi Security Audits\n\nOur previous interactions with the T-SWAP or Uniswap audit only scratched the surface, introducing us to DEXes, invariants, and important DeFi protocols. With Thunder Loan, we‚Äôre moving to a new level.\n\nThis protocol‚Äôs code base has many common DeFi bugs, which make this one of the most important audits you can learn from. In addition to these security flaws, it introduces the concept of flash loans‚Äîa \"monster\" tool with an enormous amount of information to explore.\n\nBy the time you've audited this code base, which consists of multiple folders and contracts and guides you through a more advanced protocol, you'll significantly enhance your understanding of DeFi security audits.\n\n## Price Oracle Manipulations\n\nAccording to the curriculum, price oracle manipulation was the principal attack for the first half of 2023. So as we audit the Thunder Loan protocol, we'll be learning how to tackle this risk head-on.\n\n> \"This course provides an extensive and comprehensive walk-through of the protocol that‚Äôs packed with so many common DeFi bugs that you will learn plenty along the way.‚Äù\n\nTo wrap it up, the full report and notes on how to generate the audit report are waiting in the Thunder Loan git repo‚Äôs `audit-data` branch as usual. Brace yourself and get ready to unearth a treasure trove of bugs and become a better security tester while we audit the Thunder Loan protocol!\n",
          "updates": []
        },
        {
          "lessonId": "c4bd6e67-622f-4978-81ab-b6a6b8415676",
          "number": 2,
          "title": "Phase 1: Scoping",
          "slug": "phase-1-scoping",
          "folderName": "2-phase-1-scoping",
          "description": "",
          "duration": 4,
          "videoUrl": "OGv8-uhUcDw",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/2-phase-1-scoping/+page.md",
          "markdownContent": "---\ntitle: Phase 1: Scoping\n---\n\n_Follow along with the video lesson:_\n\n\n\n---\n\n# Scoping out a Codebase: A Comprehensive Guide\n\nCode auditing is a crucial part of every developer's journey. Whether you're managing an open-source project or conducting a security review, understanding a codebase in and out is indispensable. So where do we start?\n\nWell, this guide promises to take you through the nitty-gritty of scoping out a codebase, using a protocol as an example.\n\n## Kicking Things off With the README\n\nThe README documentation serves as a good starting point when familiarizing yourself with a new protocol. While initial impressions might provoke a 'blah, blah, blah, whatever' response, we can extract valuable information about the audit scope details in this document.\n\nIn our case, the README delineates the commit hash details, which you'd typically implement via the `git checkout` command.\n\n```bash\ngit checkout [paste the commit hash here]\n```\n\nFor learning purposes, however, we're going to stick with the main branch.\n\n## Understanding Included Contracts\n\nYour next port of call should be examining the contracts embedded within the codebase. In our scenario, we noticed all contracts resided in the protocol source, particularly in the `interface for protocol`. Interestingly, we also saw an upgraded version of the protocol.\n\nThis raised a question mark‚Äîwhat defines this 'upgraded protocol'? The particulars will unravel as we progress.\n\n## Code Version\n\nPay attention to the Solidity version for the protocol‚Äîours was v0.8.20. Be mindful that the contract should match Ethereum's latest security standards.\n\n## Contracts Handled\n\nWe next located some ERC 20 contracts‚Äînamely USDC, die, Link, West. Use your past knowledge to understand how these contracts work. From our last course, we discovered that the USDC supports an upgradable contract and encompasses a block and allow list.\n\n> \"This information is vital as we need to understand how our protocol manages a token, which can transform completely.\"\n\n## Identifying Roles\n\nWe identified different roles within the protocol including an owner, a liquidity provider, and a user. Hoodwinked by terms like \"liquidity provider\"? Don't fret! As you delve deeper into DeFi, you will acquire familiarity with this lexicon.\n\nIn our case, we discovered that a liquidity provider is someone who deposits assets to earn interest, while a user is someone who takes flash loans from the protocol.\n\nThe protocol's owner holds the power to update the implementation‚Äîinteresting.\n\n### Digging Out Known Issues\n\nWe also found some known issues detailed in the README, warranting a revisit after gaining more context.\n\n## Analyzing Makefile\n\nPotentially useful insights lay in the `Makefile`, where we found Slither configuration along with some other tools. We took a minute to run solidity metrics on this \"bad Larry\", yielding an output that adds value to our understanding.\n\n```bash\nsolidity-metrics [insert codebase here]\n```\n\nIn our audit, the API gave an output of 391 N slock and 327 complexity score, indicating most complexity resided in the `Thunderloan` and `Thunderloan-upgraded`.\n\nWe dropped these metrics into a markdown file as notes to help gauge process duration in future audits.\n\n## The Importance of Context and Reconnaissance\n\nEnding phase one of our audit process, it's clear that understanding an unknown codebase‚Äîand by extension, performing a protocol audit‚Äîis a matter of patience and practice. Taking your time and being methodical can help you glean valuable contextual information about the codebase.\n\nIn the part two of this guide, we'll conduct some rigorous reconnaissance, promising further insights into the protocol audit process. Stay tuned!\n",
          "updates": []
        },
        {
          "lessonId": "06bc8d6e-5b70-4b7e-b650-01ee9c4d791a",
          "number": 3,
          "title": "Reading The Docs",
          "slug": "reading-the-docs",
          "folderName": "3-reading-the-docs",
          "description": "",
          "duration": 4,
          "videoUrl": "ZolEhNT2wMk",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/3-reading-the-docs/+page.md",
          "markdownContent": "---\ntitle: Phase 2 Recon - Reading the Docs\n---\n\n\n\n---\n\n# Thunder Loans: In-depth Dive into Flash Loan Protocols\n\nWelcome to this comprehensive deep dive into flash loan protocols. In particular, we will be focusing on the Thunder Loan protocol heavily based on Aave and Compound.\n\nIf you're not familiar with Aave, I recommend checking out this explainer video available at [Whiteboard Crypto](https://www.whiteboardcrypto.com/). It's a fantastic resource to learn the ins and outs of borrowing and lending protocols at a high level.\n\nFor this particular blog, we're going to thrust ourselves much deeper to dissect these protocols and thoroughly understand how they make Thunder Loans possible.\n\nLet's kick-off the discussion by outlining what is Thunder Loans.\n\n## Thunder Loan Protocol: A Flash Loan Blueprint\n\nThe Thunder Loan protocol is designed with two main objectives. Firstly, it aims to provide users with the ability to construct flash loans. Secondly, it offers liquidity providers a chance to profit off their capital.\n\n> \"What's a flash loan?\"\n\nIf you posed this question, I urge you to hang on as we will delve into it later in this post. But first, let's get up to speed on some terminology.\n\nA _liquidity provider_, as some of you might be aware, is an individual who pours money into a protocol to yield interest. An inevitable question that follows is, \"where does the interest come from?\" It's a question vital to both an investor and a security researcher's perspective.\n\nTaking t-swap as an example, the interest generated is sourced from the fees levied on swaps. Translating the same logic, in Thunder Loans, the interest is likely derived from the fees attached to these flash loans.\n\nRemember, when you deposit money into Thunder Loans, you're given an asset token, which gradually accrues interest over time depending on the prevalence of flash loans.\n\nAlright, let's dissect what exactly is a flash loan.\n\n## Flash Loans: A Simple Explanation\n\nThe term 'Flash Loan' refers to a loan that spans precisely one transaction. In simpler terms, a user can borrow any sum of assets from a loan protocol as long as they completely pay it back within the same transaction. Failure to adhere to this rule causes the transaction to revert, cancelling the loan automatically.\n\nAdditionally, a tiny fee is imposed to the protocol depending on the borrowed amount. In Thunder Loans, to determine these fees, we utilize the renowned on-chain T-swap price Oracle.\n\n![](https://cdn.videotap.com/NZwarBK1M4rlkUCCFnyN-120.67.png)Thunder loans are currently planning to progress from the existing Thunder Loan contract to an upgraded one. This upgrade forms part of our security review's scope.\n\nTo effectively navigate these waters, we must develop a solid understanding of flash loans and get better acquainted with this lending and borrowing protocol. Hopefully, some graphical diagrams could perhaps simplify our learning process.\n\nTherefore, to understand this innovative DeFi primitive, I implore you to delve more into flash loans. Its knowledge is crucial to dissect the intricacies of Thunder Loans.\n\n## Wrapping Up\n\nIn this modern era of DeFi, understanding flash loans is remarkably essential. This blog is intended to provide a leap pad that gets you from novice to advanced levels of understanding how Thunder Loans operates and what are Flash Loans.\n\nSo, pull out your notes, and let‚Äôs dive more in-depth into the world of flash loans. Understanding and leveraging flash loans can potentially change your perspective on lending and borrowing protocols.\n\nThat's all for today. Stay tuned for more insightful blogs on the expansive DeFi universe!\n",
          "updates": []
        },
        {
          "lessonId": "b80e0aaa-037c-414a-b27c-85c8f0b845da",
          "number": 4,
          "title": "What is a Flash Loan?",
          "slug": "what-is-flash-loan",
          "folderName": "4-what-is-flash-loan",
          "description": "",
          "duration": 4,
          "videoUrl": "CgwAYo9rpXo",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/4-what-is-flash-loan/+page.md",
          "markdownContent": "---\ntitle: What is a flash loan? - Arbitrage\n---\n\n\n\n---\n\n# Flash Loans: Leveling the Crypto Playing Field\n\nAs advances in Decentralized Finance (DeFi) shift into high gear, decentralized exchanges (DEX) are positioned at the epicenter of these developments. Previously, trading on these platforms was a privilege reserved for the financial elite - popularly known as 'whales' - who could leverage their massive capital assets to make significant gains. However, the advent of **flash loans** has democratized this field.\n\nSo, how does this groundbreaking innovation operate and help bridge the gap between the haves and the haven'ts in the crypto world?\n\n## Understanding the Concept of Arbitrage\n\nLet's consider a typical scenario. Suppose there are two DEXs, A and B. On Dex A, the exchange rate for Ethereum stands at $5, and on Dex B, Ethereum is trading at $6. Savvy investors might be quick to see an opportunity for profit.\n\nYou could buy one Ethereum at DEX A for $5, then head over to DEX B and sell that Ethereum for $6. This simple transaction would net you a profit of $1. This process is known as **Arbitrage.**\n\n> ‚ÄúArbitrage is exploiting the market's inefficiencies. By observing the different prices of an asset on various exchanges, you can leverage these differences to turn a profit.‚Äù\n\n![](https://cdn.videotap.com/14PlrcuOsiwwbz21cqO4-71.61.png)\n\n## Arbitrage in Action: Difference in Capital\n\nThe catch here is, to initiate this process, you would need to have the $5 necessary to kick-start this operation. But there‚Äôs an inherent limitation when you consider a small-scale trader, let‚Äôs say with only $5 in their pocket. Despite spotting this golden opportunity, they are limited to a single transaction due to their capital constraint. Their profits are also limited because they can only perform these operations one at a time.\n\nLet's consider a drastically different scenario: a user starts with a capital injection of $5,000 instead of $5. They can now purchase 1000 Ethereum tokens on DEX A and then sell them on DEX B, consequently earning $6,000. Here, the trader notches a profit of $1,000.\n\n> Simply put, the more money you start with, the higher your potential profits.\n\nIn the traditional web 2.0 world, this strategy was dominated by 'whales,' (a colloquial term denoting individuals with substantial capital or numerous tokens) as they could afford to take advantage of such lucrative opportunities.\n\n![](https://cdn.videotap.com/rrfz0m4i5sGKt8xvQTqp-135.26.png)\n\n## Introducing Flash Loans\n\nWhat if there was a mechanism that allowed any trader, regardless of their initial capital, to access substantial loans and instantly pay them back? Enter flash loans, an innovative concept that evens the playing field. In essence, a flash loan allows any user to become a \"whale\" for a single transaction.\n\nThrough flash loans, our earlier protagonist with only $5 can perform the same operations as the deep-pocketed trader with $5,000. This revolutionary concept raises a critical question: How can flash loans level the playing field and make web 3.0 finance more equitable?\n\nTo unravel this complex conundrum, we need a deep understanding of what a flash loan is and how it functions. Stay tuned as we dig deeper into this game-changing financial instrument in our ensuing posts.\n\nIn the next article, we dive into the workings of flash loans, their essence, and how they are leveling the playing field for every player in the crypto universe. Stay tuned!\n",
          "updates": []
        },
        {
          "lessonId": "5308c413-16b5-42c8-8b55-91ccbe055788",
          "number": 5,
          "title": "Pay Back Or Revert",
          "slug": "pay-back-or-revert",
          "folderName": "5-pay-back-or-revert",
          "description": "",
          "duration": 4,
          "videoUrl": "qeKdhbevo-w",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/5-pay-back-or-revert/+page.md",
          "markdownContent": "---\ntitle: What is a flash Loan - Pay back the loan or revert\n---\n\n\n\n---\n\n# The Power and Potential of Flash Loans in DeFi\n\nFlash loans provide an innovative financial solution in the decentralized finance (DeFi) world, particularly for arbitrage and various other investment strategies. By examining how they work in the context of smart contracts, we can see how they open up fresh opportunities for DeFi users.\n\n## A Closer Look at DeFi Protocols and Smart Contracts\n\nIn DeFi, many protocols have funds inside a contract. For instance, 1,000 USDC might be stored in a contract, controlled by immutable code. It is this immutable nature that ensures that any funds disbursed by the contract are secured against possible theft.\n\nThe power of DeFi and smart contracts makes them amazing. Particularly because we can encode instructions into them. For instance, a smart contract can be encoded to lend 1,000 USDC to a borrower within a transaction, with the strict condition that the money is returned by the end of the transaction. If the borrower fails to repay the funds, then‚Äîin the miraculous world of web three‚Äîwe can revert the entire transaction! This means that instead of the money disappearing, the transaction is restored to its initial state as though it never occurred. And all this can be encoded into the initial smart contract.\n\n## The Intricacies of Flash Loans in DeFi\n\nNow that we understand the code that governs them, let's look at what this process actually looks like in action.\n\n![](https://cdn.videotap.com/o9RbphgNLng9CnbEUGQa-140.92.png)\n\nImagine that a flash loan contract has been set up. The encoded contract permits a borrower to take a loan of 1,000 USDC, provided it is repaid by the end of the transaction. This all happens within a single transaction.\n\nThis borrowed money is then sent to a contract controlled by the borrower, where the borrower can perform various tasks with the borrowed funds. These might range from arbitrage strategies to simply maintaining the funds in possession for transaction. The contract then has an obligation to repay the loan to the initial lender contract.\n\nAt the end of the transaction, the lender contract conducts a check to ascertain whether the loan has been repaid. If the balance is less than the expected repayment, the entire transaction is reverted, and the blockchain state is restored to the point before the transaction took place.\n\nAnd this, in essence, is how a flash loan works. This facility couldn't exist outside of the web three world. It‚Äôs potential uses are almost limitless, making it an exciting financial tool in the realm of DeFi.\n\n## In the Real World of DeFi\n\nTake a moment to consider the implications of this. With strict conditions ensuring the return of funds, flash loans throw open novel opportunities in the decentralized finance space. Time and imagination are the only constraints on how these funds might be utilized within that single transaction.\n\n> The beauty of flash loans lies in their simplicity and security. A borrower can leverage these loans for sophisticated strategies in a secure, risk-free environment, thanks to built-in transaction reversion. Truly, flash loans embody the full potential of DeFi.\n\nFlash loans open up a playground for experimentation and investment strategy, and they are yet another reason DeFi is an exciting field to watch!\n",
          "updates": []
        },
        {
          "lessonId": "e55d95b1-496b-43ce-9015-bb59b98e1b04",
          "number": 6,
          "title": "Liquidity Providers",
          "slug": "liquidity-providers",
          "folderName": "6-liquidity-providers",
          "description": "",
          "duration": 2,
          "videoUrl": "2LFhhgcSxas",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/6-liquidity-providers/+page.md",
          "markdownContent": "---\ntitle: What is a flash loan - Liquidity Providers\n---\n\n\n\n---\n\n# Deep Dive Into Flash Loans and Liquidity Providers\n\nWelcome to another blog post in our crypto education series, where we explore the intriguing world of decentralized finance (DeFi) concepts. Today, we'll be focusing on the concept of Flash Loans, a highly popular instrument in the DeFi space. More specifically, we'll look at the role of those special behind-the-scene players called Liquidity Providers - their relationship with Flash Loans and how they gain from the system.\n\n## The Concept of Flash Loans\n\nFor the uninitiated, Flash Loans are a DeFi innovation which enables borrowing of an asset without collateral, provided that the loan is repaid within the same transaction block. Now you may ask, how does money magically appear for these loans? And who provides this capital? Let's answer these.\n\n## Understanding Liquidity Providers\n\nJust like in traditional finance, the capital for loans don't just materialize out of thin air. The $1,000 or any amount of the Flash Loan is actually provided by what we call a \"liquidity provider\". In most cases, these are users (or \"whales\") who deposit a significant amount of money into a liquidity pool in a smart contract.\n\nFor instance, assume a user deposited $1,000 into a smart contract. This wouldn't be as simple as a one-sided transaction. Instead, they receive shares of the pool - a sort of 'receipt' denoting their contribution of $1,000 worth of tokens.\n\n## The Flash Loan Process\n\nThe Flash Loan's working can be understood through a simple flow: the user requests the Flash Loan, borrows the money, and immediately pays it back. The USDC quickly cycles between the borrower and the liquidity pool.\n\nIt's important to note that Flash Loans are not free to utilize. Borrowers have to pay a small fee every time they borrow, often something as minuscule as a +0.1% on the borrowed amount.\n\n## Earning Through Fees\n\nHere‚Äôs where things get interesting for our liquidity providers. Every Flash Loan borrowed, and the associated fee, is accrued in the contract. So instead of just the original $1,000, the total pool keeps keeping amplified by the accrued fees e.g., $1,002, $1,003, and so on as more Flash Loans are taken.\n\nIn layman's terms, liquidity providers gather fees from every Flash Loan issued, making their investment worth it. Indeed, as succinctly summed up in this quote:\n\n> \"Because they deposited money to the protocol, they're going to get fees for people taking out these Flash loans.\"\n\n![](https://cdn.videotap.com/YjlbuTfa3JOWtnR1HeLa-81.png)\n\nIn conclusion, Flash Loans present a fascinating facet of the DeFi world, with many moving parts at play. Here's cheers to getting to understand the skeleton of yet another DeFi innovation! Stay tuned for more DeFi explorations in our upcoming blogs.\n",
          "updates": []
        },
        {
          "lessonId": "8232d5e0-21bb-491d-9e57-7dce5033eac4",
          "number": 7,
          "title": "Arbitrage Walkthrough",
          "slug": "arbitrage-walkthrough",
          "folderName": "7-arbitrage-walkthrough",
          "description": "",
          "duration": 5,
          "videoUrl": "3cVWogdtSQM",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/7-arbitrage-walkthrough/+page.md",
          "markdownContent": "---\ntitle: Arbitrage walkthrough\n---\n\n\n\n---\n\n# Spotting Opportunities with Flash Loans in DeFi: A Beginner's Guide\n\nIn this blog post, we'll walk you through a simple yet effective use case of flash loans in the ever-growing DeFi sphere. These instantaneous and uncollateralized crypto borrowings have the potential to level the playing field for those just beginning their journey with decentralized finance.\n\n![](https://cdn.videotap.com/pU3EHWsVTfLRc7Io0d4p-11.31.png)## The Scenario: Decentralized Exchanges and A Flash Loan Protocol\n\nFlash loans can be used to take advantage of discrepancies between different decentralized exchanges. In our use case, for illustrative purposes, let's imagine two decentralized exchanges, **DEX A** that values 1 ETH at $5 and **DEX B**, valuing 1 ETH at $6. Let's introduce our player, **Little Fox**, who initially has $5 and aspires to leverage these discrepancies for gains, much like big players or ‚Äúwhales‚Äú.\n\nOrdinarily, he could repeatedly buy ETH from DEX A and sell on DEX B to benefit from the price disparity while it lasts. However, performing this arbitrage manually would entail considerable gas fees and risk attracting copycats, eroding the arbitrage opportunity over time. This approach, therefore, isn't practical nor efficient.\n\nEnter **flash loans**, an innovative DeFi tool that can significantly change the landscape.\n\n![](https://cdn.videotap.com/nb798NifZCWAlRyaN0W8-39.57.png)\n\n## The Flash Loan Mechanism: How Does It Work?\n\nBelow, we're going to break down how our Little Fox can employ the power of flash loans and achieve the same level of profit as a whale.\n\nIn our example, there's a flash loan protocol that enables individuals to borrow substantial sums of capital. The protocol begins empty, awaiting deposits from prospective lenders.\n\nLet‚Äôs say a whale deposits $5,000 into the protocol, creating 5,000 flash loan tokens (FLTs). Owning 100% of the FLTs, the whale essentially owns all the money in the protocol. They can use their FLTs to retrieve their full deposit at any time they wish.\n\n## Step 1: Requesting the flash loan\n\nThe first step for Little Fox is to call the flash loan function on the smart contract to borrow the $5,000 from the protocol.\n\n### Step 2: Executing the arbitrage strategy\n\nRemember that all actions using the borrowed funds must occur within one blockchain transaction to prevent loan default. Therefore, we represent the following steps with a single 'transaction call'\n\n### Step 3: Repaying the flash loan\n\nFinally, Little Fox repays the $5,000 flash loan to the protocol and keeps the $1,000 profit.\n\n![](https://cdn.videotap.com/ZCzIKYmtOmiYCUylbef8-237.43.png)\n\nIn effect, by initially borrowing $5,000, buying 1,000 ETH, re-selling the ETH for $6,000 and returning the initial $5,000 (plus a tiny fee), Little Fox made the same $1,000 gain that the whale would‚Äôve without the initial capital.\n\n> \"Despite starting with just $5 and incurring a tiny fee, our Little Fox was able to end up with a juicy profit of almost $1,000, thanks to flash loans.\"\n\nTo provide some perspective, let's keep in mind that real-world arbitrage opportunities won't always be as substantial, and gas costs can influence the profitability. However, the example underlines the power of flash loans to amplify potential profits in DeFi by enabling smaller players to punch above their weight.\n\nFlash loans epitomize the democratization of finance that lies at the heart of the DeFi movement. They demonstrate just how the playing field can be leveled by the power of smart contracts, providing opportunity and access to all participants, not just the 'whales'.\n",
          "updates": []
        },
        {
          "lessonId": "044a08db-c6fa-4162-8996-88a28d93bf76",
          "number": 8,
          "title": "Are Flash Loans Bad?",
          "slug": "are-flash-loans-bad",
          "folderName": "8-are-flash-loans-bad",
          "description": "",
          "duration": 1,
          "videoUrl": "9RDPIdTk3Tc",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/8-are-flash-loans-bad/+page.md",
          "markdownContent": "---\ntitle: Are Flash Loans Bad?\n---\n\n\n\n---\n\n# Flash Loans in Crypto Finance: A Level Playing Field\n\nCrypto finance, or more aptly the world of DeFi (Decentralized Finance), is a rapidly evolving landscape. There's one key feature that has been stirring up quite a debate: **flash loans**. Today, we delve deeper into what flash loans are and how they're positively impacting the sphere.\n\nBefore we tread further, for those unfamiliar with the term, let's start with a brief walkthrough of what flash loans are.\n\n## What are Flash Loans?\n\nIn the context of DeFi, a flash loan is essentially an uncollateralized loan option that allows individuals to borrow cryptocurrency and repay it back within the same blockchain transaction. In other words, you borrow and repay in a single operation. This may sound more like a charade, but trust me, it's a feature that could be a game-changer.\n\n> \"Flash loans allow anybody to be a whale in the traditional finance world.\"\n\n![](https://cdn.videotap.com/Nz3tLzfPAOWomq9L4VVr-9.78.png)\n\nFlash loans are helpful in a myriad of applications, arbitrage being a major one, and we'll delve into exactly how these loans play out in the following sections.\n\n## The Power of Flash Loans\n\n### Equalizing the Playing Field\n\nIn the traditional finance world and even in most commerce spaces, arbitrage opportunities exist. For those unfamiliar with this term, arbitrage is simply the practice of taking advantage of a price difference between two or more markets. It involves striking a combination of matching deals that capitalize upon the imbalance, with the profit being the difference between the market prices.\n\nHowever, there's a catch: these opportunities are usually accessible only to the super-rich or \"whales\", as they're colloquially referred to in the crypto world. Why? Because they are the ones with substantial capital to participate in these kinds of opportunities.\n\nIn comes our knight in shining armour - the flash loans. By offering a way to take part in these opportunities without a massive initial capital, flash loans level the playing field and democratize the finance world, making it possible for anyone to be a ‚Äòwhale‚Äô ‚Äî if only for a single transaction.\n\n> \"In the DeFi world, thanks to flash loans, the playing field is leveled and anyone can be a ‚Äòwhale‚Äô for a single transaction.\"\n\n![](https://cdn.videotap.com/khoXIky8WmJ5fr0DE16U-22.png)\n\n## The Positives of Flash Loans\n\nContrary to popular belief, flash loans are not a negative elixir. They are empowering smaller investors and participants by opening gateways to opportunities that were previously locked up for the privileged few.\n\nFirstly, these loans are uncollateralized, meaning that you don't have to put up any collateral to secure a loan. You just enter, borrow the money, do your business and pay the loan back ‚Äî all within a single transaction block. This makes it really appealing for everyday folks to participate in the crypto market and benefit from the same.\n\nSecondly, flash loans have made it possible to conduct complex financial manoeuvres like arbitrage with practically zero upfront capital ‚Äî a situation that was unthinkable not too long ago. This gives an opportunity to the ordinary individuals to make a profit from the fluctuations in the notoriously volatile crypto markets, thus breaking the monopoly the ‚Äòwhales‚Äô had over such activities.\n\n![](https://cdn.videotap.com/WdxwLG3XbBSQfHjisOdu-28.11.png)\n\n## Conclusion\n\nIn conclusion, flash loans in the world of DeFi, despite some of the criticisms they face, are indeed a positive evolution, as they democratize the crypto financial world and make it accessible to an average investor. The power to be a crypto 'whale' for even a single transaction has brought a much-needed sense of equity to this space. Therefore, flash loans are here to stay and likely to shape an increasingly level playing field in the crypto industry moving forward.\n\nSo now, continue your exploration into the financial future. Know that you too can be a whale!\n",
          "updates": []
        },
        {
          "lessonId": "cd8d2270-4a46-4bdb-a9ec-7df8212ed851",
          "number": 9,
          "title": "Recap",
          "slug": "recap",
          "folderName": "9-recap",
          "description": "",
          "duration": 3,
          "videoUrl": "pq27L8XrgjI",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/9-recap/+page.md",
          "markdownContent": "---\ntitle: Recap\n---\n\n\n\n---\n\n# Decoding Flash Loans: A Comprehensive Walkthrough\n\nWelcome back! Today we're going to steer the wheel down the crypto lane and dive into a fascinating concept - Flash Loans.\n\n![](https://cdn.videotap.com/e2sbhlbfl9ZreXlI3mzt-12.08.png)\n\n## How Do Flash Loans Work?\n\nA quick rundown of how this all functions is necessary. Picture this: a whale (a large player in the crypto market) deposits $5,000 into the flash loan protocol.\n\n![](https://cdn.videotap.com/ww7stcBKpXeTs9ZF51U1-30.19.png)\n\n### The User Comes In\n\nAfter this, a user comes in and pulls out a $5,000 loan from the flash loan. This person now needs to repay the $5,000 plus any fees associated; if not, the transaction will revert. The user uses this borrowed amount to purchase $1,000 worth of Ethereum (ETH).\n\n### Trading the ETH\n\nThen comes the interesting part. They sell the $1,000 worth of ETH for $6,000, and then return the originally borrowed amount‚Äîkeeping $1,000 for themselves, which results in net earnings of $995 after paying a $5 fee.\n\n### Where Does The Money Go?\n\nSo, in the course of these transactions, the flash loan protocol ends up with the initial $5,000 plus the $5 fee.\n\n### Withdrawal by the Whale\n\nLastly, whenever the whale chooses, they can withdraw their initial deposit by trading back in the flash loan token, which signifies their 100% ownership of the pool. So, for their $5,000 deposit, they receive $5,005: a mix of the original deposit amount and the accumulated fees.\n\n## Learning About Arbitrage\n\nAlright, so that was quite a bit to absorb, but it paints a rough picture of how flash loans function. Now, why would someone want to use flash loans? A primary reason is arbitrage.\n\nArbitrage is a scenario where you exploit a price discrepancy on two different exchanges. For instance, if Exchange A lists ETH at $5 and Exchange B lists ETH at $6, you can buy from A and sell at B to make a profit. This is arbitrage simplified.\n\n## Flash Loans: Breaking Down Their Purpose\n\nNow, let's circle back to flash loans. What makes them unique is the rapidity with which they can be executed. A loan taken out for a single transaction, and if repaid immediately, it completes. If not, the transaction can be coded to automatically revert. This function is only possible in Web 3 platforms.\n\nPulling these threads together, someone might utilize a flash loan to carry out arbitrage and benefit from a market price discrepancy.\n\n> \"Flash loans allow us to take out quick loans for a single transaction. If we don't pay the money back, the transaction can automatically revert.\"\n\n## Dig into It Yourself!\n\nFor those seeking a more hands-on approach, we'll be adding examples of flash loan protocol arbitrage in the audit data branch of our GitHub repositories. All diagrams used in this post, as well as additional resources, can be found there.\n\nIn conclusion, flash loans and arbitrage could be a lucrative way to leverage crypto market discrepancies, especially considering the volatility characteristic of this space. Whether you're an aspiring whale or a novice user aiming to dip your feet, understanding this realm can illuminate a whole new way of interacting with cryptocurrency.\n\nThe main caveat, as always, is comprehension. Understanding the terms and conditions, and the associated risks, is a prerequisite to success in any financial venture, and flash loans are no exception. Be sure to dig into our other resources if you'd like more of a deep dive!\n",
          "updates": []
        },
        {
          "lessonId": "d61670f8-0992-4154-b45a-41b2a482a0ea",
          "number": 10,
          "title": "Recon Continued",
          "slug": "recon-continued",
          "folderName": "10-recon-continued",
          "description": "",
          "duration": 4,
          "videoUrl": "fTi9rI6qWlQ",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/10-recon-continued/+page.md",
          "markdownContent": "---\ntitle: Recon (continued)\n---\n\n\n\n---\n\n# Understanding the Thunder Loan Protocol: A Comprehensive Review\n\nWelcome to another intriguing blog post where we'll dive deep into the world of cryptocurrencies, specifically focusing on the Thunder Loan protocol. This post is rooted in our continued commitment to simplify complex subjects in decentralized finance for you.\n\n## Contextualizing the Thunder Loan Protocol\n\nThunder Loan protocol, like many other DeFi (Decentralized Finance) protocols, is based on borrowing, lending, and flash loans. To fully grasp how this protocol operates, one must first comprehend how flash loans and borrowing/lending processes work.\n\n> _\"Sometimes when you're doing security reviews, you got to look up stuff that might not seem related.\"_\n\nI recommend learning more about these protocols by exploring [Aave](https://aave.com) and [Compound](https://compound.finance). You could also watch related deep-dive videos to get more context.\n\n## Breaking Down Flash Loans and Liquidity\n\nSo, what is a flash loan? In essence, flash loans involve users borrowing substantial sums, completing arbitrage trades, then returning the borrowed sum in the same transaction. They are rapid transactions that thoroughly leverage the capabilities of smart contracts.\n\nUsers, also known as liquidity providers, deposit their funds into the protocol. In exchange, they receive asset tokens, representing their stake in the protocol. Users also need to pay a small fee to the protocol, which depends on the borrowed sum.\n\nOne might be curious: how is this fee calculated?\n\nEnter the **on-chain Tswap price oracle**.\n\n## The Critical Role of the Tswap Price Oracle\n\nPrice oracles play a crucial role in crypto trading platforms. They act as a bridge, bringing external real-world data or computation on-chain.\n\n> _\"An Oracle is going to be a device that takes external real-world data or computation and brings it on-chain.\"_\n\nFor instance, a price oracle could determine the price of Ethereum ‚Äì a concept forgotten by the material world. It's fascinating to note that the Thunder Loan protocol uses TSwap's Dex that we reviewed in our previous section as a price oracle.\n\nNow, one might wonder: why would the protocol need a price oracle?\n\nLet's dig in further.\n\n## The Thunder Loan Protocol Upgrade\n\nWe have one more puzzling detail. Thunder Loan Protocol is planning to upgrade their current contract to the Thunder Loan upgraded contract.\n\nThis upgrade is a crucial element to be considered under the scope of our security review. The Thunder Loan seems to be an upgradable smart contract, following the Ownable Upgradable, UUPS Upgradable and Oracle Upgradable paths.\n\n## Wrapping Up\n\nFinally, we've learned how the protocol sheds light on flash loans, arbitrage, and provides various opportunities for liquidity providers apart from their usual asset token interest.\n\nWe've also noticed some unique features like the TSwap Price Oracle embedded into the protocol's ecosystem, contributing prominently to its functionality.\n\nThis post should have given you a thorough overview of the Thunder Loan protocol. Now would be an ideal time for you to reach out to the protocol or prepare their diagrams, detailing how their whole system actually works.\n\nRemember to have fun, stay curious, and keep exploring!\n",
          "updates": []
        },
        {
          "lessonId": "cf98c920-cca9-4975-9259-b11408ae8b36",
          "number": 11,
          "title": "Static Analysis - Slither & Aderyn",
          "slug": "static-analysis-slither-aderyn",
          "folderName": "11-static-analysis-slither-aderyn",
          "description": "",
          "duration": 7,
          "videoUrl": "3xCoqt4Bx2o",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/11-static-analysis-slither-aderyn/+page.md",
          "markdownContent": "---\ntitle: Static Analysis Slither + Aderyn\n---\n\n\n\n---\n\n# Solidity Foundry Project: Running Slither and Aderyn\n\nWelcome back! In today's blog, we're going to throw ourselves into the heart of a Solidity foundry project. Unfortunately, there are no diagrams to help us along the way, but no worries, because we've got two brilliant tools at our disposal: **Slither** and **Aderyn**.\n\n## Setting the Stage: Your Make File\n\nFor this project, and any Solidity project moving forward, a typical **make file** will embrace a little Slither command line action and be embellished with a Slither Config JSON file.\n\nThe Slither Config JSON that I am fond of using, you can tailor as per your project needs. What makes it special is the string of flags that are manually turned on or off to procure meaningful Slither outputs. _Fun Fact: You might notice I don‚Äôt include a few detectors like conformance to Solidity naming conventions or incorrect versions of Solidity. That‚Äôs because I have a fair share of taste for unconventional naming and most folks aren‚Äôt using 0.8.18 versions but rather zero point 20._\n\nNext, in our mission to make the Slither output as concise and helpful as possible, we make sure to filter paths to avoid pulling in redundant information from mocks, tests, scripts, upgraded protocol, or dependencies. This ensures we don't muddle our results with data from libraries.\n\n## The Bug Hunt Begins\n\nOn initiating Slither, we did hit something noteworthy, a bug! The first info detected was thunderloan update. The problem lay in that the action of the code `s_flashloan fee = new fee` was not triggering an event emission. This was in Thunder Loan line 269.\n\nNow, let's get to the heart of the update flash loan fee function. We spotted a `s_flashloan fee` variable. When we investigated further, it was found to be a storage variable.\n\n> Important: Whenever a storage update occurs, it is mandatory to emit an event.\n\nTo make a note of it for the auditor, we wrote `@audit: low must emit an event.`But that's not the end of it. We found more issues with Slither.\n\n## Fishy Thunderloan\n\nSlither also pointed out the possibility of reentrancy vulnerabilities in the Thunderloan flash loan because of external calls being made. We're not entirely sure of the severity, but we mark these for a follow-up review.\n\n> Note: Be sure to check out the mentioned lines (#204, #181) in Thunderloan for potential reentrancy vulnerabilities.\n\n## Beware the Old Yellow\n\nFinally, Slither pointed out a yellow alert, which was a little concerning. The problem was that the return value of an external call was not stored in a local or state variable. Again, we must make a follow-up note of this and verify later if it's a grave issue.\n\nWith the last yellow alert, we've run through all theing that Slither had to offer. However, we're still not done. Next, we need to run Aderyn.\n\n## Round Two: Aderyn\n\nAfter running Aderyn, a report is generated. The report can be checked for any potential issues and, if need be, compared with Slither's findings.\n\nAnd voila, that's how you navigate through a Solidity project with the help of Slither and Aderyn. By doing so, you can identify potential vulnerabilities and build better, safer code. Until next time, happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "bd391a8a-f18f-496a-94de-1b82c42ed12b",
          "number": 12,
          "title": "Exploit: Centralization",
          "slug": "exploit-centralization",
          "folderName": "12-exploit-centralization",
          "description": "",
          "duration": 3,
          "videoUrl": "C7QJD-0ySW8",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/12-exploit-centralization/+page.md",
          "markdownContent": "---\ntitle: Exploit Centralization\n---\n\n\n\n---\n\n---\n\n# **Understanding Centralization Risk in Contracts**\n\nIf you've written code for a smart contract, you may have come across this pesky medium-issue termed the 'centralization risk.' Often underplayed or regarded as a known non-issue, centralization risk holds the highly explosive capability to compromise your entire protocol.\n\n![](https://cdn.videotap.com/RLVhl7xtB45C5923CMwb-29.14.png)\n\nIn this article, we will dissect this concept, characterized by contracts with privileged owners who exercise undue rights to perform administrative tasks. These individuals demand a blind trust not to execute malicious updates or drain funds - a colossal deal in the world of protocols.\n\nBut, why should we report this in a private audit? Let's zoom in.\n\n## **Why Centralization Risk Matters**\n\nThe alarm bells around centralization risks are not just blown for fun. There are hundreds of thousands of reasons to do so, primary being the inherent security issue. This vulnerability, if left unaddressed, can lead to the disastrous situation known as a 'rug pull.'\n\nA metaphorical term, rug pull equates to the unanticipated withdrawal of liquidity from a protocol by its creators, rendering the protocol useless. Here's a quote aptly encapsulating this scenario:\n\n> \"Imagine someone pulling the rug off underneath your feet leaving you in a freefall. That's what is a rug pull.\"\n\nTake a case wherein a contract is deployed, and it's vaunted as a decentralized entity. But the reality behind it is that it‚Äôs actually behind a proxy. At any unpredictable time, the owners of this proxy could upgrade the contract, introducing functions like 'steal all the money' - definitely not cool.\n\n## **A Deep Dive into SC Exploits Minimize Git Repo**\n\nIn the SC exploits minimize git repo associated with this course, we have chosen the SRC protocol's 'Thunder Loan.' We discovered that the protocol is rife with ownable actions. After sorting through 'Only Owner,' we spotted the functions set to allowed token, update Flash loan fee, and authorize Upgrade - all were exclusive to the owner.\n\nAdditionally, the owner of the protocol holds the power to modify all functionalities as per whims and fancies. This ownership is possible since the protocol is set behind a UUPS Proxy contract. It means that with one misstep, the entire protocol can be swept away.\n\nIt's not all bleak, though. Automated discovery tools like Adarin automatically seek centralization issues and generate comprehensive reports, minimizing the manual effort required to spot these vulnerabilities.\n\n## **Exploring Further: Case Study of Oasis**\n\nBefore we wrap up, let's undertake a brief study of an excellent DeFi vulnerability challenge based on Oasis. The purpose of this exercise is to delve into the insecurities laid bare by unchecked centralization.\n\nOur study highlighted that the contract owner could arbitrarily alter the balances of its users, effectively empowering the owner to rob the hard-earned ETH of its users. Consequently, this amplifies the centralization issue exponentially. This scenario mirrors an array of rug pulls stemmed from unchecked centralization.\n\n## **Conclusion**\n\nIn the end, it all boils down to one fact - the presence of centralization poses a severe risk to the security of any protocol. Being proactive in acknowledging and mitigating this risk is non-negotiable if we aim to maintain the integrity of our protocols. Centralization can be a security issue, but with constant vigil, we can tackle it head-on.\n\nStay safe and happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "dbe192e5-2438-42f5-a9f8-efac77de2cde",
          "number": 13,
          "title": "Case Study: Oasis",
          "slug": "case-study-oasis",
          "folderName": "13-case-study-oasis",
          "description": "",
          "duration": 3,
          "videoUrl": "e-4YOy7sc6s",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/13-case-study-oasis/+page.md",
          "markdownContent": "---\ntitle: Centralization Case Study Oasis\n---\n\n_Follow along with this video:_\n\n\n\n---\n\n# The Oasis Protocol Hack Recovery: A Tale of Centralization Risks and Court-Mandated Exploits\n\nYou have heard before about cyber thefts. But have you heard of one where hackers end up having the tables turned on them? This exactly happened earlier this year in the world of digital asset lending and borrowing. It's a rollercoaster of a story that involves smart contracts, the UK courts, and a protocol called Oasis. The protocol, incidentally, had projected itself as decentralized and permissionless, but ended up playing an ironic role. Let's dig in.\n\n## Oasis and Its Security Meltdown\n\nOasis is a digital platform that allows users to lend and borrow assets on the maker protocol. The exciting - and somewhat controversial - thing about it was its selling point as a decentralized and permissionless platform. In other words, there was no need for central intermediaries, fuss over permissions, or concerns about third-party interventions.\n\n![](https://cdn.videotap.com/TrlvVL07HW0fU9JmwRSw-26.17.png)\n\nAll well and good until one day when a hacker sneaked in and made off with a sizeable amount of money - exactly 120K wrapped ether. Placing his stolen money in the Oasis application, the hacker probably felt quite pleased with himself. However, he didn't count on the steps that the victims of this hack would take next.\n\n## Hacking Back the Hackers\n\nUnderstandably angered, the victims - who had substantial money sitting in the said protocol - turned to security researchers for assistance. The question was straightforward: Could a forced smart contract upgrade retrieve the stolen loot? To their relief, the answer was also straightforward: Yes.\n\nSo next, they went to court armed with this new knowledge of an exploit in the Oasis' codebase. Their request was straightforward: Force the team behind Oasis to upgrade the protocol and utilize the exploit to match the hacker's play. Sounds wild, right? But it didn't just end there.\n\n## A Court-Ordered Exploit\n\nThe court agreed with these victims and ordered Oasis - yes, the same Oasis that professed decentralization and permissionless transactions - to upgrade their protocol and exploit their own security flaw. The objective was clear: retrieve the hacked funds, which, in essence, was hacking the hacker.\n\n> \"The whole saga entailed coordination between the Oasis' founding team and the wormhole developer from Jump Crypto, the trading firm that had lost their money in the first place.\" - Extract from Blockworks Research Article.\n\nThis was possible only because Oasis‚Äôs protocol wasn't truly decentralized or censorship-resistant. Had it been so, this court-ordered exploit couldn't have happened at all.\n\n## The Conundrum of Centralization\n\nSo was this a happy ending? Not everyone agrees. Yes, the stolen funds were recovered, but the image of Oasis as a truly decentralized platform took a hit. It revealed centralization risks creating a shift in how users see and interact with these types of platforms, as, generally, they are under the impression of these protocols being completely decentralized. As security researchers, we need to address such misleading aspects.\n\nPerhaps the takeaway from this episode is the importance of awareness and the possible loop-holes that may exist even in the most secure looking digital assets systems, and also that, despite the convenience and freedom, decentralized platforms can pose, there are hidden pitfalls.\n\nSo the next time you're looking into using a new system or protocol, remember the story of the Oasis Protocol Hack Recovery. Not every 'decentralized' platform is truly what it claims to be. Be sure to read the information given, especially when it comes to security and understand the risks before committing your digital or physical assets. Be aware, and make a well-informed decision.\n\nStay safe!\n",
          "updates": []
        },
        {
          "lessonId": "2d1c0adc-43ec-4577-8da5-e47ba2915f66",
          "number": 14,
          "title": "Static Analysis Continued",
          "slug": "static-analysis-continued",
          "folderName": "14-static-analysis-continued",
          "description": "",
          "duration": 1,
          "videoUrl": "UZFZgPSRv7k",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/14-static-analysis-continued/+page.md",
          "markdownContent": "---\ntitle: Static Analysis Continued\n---\n\n\n\n---\n\n# Identifying Key Aspects of a Blockchain Protocol Audit\n\nThe process of a blockchain protocol audit involves numerous steps, including checking for null address errors or unused functions, and then reporting these findings. In this blog post, we will go through the transcript of such an audit, explaining the key steps and the reasons behind the auditors' actions.\n\n## Addressing Null or Zero Address Errors\n\nThe first thing on the agenda was identifying any zero address checks that were missing.\n\nWhile inspecting the code in `orible_upgradable.sol`, few aspects came to light that called for some auditing. In blockchain parlance, a zero address refers to an address that was never assigned. If any state variables in a smart contract were unintentionally assigned to a zero address, the contract may not function as intended.\n\nThe code seemed to have a couple of places where this was an issue in assigning values to address state variables that lacked checks for address zero.\n\nAn additional instance required our attention, further validating that multiple aspects of this contract require zero address checks. This recommendation came up as part of the audit's Informational findings or the 'Gas' that helps improve the contract's architecture.\n\n## Marking Unused Functions as External\n\nThe next point of attention was for functions that weren‚Äôt being used internally. These could be marked as external. Specifically, the `getAssetToken` function appeared to be a likely candidate for this change. It was found to be defined in `ThunderLoan.sol` but seemed to only be utilized in the `ThunderLoanUpgraded.sol` contract.\n\n## Defining and Using Constants Instead of Literals\n\nLiterals, in coding terms, are the set values that remain unaltered throughout the code's execution. Using constant variables instead of these literals enhance the code‚Äôs readability and maintainability.\n\nOn Line 144 of the contract, the use of magic numbers was spotted. Magic numbers refer to undisguised numerical values that could potentially create confusion in the future. Therefore, defining and using constants instead of these literals is strongly advised.\n\n## Track Missing Index Fields in Events\n\nEvents play a crucial role in smart contracts, keeping a log of essential occurrences. Therefore, including an 'index field' is essential, as it aids in filtering and searching event logs effectively.\n\nIn our project's case, some events being emitted lacked such an indexed field. Including this in the final report as an informational finding is a must, enabling the team to use events in a more structured and practical manner.\n\n# Evaluating Centralization Issue\n\nDuring our audit process, a centralization issue was identified with the protocol. It's a common practice in a private audit to notify the protocol if the contract is centralized. As highlighted in the Oasis case, an element of control or flexibility can potentially have dire consequences on protocol decentralization.\n\n\"We found a centralization issue. We'd generally advise against this if the protocol doesn't need to be ownable or upgradable, as it presents a centralization vector.\"\n\n# Concluding Remarks\n\nInformation gleaned from this audit demonstrates how intricately the process needs to be conducted. Key findings drawn during the process included missing zero-address checks, unused internal functions, usage of literals instead of constants, and missing index fields in events. Along with this, an important aspect brought forth was the issue related to centralization.\n\nIt's vital to consider every possible attack vector when developing a protocol. By acknowledging potential risks, such as an unsuspecting bad actor gaining control and pilfering funds, we can make necessary adjustments to mitigate these risks.\n\nBy running various audits like Slither or Adarin, we can close potential loopholes and aim to deliver a more streamlined, safe, and reliable protocol. These measures culminate in securing your protocol's integrity against potential risks, enhancing its potential for real-world utilization.\n",
          "updates": []
        },
        {
          "lessonId": "eff20578-d301-44a4-9a97-57140f7e19b5",
          "number": 15,
          "title": "Recon IPoolFactory",
          "slug": "recon-ipoolfactory",
          "folderName": "15-recon-ipoolfactory",
          "description": "",
          "duration": 6,
          "videoUrl": "4si96F9njXU",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/15-recon-ipoolfactory/+page.md",
          "markdownContent": "---\ntitle: Recon Manual Review IPoolFactory sol\n---\n\n\n\n---\n\n# Manual Code Review: Getting Started\n\nAfter setting our initial context and utilizing our suite of auditing tools, it's time to get our hands dirty with some thorough manual review. Much like our previous auditing process, one viable option available to us is to start from the test suite.\n\n## Diving Into the Test Suites\n\nThe project at hand features an invariant test suite, which, unfortunately, is rather redundant, hence ineffective. Additionally, there are some unit tests that warrant our attention. Consequently, an excellent first step is to run the `forge coverage` command to get an idea of the current test suite under scrutiny.\n\n## Reviewing Test Coverage\n\nOur preliminary exploration reveals that the test coverage is unsatisfactory. Therefore, it's mute to map out our plan of action: We need to scrutinize this test suite, comprehend its shortcomings, infer the invariants, and consequently pen a robust invariant test suite. Afterward, all related findings would be relayed to the client‚Äîhighlighting their dire need to improve test coverage, expressed as an informal suggestion.\n\nOur last venture had us initially peering into their test suite and buffing it up. By taking this approach, revealing the hidden bugs was a breeze, and it seems likely that this strategy would prove beneficial once more. Nevertheless, this journey would also incorporate a thorough manual review.\n\n## Focus on Proof of Code\n\nAn essential part of the auditing process would involve digging deep into the provided code with a fine-toothed comb. While no single approach guarantees success, we'll be implementing the 'Tincho method' with considerably more gravity this time around.\n\n### Workflow Setup with the Tincho Method\n\nOur journey begins in the SRC, using the `solidity metrics` command. The output would be copied in entirety and pasted into a document of choice. I personally prefer Google Sheets due to its easy to use interface and sorting abilities.\n\n![](https://cdn.videotap.com/UrVcjpzYpZgiEY4KluYE-96.32.png)\n\nAfter eliminating any unnecessary columns, it is sensible to sort the code by size, in ascending order. This list forms the foundation of our audit, providing a linear path of progression from smaller contracts to larger ones.\n\n### Mining the Code: Ifactory sol and ipoolfactory sol\n\nUsing the Tincho method, we start by tackling the smallest contract: 'ifactory.sol'. The microscopic size may make it seem insignificant, but give it due diligence.\n\nShortly after, 'ipoolfactory.sol' comes under scrutiny‚Äîthe first contract addressed in this session. Notably, this contract seems to interface with the T swap pool factory, as signified by the function 'get pool'.\n\nOn closer inspection of the TSWAP code base, we can see that there is indeed a 'get pool' function present in the 'pool factory' ('poolfactory.sol').\n\nA useful annotation to consider:\n\n> 'ipoolfactory' is likely the interface used for communication with 'poolfactory.sol' from TSWAP.\n\nIt would be beneficial to jot down these insights as an organized mind note or Google Sheets document, with sections such as 'About', 'Potential attack vectors', 'Ideas', and 'Questions'.\n\nA few starting points include:\n\n- Write about the protocol in your own words.\n- Why are we using TSWAP in this context?\n- How do flash loans correlate with this usage of TSWAP?\n\nThis document acts as a brain dump, helping record initial thoughts, insights, and potential attack vectors. Maintaining an organized note system would likely make your work more efficient.\n\nAt first glance, 'ifactory.sol' seems sound without any evident issues, which is a good sign. This quick win aligns with our ideology: to confirm the validity of the smaller parts before progressing onto larger sections.\n\n## Keeping An Audit Trail\n\nEvery reviewed snippet is ticked off, allowing us to keep track of our journey and ensure that ground covered is not tread twice.\n\nOur first milestone? 'ipoolfactory.sol': reviewed successfully.\n\nTo improve our workflow, we could even factor in stages of review ('first pass', 'second pass', etc.). Our current initiative involves only a single comprehensive review to keep things simple.\n\n## Wrapping It Up: First Review\n\nAfter this successful review of 'ipoolfactory.sol', we realise that the audited code interacts with an external contract: the pool factory. By understanding these relationships and ensuring the correctness of the smaller contracts, we're paving the way to a comprehensive project audit. Armed with keen eyes and perseverance, we're ready for our next task‚Äîbe it large or small.\n",
          "updates": []
        },
        {
          "lessonId": "b749f8e0-87f5-4e12-880d-8ecd81d5871b",
          "number": 16,
          "title": "ITSwapPool",
          "slug": "itswappool",
          "folderName": "16-itswappool",
          "description": "",
          "duration": 2,
          "videoUrl": "HsrzejNBhYs",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/16-itswappool/+page.md",
          "markdownContent": "---\ntitle: ITSwapPool sol\n---\n\n\n\n---\n\n# Deep Dive into Tswappool.sol Interface\n\nOne mystery that never loses its charm in the world of programming is the magic and intrigue of code reviews. It's an opportunity to navigate a labyrinth of ideas coded into existence, where the treasure isn't a particular conclusion, but a drive towards understanding and well, continuous improvement. In our expedition today, we're exploring the exciting realm of \"Tswappool.sol\".\n\n## The Intriguing Interface of TSwapPool\n\nAs we pulled up the \"Tswappool.sol\" file, it quickly became clear that the script was another interface in the ever-expansive Ethereum world, and the initial overview was rather promising.\n\nHere's a quick view into the key aspects of this interface:\n\n- `SPDX license Identifier`: Check. Good on this front.\n- `Pragma solidity`: All clear here.\n- `Interface TswapPool`: The main piece we're interested in.\n\nThe structure and organization of the script were clean, effective, and up to standards at first glance, which adds a tick on the checklist.\n\n### The Key Function: Get Price of One Pool Token in WETH\n\nThe heart of any interface lies within the crucial functions it employs. In TswapPool, we uncover a singular but significant function - `getPriceOfOneTokenInWETH`.\n\n![](https://cdn.videotap.com/AVRQTYRhhg4lDMb4rQM4-43.2.png)\n\nUsing this function, the interface ends up working with TSWAP quite seamlessly. So kudos on the smart use of simplicity guided by functionality!\n\n#### But Why Only One Function?\n\nWhile everything else falls perfectly into place, a peculiar aspect emerges. The existence of only one function in the interface raises the question, \"Why is the price of pool token in WETH the solitary functionality being implemented here?\"\n\n> \"Why is the `getPriceOfOneTokenInWETH` function the only one in this interface?\"\n\nThis question remains open-ended for now and forms an essential part of understanding and further exploring the purpose and design of this interface.\n\n## It's a Check!\n\nMinus the above question, scrutinizing the 'Tswappool.sol' interface looks predominantly positive. Both the syntax and architecture of the coded script meet the expected standards.\n\nLiving up to the 'Tincho method' philosophy, which advocates for the clarity and optimization of code, the TswapPool interface easily garners a big shiny check ‚úì!\n\nIndeed, code reviews especially with the Tincho method in our toolkit, feel deeply satisfying when met with such well-structured and cleanly scripted interfaces.\n\nAs we come to the end of our review, remember that understanding scripts isn't just about putting checks on a list, but about appreciating the complexity coded into simplicity and the team spirit built into community standards.\n\nReviewing the `Tswappool.sol` interface was a pleasure. Here's to many more engaging dives into the intriguing world of Ethereum and blockchain development!\n",
          "updates": []
        },
        {
          "lessonId": "2fd9c1c0-5353-4d44-acd7-c33062f816e2",
          "number": 17,
          "title": "IThunderLoan",
          "slug": "ithunderloan",
          "folderName": "17-ithunderloan",
          "description": "",
          "duration": 3,
          "videoUrl": "Elfslyct1tw",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/17-ithunderloan/+page.md",
          "markdownContent": "---\ntitle: IthunderLoan.sol\n---\n\n\n\n---\n\n# Unearthing Bugs and Enhancing Interfacing in ThunderLoan Protocol\n\nIn the overlapping maze of smart contracts and blockchain protocols, it's critical not to miss any threads. You can uncover this through a methodical analysis of the mechanism layer by layer, as demonstrated with ThunderLoan protocol.\n\n## Unraveling the ThunderLoan Contract\n\nThe journey begins with taking a peek at the IThunderLoan interface we have been investigating. Here, the classic `ThunderLoan` contract caught my eye. As the usual procedure goes, we need to tackle a crucial question ‚Äì \"Does `ThunderLoan` implement the `IThunderLoan`?\"\n\nIn this case, the `ThunderLoan` contract doesn't implement `IThunderLoan`. This might seem odd at first, but it could perhaps be an informational point from an auditing perspective. Intriguingly, the `IThunderLoan` interface should ideally be carried out by the `ThunderLoan` contract. An interface is a valuable tool in programming, it acts as a guideline to developers, ensuring that they don‚Äôt leave out any critical functions.\n\nNow, if the contract isn't implementing the interface, it's time to delve deeper into the details and discrepancies that might crop up in such cases. Let's compare the two closely and see if they're actually different.\n\n![](https://cdn.videotap.com/Bft86JEs1cIqjxRo4BZq-39.92.png)## Scrutinizing the Repay Function\n\nKeeping a sharp focus on the `repay` function, we can see that it accepts a token, an address, and an amount. If we dig into the `IThunderLoan` interface, we notice this function takes an `IERC20` token and an address amount.\n\nUpon a detailed observation, this presents a peculiar situation ‚Äì the `IThunderLoan` and `ThunderLoan` contract parameters are not only different, but they contradict each other, creating grounds for an issue. Just imagine scenarios where the `repay` function is expecting an `IERC20` token, but it receives an address token; the resulting confusion could cause the process to break!\n\nNow, when we try to import the `IThunderLoan` and inherit it into `ThunderLoan` in Visual Studio Code, and if we save it, it says _\"ThunderLoan should be marked abstract because it doesn't implement this `repay` function.\"_ This issue would have been caught easily if best practices had been followed and the auditing information had been put into use.\n\nFurther, when the forge build is actioned, it doesn‚Äôt compile. This draws our attention back to the different parameters of the `repay` function.\n\n> \"Stacking up both the interfaces side by side, in the `ThunderLoan` contract, the `repay` function is clutching an `IERC20` token and a `uint256`, whereas its counterpart ‚Äì `IThunderLoan` is nesting an address token and an amount.\"\n\nThis makes it clear that these two are not singing in harmony, creating the need for amendments where necessary.\n\nABOUT THE AUTHOR: This auditing journey showcases the significance of in-depth code investigation in contracts and interfaces. It provides insights into the potential complexities that might arise in coding and software development. It‚Äôs a concrete reminder of how seemingly insignificant details can crop up to create considerable confusion in function implementation and can carry far-reaching consequences if overlooked ‚Äì prominently, in smart contracts and blockchain protocols.\n\n### Unraveling Code Rubrics, One Function at a Time\n\nIt's time to retract the changes made and run some `command z's` to restore the code. Here lies an opportunity to leave a note to remind that the referenced interface should be implemented. This attention to detail can be tagged as either low or informational. These tags would depend on the possible future risks; it would probably be informational if the address token doesn't pose much of an issue. But it‚Äôs definitely something that demands further investigation.\n\nIn essence, it‚Äôs crucial that accurate information is included in the report. So what at first glance looked like an odd piece of code, presented us with a whole other issue to dive into, and that's another feather in our problem-solving cap!\n\nThrough this auditing adventure, we were able to uncover multiple discrepancies and enhance uniformity in the interfacing processes.\n\nLet‚Äôs keep this journey of code analysis ongoing - one function, one issue at a time. We may find the codebase exhausting at times, but as we unravel the layers, it's definitely rewarding for the meticulous code investigator.\n",
          "updates": []
        },
        {
          "lessonId": "3f456769-0a89-4ae3-983f-f881a20e3d44",
          "number": 18,
          "title": "IFlashloanReceiver",
          "slug": "flashloan-receiver",
          "folderName": "18-flashloan-receiver",
          "description": "",
          "duration": 7,
          "videoUrl": "fWAf5IrOdbA",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/18-flashloan-receiver/+page.md",
          "markdownContent": "---\ntitle: IFLashLoanReceiver.sol\n---\n\n\n\n---\n\n# Deep diving into Flash Loan Audits\n\nGoing through audits especially when it involves assert checking can be a bit of a challenge even for seasoned programmers. Today, we will be looking into **IFlash Loan Receiver** contracts, finding out potential loopholes and code clean ups that we can perform to ensure our contract is as secure and tight-knit as possible.\n\n![](https://cdn.videotap.com/nmh2iNPnadGsdWNfaTx7-13.81.png)## Understanding the Flash Loan receiver contracts\n\nA quick look at our code shows that we use a lot of import statements like `import IThunderLoan from ../IThunderLoan`. Now it might seem okay to import libraries and classes that we might not really use directly in our codebase, but there's reason to trim down on that. Let's delve in.\n\nWhile this line of code might seem harmless initially, closer inspection reveals that we don't really need to import this. Why is it there? One may think there could be an underpinning connection by another class or component. So let's try to find out where exactly this particular import is being utilized.\n\nUsing the handy keyboard shortcut **Command Shift F** (or Control Shift F for Windows) in Visual Studio, we can quickly locate where `IFlashLoanReceiver` file is and where `IThunderLoan` is being imported.\n\nTo our surprise, we found out that `IThunderLoan` isn't imported or used anywhere in the `IFlashLoanReceiver`. So it begs the question, why is it there?\n\n## Cleaning Up Unused Imports\n\nWhile it's tempting to leave unused imports like this in your code (who knows, you might need it later, right?), this could be seen as bad practice in general. This is largely because it makes the code harder to read and understand, especially for new people coming onto the project and also, it could introduce potential security risks.\n\nWe went ahead to comment out the `IThunderLoan` import to see if anything breaks. Running `forge build` in the terminal, we confirmed that, indeed, we didn't actually need this import.\n\n> **Note:** It's a fundamental principle of smart contract engineering to avoid altering live codes for test mocks. Hence we need to remove the import from `MockLoanReceiver.sol`.\n\nAfter removing the redundant import, our build is still in great shape, and we've made our project slightly cleaner and easier to understand.\n\n## Exploring Flash Loan mechanics with Aave\n\nWith the code cleaned up, we now shift focus to understanding some foundational concepts. Looking at the Flash Loan receiver contracts available on [Aave](https://github.com/aave), we realize that the implementation here is somewhat similar to what we have in our own codebase. The perfect opportunity to learn!\n\nHere's a snippet of the Aave code we were going through:\n\n```js\nfunction executeOperation(address _reserve,uint256 _amount,uint256 _fee,bytes memory _params)external returns (bool);\n```\n\nThis part of the code piqued our curiosity. We came up with some assumptions about what each parameter might be doing:\n\n- `_reserve` could be the token being borrowed.\n- `_amount` probably is the amount of tokens.\n- `_fee` seems like it could be the fee of the Flash loan protocol.\n- `_params` could likely be the callback function.\n\nAt this point, the code isn't elaborating on what these parameters are doing (a big shoutout to @audit for the Nat spec!), so we will need to do some more digging to find out.\n\n> **Quote:** \"A big part of becoming proficient in contract auditing involves making well-educated guesses and then verifying those guesses.\"\n\nAs we are going through the process, we find that the `executeOperation` is implemented in the `ThunderLoan.sol` which on running looks sufficiently secure.\n\n## Wrapping Up and Taking Breaks\n\nWith this deeper understanding, we actually managed to find some informationals that we can pass on to our client - which, at the end of the day is what it's all about: making the protocol safer, more successful, and better. And let's not forget, adhering to best practices in engineering.\n\nDuring this audit process, don't forget to take breaks! Applying the Pomodoro technique helps maintain focus, where one works for about 50 minutes and then takes a break for 5-10 minutes.\n\n**And there you have it, folks! Remember, keep your code clean, follow good engineering practices, and always, always remember to question everything. Happy auditing!**\n",
          "updates": []
        },
        {
          "lessonId": "40862597-8a81-4c01-b2a7-8a316236b940",
          "number": 19,
          "title": "OracleUpgradeable",
          "slug": "oracle-upgradeable",
          "folderName": "19-oracle-upgradeable",
          "description": "",
          "duration": 5,
          "videoUrl": "y1VG8lD75VY",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/19-oracle-upgradeable/+page.md",
          "markdownContent": "---\ntitle: OracleUpgradeable.sol\n---\n\n\n\n---\n\n# Understanding the Tincho Method: A Deep Dive into Solana Smart Contract\n\nIn our previous discussion, we were introduced to the Tincho method. Thanks to its creator, Tincho, it gave us more confidence in creating our first Solana smart contract. Now, let's dive deeper into this journey and breakdown the necessities of preparing a Solana smart contract with a hand on codebase.\n\n## A Look at the Codebase\n\nFirst, navigate to the Solana `.sol` file. It's our initial contract. It may seem small, but it's our first step into the universe of smart contracts. So let's explore what its components are. If you are not familiar with Solana or `.sol` files, you may find it easier to use 'Word Wrap' function to easily view the code.\n\nWith the 'Word Wrap' enabled, we can see some keywords like `pragma` and `solidity`. There are also several imports, such as `it swap pool`, `Ipool factory`, and `initializable` which are being used within the same contract.\n\n## The Role of Initializable\n\nNow, let's take a more in-depth look at the `initializable` package. It originates from OpenZeppelin, more specifically `OpenZeppelin contracts Upgradable`. As the name suggests, it aids in writing upgradable contracts and will be crucial to our understanding due to its role in proxy elements.\n\n> OpenZeppelin's `initializable` package plays a significant role in Solana smart contract creation. It makes it possible to construct complex contracts that are easily managed and upgradable. It is imperative to understand its functionality and how it interacts with other elements in the smart contract.\n\n## Understanding Proxy in Solidity\n\nNow, let's navigate our way to Thunderloan.sol contract. Here, we will come across `Oracle Upgradable`, which is inherited into the main Thunderloan contract.\n\nThe `Oracle Upgradable` contract is a part of the main `Thunderloan` contract. It's a base contract facilitating upgradable contracts or contracts deployed behind a proxy. To get more comfortable with this concept, it's important to understand proxies and their use in Solidity.\n\nIf you take a look at the Nat spec (Natural Specification), you'll learn that upgradable contracts can't have constructors. The reason is, in an upgradable contract the storage is delegated to the proxy, but the logic resides in the implementation.\n\nHere is an important takeaway:\n\n> A contract's storage variables live in the proxy contract, while the contract logic lives in the implementation contract. Therefore, making use of constructors to initialize storage variables isn't applicable.\n\nIn order to circumvent this issue, the `initializable` contract comes into play. Instead of constructors, you have initializer functions that help initialize proxies with storage. For instance, in OpenZeppelin contracts, you will find initializer functions signified as `__Init` and `__Initunchained`.\n\n## Decoding Oracle Init\n\nNext, we have `Oracle Init` which is our initializer. It calls `Oracle Init Unchained` that takes a `pool factory address`, a `TSWAP address`, and another `pool factory address`.\n\nOur initializer function, `Oracle Init`, calls another function, `Oracle Init Unchained`. This function has a parameter `only initializing` which restricts the function to be called only one time.\n\n(Here's a piece of convention information: I suggest changing the name `TSWAP address` to `pool factory address` for better consistency. Just something to note if you are auditing the contract.)\n\nIn simple terms, the entire setup here is to initialize the contract's state because we are using a proxy model where a constructor is not applicable. Now that we've successfully dived into the codebase and demystified key concepts, our Solana smart contract is ready for deployment!\n",
          "updates": []
        },
        {
          "lessonId": "4c23d2c2-a3c7-4303-b5a7-7e0736abb8df",
          "number": 20,
          "title": "Exploit: Failure To Initialize",
          "slug": "failure-to-initialize",
          "folderName": "20-failure-to-initialize",
          "description": "",
          "duration": 3,
          "videoUrl": "ud4dDYNGgVU",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/20-failure-to-initialize/+page.md",
          "markdownContent": "---\ntitle: Exploit - Failure to Initialize\n---\n\n\n\n---\n\n# Unmasking a Major Pitfall in Smart Contracts: Initialization Vulnerability\n\nHello code enthusiasts and blockchain fans! Today, I want to share with you my recent findings while perusing the Thunderloan smart contract. For the uninitiated, smart contracts are self-executing contracts that live on the blockchain. They are primarily used to enforce agreed-upon rules without requiring the presence of third parties.\n\n## The Constructor in Smart Contracts\n\nLet's delve into a peculiar problem I've observed multiple times - particularly concerning initializers. As someone who has been doing this for quite a while, I've developed an instinct for catching certain risks. While examining Thunderloan's `initialize()` function, I knew I had stumbled upon an interesting issue.\n\n![](https://cdn.videotap.com/OpjaMfHKQ2Zje0pNKhzI-13.95.png)\n\nLet's break down what an `initializer` is. This method is essentially replacing the traditional contract `constructor` as a setup function in contracts. It serves to initialize contract parameters when the contract is deployed.\n\n## The Vulnerability: Front-running Initializers\n\nWhat could possibly go wrong with this, you may wonder? I'd like to pose a question: What if we deploy a contract and someone else gets to initialize it before we do? In other words, what if another person jumps the queue and sets the essential contract parameters prior to our initialization?\n\nThis is akin to someone else picking up your rental car and setting the GPS addresses before you even get the keys!\n\nTaking this potential scenario into consideration, it becomes clear why 'initializers being front-run' have often been flagged in audits as low-risk vulnerabilities.\n\n```\naudit('low', 'initializers can be front run');\n```\n\nImagine you have deployed a contract and forgotten to call the `initialize()` function. The scammer in our scenario notices this, exploits the vulnerability, and changes the `TSWAP` (Token Swap) address before you. The entire contract ends up being skewed towards this malicious user's benefit.\n\n## The Result of the Attack\n\nSo, what happens to the contract we just deployed? If the contract hasn't been initialized, it will likely malfunction or fail to work as smoothly as intended.\n\nFor instance, within the Thunderloan contract, if the `SPoolFactory` (smart pool factory) is not initialized, the `getPrice()`, and `WETH()` function calls may instead invoke the Ethereum null address, leading to unexpected behavior.\n\n```\nif (!initialized) {getPrice() --> address(0)WETH() --> address(0)}\n```\n\nThis scenario emphasizes the critical importance of ensuring initialization. Without it, the protocol ends up under-performing or in worse scenarios, completely breaks.\n\n## Mitigation: Keeping it Tight and Right\n\nIdentifying the problem is half the task. Knowing how to prevent it, however, is the real deal. How do we solve this initialization front-running problem in our contracts? It can be slightly tricky, and the best practice to ensure your contract's safety is actually quite simple - automate the initialization during deployment.\n\nBy automatically calling the initialize function during deployment, developers can reduce the risk of forgetting to manually trigger it post-deployment. This tactic not only ensures that all contract parameters are set as soon as the contract is deployed, but it also provides a consistent testing and deployment flow.\n\n## Conclusion\n\nDespite `initializers` being flagged as a low risk, they pose an architecture flaw that can easily be exploited if left unchecked. As blockchain developers, we need to not only write rock-solid smart contracts but ensure they're thoroughly tested and deployed without leaving potential loopholes for others to exploit.\n\nAnd to the auditors out there, next time you come across an `initializer`, remember:\n\n> \"An initializer, though small, can cause great wreckage.\"\n",
          "updates": []
        },
        {
          "lessonId": "875535af-67e2-4d0f-9a4b-2a043ad2b20e",
          "number": 21,
          "title": "Failure To Initialize: Remix",
          "slug": "failure-to-initialize-remix",
          "folderName": "21-failure-to-initialize-remix",
          "description": "",
          "duration": 2,
          "videoUrl": "BoMi3lArXiQ",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/21-failure-to-initialize-remix/+page.md",
          "markdownContent": "---\ntitle: Exploit - Failure to Initialize - Remix Example\n---\n\n## Let's Play: Exploring the Issue in Remix\n\n[Remix](https://remix.ethereum.org/) et's compile and deploy a sample SC simulating the 'failure to initialize' flaw.\n\n![](https://cdn.videotap.com/HhYH7vlvKZcgQ2YeBn5v-29.77.png)\n\nFollowing successful deployment, you will find several functions. Initiating the `initialize` function will initially return `false` since, with nothing preset, the value is logically zero.\n\nHowever, if we forget to officially initialize our variable and start incrementing the not-yet-existent element (say 4-5 times), it would start registering those values. We can then observe that my value has progressively increased with each increment, despite having no explicit initial value.\n\nHere's the kicker - if you now stumble upon the error and initialize the element (say, with 123), an anomaly occurs. Instead of adding to the increments, the value is completely overwritten with the initialized value. In our case, my value resets to 123, disregarding all prior increments.\n\n> **Note**: Remember that a correctly built `initialize` function should have protection against subsequent initializations, to prevent overwriting of any pre-existing data.\n\n## Proactive Measures and Further Exploration\n\nThe aforementioned problem can be prevented by ensuring initialization prior to interaction with a contract. This might seem insignificant, but in the world of coding, minor details can influence the major outcomes.\n\nLet's conclude with a suggestion - why not challenge yourself with the capture-the-flags exercise available on the repository? It might provide an interactive environment for understanding the problem better.\n\nTo explore further on this issue, head back to the associated Github repository.\n\nAnd that's it folks, the overlooked yet crucial issue of 'Failure to Initialize' in the realm of SC exploits. I hope this post offers you meaningful insights and may your journey in the world of programming be devoid of such pitfalls!\n\nHappy Coding!\n",
          "updates": []
        },
        {
          "lessonId": "198f16fc-ba92-4b30-aa7d-74d507193315",
          "number": 22,
          "title": "Case Study: Failure To Initialize",
          "slug": "failure-to-initialize-case-study",
          "folderName": "22-failure-to-initialize-case-study",
          "description": "",
          "duration": 3,
          "videoUrl": "wD1_fRYQuSo",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/22-failure-to-initialize-case-study/+page.md",
          "markdownContent": "---\ntitle: Exploit - Failure to Initialize - Case Study\n---\n\n# Failure to Initialize: A Lesson from Smart Contract Exploits\n\nIf you've ever dabbled in the realm of smart contracts, you may be familiar with an infamous exploit called \"Failure to Initialize.\" This notorious event unfolded in the Web Three Ethereum Ecosystem, involving a GitHub issue that potentially devastated the contract behind the Parity Wallet. It serves as a harsh reminder to all smart contract developers to initialize their contracts properly, or risk catastrophic failure.\n\nIn this blog post, we'll dissect the event and analyze the lessons learned. This way, we aim to prevent a similar misstep from reoccurring in our own projects or those of others.\n\n## The Initial Issue\n\n![](https://cdn.videotap.com/OY6Xn3YTnnAcgF4AnFtX-17.09.png)The tale starts with an innocent-looking [Git issue](https://github.com/paritytech/parity-ethereum/issues/6995) submitted to the Parity Wallet. Someone had unintentionally \"killed\" the contract - a possibility they were unaware of until it happened. This shocking event triggered a cascade of errors that brought to light a serious vulnerability in the smart contract.\n\nThe Etherscan transaction associated with it confirms the event. When we navigate down to the transaction details, click \"Show more,\" and decode the input data, we can see the parameters they entered when they accidentally invoked the contract's kill function.\n\nThe user was merely experimenting with the contract ‚Äî not anticipating that their \"play\" would cause such devastation. They had overlooked a significant precaution in the preparation: initializing their initializer function.\n\nTragically, the initializer, which was initially neglected, was later invoked. This act inadvertently caused the breakdown of a contract hosting a considerable sum. It's a tale that triggers despair among developers and serves as a potent reminder: **Never forget to initialize your contracts**.\n\n> \"Initialize your initializers. This might seem like a simple step, but one oversight can cause catastrophic consequences for your contracts.\"\n\n## Lessons You Should Carry\n\nWhat enlightenment can we glean from this unfortunate event? Well, it screams out the need for initialization. It also raises questions about potential methods to ensure initialization is never omitted, like incorporating it into a deployment script or implementing a parameter that blocks the rest of the system from interacting until initialization has occurred.\n\nWhile we are discussing potential solutions, it is crucial to note that merely attaching a ‚ÄúonlyInitialized‚Äù modifier to functions won‚Äôt cut it. This strategy is often ignored by developers who are looking to save on gas fees. However, the primary concern here is to guarantee initialization, irrespective of how it is achieved.\n\nIn the dissected smart contract, there were no blockers placed to prevent interaction with the contract until initialization was complete. This absence is a glaring shortfall needing rectification.\n\nRemember, **initialization can be front-run**. It's vital you put mechanisms in place to prevent such actions from happening, which might wreak havoc akin to the Parity Wallet incident.\n\n## Remember This Tale\n\nThis event, classified under the infamous hack, is widely known as \"Failure to Initialize\". To avoid facing this unfortunate situation, get familiar with the case study, and make sure to initialize your initializers appropriately.\n\nWith the constant evolution of the Ethereum ecosystem, it's crucial to learn from our predecessors' missteps. Let this serve as a lesson to you: Pay attention to initializations, or you might accidentally \"kill\" something you didn't intend to.\n\nThe dark tale of this smart contract mishap should remain a beacon guiding you away from similar pitfalls. It's a call to ensure attentive and thorough development processes, bearing in mind that one small oversight can lead to the interruption of an entire system.\n\n> \"Even the smallest oversight in a contract can lead to the destruction of the entire protocol. Understanding the importance of the initialization steps is critical. Remember, don't let a similar fate befall your contracts.\"\n\nAnd lastly, let the grim tale of \"Failure to Initialize\" remind you: it's wiser to prevent than lament.\n",
          "updates": []
        },
        {
          "lessonId": "0436b816-136a-46c2-9614-c8ce9483128b",
          "number": 23,
          "title": "OracleUpgradeable Continued",
          "slug": "oracleupgradeable-continued",
          "folderName": "23-oracleupgradeable-continued",
          "description": "",
          "duration": 4,
          "videoUrl": "CLMi8WW6SDg",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/23-oracleupgradeable-continued/+page.md",
          "markdownContent": "---\ntitle: OracleUpgradeable.sol (Continued)\n---\n\n# Oracle Upgradable: A Thorough Review\n\nWelcome back, Code Critiques! We‚Äôre continuing our journey through the world of blockchain programming and today, we're examining the Oracle Upgradable back-end.\n\n## When It Gets Interesting - getPrice in WETH\n\nOne striking feature that piqued our interest is the `getPrice in WETH`. It is an external public view. Here‚Äôs how it works:\n\n- An address swap of pool tokens is initiated.\n- A specific token is passed through, utilizing the command `Ipool_factory_s_pool_token`.\n- To round this up, `Getpool pool` is then invoked, which is where `get pool tokens` comes in.\n\n![](https://cdn.videotap.com/wbYYfuMAg04eG7LYpZp8-48.15.png)\n\nTo be put simply, we capture the pool swap token, call on `getPrice of one pool token in WETH`, and voila!\n\nInterestingly, this entire process could be completed sans any knowledge of TSWAP. We could still continue with our security review and audit, completely ignoring TSWAP. That being said, it invariably adds value to understand the inner workings of TSWAP.\n\n> If we can identify a loophole or break in this function on TSWAP, it could potentially lead us to finding cracks in Oracle Upgradable as well.\n\nIn essence, whenever we invoke an external contract, one should instantly scan for attack vectors. Questions to ask include: could the price be manipulated? Is there potential for reentrancy attacks?\n\n## The Mystery of TSWAP\n\nHaving explored the intriguing aspects of getPrice in WETH, let's unravel TSWAP. Within TSWAP, the main operational functions appear to be `getPrice of pool token in WETH` and `getPool`.\n\n![](https://cdn.videotap.com/5cZTXH0KnXV4ii8uCDjE-96.3.png)\n\nTo an unskilled eye, it might seem as though the getPrice command redundantly repeats itself. That might be true. Nevertheless, it is doing two distinctly separate tasks ‚Äî it computes the output amount based on an input utilising reserves to ascertain the asset price and pulls out the pool.\n\n## Tests Evaluation\n\nNow let's move to testing, using `units thunderloane test sol` or `Oracleupgradable sol`. If we individualise each point, we can see they are using a mock pool factory for interaction.\n\nUpon closer examination, we can ascertain they are using constraints, which might be a potential issue. An audit informational note would be to recommend them to use forked tests for live protocols.\n\nWhy you may ask? Forked tests simply offer higher guarantees of successful operation.\n\n![](https://cdn.videotap.com/fEeOEcrvj5RmWqYZn9Sd-128.4.png)\n\n## Attack Vector Investigation\n\nLet's take potential attack vectors as an example.\n\nThe `getPrice in WETH` function poses few directly observable issues. However, as we dig deeper, doubts start to emerge. What if someone could break this function? Could the priveleges be misused?\n\nA seemingly harmless function like `getPool, factory address` also needs to be observed closely. On the surface, it looks quite uncomplicated, with a private variable being used to extract the address ‚Äî all good so far.\n\n## Initializer Front Run ‚Äì A Possibility?\n\nNevertheless, while reviewing the `getPrice in WETH` function, we stumble upon an issue - the possibility of initializer front runs. Although in competitive audits such threats are usually overlooked, protocols still need to be warned of this possibility.\n\nRemembering the infamous attack: What delicate maneuvers are being employed to ensure there's no front run?\n\n## Wrapping it Up\n\n![](https://cdn.videotap.com/4CT0yiquS1CTN2jjVFe4-176.55.png)\n\nOur intense review journey culminates here, having done a fairly comprehensive review, exploring the Oracle Upgradable in its entirety, bringing potential lows to light, such as the chance of initializer front-runs.\n\nBut nonetheless, completing yet another successful review delivers a sense of accomplishment. And so, Oracle Upgradable ‚Äì ticked off and aced!\n\nOur checklist continues to shorten. Stay tuned for the next fascinating code critique in our series. Happy coding!\n\n> \"Security is a process, not a product. Let's continue this journey together!\"\n",
          "updates": []
        },
        {
          "lessonId": "e5fa2499-e153-4854-8391-1dd83033c999",
          "number": 24,
          "title": "AssetToken",
          "slug": "assettoken",
          "folderName": "24-assettoken",
          "description": "",
          "duration": 10,
          "videoUrl": "EjQKnB0i8QM",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/24-assettoken/+page.md",
          "markdownContent": "---\ntitle: AssetToken.sol\n---\n\nIn today's lesson, we will dissect and understand the process and chronology of AssetToken.sol while simultaneously attempting to reduce the complexity of this unwieldy 129-line monster code. We will be following the analysis methods of one of the smart contract industry's finest - Tincho.\n\n![](https://cdn.videotap.com/ymeUVPEJfTmzpyvsbUJU-38.26.png)\n\nAlthough the enormity of the code may make the checklist seem redundant, it is essential to understand that this seemingly lightweight tool can provide both structure and context, serving as a roadmap when trudging through unknown territories of the code.\n\n## Tackling AssetToken.sol Line-by-Line\n\nEagle-eyeing the checklist we realize that we have revealed another checkmark, indicating we are ready to plow into AssetToken.sol. As we delve deeper, the checklist will begin to take a back seat, but remember, it remains an invaluable tool to grasp the overall context and provide a starting point for understanding the essence of these components.\n\n### Thunderloan Digitization\n\nThunderloan serves as an apt milestone in our journey. We will first scour Thunderloan, before advancing to its upgraded version. The sequence may seem counterintuitive due to the contracted length of its upgraded edition. However, a profound understanding of the current protocol is instrumental in discerning the necessities for upgrades. The supposed 327-line-dependent code may differ drastically, but only time will tell!\n\nNow, let's proceed to dissect AssetToken.sol. It exemplifies the receipt role in our smart contract. It enables liquidity providers to deposit assets into Thunderloan, in return for asset tokens. The accumulation of interest over time is influenced by the number of people who borrow flash loans.\n\nBorrowing our previous Flash loans example, consider a whale who deposits money into a Flash loan contract. In return, they receive shares or a token representative of the money they've placed in the contract. This share-token accrues interest based on the flash loan borrowers' fees.\n\nThe role of Open Zeppelin's ERC20 here needs special mention. It provides an interface and a wrapper around ERC20 operations that would typically fail if the token contract returned false. The wrapper, aptly named Safe ERC20, serves as a fail-safe for erratic ERC20s, throwing on failure to prevent compromising the entire operation.\n\n## Unveiling Asset Token and Shares\n\nAs we dig deeper, mining further insights from the wall of text, a pattern begins to emerge. The term \"underlying\" in the code seems to refer to USDC, whereas the \"asset token\" is linked to the pool's shares. Depositing USDC gives you pool shares proportionate to the exchange rate defined within the contract.\n\n> \"For instance, if we have two shares and the exchange rate is two to one, we can exchange our two shares for four tokens.\"\n\nHow they calculate the exchange rate mirrors the workings of Compound Finance, underlining the deliberateness in the design. If we can master understanding the contract's innards, unraveling the rest of the mysteries becomes a breeze.\n\n### Side Quest into Compound's Territories\n\nAt this juncture, it might be advantageous to wander into the realm of Compound, discern how it functions and sift out any potential issues. Familiarity with similar protocols can empower us in our mission to secure this contract.\n\nHowever, we won't be trailing down this path today. It is, nonetheless, a recommended sidequest to undertake at some stage. Try writing a concise, understandable article explaining the working protocol of Compound, or even the comparable Aave.\n\n## Tracing the Exchange Rate Pattern\n\nReturning to our original predicament, we bump into our exchange rate again, causing us to raise an eyebrow. This instance hints at a potential bug spot in our code.\n\nThe next issue arises during the creation of new asset tokens or shares. Minting new asset tokens conducts an access control check to confirm the caller is the Thunderloan contract.\n\n> \"This begs the question, could an attack vector appear that allows an attacker to call mint from the Thunderloan contract when they shouldn't?\"\n\nIn the same vein, burning existing asset tokens or shares runs a similar check. Our questioning spirits seek an answer from the code. Could non-standard, \"weird\" ERC20s wreck havoc in our methods - Safetransfer? And more specifically, what if USDC decided to blacklist contracts (like thunder loan or the asset token contract)? A medium to low priority question but worth a nod.\n\n### Minting New Conclusions\n\nWrapping up our intricate dissection of the code, we are left with relevant questions that will guide us down the path of systematizing a secure, functional protocol. As we remain vigilant, aiming to decipher the mysteries of our smart contract, let us head over to the next complex labyrinth- Thunderloan.\n\nIn the coming blog posts, we'll continue to explore potential security vulnerabilities, unravel other intriguing aspects of this code, and hopefully unlock more mysteries of smart contract security reviews. So, stay tuned and keep reading.\n",
          "updates": []
        },
        {
          "lessonId": "a0f06f3b-c211-4369-9667-636f39d1cb0a",
          "number": 25,
          "title": "AssetToken: Update Exchange Rate",
          "slug": "asset-token-update-exchange-rate",
          "folderName": "25-asset-token-update-exchange-rate",
          "description": "",
          "duration": 6,
          "videoUrl": "h9NHFMriJ_Y",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/25-asset-token-update-exchange-rate/+page.md",
          "markdownContent": "---\ntitle: AssetToken.sol - updateExchangeRate\n---\n\n## The Function: Update Exchange Rate\n\nLet's dive into a seemingly vital function called `updateExchangeRate()`. The comments clarify that it obtains the current exchange rate (#1) and computes it by dividing the fee size by the total supply. An intriguing remark states that the exchange rate should consistently increase‚Äînever decrease‚Äîan invariant principle at work. **But why should this exchange rate always escalate and never decline?**\n\n**CODE BLOCK HERE**\n\nAs we delve deeper, we set:`newExchangeRate = oldExchangeRate * (totalSupply + fee) / totalSupply`.\n\n![](https://cdn.videotap.com/gi422wVmQ3SFrgJrvlSw-84.97.png)\n\nAs we break down how this formula functions:\n\n- If the old exchange rate is 1,\n- The total supply of asset tokens is 4,\n- Fee is 0.5,\n\nComputing ((4 + 0.5)/ 4), we result with a new exchange rate of 1.125. From this, it seems that `updateExchangeRate()` is likely responsible for updating the asset tokens' exchange rate to their underlying assets.\n\nTo illustrate, imagine this hypothetical scenario where a whale deposits or withdraws shares. The amount that gets deposited or withdrawn hinges upon the exchange rate, which can change, presumably having something to do with the fee. In a scenario where the exchange rate is two to one, if a user were to deposit $1,000, they would receive 2000 asset tokens in return.\n\n**But why are we updating the exchange rate?**\n\nLet's revisit the above formula: What happens if the total supply is zero?As per the formula, `S exchange rate starts at 1 * 0 + let's say the fee is zero divided by zero`, the computation breaks. Would this pose an issue? Could there be a way that this could break and make the total supply zero? Questions to consider.\n\n![](https://cdn.videotap.com/SLGckrl4g0AjIi7bUdwS-230.62.png)\n\nWe check for a condition `if newExchangeRate <= oldExchangeRate`, then instruct it to revert, with a message saying, \"Exchange rate can only increase.\" The condition itself is a clear implementation of the invariant principle stated earlier. On the other hand, if the new exchange rate is higher, it sets `sExchangeRate = newExchangeRate` before emitting an event.\n\nAt a first glance, this function seems correct and ready to run. It updates the exchange rate, a crucial variable in the relationship between the shares and the underlying assets. The rate update mainly seems to be triggered by fees.\n\n## Some Possible Improvements\n\nAn important aspect that one could focus on is the multiple storage reads in the `updateExchangeRate( )` function‚Äî `s_ exchangeRate`, `s_totalSupply`, and `s_fee`. Given that storage reads are gas expensive, you could possibly optimize this by storing them as a memory variable‚Äîan aspect to consider during an audit for gas usage.\n\nNote: Sometimes, it is the experience that helps spot these potential storage issues. For instance, if you see multiple s\\_ syntax terms, that might be a hint about multiple storage operations.\n\n![](https://cdn.videotap.com/tGc23bAltPLCCdT51Y39-303.45.png)\n\nDespite not discovering any immediate problem with the contract, analyzing this function helped us understand the contract better. We now know how the exchange rate behaves, and it's clear that the fee plays a significant role in its computation.\n\nIn the next phase, we plan on investigating two more functions‚ÄîThunderLoan and ThunderLoanUpgraded. We'll tackle ThunderLoan first, understand its functionalities thoroughly, then move onto ThunderLoanUpgraded to identify the upgrades.\n\nStay tuned in for our exciting journey as we delve deeper to explore these functions. Keep coding!\n",
          "updates": []
        },
        {
          "lessonId": "3f374647-b6b6-4687-bda5-c4262ae1a79a",
          "number": 26,
          "title": "Thunderloan: Starting At The Top",
          "slug": "thunderloan-starting-at-the-top",
          "folderName": "26-thunderloan-starting-at-the-top",
          "description": "",
          "duration": 9,
          "videoUrl": "Cle0xTszptY",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/26-thunderloan-starting-at-the-top/+page.md",
          "markdownContent": "---\ntitle: Thunderloan.sol - Starting At The Top\n---\n\n## Initial Exploration: Imports\n\nBefore we get our hands dirty with the functions, we start our journey with imports. There's plethora of imports in there, some of which include `Safe ERC 20`, `Asset token`, `IERC 20`, `Metadata`, `Ownable upgradable`, `Initializable`, `UUPs upgradable`, `Oracle Upgradable`, just to name a few.\n\nIn order to facilitate the learning process, I will provide a preamble of our focus in each section, \"priming your brain\" to absorb the upcoming content. Educational studies support this method, indicating that offering a high-level overview before delving into deeper detailing enhances the learning experience.\n\n**Quick tip:** In order to better understand protocols, remember to go through their read-me's for a bird's eye view before examining the individual codes.\n\nFollowing this advice, let's start piecing together the puzzle. `Ownable upgradable` might be a newer import to some, so it might be beneficial to quickly explore it in Open Zeppelin. This is the only-owner contract but with an upgradable version. Taking a close look, we see that it uses `ownable init` and needs to set an initial owner and transfer ownership.\n\n![](https://cdn.videotap.com/kyjLSLgBPsyDSSFpZ9P1-124.85.png)\n\nWe also find a reference to `UUPs upgradable`, which implements the UUPs proxy pattern, a common pattern for smart contracts. If you‚Äôre unfamiliar with the UUPs proxy, I strongly recommend that you brush up on it or you could revisit the Foundry course and specifically look at the `Foundry upgrades F 23` for a better understanding.\n\nFinally, in the list of our imports, we come across `iFLASH loan receiver`, which is a library offering easier to use functions like `send value`.\n\n## Diving Deep into the Smart Contract\n\nNext up, we ask, \"While going top to bottom, have we asked enough questions?\" Since there aren‚Äôt major issues with the imports, we move on.\n\nLooking at the contract `Thunderloan`, it is clearly recognizable that it extends `Initializable`, `Ownable upgradable`, `UUPs upgradable`, and `Oracle Upgradable`. Checking whether it should extend anything else, we find no, it's all good here.\n\n![](https://cdn.videotap.com/8ErUx4D6tAmn03SvJNAC-218.48.png)\n\nIn the next section, we encounter a bunch of constants and state variables, first of which is `token to asset token`. To gain a better understanding of its role, we do a quick search and find that it‚Äôs used in various operations like deposit, redeem, Flash loan, etc.\n\n```code\n// State variableS token to asset token\n```\n\nAfter some explanation and assumptions, we infer that this maps the underlying token to its asset token. For example, if a liquidity provider deposits USDC, it will generate a USDC asset token, representing the amount of USDC you've deposited.\n\nFollowing this, we stumble upon `fee in way`, which we verify by checking its initialization in the initializer function.\n\nAlso, we encounter an auditing issue that `fee precision` should be either constant or immutable.\n\nNext is `token to currently flash loan`, so this is assumedly a mapping that notifies us if a token is mid flash loan.\n\n## Delving into the Modifiers of our Smart Contract\n\nWell, we‚Äôve had our fair share of state variables. Now, it's time to unravel the modifiers.\n\n```code\nrevert if zero\n```\n\nThis modifier reverts operation if amount equals zero. The other modifier `revert if not allowed token`, ensures operation would only proceed with allowed token only.\n\nTurns out, there's a precheck for tokens, which as a result reduces the risk of passing bad tokens to the contract.\n\n```code\nmodifier not allowed token\n```\n\nWe find a function named `is allowed token`, and upon exploration, it returns `s token to asset token of the token does not equal zero`. Therefore, it seems it's only allowing a token if it has been set before.\n\nLastly, we observe that most of this looks benign so far, but remember we're just getting started. In this initial inspection, we haven't really delved into the functions yet. But rest assured, there's more to find in this intriguing world of the Thunderloan Sol smart contract!\n",
          "updates": []
        },
        {
          "lessonId": "43164196-4157-43e1-a634-c202d8fd2b9e",
          "number": 27,
          "title": "ThunderLoan Functions",
          "slug": "thunderloan-functions",
          "folderName": "27-thunderloan-functions",
          "description": "",
          "duration": 8,
          "videoUrl": "2awqGN_TDeQ",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/27-thunderloan-functions/+page.md",
          "markdownContent": "---\ntitle: Thunderloan.sol - Functions\n---\n\n# Demystifying Smart Contracts: A Deep Dive into Functions, Constructors and Operators\n\nLearning how to build smart contracts is challenging, but the rewards are immense. To help you on this journey, in this blog post, we will scrutinize the intricate workings of smart contract functions, constructors, and more.\n\n## Beginning with the Constructor\n\nFirst things first, we start by defining a constructor with a custom Oz (OpenZeppelin) upgrade ‚Äî `Unsafe Allow Constructor`. This construct serves to pacify static analysis tools that generally get riled up with all the initializer tricks we use.\n\nA vital keyword we use is `DisableInitializers` that originates directly from the Initializable package. It's a safeguard to prevent the inadvertent calling of any initializers in the constructor, an act we want to avoid at all costs because our smart contract is upgradable, and it exists behind a proxy.\n\n### Understanding OwnableInit\n\nWe already mentioned the effects of `initializer` modifier, particularly how it could get front run. Now, let's talk about `OwnableInit`. This function merely facilitates the transfer to the preliminary owner.\n\n### Diving into UpgradableInit\n\nThis function has the same modus operandi as `UUPsUpgradableInit`, setting up storage for UUPs. However, considering UUPs is a comprehensive subject, we will not go into its details for now.\n\n### Getting Familiar with OracleInit\n\nTo further understand `OracleInit`, imagine using T-Swap (an address) as a kind of oracle. There's also the initial fee precision and initial fee for flash loans.\n\n## The Deposit Function\n\nThis is a very crucial function and, yes, it's missing Natspec! It's essential to call this out and highlight the necessity of the Natspec. This function is responsible for allowing users to deposit their tokens into the contract, thus facilitating flash loans for other users.\n\nA few key takeaways from the deposit function:\n\n- If the deposited `amount` is zero, revert\n- If the token is not an allowed token, revert\n- The function also employs the mapping `sTokenToAssetToken` to evaluate which sToken corresponds to which AssetToken\n\n## Setting Allowed Tokens\n\nA healthy exercise in understanding how these tokens are determined, let's look at the `setAllowedToken` function. In effect, it facilitates the setting or removal of tokens.\n\nThis critical function is permissioned and can only be executed by the owner of the protocol. Here's how it works:\n\n- If the token is allowed, it is added to the `sTokenList`\n- If the token is to be disallowed, the function will proceed accordingly\n- The function reverts with the status of the token, i.e., whether it is `already allowed` or not\n\n## Conclusion\n\nIn conclusion, the journey into the realm of smart contracts can be a bit tricky and complex. Still, by analyzing the various functions and their specific roles, one can gain a solid understanding of their dynamics and workflow. Persistent learning, constant practice, and a practical mindset are all that's required to master smart contract development. And remember: always make use of Natspec for the sake of readability and developer friendliness. Happy Coding!\n",
          "updates": []
        },
        {
          "lessonId": "5a4c33fb-b6dc-4a5d-99fd-d123dbfddc28",
          "number": 28,
          "title": "Testing Deleting Mappings",
          "slug": "testing-deleting-mappings",
          "folderName": "28-testing-deleting-mappings",
          "description": "",
          "duration": 3,
          "videoUrl": "nKgcMlL_Tbo",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/28-testing-deleting-mappings/+page.md",
          "markdownContent": "---\ntitle: Testing Deleting Mappings and Fixing Our Tools\n---\n\n# Smart Contracts and Data Management: A Deep Dive into Token Mapping and Deletion\n\nWelcome to our deep dive discussion on asset tokens, deleting mappings, and the peculiarities of Solidity smart contracts. Today, we'll unravel how smart contracts interact with asset tokens and the possible pitfalls and bugs that can arise as we develop our applications.\n\n## Deletion and Checks in Asset Token Mappings\n\nIn a smart contract, we typically assign values and map `address` to `assetToken`.\n\nThis line means, simply, we're assigning the token located at `assetToken` to a variable also named `assetToken`.\n\nNow, this can lead to a critical question:\n\n> Does deleting a mapping work?\n\n![](https://cdn.videotap.com/EFG0Cihz1p7oQkV1y9Hx-36.9.png)\n\nIt's a valid question because let's say we have several checks on `assetToken == 0`. If the deletion process doesn't work as expected, our asset won't return to 0. So, how do we test this?\n\n## Testing Deletion with Chisel\n\nTo explore this, I decided to pull up Chisel, a Solidity language extension for Visual Studio, and create a mapping with the structure `address` to `address`.\n\nIn theory, when I look up `tokenToToken[address1]`, I'll get `address2`. Now, let's go ahead and attempt deletion:\n\nConsequently, when I look up `tokenToToken[address1]` after the deletion, I'm still getting `address2`. Clearly, something is off here.\n\n![](https://cdn.videotap.com/nqmehgM9xG2CGsHOR1yI-80.5.png)\n\n## Digging Deeper with Remix\n\nTo further understand the issue, let's pull up Remix, a powerful, open-source tool used for writing Solidity smart contracts. We'll create a simple contract, aimed at mapping `address` to `address`.\n\nFollowing similar steps as before, we'll set the mapping between an account address and the contract address, then delete the mapping, and finally, check the mapping again.\n\nThis time we get zero, contrary to what Chisel showed.\n\n## A Bug in Foundry\n\nThe probable conclusion? There's likely a bug with Foundry.\n\nYour logical next step should be heading to Foundry's GitHub page and opening an issue. Check out the existing issues first, of course. Search for \"Chisel mappings\" and see if there's a relevant issue already there. If nothing matches, make a new issue indicating the problem with Chisel mappings deletion.\n\nHere we've encountered a real-life bug, and we have done our part to inform the community about it. So, until next time, keep exploring, keep debugging, and keep developing.\n",
          "updates": []
        },
        {
          "lessonId": "380a7e19-c5ed-471c-a3d6-dbe8ad472e6e",
          "number": 29,
          "title": "Note On Linear Progress",
          "slug": "note-on-linear-progress",
          "folderName": "29-note-on-linear-progress",
          "description": "",
          "duration": 2,
          "videoUrl": "0STq_tuJKJI",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/29-note-on-linear-progress/+page.md",
          "markdownContent": "---\ntitle: A Note On The Linear Progress Of Security Reviews\n---\n\n# Evaluating Smart Contract Security: Journey Through \"Thunder Loan\"\n\nWelcome, tech lovers! Today, we're taking a deep-dive into the riveting world of smart contract audits. In this post, we'll be dissecting a Tech Talk where we audited a smart contract named \"Thunder Loan.\" Buckle up, it's going to be an exciting learning experience!\n\n## Remix vs Chisel: The Battle of Testing Tools\n\nIn the world of software development, it's not uncommon to use different tools for testing code. In this instance, we initially tested Thunder Loan using Remix and throughout our auditing process, we discovered a few things that are worth mentioning.\n\n_Fire up your terminal, it's time to discuss some code!_\n\n![](https://cdn.videotap.com/86697zC0OHfWSFQSGKUh-13.33.png)\n\nWhen we attempted to delete particular sets of code, it appeared to work in Remix quite fluidly.\n\n```javascript\ndelete this;\n```\n\nDespite the successful outcome in Remix, the same could not be said when we tried it in Chisel. As a coding auditor, I can safely say Remix was more accurate in this case. Chisel was, unfortunately, incorrect in its evaluation of the aforementioned code.\n\n## Emitting Tokens and Asset Returns\n\nNext, we looked into the `Emit allowed token set` function. After careful examination, we were pleased to see that the system accurately complied.\n\n```javascript\nemit allowedTokenSet;\n```\n\nFollowing this, we went on to return the asset tokens.\n\n```javascript\nreturn assetToken;\n```\n\nAgain, this process appeared to run smoothly. Keep in mind; one crucial aspect of an audit is multiple points of review. This helps maintain precision in an audit. I usually do an \"Okay\" check at the start and then perform another towards the end, as in \"Audit in Foe.\"\n\nAlso, another point to ponder; many tools such as Darren catch the \"needs Nat spec\" command pretty well. So while it may not seem necessary to include this, it could assist in accurate evaluations and maybe even in bug spotting!\n\n## Deep Dive into the Deposit Function\n\nNow we've arrived at another integral part of our audit ‚Äì the deposit function. Furthermore, we explored the selection process for tokens.\n\n```javascript\nadd Token;remove Token;\n```\n\nHere, things got a tad more interesting. The code seemed to be allowing the addition and removal of tokens at the will of the owner. While this is generally great, it might potential problems in the future. But, of course, only time will unveil that truth.\n\n## Understanding the Non-linear Nature of Audits\n\nSo far, we've gone through at least one function of Thunder Loan, and guess what - No bugs yet! But don't let that fool you. The absence of bugs at the initial stages does not necessarily illustrate a perfect system.\n\n> \"Security reviews are often not linear. It's not like, oh, found a bug here, found a bug here, here, and then three bugs here, and then done. No! They are often exponential.\"\n\nBy the time auditors gain a comprehensive understanding of the codebase, they are better equipped to identify bugs. If bugs are found along the way, that's a bonus!\n\n## A Final Word\n\nAt the end of the day, a thorough audit is more about understanding than it is about unearthing bugs. The more you understand the code, the more efficient you become in identifying any potential or existing bugs. As discouraging as it might seem when bugs fail to show up initially, remember, it's all part of the process! Happy coding, everyone!\n",
          "updates": []
        },
        {
          "lessonId": "b1f60e02-ebdf-4dc1-a994-d22df5ceefa5",
          "number": 30,
          "title": "ThunderLoan Continued",
          "slug": "thunderloan-continued",
          "folderName": "30-thunderloan-continued",
          "description": "",
          "duration": 5,
          "videoUrl": "yu24aR25npU",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/30-thunderloan-continued/+page.md",
          "markdownContent": "---\ntitle: Thunderloan.sol (Continued)\n---\n\n# Understanding Asset Tokens and Exchange Rates in Thunder Loan\n\nHello coders! In this blog post, we're delving into the world of contracts and tokens. If you're here, you know that asset tokens represent the shares of the pool. But honestly, how many times have we gone over that?\n\nStill, it's crucial to understand that the asset token represents just how much of the contract the whale or depositor actually owns.\n\n## Getting the Asset Token\n\n![](https://cdn.videotap.com/2I1K8YkcCB7hMk6vhMGv-37.2.png)\nTo get the asset token, you simply use `AssetToken get exchange rate`. Here we're getting the exchange rate between USDC (the USD Coin) and the flash loan tokens. The key question here is: what ratio exists between these flash loan tokens and the underlying tokens?\n\n## Minting the Amount\n\nYour mint amount is calculated from the amount deposited, maybe around 100 USDC, times the exchange rate precision times the asset rate. The exchange rate precision usually defaults to `1E 18`.\n\nFor all you math enthusiasts, here's the calculation flow:\n\n```bash\nExchange rate precision = 1E 18100 (deposit amount) x 1E 18 (exchange rate precision) / Exchange rate = Mint amount\n```\n\nIf the exchange rate is 2, then you would have half the flash loan tokens in exchange for the 100 USDC, which stands to reason logically.\n\n> An important point to note here is that we cannot divide by zero in this context. The exchange rate cannot be zero and should preferably always be increasing, never decreasing. If you start at one, it should never decrease to zero due to the way asset tokens are conditioned.\n\n## Emitting the Event\n\nThe role of the event emitter comes into play high up in this process when we call `AssetToken mint`. This is only callable by the Flash Loan investors and passes fine, giving the depositor the mint amount.\n\nInterestingly, when a liquidity provider deposits, the money sits in the asset token contract, not in Thunder Loan. Hence, the money goes directly to the asset token contract.\n\n## Calculating the Fee and Updating Exchange Rate\n\nIn our final stage of the process, the calculated fee is determined using `getCalculatedFee`; this updates the exchange rate and the asset token amount is transferred from message sender to the address of the asset token.\n\nHere's where it could get a little confusing. Why are we calculating the fee of the flash loans at the deposit? And why are we updating the exchange rate?\n\nLet's examine the first issue; our flash loan calculation process goes like this:\n\n```bash\nValue of borrowed token = Amount x getPrice / Fee precisionFee = Value of borrowed token x Flash loan fee / Fee precision\n```\n\nHowever, it's perplexing as to why the fee of the flash loans would be calculated at this juncture in the depositing process.\n\nSecondly, the matter of updating the exchange rate also raises questions. If tokens are deposited, the exchange rate varies. If more is deposited, then what would the exchange rate be? This part seems a little disorienting, definitely warrants a follow-up audit as there may be something off here.\n\nOnce these two issues are addressed, the process should work correctly. The user gets minted some asset tokens and the tokens are then transferred to the underlying.\n\nThere are a few perplexing areas as noted which we look forward to addressing in future posts. Happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "f2a37dbe-b59a-4741-b749-a9a1f05c5d59",
          "number": 31,
          "title": "Diagramming ThunderLoan",
          "slug": "diagramming-thunderloan",
          "folderName": "31-diagramming-thunderloan",
          "description": "",
          "duration": 1,
          "videoUrl": "fm1IcAZuVL8",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/31-diagramming-thunderloan/+page.md",
          "markdownContent": "---\ntitle: Diagramming Thunder Loan\n---\n\n# Understanding the Asset Token Lifecycle: A Deep Dive\n\nLooking at the origin of tokens can sometimes seem like staring into an abyss, especially when one is trying to break down complex DeFi protocols like how an Asset Token comes alive. However, it's not quite as convoluted as you might initially think. Grab a beverage of your choice, strap down and come with me on an exploration of the Asset Token Lifecycle.\n\nFirst, let's get started by laying the schematic foundation, the blueprint of our Asset Token universe. Transitioning thoughts into visuals and diagrams. You know, because a picture says a thousand words right?\n\n## The Basic Anatomy of the Asset Token\n\n![](https://cdn.videotap.com/2sWH0NEKSYYOOCz3JhNl-7.47.png)\n\nAn essential part of the Asset Token lifecycle begins with the liquidity provider (LP), who owns USDC. As a first step, the LP 'calls deposit' to kickstart this entire process. The underlying USDC is sent to the asset token (Say, Asset Token A or USDC) during this deposit process.\n\n> _The deposit kickstarts the process, triggering a transaction into the Asset Token._\n\nAt this stage, the contract governing the Asset Token is crucial. This contract plays the role of a storehouse, a vault that holds and secures the underlying USD.\n\n## Asset Token Orchestrating Transactions\n\nOur adventure into the Asset Token Lifecycle takes us deep into the heart of interactions and transactions between different entities. The USDC held by the liquidity provider is sent over to the Asset Token post the deposit call. But that's not where the transactions stop.\n\nFinally, the Asset Token mint machine kicks into gear. The asset token mints the LP an equivalent amount of the underlying USD, following the deposit and storage of USDC. Seem complex? Let's simplify with a diagram!\n\n![](https://cdn.videotap.com/2jNGLhZwIkTe4vPJr8UC-24.27.png)\n\nHere's how the transaction process goes:\n\n1. The LP owns USDC.\n2. The LP calls deposit, signaling intent to transition the USDC into an Asset Token.\n3. This deposit triggers a sequence where the USDC moves from the LP to the Asset Token.\n4. Once the USDC is in the Asset Token, the Asset Token mints an LP against the equivalent USDC.\n\nBy reaching this point, we've successfully navigated the murky waters of the Asset Token lifecycle, from deposit call to minting of the LP. This journey underscoring the power of decentralized finance offers valuable insight into the ecosystem. But there's so much more to explore - start digging deeper into contract calls, consensus algorithms and tokenomics right now!\n\nIn our opening diagram and explanation, the statements might seem broad or oversimplified ‚Äì that is far from the case! Each step occurs in a well-defined, precision-driven process. It's a well-oiled machine, offering insights into the unseen side of token generation and distribution. We shall continue to dissect further and reveal more layers to this 'simple' transaction as we move ahead.\n",
          "updates": []
        },
        {
          "lessonId": "8fd6d0f7-584f-4553-a0c0-13843171df18",
          "number": 32,
          "title": "ThunderLoan Redeem",
          "slug": "thunderloan-redeem",
          "folderName": "32-thunderloan-redeem",
          "description": "",
          "duration": 5,
          "videoUrl": "fDVny7SU1vw",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/32-thunderloan-redeem/+page.md",
          "markdownContent": "---\ntitle: Thunderloan.sol - Redeem\n---\n\n# How to Deposit and Redeem Asset Tokens: A Deep Dive into Blockchain Functions\n\nWelcome back to the world of token functions! Today, we're going to dive deep into deposit and redeem functions in a blockchain-based system. Strap in!\n\n## Diving into the 'Deposit' Function\n\nFirst, let's revisit the `deposit` function. This function allows a user to deposit an underlying token in exchange for an asset token. In essence, the user puts their underlying token into the pool and receives the equivalent amount of asset tokens in return. We may return to it later, but it's critical to understand this function before we dig deeper into the `redeem`.\n\n## Understanding the 'Redeem' Function\n\n![](https://cdn.videotap.com/PFna6Zl1YqUpuTWXUXwx-48.27.png)\n\nMoving on, the `redeem` function plays the opposite role. Where the `deposit` function pulls in an underlying token, the `redeem` function withdraws the underlying token from the asset token. When using this function, we must specify the token from which we want to withdraw, and how much therein we want to withdraw.\n\n#### The Token Ambiguity\n\nAt this point, you might be wondering - does \"token\" refer to the asset token or the underlying token? After a detailed scrutiny, we confirmed that it refers to the actual token to be withdrawn, not the asset token.\n\n![](https://cdn.videotap.com/ez1kq5fAGd1OgsIQfDqE-86.88.png)\n\nComing back to our code, we need to determine the exact asset token to withdraw (let's call it the 'actual asset token'). We have a revert of zero if the token is not allowed to be withdrawn, thus eliminating any unauthorized tokens.\n\n#### On User Experience and Exchange Rates\n\nThis code incorporates an eye for user experience. If the amount equals the maximum, the contract returns the balance of asset tokens for the address (or 'message sender'). This function essentially lets a user say, \"I have ten asset tokens for USDC, I want USDC equivalent to these ten tokens.\" And our function does exactly this.\n\n![](https://cdn.videotap.com/54JcHcJspGCdA0pezifC-125.5.png)\n\nThe maths underline the code logic:\n\n```javascript\namount_underlying =\n  (amount_of_asset_token * exchange_rate) / asset_token_exchange_rate_precision;\n```\n\nThis takes into account the precision of the exchange rate - if the user wants `1 E 18` and the exchange rate is `1 E 18`, dividing by `1 E 18` would yield a `1 E 18` back.\n\nThe function then emits a `redeemed` event and calls `assetsBurn` to burn the asset tokens from the user's holdings. This mirrors the process of deposit, but in reverse: where deposit multiplied the precision by the exchange rate, this instead multiplies the exchange rate by the precision.\n\n#### Handling Weird ERC 20 Tokens\n\nLooking at it from the outside, everything seems to be falling into place. But what if we're dealing with a non-standard ERC 20 token? Let's consider `USDT`, which has six decimals instead of eighteen (thus being referred to as a 'weirdo'). Would the equation still hold? After some calculations and investigations, we found that it does!\n\n![](https://cdn.videotap.com/jWxqkTW1E5Jz4AjmtCqu-202.73.png)\n\nThe redeem function came out looking pretty solid. There was no apparent issue with re-entry and it seemed to follow \"Checks-Effects-Interactions\" (CEI) principle, where it checks upfront, performs certain effects, and then carries out any required interactions. DEI is a widely-accepted guideline in Ethereum community to avoid common issues such as reentrancy attacks.\n\nWith `redeem` function now in tow, we have two important functions - `deposit` and `redeem` - both seemingly bug-free.\n\n![](https://cdn.videotap.com/nNvbG3E0OfsqbxJORxX2-231.69.png)\n\nIn conclusion, while blockchain functions like `deposit` and `redeem` can look complicated, breaking them down and understanding what each element does turns these seemingly convoluted calculations into understandable steps. As with anything in blockchain, the devil is in the detail - and it's safe to say we've captured all of them here. Stay tuned for more deep dives into the world of blockchain functions!\n",
          "updates": []
        },
        {
          "lessonId": "bca8e64a-09ac-40e0-a723-f0100b143e4d",
          "number": 33,
          "title": "ThunderLoan Flashloan",
          "slug": "thunderloan-flashloan",
          "folderName": "33-thunderloan-flashloan",
          "description": "",
          "duration": 14,
          "videoUrl": "6MjNs46JJzk",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/33-thunderloan-flashloan/+page.md",
          "markdownContent": "---\ntitle: Thunderloan.sol - Flashloan\n---\n\n# Understanding the Flash Loan Function\n\nIn reviewing, understanding, and working with the flash loan function in a smart contract, I encountered a few challenges due to the lack of a Nat Spec. But fear not, in this blog post, we'll walk through it, figure out what each parameter does, and build the Nat Spec ourselves.\n\n## Decoding the Parameters\n\n![](https://cdn.videotap.com/70D5PzXZylGPTZ8Ak7ea-44.44.png)\n\nThe main parameters in the flash loan function are:\n\n- Receiver address : This is probably the address that should receive the flash-loaned tokens, essentially, where to send the borrowed tokens.\n- ERC 20 : This is the token you want to borrow.\n- Amount : Obviously, this would be the amount you want to borrow.\n- Params : These are the function call parameters for the receiver address. Meaning, when the flash loan function sends the tokens to the receiver address, it will also send these parameters. It is important to note here that the receiver address is expected to be a smart contract.\n\n## Function Breakdown\n\nTo get a better understanding, we should examine each line of the function.\n\n```\nrevert is 0;revert if not allowed token;\n```\n\nWhile these lines may seem perplexing, they are simple checks, the first is to ensure that the function does not revert right out of the gate and the second verifies that the token is allowed. To understand this, you can look into the `isAllowedToken()` function.\n\n```\nAsset token = s_2 asset token of the token.\n```\n\nHere, `assetToken` is the contract that holds the underlying tokens we want to borrow.\n\nA critical part of the function is getting the `startingBalance` of the asset token contract, which will come in handy later on when we verify if the flash loan has been repaid.\n\nIf the `amount` to borrow is more than the `startingBalance`, it means that the function is trying to borrow more than the total available tokens, and it will resultantly revert and terminate the operation.\n\nIn addition to the checks mentioned above, the function verifies the code length of the receiver address. If it equals zero, the operation is once again reverted.\n\n## Understanding the Fees\n\n![](https://cdn.videotap.com/nrDYkgtsrD1YCbh5GO4J-474.07.png)One thing that might seem confusing initially is how they calculate the fee. `getCalculatedFee()` is the function that gets used for that. It's important to note that this fee is the contract's charge to facilitate the flash loan operation.\n\nTo make more sense of this, it's useful to go back to this line:\n\n```\nAssetToken.updateExchangeRate (fee)\n```\n\nHere, the `updateExchangeRate` of the `AssetToken` contract is getting updated with the `fee`. In essence, this step ensures the protocol updates the exchange rate so that everything adds up mathematically with the introduction of the new fee.\n\n> It's important to pause here and do some quick math to fully grasp the impact of the fee on the exchange rate.\n\n## The Flash Loan in Action\n\n![](https://cdn.videotap.com/m50tzcSXOfTUOdDNWqXL-622.22.png)Now that we have understood what each parameter does, we can actually do a quick run-through of the function. Here are the steps:\n\n- The user calls the flash loan requesting for a specific amount of a specific ERC20 token.\n- The function verifies the code length of the receiver address and the amount of the requested token, checks the starting balance of the underlying asset token contract, and verifies if the flash loan has been repaid.\n- If all checks out, the necessary amount of tokens are transferred to the receiver address via `AssetToken.transferUnderlyingTo()`.\n- The function interface calls the `executeOperation` of the receiver contract using the provided params for further operations.\n- Ultimately, it expects the receiver contract to call the `repay` function, sending back the borrowed amount plus the fee.\n\n## Conclusion\n\nWalking through this function sheds light on how a flash loan function works in conjunction with other pieces of a smart contract. However, it's always critical to do your own due diligence and research, check out how other protocols implement similar functionalities, and learn from existing work.\n\nHappy coding!\n",
          "updates": []
        },
        {
          "lessonId": "cc8b39c4-b859-4c01-a12a-45e910bac4bf",
          "number": 34,
          "title": "Note On Being Discouraged",
          "slug": "note-on-being-discouraged",
          "folderName": "34-note-on-being-discouraged",
          "description": "",
          "duration": 1,
          "videoUrl": "XsCj0ueWJis",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/34-note-on-being-discouraged/+page.md",
          "markdownContent": "---\ntitle: A Note On Being Discouraged During The Audit Process\n---\n\n# Understanding the Complexity of Codebase Audits: An In-Depth Exploration\n\nIn the world of coding, auditing your codebase is akin to a treasure hunt. Only in this case, the treasure isn't chests of gold and diamonds, but issues and flaws that need to be addressed. It‚Äôs a crucial process for maintaining code quality and ensuring your app's security. At times, the search can appear discouraging, especially when a clear solution or bug isn't immediately evident. This blog post will dive into the complex world of codebase audits and why it may sometimes feel like you're going around in circles, even though you‚Äôre on the right track.\n\n![](https://cdn.videotap.com/zCv8VBC70weROS4c3wJa-1.69.png)## Unraveling the Codebase: Do You Have Any Audit Highs?\n\nHaving reached this point, you're likely deep into your codebase, scanning various components and notes, and your eyes may have become glossed over with `SRC` entries. You‚Äôve probably posed the question ‚ÄúDo we have any audit highs?‚Äù\n\nThere's no sugarcoating it: learning that you haven't unearthed any 'high' flag issues may feel deflating. After all, you‚Äôre searching for bugs that pose serious risk and, logically, finding a higher risk issue means you‚Äôre making progress, right? Unfortunately, this reasoning skips a very important point: security reviews are not linear.\n\nIt's not as simple as starting at Point A and proceeding seamlessly to Point B. Sometimes, you only find small, lower-risk issues. Sometimes, you hit a wall. And occasionally, you find exactly what you've been looking for.\n\n## Perseverance is Key: Addressing Absence of Medium-category Issues\n\nThe feeling of dismay might deepen when you move to the next level - the medium-category issues, only to discover a similar scenario ‚Äì no apparent bugs. These mid-level issues often provide a balance between complexity and harm potential, making them valuable finds during the audit process.\n\nThe very absence of any high or medium level issues might make you question - ‚ÄúWhat's going on?‚Äù\n\nAnd this is where the answer starts to become apparent.\n\n> **Remember, security reviews are not linear.**\n\n## The Non-linear Nature of Security Audits\n\nJust as with any code review, a ton of questions may spring up, some of which will remain unanswered. Within these mysteries could be hidden the very bugs you seek. You might have already spotted some bugs but dismissed them because they didn't fit into the 'high' or 'medium' categories you were actively searching for.\n\nThat‚Äôs why it‚Äôs so important to remember that path isn't a straight line. It might feel like you're going in circles, but each review, each question asked, and each bug found is a step forward.\n\nRemember, it‚Äôs not about high or medium issues; it's about the hunt for irregularities that can compromise your application's security. It‚Äôs arduous and often tedious, but that doesn‚Äôt mean you‚Äôre not making strides. Every time you cycle through your code, peering at it from all angles, you're gaining a broader perspective and understanding of how your codebase functions.\n\n## Conclusion: Keep Going\n\nSo, next time you find yourself wrapped up in a painstaking codebase audit, don‚Äôt be discouraged if you‚Äôre not finding high or medium issues. Remember the nature of security reviews‚Äîthey are complex, they are multifaceted, and they are definitely not linear.\n\nKeep going, keep searching, and trust that while the path may seem winding and peppered with dead ends, it is leading you to a more robust and secure codebase.\n",
          "updates": []
        },
        {
          "lessonId": "177ebf9d-fe5d-40e0-9892-5757986d60ff",
          "number": 35,
          "title": "ThunderLoan Repay Final Functions",
          "slug": "thunderloan-repay-final-functions",
          "folderName": "35-thunderloan-repay-final-functions",
          "description": "",
          "duration": 8,
          "videoUrl": "WVTwJqj4sY8",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/35-thunderloan-repay-final-functions/+page.md",
          "markdownContent": "---\ntitle: Thunderloan.sol - Repay and Final Functions\n---\n\nTitle: Simplifying Cryptocurrency - Understanding and Breaking Down the Repay Function on Thunder Loan Contracts\n\nWelcome to the intriguing world of Thunder loan contracts! Today, we'll dive into the complexities of the repay function and how it fits into the broader cryptosphere.\n\n## Repay Function: An Overview\n\nYou may wonder why users are expected to use this foundation of Thunder loan contracts. The repay function could be termed a helper function as it essentially facilitates the transfer of tokens from the message sender to the asset token.You could choose to use this function or proceed with a direct transfer.\n\n![](https://cdn.videotap.com/clirVfwioc458w6aVh7V-53.02.png)> _Quick Note:_ Direct transfers can be initiated by simply calling the transfer function and then directing tokens to the asset.\n\nIn our evaluation, the repay function passed the net spec check with flying colors. It contributes significantly to the handling of allowed tokens in the contract.\n\n## Decoding getCalculatedFee\n\nOne question that is often asked is whether this function calculates the fees of the flash loan. To answer this straightforwardly, yes, it does! The getCalculatedFee function appears not only in the flash loan but is also utilized in the deposit aspect.\n\n![](https://cdn.videotap.com/6mvrIM7OsjoztStUZ3t8-127.26.png)\n\nIn terms of decision-making, the question now arises: how does getCalculatedFee calculate the fee?\n\nIn simple words, it first gets the value of the borrowed token by multiplying the amount by the price in WETH. Importantly, this is sourced from the Oracle upgradable getPriceInWETH, which in turn uses the TSWAP Oracle to calculate the value of the borrowed token.\n\nThe 'flash loan fee,' then calculated, divides the calculated value by some fee precision. From here, it applies a 0.3% fee based on the value of the token rather than the actual token amount.\n\n## Digging Deeper\n\nIn delving into the code, we find that getPriceInWETH derives the price of one pool token in WETH.\n\n![](https://cdn.videotap.com/jZtPSFvT2rr7Jszw6QmJ-286.33.png)\n\nFirstly, it's important to revisit TSWAP to further understand this function, particularly how it calculates the amount based on input and output reserves. It raises a potential area of concern. Within an auditing context, we could ask:\"What if the token has six decimals? Would it then distort the price calculation?\"\n\n> _Critical Outlook:_ Ignoring token decimals could result in inaccurate price calculations, especially when working on the basis of TSWAP decks for determining the flash loan fee.\n\nWhile this looks plausible, it may still not be entirely correct. Circumspection is needed at this point, and we would do well to return and probe further.\n\n## Addressing Minor Questions\n\nAfter reviewing the functions like updateFlashLoanFee, isAllowedToken, and getAssetFromToken, we now move on to view functions. The authorizeUpgrade function is particularly interesting as it underlines why we ought to understand proxies in detailed terms.\n\n![](https://cdn.videotap.com/xKIHOvSLAXgodeugEkw9-381.77.png)\n\nIn essence, adding the _only owner_ stipulation in the authorized upgrade function restricts contract upgrades to the owner alone. Take away this extra layer, and you throw open the door to anyone upgrading the contract!\n\nIn conclusion, our initial pass through the Thunder Loan contracts codebase may not have uncovered any distinct issues. But it certainly has left us with questions that need answering, and that‚Äôs where the real fun begins!\n\n## Onwards and Upwards\n\nCracking the code behind algorithms in the cryptosphere may seem incredibly daunting. But remember that the key lies in taking one step at a time, going back to your questions, and digging deeper to find the answers.\n\n![](https://cdn.videotap.com/SeBnhlFpXSRHJX757F1r-434.79.png)\n\nJoin us in our next post for a further breakdown of these questions ‚Äì who knows, we might uncover new insights in our exploration of Thunder Loan contracts. Until then, happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "59f203cb-1a3d-4aa0-86a2-4cd7faaf1785",
          "number": 36,
          "title": "Answering Our Questions",
          "slug": "answering-our-questions",
          "folderName": "36-answering-our-questions",
          "description": "",
          "duration": 9,
          "videoUrl": "TNiNgDiJpSA",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/36-answering-our-questions/+page.md",
          "markdownContent": "---\ntitle: Answering Our Questions\n---\n\n---\n\n# A Deep Dive into T-SWAP: Unpacking Questions and Bugs\n\nIn our exploration of the intricate protocol called T-SWAP, we're going to be asking some hard questions and unraveling complex aspects. The key thing about crypto dApps is you need to understand their working down to the bare-bones in order to exploit or protect against potential vulnerabilities.\n\nTo make the exercise simple, we will treat the hard-hitting questions as dialogue, with each question and answer followed by a quick analysis or piece of advice.\n\nLet's jump in.\n\n## Q1: Why are we using T-SWAP?\n\nWe're using T-SWAP to get the value of a token so that we can calculate fees. Sounds simple enough, right? However, this leads us to another question.\n\n## Q2: Why are we only using the price of a pool token in WETH (Wrapped Ethereum)?\n\nThis is the part that may sound a bit odd. Why are we getting the price in WETH when our primary objective is the price of the token? We're using this pricing in `calculateFee` or `getCalculatedFee`. This calls the `getPriceInWETH`, but for a scenario where we have a flash loan, it's not making much sense.\n\n![](https://cdn.videotap.com/Ko9tuGIzxt2a7EKvdpiz-189.39.png)\n\n\"If we intended to get the price in WETH then the fee should probably be in WETH,\" I hear you say. And you're right. This `getCalculatedFee` seems off. How can one USDC plus 0.3 USDC make sense when the fees are being calculated using `getPriceInWETH`? This could be a potential bug in the software.\n\nAt this juncture, we must determine the impact and likelihood of this bug.\n\n## Potential Bugs in Fee Calculation\n\nFirst off, let me assure you - we're not expecting you to grasp everything the first time around. Crypto security is rife with quirky implementations that some might consider \"weird wonkiness.\"\n\nHere's what we're dealing with - Whenever a fee gets calculated, it uses this potentially flawed method. If this is not the intended functionality, that's a problem! The audit likelihood might be high, leading to a 'medium to severe disruption of the protocol' and the impact could be either medium or high.\n\n> **Quote:** \"If the fee is going to be in the token, then the value should reflect that. But in current scenario it's super weird. We're getting the value of the borrowed token in units of WETH, and we're increasing the fee in units of WETH and USDC.\n\n## Q3: Weird ERC20s with USDC\n\nNow, let's move onto the next question. What if USDC blacklists the loan contract? USDC is behind a proxy and could be upgraded anytime, which could potentially 'wreck' the protocol. This could lead to a freeze on the whole protocol. This is crucial to discuss in private or competitive audit.\n\nBut remember, the rules in competitive audits _usually_ are: 'if a user is denied service or removed, too bad. However, if a user's denial affects others, that's usually an accepted finding in a competitive audit'.\n\nIn case of ERC20s, in competitive audits, these are often not considered valid findings. Sure, you need to keep the clients aware in a private audit, but competitive audits call for more pressing issues. We'll rate this an audit medium, maybe an audit low.\n\n## Q4: Decimals with Token - Can the Price be Wrong?\n\nNow, this is an intriguing aspect. Please note that for this blog, we're going to skip over this question. But here's a challenge to you, the reader, if you think you can answer it better: If a token is characterized by weird and different decimals, can the price be wrong?\n\nHere's a nugget of wisdom: Always be thinking about these types of things. Find out if you can break the protocol by using weird tokens with weird decimals.\n\n## Q5: Is `feePrecision` Misplaced?\n\nThis code deep dive also raises the audit question on whether the `feePrecision` value, which is currently a storage variable, could be better served as a constant immutable.\n\nThat covers some of our perplexing questions about T-SWAP, and we've unfortunately stumbled upon a few potential bugs! But hey, it's better to discover them now in an audit than later when the damage could be far more considerable.\n\nThe key takeaway from this exploration is the importance of meticulous analysis during crypto dApp development. Every piece of code should be audited carefully to ensure it's bug-free and works as intended.\n\nI hope this blog enriched your knowledge about potential pitfalls and the need for audacious questions during protocol designing process.\n\nRemember, in the complex world of crypto, curiosity doesn't kill the cat; complacency does!\n",
          "updates": []
        },
        {
          "lessonId": "7246ca88-7397-43b7-9500-87bb15eafa70",
          "number": 37,
          "title": "Improving Test Coverage To Find A High",
          "slug": "improving-test-coverage-to-find-a-high",
          "folderName": "37-improving-test-coverage-to-find-a-high",
          "description": "",
          "duration": 16,
          "videoUrl": "FaZdYBxgXS0",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/37-improving-test-coverage-to-find-a-high/+page.md",
          "markdownContent": "---\ntitle: Improving Test Coverage To Find A High\n---\n\n# Unraveling the Mystery: Decoding Flash Loan Fees and Exchange Rate Updates\n\nAs we delve deeper into the complexities of DeFi protocols, we find ourselves constantly asking - Why? Why are we calculating the fees of a flash loan in the deposit? And why are we updating the exchange rate? Isn't it a bit strange to perform these updates here?\n\nTo unravel this puzzle, we embarked on an audit trail that led to some unexpected discoveries and revelations.\n\n## Deciphering the Problem: Understanding Exchange Rates and Flash Loans\n\nThe first oddity we noticed was the update of the exchange rate in the deposit function when adding fees. This process typically only commences when there's a significant increase in the total amount of money in the asset token. It seemed illogical that the deposit function, which accrued no fees, was responsible for this update.\n\nIf the update exchange rate was malfunctioning, it would have repercussions on the 'redeem' function - our protocol's withdrawal mechanism. To confirm our suspicions, we needed to test this function first.\n\n## Running the Test: Examining the 'Redeem' Function\n\nTo validate the functionality of the redeem function, we had to initiate a test. We decided to write a test for the redeem function and simulate a scenario of borrowing from the test flash loan and then attempt to redeem.\n\nWe commenced with the test by first setting up a mock Flash Loan receiver with a specified fee, which would be used for the Flash Loan.\n\nThe test would first change the exchange rate by depositing some funds, then modify it again by initializing the Flash Loan. ideally, at this stage, the depositor should be able to withdraw all their money.\n\n![](https://cdn.videotap.com/NHVntHvDBDp2yLjdahS4-377.57.png)\n\n## The Unexpected Revelation: Insufficient Balance\n\nThe test, unfortunately, produced an unexpected outcome - Insufficient balance.\n\nAfter analyzing the logs of the transactions performed during the test, we noticed that the 'transferUnderlyingTo' function was returning an error stating insufficient funds. The amount to be transferred back (1003 tokens) was higher than the initial deposit (1000E 18).\n\nThis discrepancy threw us off balance. We had triggered a Flash loan, and expected to incur a fee, but the increase in the withdrawal amount surpassed the fee incurred. Upon scrutinizing the deposit function once again, we discovered an uncanny occurrence - the exchange rate was updating the fee.\n\nThe exchange rate, which was originally responsible for tracking the total amount of money in the protocol at all times, had now charged a fee without any transaction taking place.\n\nThis detrimental coding error was affecting liquidity providers' ability to redeem their tokens, setting off alarm bells for us.\n\n## Assessing the Damage: Decoding the High\n\nTo ascertain the gravity of the impact of this error, we performed a follow-up test with the problematic lines of code in the Thunder loan commented out. As expected, the test passed, solidifying our suspicion. The initial mock test we developed served as a proof of code that affirmed our findings.\n\n![](https://cdn.videotap.com/liERWQdBJtLyf0Oj21Oc-556.43.png)\n\nThe paramount error was evident - the erroneous exchange rate update in the deposit function. This update was blocking redemptions and incorrectly setting the exchange rate, leading to severe disruptions in the contract functionality.\n\nThe likelihood of this recurring was high due to its occurrence every time someone deposited. The impact, too, was high as users' funds would be locked. Moreover, rewards were incorrectly calculated due to reward manipulation leading to users potentially getting way more or less than deserved.\n\n## Mitigating the Threat: Towards a Safer Protocol\n\nHaving extensive experience in blockchain security, we carefully devised a countermeasure to neutralize this imminent threat.\n\nThrough our persistent efforts probing into the code, we have managed to reveal a glaring irregularity that could have potentially endangered the whole protocol. The mandatory removal of this erroneous exchange rate update from the deposit function could significantly impact the protocol, making it safer and more secure, offering a fortifying solution to this daunting mishap.\n\nAnd, as we continue ahead in our journey, probing for more security vulnerabilities and solving them, we learn that most bugs tend to surface towards the end of the audit. As our understanding of the protocol deepens, we get better at detecting potential threats, eventually leading to a more secure eco-system for all.\n",
          "updates": []
        },
        {
          "lessonId": "8564f658-ef5f-4c3f-9f4b-9cb564b5f609",
          "number": 38,
          "title": "Exploit: Oracle Manipulation",
          "slug": "exploit-oracle-manipulation-intro",
          "folderName": "38-exploit-oracle-manipulation-intro",
          "description": "",
          "duration": 2,
          "videoUrl": "D4CGfLPhvY0",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/38-exploit-oracle-manipulation-intro/+page.md",
          "markdownContent": "---\ntitle: Exploit - Oracle Manipulation - Introduction\n---\n\n# The Art of Debugging: A Deep Dive into Oracle Manipulation\n\nHello Code Lovers! We're back with another exciting and intriguing chapter of our journey today. So, keep your curiosity alive as we have some complex but fascinating issues to untangle.\n\n## Unravelling the Mystery: Deleting a Mapping\n\nFirst things first ‚Äì let's delve into one compelling question that's been troubling us: Does deleting a mapping work? Remember, the key to successful debugging is not just fixing the bug, but comprehending the reason behind it.\n\nAfter a thorough examination, we did come across some irregularities earlier. But with our renewed focus, let's try to unlock this puzzle.\n\n![](https://cdn.videotap.com/EDZ935DJCvseMdojYDqQ-15.74.png)\n\n## Decoding the Fee Calculation Conundrum\n\nMoving on to another important question: How does the fee get calculated? Now, if you'll recall from our previous discussion, we uncovered some strange issues concerning the fee represented in the token.\n\nWithout getting bogged down by the past problems, let's scrutinize if there's a deeper complication here, especially with the usage of T-SWAP as the protocol.\n\nOn a side note, this is an instance where the wisdom derived from previous experience comes into play. It's essentially when debugging starts resembling a thrilling treasure hunt - the more treasures (read: issues) you uncover, the more experienced and capable you become.\n\nSo, roll up your sleeves as we uncover a grave inconsistency embedded in the depths of this code.\n\n![](https://cdn.videotap.com/ILyKyCIUBPHesdezqO7A-34.63.png)\n\n## The Hidden Dragon: Oracle Manipulation Issues with AMM\n\nAs we delve deeper, there's a staggering hiccup with using the reserves of a Decentralized Exchange (DEX) or an Automated Market Maker (AMM), like TSwap. Did you know the reserves' modification could drastically alter the price, thus jeopardizing the entire protocol?\n\nConsider, for instance,If you could alter the reserves in TSwap, it, in turn, alters the price and disrupts the entire protocol.\n\nThis brings us to our next cornerstone - understanding Oracle Manipulation, to determine any potential malfunctions leading to a breach.\n\n![](https://cdn.videotap.com/Dq8ETmltBDcUUQFSFh4o-56.67.png)\n\n## Oracle Manipulation: Spotting the #1 Attack Vector of 2023\n\nThere's a critical question to address here: What's the likelihood of a breakdown? And if it exists, can it expose the system to potential hacks?\n\nIf you're in tune with the trends, then you most certainly know that Price Oracle Manipulation topped the list of attack vectors for the first half of 2023. It's essential to have a clear understanding of how it operates, how to steer clear of it and, most importantly, spotting this concern.\n\nUnfortunately, the problem is commonplace in competitive audits, private audits, and also manifests \"in the wild.\"\n\nLet's delve into this vast sea of knowledge, which may seem intimidating for beginners but indeed holds the key to amending this widespread issue.\n\n![](https://cdn.videotap.com/DFzBDvQKrlAS9RSlOvGX-75.56.png)\n\n## In Conclusion\n\nSo let's start snowballing now and romp through this course! Debugging and solving these issues will give you a giddy sense of accomplishment. More importantly, learning to identify these potential landmines can equip you to deal with an array of daunting challenges in your coding journey. Happy Debugging!\n",
          "updates": []
        },
        {
          "lessonId": "ec5a245b-0240-4ebe-8389-35259b0e7af7",
          "number": 39,
          "title": "Oracle Manipulation: Minimized",
          "slug": "exploit-oracle-manipulation-minimized",
          "folderName": "39-exploit-oracle-manipulation-minimized",
          "description": "",
          "duration": 10,
          "videoUrl": "oroW__t1JMg",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/39-exploit-oracle-manipulation-minimized/+page.md",
          "markdownContent": "---\ntitle: Exploit - Oracle Manipulation - Minimized\n---\n\n# Utilizing SC Exploits for Oracle Manipulations in Blockchain Protocols\n\nIn the whirlwind universe of blockchain protocols, there lies a fascinating yet notoriously common class of vulnerabilities that all budding developers should be aware of - Oracle Manipulations. The term \"Oracle\" refers to an entity that helps blockchain protocols interact with the outside world by providing them with real-world data. In this article, we'll delve deep into the world of SC (Smart Contract) exploits, examining a particular vulnerability concerning Oracle manipulations and how it can be leveraged for profit.\n\n![](https://cdn.videotap.com/7l5XeduNYadMolRpvY1p-27.77.png)\n\n## A Basic Understanding of Flash Loans\n\nFirst things first, let's recap an elemental concept - Flash loans. To keep it simple, flash loans are loans that allow you to borrow assets without any collateral, with the condition that you return them within a single transaction.\n\nHere's a basic formula for a flash loan:\n\n1. An entity calls for a flash loan.\n2. They get the loaned asset (say, a particular cryptocurrency).\n3. They carry out an operation or multiple operations using the asset.\n4. Finally, they return the money within the same transaction.\n\n## SC Exploits and Oracle Manipulations - How Does It Happen?\n\nLet's walk through an example of how these exploit works. Consider a common situation where we have a decentralized exchange, TSwap for instance. Within TSwap, you have two liquidity pools, as in all traditional DEXs. Let's say these pools hold 100 USD Coin (USDC) and 10 Wrapped Ether (WETH) respectively.\n\nGiven the current holdings, the ratio of USDC to WETH in this pool is 10:1. This means that you could theoretically get 1 WETH for 10 USDC, ignoring slippage and other factors.\n\nSo, what happens if our savvy exploiter decides to take a flash loan?\n\nLet's say the entity takes out a flash loan of 1,000 USDC. Instead of using this for the usual operations, they decide to swap it onto TSwap, pushing its USDC reserves up to 1,100. This drastically changes the ratio in the pool, making WETH significantly more expensive in terms of USDC.\n\nThe trick here, however, is that all of this is happening within the timeline of a single transaction. To an outside observer (including other smart contracts), it looks like for a brief moment, the price of WETH has soared.\n\n## The Consequences of Price Manipulation\n\nIf another protocol that uses Tswap's price feed to determine the price of certain assets, it would momentarily read this wrong price. Assume a protocol, which we call Protocol 'Whoops', mints NFTs at a rate pegged to the price of WETH. The hacker can temporarily buy these NFTs for cheap, sell them for a profit, and then pay back the flash loan - all in one transaction!\n\nWe can see how exploiting oracle manipulation can be quite a lucrative business - but only for those equipped with in-depth knowledge of blockchain, smart contracts, and DeFi protocols.\n\n## The Thunderloan Example\n\nConsider the Thunderloan contract, which is a perfect representation of such exploits. It uses a TSwap-like decentralized exchange as its price oracle, creating a significant risk as flash loans can manipulate the price feed quite conveniently. Thus, a savvy exploiter could utilize a flash loan from Thunderloan to manipulate Thunderloan itself.\n\nYou can explore further on oracle manipulation exploits by checking out the SC exploits in the \"minimized\" section on Github. It includes a detailed example of Oracle manipulation and how it played out, including everything needed for you to try and test it yourself in a local environment.\n\n## Notable Incidents\n\nOne notable case that stands out in history is the Cream Finance attack that took place in 2021. The attacker exploited a pricing vulnerability by lending and borrowing flash-loaned funds between two addresses, wreaking havoc on Cream's financial assets.\n\nThe Cream Finance attack is not unique; several other significant and minor hacks have been carried out over the years that involve similar exploit methods. Therefore, be it as a developer on the lookout for bugs in your protocols or a crypto enthusiast looking for loopholes, understanding oracle manipulation attacks should be in your toolkit.\n\n## Conclusion\n\nOracle manipulation is an intriguing and unfortunately prevalent attack vector within blockchain protocols. It is crucial as developers, stakeholders, and enthusiasts to understand such vulnerabilities to build, invest, and operate more securely within the crypto space.\n",
          "updates": []
        },
        {
          "lessonId": "6a890d64-3b94-4fba-907a-935065ff8efd",
          "number": 40,
          "title": "Oracle Manipulation: ThunderLoan Poc",
          "slug": "exploit-oracle-manipulation-thunderloan-poc",
          "folderName": "40-exploit-oracle-manipulation-thunderloan-poc",
          "description": "",
          "duration": 29,
          "videoUrl": "DyChU8-c6oU",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/40-exploit-oracle-manipulation-thunderloan-poc/+page.md",
          "markdownContent": "---\ntitle: Exploit - Oracle Manipulation - Thunder Loan PoC\n---\n\n# Exploiting Oracles with Flash Loans\n\nOracles play a critical role in blockchain systems by providing external data to smart contracts. However, improperly designed oracles can lead to devastating oracle manipulation attacks. In this post, we will demonstrate an advanced oracle manipulation attack using flash loans.\n\n## Overview\n\n![](https://cdn.videotap.com/kM0YOBTs7t8WreMLhr2A-49.5.png)We recently audited a lending protocol called ThunderLoan that relies on a DEX called TSWAP for price feeds. By exploiting TSWAP with flash loans, we will manipulate prices and extract cheaper flash loans.\n\nThis is an extremely advanced attack that combines:\n\n- Flash loans\n- Oracle manipulation\n- Arbitrage bots\n- DEX price manipulation\n\n## Exploiting the Oracle\n\nTo manipulate the price oracle, we will:\n\n1. Take out a flash loan of 50 **tokenA**\n2. Use the loan to manipulate TSWAP reserves\n3. Take out another flash loan for a hugely reduced fee\n\nWhen `maliciousFlashLoan` is called:\n\n1. The first 50 token loan dumps onto TSWAP, manipulating prices\n2. The second 50 token loan has a massively reduced fee due to the price change\n\n### Full Exploit Code\n\n![](https://cdn.videotap.com/xK2fynd4EnHBvr8emyyD-1501.5.png)\n\nIt's very complex but essentially:\n\n1. Borrows 50 tokens\n2. Swaps them on TSWAP, nuking the price\n3. Borrows another 50 tokens for cheaper\n4. Checks the fee is reduced\n5. Repays everything\n\nRunning the code proves fees are drastically reduced by the attack.\n\n## Impact\n\nThis attack allows attackers to take flash loans for extremely cheap. They circumvent the protocol's fees and essentially get free money.\n\nWe classify this as a medium severity issue. It's unlikely to be exploited in the wild due to complexity, but if it was, it could seriously compromise sustainability.\n\n## Recommended Mitigation\n\nThe root cause is using on-chain DEX reserves to price assets. This is easily manipulated.\n\nInstead, we recommend decentralized oracle solutions like:\n\n- Chainlink Price Feeds\n- Uniswap TWAP\n\nThese are robust against manipulation, ensuring accurate prices even during attacks.\n\nWe hope this post has provided valuable insight into advanced oracle manipulation attacks in blockchain systems. As protocols expand in complexity, deeply understanding these attacks will prove invaluable to engineers and auditors alike.\n",
          "updates": []
        },
        {
          "lessonId": "14bf10cf-959a-4040-862f-e91241459691",
          "number": 41,
          "title": "Oracle Manipulation: Recap",
          "slug": "oracle-manipulation-recap",
          "folderName": "41-oracle-manipulation-recap",
          "description": "",
          "duration": 3,
          "videoUrl": "ag6Gcm6AIkc",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/41-oracle-manipulation-recap/+page.md",
          "markdownContent": "---\ntitle: Oracle Manipulation Recap\n---\n\n# Flash Loans: Making Blockchain Arbitrage Accessible\n\nArbitrage, the simultaneous buying and selling of assets in different markets to take advantage of differing prices, has long been an effective strategy for the 'financially fearless' among us. A concept traditionally dominated by the deep-pocketed whales of Wall Street, the decentralised finance (DeFi) world is flipping the field on its head with the application of flash loans.\n\nCan't tell your flash loans from your DeFi? No worries, mate. Let's dive deep into it all and level the arbitrage playing field!\n\n### The Magic of Flash Loans\n\nBut what's a flash loan? A flash loan is a loan that lasts exactly one transaction! Quite an alien concept to anyone versed in traditional finance, this tool is peculiar and unique to the DeFi blockchain realm.\n\n```markdown\n\"It is a loan that lasts exactly one transaction.\"\n```\n\n![](https://cdn.videotap.com/VtEQgP01EvzX42ymoqp1-45.63.png)\n\nWhy so peculiar, you ask? That's because a flash loan smart contract can stipulate 'if you don't pay me back, I will just revert everything that you've done'. Imagine the applications!\n\n### Where the Whales Swim: An Example\n\nThis is where it gets interesting. Major players (whales) deposit large sums of money into protocols that host flash loans. Why? Because every flash loan carries a fee, incentivising whales to keep their money safely in the protocol. But how does this tie into arbitrage, and why should we care?\n\nWell, let's scope out a practical application of flash loans in our arbitrage world.\n\nImagine two different cryptocurrency exchanges present a price discrepancy for the same asset. If you had the funds, you could buy from one exchange at a lower price and sell on the other at a higher price, making a neat profit. This requires substantial initial investment to explore, which is where flash loans change the game completely.\n\nFlash loans democratize the arbitrage domain, allowing even the smallest fish in the sea to swim amongst the whales. By providing the funds for the duration of one transaction, users can perform arbitrages without owning the requisite amount at the outset!\n\n### Flash Loans and DeFi: A New Era of Financial Democracy\n\nIn a regular finance landscape, opportunities for arbitrage are available exclusively to the wealthy class. The DeFi landscape transforms the traditional constructs of finance by opening these virtual doors to anyone and everyone. Flash loans are an empowering tool for the smaller fish to leapfrog the barriers of entry and start swimming in the arbitrage ocean.\n\n```markdown\n\"DeFi levels the playing field and allows anyone to take advantage of these opportunities.\"\n```\n\n### Life in the Flash Lane: From Arbitrage to Collapse\n\nAnother fascinating interaction that can occur between flash loans and DeFi protocols involves ‚Äòprice manipulation‚Äô. Here, users leverage flash loans to manipulate the price on a decentralized exchange (DEX), resulting in opportunities for further trading advantages.\n\n![](https://cdn.videotap.com/0dhGroKi4k72ZIMv0UAb-130.37.png)\n\nThis tactic is illustrated in a test we conducted using an imaginary 'Thunder Loans' protocol. We set it up, requested a flash loan, and manipulated the reserve ratios of the DEX, causing a significant change in price. This setup enabled us to borrow another flash loan, this time with a substantially lower fee due to the manipulated rates.\n\nThis might sound somewhat unscrupulous, as the liquidity providers (the whales) lose out, yet the strategy worked. We completed all the necessary moves, hit the 'Thunderloan flash loan' button, manipulated the contract code, ensured the change in reserves, and witnessed the price drop from a 1:1 ratio down to a 1:2 ratio.\n\nFinally, we executed another flash loan, leaving us with a drastically cheaper fee due to our manipulations with the initial flash loan. We then repaid this loan, leading us into an intriguing question: What if we didn't need to repay?\n\n![](https://cdn.videotap.com/CTDan8syFjGyGDy0iJ02-156.44.png)\n\nThis was quite a jog around the DeFi neighborhood and our thrilling exploration of flash loans. Now, take a breather, grab some water or coffee, and let‚Äôs gear up for the next leg of this captivating journey in the fantastic world of blockchain technology!\n\nRemember, with DeFi and flash loans, the future of finance is truly in your hands.\n",
          "updates": []
        },
        {
          "lessonId": "ea331fa9-cbc2-4a7c-b208-6ef48440986d",
          "number": 42,
          "title": "Exploit: Deposit Instead Of Repay",
          "slug": "exploit-deposit-instead-of-repay",
          "folderName": "42-exploit-deposit-instead-of-repay",
          "description": "",
          "duration": 17,
          "videoUrl": "a_yZVutniag",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/42-exploit-deposit-instead-of-repay/+page.md",
          "markdownContent": "---\ntitle: Exploit - Deposit Instead of Repay\n---\n\n---\n\n## title: \"Uncovering Unexpected Bugs in Defi Smart Contracts with Thunderlone\"date: \"2021-07-18\"author: \"DeFi Geek\"\n\nWelcome back fellow DeFi enthusiasts! Get ready as we dive into our awesome bug-hunting exercise featuring - Thunderlone and Thunderlone upgraded.\n\nIn this article, I am excited to reveal not just one, but two juicy bugs for you today. One is in the original Thunderlone smart contract, and the other one is lurking in the upgraded version of Thunderlone, which we'll dissect later on.\n\nBear with me as we uncover these bugs and provide strategies to squish them.\n\n## Unearthing Bugs in DeFi Smart Contracts\n\nBefore delving into the bugs, let me remind you - you're doing great. If you're new to DeFi, this section might be a little tough, but hang in there, we're almost at the finish line.\n\n### Bug Hunting Begins!\n\nWith our newfound expertise in flash loans, we've managed to uncover some interesting behaviors and potential oversights.\n\nOur journey began with a simple question: _What other ways exist to get money into this contract, outside of repaying or sending assets directly, that can potentially pull it out later?_\n\nHow did we answer this? For this, we ran a quick scan of Thunderlone's methods.\n\nThis gave us a comprehensive overview of all the methods that Thunderlone has, and their respective function signatures. As we analyzed this information, one function jumped out - _deposit_.\n\n### The \"Deposit\" Function ‚Äì A New Way to Leverage the System?\n\nUntil now, deposit was mainly used by whales to put their tokens in and redeem them later. But we started wondering, what if the system allowed us to deposit tokens and then redeem them without calling repay?\n\nSounds like a twist in the plot, doesn't it? This interesting loophole sparked our curiosity, leading us to write a proof of code.\n\n### Writing Test to Verify The Bug\n\nOur next step was to create a test scenario. Our test involved initiating a flash loan, after which the user would need to deposit a certain amount.\n\n```markdown\nTest scenario:1. Start loan2. Deposit assets3. Redeem money4. Conclude loan\n```\n\n### Test Results ‚Äì Validation of the Bug\n\nWhat did we find? We found a loophole ‚Äì stealing money. You heard right! It turns out that our users can manipulate the system by initiating a flash loan and then merely depositing it. Next, they can redeem all the money, causing a huge loss for our liquidity providers.\n\nCheck it out; the test along with the results of this big reveal is available at `test_number1` on our repository.\n\n## Thunderlone Upgraded - Examination and Exploration\n\nWith Thunderlone dissected, it was time to aim our magnifying lens on Thunderlone Upgraded. Remember, Thunderlone Upgraded was supposed to be the improved version. Did it hold up to expectations? Let's find out.\n\nSince this is an upgradable contract, we had two paths to explore:\n\n1. Starting from scratch - study the code line by line as we did with Thunderlone.\n2. Use **diff** - a command used to spot the differences between two files.\n\nIn this case, we chose the **diff** command as the more efficient approach.\n\nTo see the differences between the two files, we use the diff command:\n\nThanks to **diff**, we got a comprehensive report sifting through lines of codes and comments. This method helped us identify that they planned on swapping the storage spots of `sFlash Loan fee` which would lead to a disastrous storage collision issue!\n\n### Introducing Storage Collision Attack\n\nThis brings us to our second bug - a _storage collision attack_.\n\nTake a moment to imagine a world where a programmer decided to make a quick swap in the storage variables. Initially, you may think it's an innocent programming overlook, right? However, it's an altering decision that will wreak havoc on the entire storage structure, leading to a storage collision attack.\n\nIn short, you can't just swap the storage spots!\n\nIn the original Thunder Loan, `sFlashLoanFee` is present at slot 3, but in the upgraded version, it's present at slot 2. This shift increases the chances of a fatal storage collision. As such, the swap would directly affect the asset owners, hence, leading us down the path of financial discrepancy.\n\n---\n\nAs a final thought, let me just remind you - no matter how minor the change in the code appears, it can have major impacts on your contract's functionality. In this case, this seemingly insignificant storage variable swap has the potential to lead us down a path of storage collision, causing a significant catastrophe.\n\nHappy bug hunting!Stay Safe. Stay Decentralized!\n\nThat's all for now, fellow developers and DeFi enthusiasts. See you in the next venture, decoding, dissecting, and debugging DeFi contracts.\n\nUntil then - keep defying, keep decoding!\n",
          "updates": []
        },
        {
          "lessonId": "4ece65ad-a1e7-405e-9d6c-8f5aaa7f2e45",
          "number": 43,
          "title": "Exploit: Storage Collision",
          "slug": "exploit-storage-collision-storage-refresher",
          "folderName": "43-exploit-storage-collision-storage-refresher",
          "description": "",
          "duration": 3,
          "videoUrl": "U2P5sHVWsjQ",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/43-exploit-storage-collision-storage-refresher/+page.md",
          "markdownContent": "---\ntitle: Exploit - Storage Collision - Storage Refresher\n---\n\n# Understanding the Mechanism of Ethereum Smart Contract Storage.\n\nThe vast and innovative landscape of Ethereum smart contracts demands a comprehensive understanding of the subtle ways in which these self-executing bits of code work. In this article, we aim to unpack the operational mechanism of smart contract storage, drawing focus on its organization, types of variables, and implications of upgrades. Without further ado, let's dive straight into understanding contract storage.\n\n## Variable Placement in Storage\n\nStorage, in essence, can be understood as a giant array containing variables. Sequential variables get chronologically placed into this array, with each variable occupying a unique storage slot.\n\nFor instance, let's consider a simple variable - `int256 favoriteNumber`. As a first variable, it's placed into `storage slot 0`. If we add another variable, such as a boolean `bool someValue`, it follows suit and gets stacked into `storage slot 1`.\n\n![](https://cdn.videotap.com/fqXHyZ8Wd1AmcWeZV9jE-24.png)\n\n### Variable Packing\n\nWhile this description captures the essence of storage placement, there's an added layer of complexity; Solidity does some interesting stuff like \"packing variables\". However, that's a topic for another day. Rest assured, this bit of information won't interfere with the fundamental understanding of storage.\n\n## Arrays and Mappings in Storage\n\nStorage gets slightly trickier to comprehend when dealing with arrays and mappings. The organization of an array is a tad bit complicated - the length of the array gets positioned in a slot analogous to a regular variable. The actual elements of the array, however, find their home in a hash of the storage slot of the array length.\n\n![](https://cdn.videotap.com/JMGwpAcocpS7uwDvgxPP-45.png)\n\n## The Storage Exceptions: Constants and Function Variables\n\nTwo types of variables are exempted from having storage slots - constants and function variables.\n\n- **Constants**: Constant variables do not warrant storage slots as they are hard-coded directly into the bytecode. Consequently, we don't need to worry about constant variables while delving into storage.\n\n- **Function Variables**: Such variables‚Äîoften initialized during the execution of a function‚Äî are temporary and exist only for the duration of the function call. Hence, they are stored in memory space, not in storage slots.\n\n## Storage Slots Upon Contract Upgrade\n\nA key question arises - what happens to the storage slots when a contract is upgraded? Well, the order of variables in our upgraded contract is assigned new storage slots, but it also inherits the previous order of variables.\n\n> \"We've just totally messed up storage by upgrading our contract to some new nonsense.\"\n\nLet's say the boolean variable `someBool` was initially in `storage slot 1`, but upon contract upgrade, the variable shifts to `storage slot 2`. This transition recapsulates the flexibility, albeit complexity, of the Ethereum storage structure.\n\n![](https://cdn.videotap.com/UvEwzYfKpxND8OGan5AW-114.png)\n\nIn conclusion, understanding the storage behavior in Ethereum smart contracts is fundamental for anyone trying to navigate the rich ecosystem. The mappings and order change can surely create some confusion, but with time and practice, managing storage slots becomes second nature.\n",
          "updates": []
        },
        {
          "lessonId": "c0fae74b-3866-49ff-98b8-42cd7c0ae3ce",
          "number": 44,
          "title": "Storage Collision: Diagram",
          "slug": "exploit-storage-collision-diagram",
          "folderName": "44-exploit-storage-collision-diagram",
          "description": "",
          "duration": 2,
          "videoUrl": "E-_nrC6pqR4",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/44-exploit-storage-collision-diagram/+page.md",
          "markdownContent": "---\ntitle: Exploit - Storage Collision - Diagram\n---\n\n# Understanding Ethereum Smart Contract Proxies and Upgrades\n\nIn the exciting world of Ethereum smart contracts, the design pattern of using proxies for contract upgrades provides an effective solution to the otherwise immutable nature of contracts. However, this approach is not devoid of complexities, and amateur developers may often encounter problems with storage slots during contract upgrades. Let's delve into an illustrative example to understand better how this works.\n\n## Fundamentals of Proxy Interaction\n\nTo kick off, let's take a closer look at the basic principles of proxy interaction with smart contracts.\n\nTo put it simply, imagine we have an implementation contract. When a user executes a function, say `setValue(x)`, the call initially goes to the proxy. The proxy is programmed to look at the implementation contract for executing the function. For example, if our contract has an instruction to set its value to `x`, the logic gets sent to the proxy.\n\nOnce inside, the proxy modifies its internal state, storing the new value at a defined storage location. Typically, the first storage slot (slot 0) is used for this purpose.\n\nThis gives us a simplistic view of how the proxy pattern helps align storage with contract implementations.\n\n![](https://cdn.videotap.com/WUQkx9srA6tjA8Yo5lRL-42.36.png)\n\n## The Upgrade Process: What Happens within the Proxy\n\nNow let's see what happens when we decide to upgrade our contract.\n\nIn an upgrade scenario, the proxy points from implementation contract `A` to a new implementation contract `B`. However, the storage inside the proxy remains intact. It will simply start referring to the new contract to carry out its logic.\n\n> Note: The essence of the upgrade process is that the proxy's storage does not get changed or migrated. It just adopts a new source of instruction.\n\n![](https://cdn.videotap.com/gKwLO8tKUQsQFgdhAmZB-72.62.png)\n\n## Potential Issues with Storage Slot Misalignment\n\nThe seamless continuation of storage masks a potential pitfall ‚Äì storage slot misalignment. If the new implementation isn't mindful of how the storage was structured in the previous implementation, chaos can erupt!\n\nLet's continue our example to see how. Our user calls `setValue(10)` which now points to logic `B`. If `B` has instructions that alter the storage structure like,\n\nIn this situation, `value` gets stored in slot 1 since `initialized` has taken up slot 0. Now, proxy's storage looks completely different with value 5 still in slot 0 and the new value of 10 in slot 1.\n\nStorage slot misalignment might result in overriding storage slots, uninitialized variables, and other issues leading to potential contract vulnerabilities.\n\n![](https://cdn.videotap.com/nvkgWHqUU232F6YtZgQD-111.95.png)\n\n## Diving Deeper with Remix\n\nTo see this in action and further understand, we can use Ethereum's browser-based IDE, [Remix](https://remix.ethereum.org/). In the follow-up post, we'll walk through an immersive hands-on example using Remix to intricately explore the subtleties of contract upgrades and proxy interactions. Stay tuned!\n",
          "updates": []
        },
        {
          "lessonId": "3bc7ad4f-9c3f-441c-921e-a3af7b50f5a9",
          "number": 45,
          "title": "Storage Collision: Remix Examplee",
          "slug": "exploit-storage-collision-remix-examplee",
          "folderName": "45-exploit-storage-collision-remix-examplee",
          "description": "",
          "duration": 4,
          "videoUrl": "N6OeYLKhMCU",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/45-exploit-storage-collision-remix-examplee/+page.md",
          "markdownContent": "---\ntitle: Exploit - Storage Collision - Remix Example\n---\n\n# Understanding the Storage Collision in Ethereum Smart Contracts\n\nIn this blog post, we're going to dive deep into understanding one of the common issues Ethereum smart contract developers encounter: the storage collision. In this exploration, we'll utilize Storage Collision, a contract we've sketched in Remix ‚Äî an open-source tool developed by the Ethereum community to help you build smart contracts.\n\n## Introduction to Storage Collision Contract\n\nScroll down in the remix interface and you'll come across the Storage Collision contract. Opening this contract, there are quite a number of lines to dissect. You'll see a special type of contract called `proxy`. Its pivotal role is to call the `set implementation` function.\n\nThere are also helper functions in this contract whose primary task is to read data from the contract. For example, the `readStorage` function checks and fetches the value stored in a specific storage slot.\n\n## Implementation A and B and their peculiarities\n\nThe contract contains two distinct implementations labeled as `implementation A` and `implementation B`, mirroring what was shown in the initial diagram.\n\n- **Implementation A** has `value` located at storage slot zero.\n- **Implementation B** is a bit more complex with `initialized` at storage slot zero. By default, `initialized` should be `false`. But if there's a value in the corresponding slot, `initialized` becomes `true`.\n\n## Deployment and Compilation\n\nNext on the stop, is to compile and deploy these contracts: `Implementation A`, `Implementation B`, and `Storage Collision Proxy`. It's important to note that the `Storage Collision Proxy` is first associated with the contract address for `implementation A`.\n\nNow, we've set our Proxy to point to `implementation A` and we can interact with it accordingly.\n\n## Interacting with Implementation A\n\nTo do this, copy the Proxy address into `implementation A`, allowing us to work directly with `implementation A`.\n\nWhen we check the `value`, it reads '0' because we haven't assigned any value yet. But when we assign 15 to the `value`, the `value` in `implementation A` changes to 15.\n\nIt's worth noting that in solidity, anything aside from 0 is considered `true`. Hence, the `bool public initialize` in `implementation B` is expected to default to `false`. But let's see if that's the case.\n\n## Transition to Implementation B and the Twist\n\nSwitching to `Implementation B`, we change the implementation address in our `Storage Collision Proxy` and then inspect the `value`.\n\nSurprisingly, our `value` reads zero - this is because we have upgraded the contract. However, we can imitate the previous process with `implementation A` and interact with `implementation B`.\n\nWhen we call `initialized`, contrary to the default being `false`, it returns `true`. This happens because within the proxy, the `readStorage()` function is indicating that there's a '15' at storage slot zero.\n\nSince `initialized` is coupled to storage slot zero, the non-zero value makes it return `true`.\n\nThe next process is to set the `value` of `implementation B` to a new number, which affects the `storage slot one`.\n\nThe consequence of this action reveals a **storage collision**.\n\n> In essence, the 'storage collision' is a situation whereby values in the storage slots overlap as a result of an upgrade, causing unexpected changes in the system.\n\n## In Conclusion\n\nIn Ethereum smart contracts, collision issues are something we ought to be wary about. As we've noticed, our upgraded contract seems to be colliding due to these issues, causing unintended changes in the system. Careful architecture of contracts and more thorough analysis are needed to mitigate this risk. As always, understanding the underpinnings of the system and how actions interact with it is key to a successful deployment and operation of your Ethereum smart contracts.\n",
          "updates": []
        },
        {
          "lessonId": "d36939fe-b02e-45d5-9d22-4eba1bf60575",
          "number": 46,
          "title": "Storage Collision: Poc",
          "slug": "exploit-storage-collision-poc",
          "folderName": "46-exploit-storage-collision-poc",
          "description": "",
          "duration": 3,
          "videoUrl": "LaYQ6-SEJr8",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/46-exploit-storage-collision-poc/+page.md",
          "markdownContent": "---\ntitle: Exploit - Storage Collision - PoC\n---\n\n# Code Proving 101: An In-Depth Walkthrough in Upgrading Solidity Contracts\n\nWelcome to our walkthrough of writing a proof-of-code for Solidity contracts. Here, we'll be outlining a detailed practice on how you can handle upgrades - an essential part of maintaining and improving smart contracts. The entire process is clear-cut, so don't be shy about getting your hands dirty with code.\n\n### The Test Unit\n\nConveniently, we'll be examining a test unit called Thunderlone, which has an upgrade function we will dissect. Below we will act as the owner of Thunderlone, including deploying a new logic address and making an upgrade proxy call.\n\nAt this point, we fetch the fee before making any changes and state a new `ThunderloneUpgraded`.\n\n![](https://cdn.videotap.com/KgYyc5GgyHgGV9f1xeiW-44.57.png)\n\nIntriguing right? But, not so fast! We‚Äôve missed something vital. Just before diving to that, we ought to import the upgraded protocol at the top of the test page. Here, `ThunderloneUpgraded.sol` is the Solidity script that defines our `ThunderloneUpgraded` contract.\n\nWith that code added, we now have access to the `ThunderloneUpgraded` contract we instantiated earlier.\n\n### Handling the Upgrade\n\nThe next crucial part involves calling Thunderlone's upgrade function.\n\nFor our purpose, there's no data to call, hence the \"0x\". This function upgrades the proxy to the upgraded address, nifty right?\n\n### Assertions\n\nOnce we log the fees, we come to our final part - asserting that the `feeBeforeUpgrade` indeed changed from `feeAfterUpgrade`.\n\nThis simple test will tell if there is a discrepancy in the fees, which would mean our upgrade tinkered with more than it should have, causing storage collisions.\n\n### Running the Tests\n\nWe are now ready to run this forge test. It's pretty scary how such small changes can end up making mega alterations, right?\n\nKeep crafting your test units as you explore the vast world of Solidity. Don't be too hard on yourself; it takes a few trial and errors before you become a pro! And remember, learning is a never-ending journey. :)\n\nHappy testing!\n",
          "updates": []
        },
        {
          "lessonId": "58af1688-efa6-4821-86af-6adce089437c",
          "number": 47,
          "title": "Reporting: Storage Collision",
          "slug": "exploit-storage-collision-write-up",
          "folderName": "47-exploit-storage-collision-write-up",
          "description": "",
          "duration": 7,
          "videoUrl": "nUr89KqK_kA",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/47-exploit-storage-collision-write-up/+page.md",
          "markdownContent": "---\ntitle: Exploit - Storage Collision - Write Up\n---\n\n# Debugging and Improving Your Solidity Code with Thunder Loan\n\nIn this blog post, we will take a closer look at how to test, debug and improve your Solidity code, using our Thunder Loan example. Solidity, for those who are less familiar, is a statically typed, contract-oriented, high-level language whose syntax is similar to that of JavaScript and it is designed to target the Ethereum Virtual Machine.\n\nLet's dive right into it.\n\n## Starting with the Git Checkout and Stashing Changes\n\nFirst, let's pull up our Thunder Loan test. After reviewing the code, it is advisable to stash your changes. Stashing is a great feature of Git that allows you to take a snapshot of your current changes, store them off to the side on a stack of unfinished changes, and then reapply them later.\n\nAfter stashing, I switch the currently active branch to 'demo' using git checkout command.\n\n## Understanding the Impact and Likelihood of Issues\n\nBefore wrapping things up, it is essential to consider the impact and likelihood of the issue in question.\n\nIn our current setting, the impact is high; primarily because the upgrade could potentially lead to what is referred to as a 'storage collision'; a serious problem whereby addresses of storage variables overlap, causing unexpected behaviours. These could inadvertently skew the fees associated with our Thunder Loan.\n\n![](https://cdn.videotap.com/MJYevuA6WF1Wcqj3AgIR-148.52.png)\n\nThe likelihood of this occurring can be medium to low. However, it tends to lean towards a higher likelihood considering that an upgrade was planned.\n\nThe key here is to understand your protocol's likelihood and impact of the storage collision issues, which is a very common pain-point when it comes to proxy contract upgrades.\n\n## Identifying the Root Cause\n\nA root cause analysis reveals that variable location mix-ups can result in storage collisions. In our Thunder Loan case, the problem arises in the _Flash Loan fee_ and the process of _Flash Loaning_. The severity of this problem means that it could potentially paralyze the entire protocol due to the storage location mismatches.\n\nAn example of wrongly mapped variable storage location is as follows:\n\nWhile for the upgraded contract, `thunderloanupgraded.sol`, the storage layout difference is slightly different:\n\nStorage location inconsistencies not only directly impact your protocol's modification, but they can also freeze up the protocol.\n\n## Potential Mitigations and Recommendations\n\nTo mitigate such an issue, it is recommended to maintain constant variables when removing and introducing storage variables.\n\n![](https://cdn.videotap.com/EsivAEC6dyzbBCAvtsGP-267.33.png)\n\nThis recommendation is based on the understanding that storage layouts are very important to the solidity coding structure ‚Äì modifying them could lead to unexpected errors.\n\nYou can compare the storage layout difference by running the commands:\n\nIf a storage variable must be removed, leave a blank to avoid messing up the storage slots. Here's what it would look like:\n\n## Wrapping Up\n\nIn this post, we have walked through not just the intricacies of debugging and improving solidity code, but also the complexities that proxy contracts introduce. It's no surprise that some developers see proxies as a necessary evil while others view them as progress in the smart contract sphere.\n\nWhether you side with the 'Bad News Bears' or 'Great Progress' team, we strongly encourage you to share your view in our ongoing community discussion!\n\nAs for our next step with Thunder Loan, that will largely consist of doing the reporting. Stay tuned for more updates in that regard. Happy coding until then!\n",
          "updates": []
        },
        {
          "lessonId": "0999f95c-f86e-4739-824d-8565169cfe2f",
          "number": 48,
          "title": "Wrapping Up",
          "slug": "wrapping-up",
          "folderName": "48-wrapping-up",
          "description": "",
          "duration": 2,
          "videoUrl": "xqD4VeRcAYg",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/48-wrapping-up/+page.md",
          "markdownContent": "---\ntitle: Wrapping Up\n---\n\n# Debugging and Improving Your Solidity Code with Thunder Loan\n\nIn this blog post, we will take a closer look at how to test, debug and improve your Solidity code, using our Thunder Loan example. Solidity, for those who are less familiar, is a statically typed, contract-oriented, high-level language whose syntax is similar to that of JavaScript and it is designed to target the Ethereum Virtual Machine.\n\nLet's dive right into it.\n\n## Starting with the Git Checkout and Stashing Changes\n\nFirst, let's pull up our Thunder Loan test. After reviewing the code, it is advisable to stash your changes. Stashing is a great feature of Git that allows you to take a snapshot of your current changes, store them off to the side on a stack of unfinished changes, and then reapply them later.\n\nAfter stashing, I switch the currently active branch to 'demo' using git checkout command.\n\n## Updating the Protocol\n\nNext, I paste our Proof of Concept (POC) into the current branch. For this, the Thunder Loan upgraded protocol needs to be imported from the respective source folder.\n\nThe code for this would look like:\n\nAt this point, a test run is required to ensure everything runs smoothly.\n\nThis command runs the test that we just added, confirming its successful implementation.\n\n## Understanding the Impact and Likelihood of Issues\n\nBefore wrapping things up, it is essential to consider the impact and likelihood of the issue in question.\n\nIn our current setting, the impact is high; primarily because the upgrade could potentially lead to what is referred to as a 'storage collision'; a serious problem whereby addresses of storage variables overlap, causing unexpected behaviours. These could inadvertently skew the fees associated with our Thunder Loan.\n\nThe likelihood of this occurring can be medium to low. However, it tends to lean towards a higher likelihood considering that an upgrade was planned.\n\nThe key here is to understand your protocol's likelihood and impact of the storage collision issues, which is a very common pain-point when it comes to proxy contract upgrades.\n\n## Identifying the Root Cause\n\nA root cause analysis reveals that variable location mix-ups can result in storage collisions. In our Thunder Loan case, the problem arises in the _Flash Loan fee_ and the process of _Flash Loaning_. The severity of this problem means that it could potentially paralyze the entire protocol due to the storage location mismatches.\n\n## Potential Mitigations and Recommendations\n\nTo mitigate such an issue, it is recommended to maintain constant variables when removing and introducing storage variables.\n\n![](https://cdn.videotap.com/MJYevuA6WF1Wcqj3AgIR-148.52.png)\n\nThis recommendation is based on the understanding that storage layouts are very important to the solidity coding structure ‚Äì modifying them could lead to unexpected errors.\n\n## Wrapping Up\n\nIn this post, we have walked through not just the intricacies of debugging and improving solidity code, but also the complexities that proxy contracts introduce. It's no surprise that some developers see proxies as a necessary evil while others view them as progress in the smart contract sphere.\n\nWhether you side with the 'Bad News Bears' or 'Great Progress' team, we strongly encourage you to share your view in our ongoing community discussion!\n\nAs for our next step with Thunder Loan, that will largely consist of doing the reporting. Stay tuned for more updates in that regard. Happy coding until then!\n",
          "updates": []
        },
        {
          "lessonId": "04952e33-4469-4ae7-8848-e964fc003ee4",
          "number": 49,
          "title": "Section 6 Recap",
          "slug": "section-6-recap",
          "folderName": "49-section-6-recap",
          "description": "",
          "duration": 6,
          "videoUrl": "m5ZGFbCOXNQ",
          "rawMarkdownUrl": "/routes/security/6-thunder-loan/49-section-6-recap/+page.md",
          "markdownContent": "---\ntitle: Section 6 - Recap\n---\n\n.\n\n## Unraveling the Flash Loans on Thunder Management Protocol\n\nFirstly, let's talk about flash loans, the key feature of the Thunder Management Protocol. Flash loans are innovative DeFi tools that allow users to borrow substantial amounts of assets for one single transaction. They have gained prominence due to their significant use in arbitrage opportunities, previously only utilized by prolific investors, fondly known as 'whales'. With flash loans, however, anyone can seize these golden opportunities.\n\n![](https://cdn.videotap.com/XdZhyn8C3rqPpi7yPlNe-50.31.png)\n\n> \"Flash loans are phenomenal DeFi primitives turning anyone into a whale.\"\n\nAs security researchers, we recognize the importance of understanding top protocols like Aave and Compound. This foundational knowledge provides us with necessary context for quicker and more efficient future project comparisons. Moreover, we've realized using an AMM(Automated Market Maker) or a DEX(Decentralized Exchange) protocol as a pricing oracle is a poor choice. Instead, a decentralized price feed like Chainlink should be on your go-to list for robust and secure oracle solutions.\n\n## Shedding Light on Proxies and their Risks\n\nWe discussed the significant implications of utilizing proxies in contract development, particularly UUPS(Upgradable Unambiguous Proxy Standard). Proxies can lead to dreaded risks such as centralization and storage collisions if not handled carefully. However, our discussion did not extensively cover the transparent proxy or the multi-faucet proxy‚Äîimportant topics available for further research.\n\n![](https://cdn.videotap.com/rq3TwsRcnxoecVEB3Kir-138.35.png)\n\nOne intriguing topic we brushed upon is 'malicious scope'. Sometimes, while auditing a codebase, a protocol might ask you to ignore auditing a certain part. Interestingly, that often is the part housing the rug pull. As analysts, it's important to snuff out such malicious intentions. If you keep missing the red flags and all audited projects end in rug pulls, it reflects poorly on your auditing abilities. At the very least, all potential risks should be plainly stated in the audit report, serving as a potential alarm for the readers.\n\n## Introduction to Useful Tooling and Strategies\n\nExploring some handy tools, we touched briefly upon Upgrade Hub, a powerful tool highlighting how often protocols have undergone silent upgrades‚Äîsome rather misleading ones, though. In addition, we dug into some fascinating exploits, especially the infamous failure to initialize contracts. Important note: always ensure contracts you're analyzing or designing have a method deployed to authenticate contract initializations.\n\n![](https://cdn.videotap.com/WZFqXvkBGJ6wgC3VdPJ0-188.65.png)\n\nTalking about the infamous Oasis case study, it served as a prime example demonstrating the repercussions of protocol centralization, reminding us of the potential rug pull danger lurking beneath the surface of centralized architectures. Remember to signal such major centralization risk in your audit reports.\n\nAnother important topic was Oracle and price manipulations. A considerable number of Oracle manipulation attacks pose high risks, reinforcing our advice not to use an AMM as your pricing Oracle.\n\nWe concluded our section with design patterns, aiding in understanding the underlying operational concepts in smart contract development.\n\n## Concluding Remarks and How to Move Forward\n\nAdmittedly, this section is information-dense and might seem confusing at first glance. However, remember to interact with fellow developers, share insights, ask questions, and contribute to discussions on platforms such as our Cypher Updraft community. You‚Äôll find yourself gradually familiarizing with the concepts, making them seem less daunting.\n\n![](https://cdn.videotap.com/aXjjMtL66bz5IgquDe55-264.12.png)\n\nOnwards, we're heading to section seven, offering riveting insights about Boss Bridge and its inner workings. It's going to be an intriguing journey into Yul and Assembly's realm‚Äîan important break from our previous section.\n\nA massive thank you to everyone following along on this informative journey. Your perseverance and eagerness to learn have made this adventure fun and informative, equally. Remember, it's okay to take a breather, get some coffee, maybe go for a good workout, rest, and come back ready to dive deeper into this fascinating world of blockchain and smart contracts.\n\nOkay then, are we ready to dive into section seven? Great! Let‚Äôs begin our exploration.\n\n![](https://cdn.videotap.com/i3PPe1YFwpZgqTiGNVBF-314.42.png)\ns\n",
          "updates": []
        }
      ]
    },
    {
      "sectionId": "3753a05a-5de5-4b4b-9766-5e1a75eb1d73",
      "number": 7,
      "title": "Boss Bridge",
      "slug": "bridges",
      "folderName": "7-bridges",
      "lessons": [
        {
          "lessonId": "0f5c515e-a28a-4a32-abcc-1e81b432b1b8",
          "number": 1,
          "title": "Introduction",
          "slug": "part-intro",
          "folderName": "1-part-intro",
          "description": "",
          "duration": 5,
          "videoUrl": "WZSwgk4oi7I",
          "rawMarkdownUrl": "/routes/security/7-bridges/1-part-intro/+page.md",
          "markdownContent": "---\ntitle: Introduction\n---\n\n\n\n---\n\n# Unveiling Section Seven of Security and Auditing EVM DeFi: A Comprehensive Security Review\n\nWelcome back, enthusiastic coders! Brace yourselves for an exciting deep dive into Section Seven of the Security and Auditing EVM DeFi. In this intriguing space, we are going to roll up our sleeves and immerse in not less than five detailed security reviews or audits. Stay tuned for more in part two as well.\n\n## Flashback to Thunder Loan\n\nWe have recently waved goodbye to the thrilling Thunder loan security review and audit, an eye-opener in the world of Decentralized Finance (DeFi). The concept explored here, ranging from flash loans to Oracle manipulation encapsulates the primary attacks presently haunting DeFi.\n\n![](https://cdn.videotap.com/j6Dr40RzmumPq9jhPJY3-36.13.png)\n\n### New Concepts Unfolded\n\nOur journey shed light on a multitude of aspects essential for better understanding the DeFi landscape, including price Oracle manipulation, reward manipulation, insufficient function access control, and a gamut of logic errors, function parameter validation, misconfigurations and reentrancies.\n\nWhile these are considerable advancements, we are yet to uncover every crevice of the DeFi sphere. More obscure areas, such as governance attacks and stolen private keys, are yet to be traversed. Fortunately, we will unveil these mysteries and delve deeper into the riveting world of DeFi security in this seventh chapter.\n\n## Sneak Peek into Section Seven\n\nPrimarily, we will scrutinize the Seven Boss Bridge audit code base, currently available for the first flight on the [CodeHawks platform](https://www.codehawks.com).\n\n![](https://cdn.videotap.com/LLXHIyWzga7BHJru6Wjv-90.31.png)\n\n### The Power of CodeHawks\n\nRemember, reading and evaluating security reviews is an effective way to level-up your skills. If tech-upscaling piques your interest, Code Hawks curates a vast array of first flights that are worth exploring. Furthermore, signing up for CodeOx posts and participating in competitive audits can be quite advantageous.\n\n### Repo Overview and Tooling Upgrades\n\nExploring this chapter's repo, we will first notice two conventional branches: `main` and `audit data`, where `audit data` hosts the answer keys (no peeking!).\n\nWe will explore varying Ethereum Virtual Machine (EVM) chains such as Arbitrum, Optimism, ZKSync, and Ethereum. We will ponder whether these are analogous or have unique features that set them apart.\n\nFurthermore, we will explore tools, Tenderly and Solidit, which will aid us in streamlining our code review process.\n\n### The Hans Checklist: A Systematic Approach to Coding Reviews\n\nNext, we delve into a novel system for conducting smart contract security reviews: the Hans Checklist.\n\nTowards the end of this section, we'll break down Hans' trend-setting checklist methodology, which helped him ascend to the rank of top competitive auditor globally for the first half of 2023.\n\n## The Classic Security Review Steps and Exciting Case Studies\n\nAs before, we will follow the classical method for security reviews, incorporating scoping, reconnaissance, vulnerability identification, writeups, and reporting. We will also look at the intriguing case studies based on various chains, including Polygon, ZK Sync, and how different chains actually work with different opcodes.\n\nIn this part, we will focus more on bridge hacks as these were rampant in the year 2022. Most bridge hacks we noticed unfortunately happened due to centralized controls and the loss of private keys, leading to bizarre exploitations.\n\nWe will also study several exciting exercises that include researching some attacks and doing write-ups on them. Some significant aspects would be Signature Replay, merkel tree, signature issues, polygon double spend, and nomad bridge hack.\n\n## Onwards with the Contract Scoping Phase\n\nFinally, after discussing the technicalities, we will commence with the scoping phase of the contract that will be considerably quicker this time. Following the scoping, we will move on to the actual security review of the contract.\n\nRemember, there are conceivably more issues than we cover. Thus, if you stumble across some extra issues, don't hesitate to share your insights!\n\nBrace yourselves‚Äîwith all that we have in store, we're sure to add significant value to your coding and auditing skills, inspiring you to dive deeper into the mesmerizing world of coding.\n",
          "updates": []
        },
        {
          "lessonId": "d52feb22-38e1-4616-b8e6-274c58a892b6",
          "number": 2,
          "title": "Phase 1: Scoping",
          "slug": "phase-1-scoping",
          "folderName": "2-phase-1-scoping",
          "description": "",
          "duration": 6,
          "videoUrl": "FKFU43o4U-8",
          "rawMarkdownUrl": "/routes/security/7-bridges/2-phase-1-scoping/+page.md",
          "markdownContent": "---\ntitle: Phase 1: Scoping\n---\n\n_Follow along with the video lesson:_\n\n\n\n---\n\n# Kick-starting our Security Audit: The Boss Bridge Project Case Study\n\nIn this extensive blog post, we're going to dive into the world of security auditing, using an example project: Boss Bridge. We'll begin in a familiar place, assuming you've just downloaded the project through GitHub, opened a fresh VS Code window, and you're ready to explore.\n\n## Getting Started: The Importance of Pre-boarding\n\nWhen auditing any project‚Äôs codebase, a key step in your preparation should be notetaking: scribbling down your thoughts, ideas and key points in your 'notes' section or equivalent. Think of it as your own personal checkpoint system.\n\nAs you delve further into the codebase, your entity list should grow into a robust compilation. This helps keep track of vulnerabilities, concepts to revisit, and potential threat vectors that could minimise attacks. Just like a detective unravelling the clues, your notes provide the foundation of a thorough investigation.\n\n## Understanding the project scope\n\nOnce you've downloaded the code, the next step is to determine the overall project scope. Begin by investigating the 'src' folder, opening the README file, and understand its core facets.\n\n![](https://cdn.videotap.com/Z6FwLQhDRCyW6ZPk1OQ4-80.11.png)\n\nTo determine the full extent of the project, you'll need to scrutinize the audit scope details particularly. Here, you'll uncover details of the commit hash, the contracts and tokens, any unusual behaviors, and even the expected deployment chains.\n\n### Holler Out for More Information\n\nDon't hesitate to reach out if you need additional data. Developing a comprehensive understanding of this project is pivotal, and while speed is critical, you want to ensure you aren't missing critical elements. Request more diagrams, data, and subsequent supporting information as needed.\n\n### An Overview of the Contracts\n\nFrom our initial study, we gather that our contracts will deploy to the Ethereum Mainnet. Interestingly, we're deploying a new entity, `tokenfactory.sol`, for the first time to ZKsync era.\n\n![](https://cdn.videotap.com/SYHd0AD9SPTDOeE3c8j6-148.78.png)\n\nYou will notice several roles or 'actors', one of which has the authority to pause and unpause the bridge in event of an emergency - a common design pattern known as the Emergency Stop pattern.\n\n## Acknowledging known issues\n\nFrom the outset, it's evident that there's an element of centralization with the project. This sort of authority vested with an individual or a single entity has its own pros and cons. On one hand, it's beneficial for effective and quick resolution of discrepancies. On the other, it tends to undermine the fundamental principle of blockchain's decentralization. However, such centrality aspects could be disregarded in a competitive audit.\n\nUpon further review, we notice that zero-address checking seems to be intentionally disabled, presumably to save gas. Also, there are some magic numbers that, instead of being recognized as constants, have been distinguished as literals.\n\nDespite these hiccups, it's clear that the protocol has a decent understanding of 'weird ERC20s'. They've incorporated `make slither` and `make aderyn` into the codebase as tools, key signs of protocol's awareness towards security.\n\n## Checking Code Coverage\n\nTo get an idea of the code coverage, we need to install the necessary libraries and run `forge coverage`. While our coverage might not be exhaustive, it could be considerably better. The `tokenfactory` is fully covered. However, the `vault` entity misses out entirely, which might result in several attack vectors.\n\n![](https://cdn.videotap.com/gS0LrDyx1XBys7mxdaUB-240.33.png)\n\nIn such scenarios, stateful fuzzing test suites could compensate for the shortcoming in manual reviews. At the moment, this approach is increasingly becoming a standard requirement for security.\n\n## Running Solidity Metrics\n\nFinally, as part of your project scope, remember to run a couple of tools ‚Äì even if it blurs into vulnerability identification. This instance of the project has a complexity score of 106 and 101 lines of code ‚Äì nearly half the size of the Thunder Loan project, which makes it quite simple to work through.\n\nWith this comprehensive understanding of the README and documentation, it's time to start your reconnaissance. From here on, with the context you've gained from the project scope, you're ready to probe further and uncover potential vulnerabilities and exploits.\n\nHappy auditing!\n",
          "updates": []
        },
        {
          "lessonId": "846a626f-c44a-4167-9988-cdaedce16969",
          "number": 3,
          "title": "Phase 2: Recon",
          "slug": "recon",
          "folderName": "3-recon",
          "description": "",
          "duration": 2,
          "videoUrl": "RKjx1wGuUco",
          "rawMarkdownUrl": "/routes/security/7-bridges/3-recon/+page.md",
          "markdownContent": "---\ntitle: Recon\n---\n\n\n\n---\n\n# Static Analysis of Ethereum Smart Contracts\n\nOne of the first steps in smart contract auditing involves the use of static analysis tools. These tools can scan your codebase and identify potential issues such as vulnerabilities, bugs, or deviations from best practices. This blog post will provide a detailed walkthrough of static analysis, using `make slither` and `make aderyn` commands as primary examples of tools that we can use.\n\n## Reading The Documentation\n\nThe first step on this journey of static analysis will always be reading the documentation of the tool that you want to use. Why is this? Because it will help you understand the full capabilities of these tools. Despite this, the documentation step is often overlooked, so do remember to pay special attention to it.\n\nToday, however, after a quick glance over the user manual, I am eager to dive straight into the codebase. Brace yourself for some adventurous code auditing!\n\n## Running Static Analysis Tools\n\nIn this scenario, I've decided to start by running my static analysis tools.\n\n![](https://cdn.videotap.com/WV5JlvHe6ylxiE7aFko2-12.35.png)\n\nThe command to initiate the process is `make slither`. This should be run as a baseline test for any codebase under scrutiny. As devs, it's our responsibility to ensure a codebase complies with best practices.\n...\nIt turns out the codebase is riddled with issues. But no worries ‚Äì this is what we signed up for. Let‚Äôs dive deeply into these issues shortly.\n\nNext, it's time to run the `make aderyn` command to get a secondary report:\n\n## Analyzing the Report\n\nNow we have the `report.md` ready. Time to examine its findings.\n\n![](https://cdn.videotap.com/l0Mt9wevI06wPhE5FmZS-38.8.png)\n\nA sneak peek into the report reveals some medium-grade issues. Let's examine them closely:\n\n- **Centralized Risk** - The contract has a centralized risk problem. Despite the fact that blockchain was built on the pillars of decentralization, many developers fall into the trap of creating contracts that rely on central authority.\n- **Unsafe ERC20 operations** - The contract uses unsafe ERC20 operations. This is a big no-no.\n\n> \"ERC20 operations should not be used. The return values are not always meaningful. It is recommended to use [OpenZeppelin's SafeERC20 library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol)\".\n\n- **Missing zero address checks** - The contract does not have zero address checks.\n- **Functions could be marked external** - There are functions which are not used internally, these could be marked external which could save some gas.\n- **Undefined constants** - The contract uses magic numbers instead of defined constants.\n- **Incorrect events** - Events in the contract are not defined correctly.\n\nThe report from Aderyn is full of useful insights. They will all be copied and pasted into their rightful sections in the final report.\n\n## Reconnaissance\n\nFinally, it's time for reconnaissance. I pondered over whether to do the `Tincho`, which analyzes the contracts from the least to the most complex. Since there are only four contracts, I opted to forgo creating a new sheet for documentation.\n\nStay tuned for further posts to unveil the specifics of each of these issues, and the steps taken to mitigate them.\n",
          "updates": []
        },
        {
          "lessonId": "79941ec5-6897-46fd-a326-69e439282e2c",
          "number": 4,
          "title": "Checklist",
          "slug": "checklist",
          "folderName": "4-checklist",
          "description": "",
          "duration": 2,
          "videoUrl": "4vcHCgsfkpk",
          "rawMarkdownUrl": "/routes/security/7-bridges/4-checklist/+page.md",
          "markdownContent": "---\ntitle: Checklist\n---\n\n\n\n---\n\n# The Ultimate Auditor‚Äôs Checklist Method: The Hans\n\nHave you ever wondered about the techniques that a talented and successful auditor uses (like the No.1 Web3 auditor, Hans), to keep everything organized? Well, wonder no more. Today, we are going to discuss an important tool Hans uses, a highly comprehensive checklist that we will explore here. The information might astonish you, so now is the time to buckle up for an Audit Adventure.\n\n![](https://cdn.videotap.com/tXeWNgj1dZEkapH1ksfB-13.48.png)\n\n## The Power of a Checklist\n\nThe power of a checklist lies in the precision it can bring to a potentially massive process. By breaking down what might otherwise feel like a daunting task into structured and doable segments, checklists allow us to tread with confidence. Entertainment tech giant GitHub has embraced this approach by maintaining a repository-driven checklist entitled \"audit checklist\" for performing code audits.\n\n> The checklist is part of an extensive repertoire of different attacks complete with links to Solidit, where these attacks have been reported, their implications and much more. Initially, it is in the JSON format, but will soon be hosted on Solidit for an enhanced user-friendly experience.\n\nYou can view and utilize this effective tool [here](https://github.com/Cyfrin/audit-checklist).\n\n![](https://cdn.videotap.com/Os7tDGbFK1OTvjjccMdx-60.68.png)\n\n## Diving into the Checklist\n\nThe checklist dives instinctively into an attacker's mindset and focuses on a list of general checks for common attack types. Each section is meticulously designed to guide you through the audit process, complete with descriptions, remedial advice, references to potential attacks, and tags.\n\nFor instance, a section on \"Reentrancy Attacks\" includes questions you might ask to verify a system is safe from this category of assault. Questions like: \"Are there any state changes after interaction with an external contract?\" guide the process strategically.\n\nThe checklist covers other types of attacks, such as:\n\n- Denial-of-Service\n- Griefing Attacks\n- Replay Attacks\n\nThe FAQ format ensures you‚Äôre doing your due diligence when evaluating a protocol. For example, under denial of service, you could inquire \"Is the withdrawal pattern followed to prevent denial of service?\" or scrutinize how the protocol manages tokens with blacklisting functionality ‚Äì a point we have touched on before.\n\n## Making It Your Own\n\nOptimizing this checklist to suit your needs will help you make the most of it. You can do this by visiting the [Cyfrin GitHub audit checklist](https://github.com/Cyfrin/audit-checklist) and tweaking the JSON format to suit your preferences. The inclusion of your ideas not only makes the checklist more usable but also contributes to the creation of a collective knowledge base that benefits everyone.\n\n![](https://cdn.videotap.com/ndm5LlDWEj2Gnsr6ADqz-148.32.png)\n\n## Going Beyond the Given\n\nThe nature of our industry means the checklist isn‚Äôt definitive. New issues and challenges come up that might not be covered by the current framework.\n\nTherefore, this checklist remains a living document, one which requires continuous updating and refining. This could mean adding new issues to your list or making a pull request to include new questions that arise during the audit process.\n\n## Conclusion\n\nSo there it is, the Auditor's Checklist Method by Hans. The roadmap to auditing a project, checking off every potential security vulnerability, ensuring that the protocol follows best practices.\n\nRemember, the best use of this checklist comes not only from following it but also in reflecting upon its points and amalgamating your insights into it.\n\nHappy auditing!\n\n![](https://cdn.videotap.com/B8DVGbPuHxUALaBDmvYC-202.26.png)\n",
          "updates": []
        },
        {
          "lessonId": "925e54df-38a4-466f-8c04-b7cabf3f39ce",
          "number": 5,
          "title": "Docs",
          "slug": "Docs",
          "folderName": "5-Docs",
          "description": "",
          "duration": 2,
          "videoUrl": "CYFBEMBKSe0",
          "rawMarkdownUrl": "/routes/security/7-bridges/5-Docs/+page.md",
          "markdownContent": "---\ntitle: Docs\n---\n\n## \n\n# Bridging the Gap: Introducing Boss Bridge for ERC20 Tokens\n\n![](https://cdn.videotap.com/7JrqjCcxUyOafjUdWM9V-11.74.png)\n\n## How Does Boss Bridge Work?\n\nIn essence, the key function of our Boss Bridge is providing a pathway for users to deposit their tokens. Upon deposit, these tokens are stored securely in an L1 digital vault. The deposit event triggers a subsequent off-chain event which our mechanism discerningly picks up, parses it, and then mints the corresponding amount in L2.\n\n> Remember: The main goal here is ensuring user safety and security.\n\nThe first version of the bridge adheres strictly to this ideal and includes several security features.\n\n## Key Security Features\n\nThe current version of our Boss Bridge boasts multiple mechanisms aimed at enhancing the security of deposited tokens:\n\n1. The bridge owner has full authority to pause any operations during emergent situations.\n2. Account deposits are permissionless, but to avoid any potential abuse, we have imposed a strict limit on the number of tokens that can be deposited.\n3. All withdrawal requests must be approved by the bridge owner.\n\nWe are focused on continually improving this system, making it even safer and more secure with each update.\n\n![](https://cdn.videotap.com/DSoIzu6Rtt37d8MackPQ-55.77.png)\n\n## The Launch\n\nWe are preparing to launch our L1 Boss Bridge on both the Ethereum Mainnet and ZK Sync platforms. Initially, we will use only L1 tokens, or their duplicates, within the bridge system.\n\n**Please note**: At this early stage, other ERC20 tokens will not be supported, and their 'weirdness' is considered out of scope on withdrawals.\n\n## Withdrawal Process\n\nIn the context of withdrawals, the bridge operator holds the responsibility of signing each withdrawal request submitted by users. These requests are made on the L2 component of the bridge.\n\nEssential point to mention: For a successful withdrawal, our service will check that the account submitting a withdrawal previously initiated a successful deposit on the L1 part of the bridge.\n\n![](https://cdn.videotap.com/oRDUILrsz7wMudIoZwVx-76.32.png)\n\n## Making Sense of the Boss Bridge\n\nIf this seems a bit overwhelming, it is natural. This is where you might be getting the urge to delve into the protocol design, or you might want to explore the contract and draw up some diagrams on your own.\n\nIn either case, these are healthy steps toward understanding the mechanism better. For those willing to roll up their sleeves and create some diagrams, we encourage you to pause right here, grab your notebook, and start sketching. It's a great learning experience!\n",
          "updates": []
        },
        {
          "lessonId": "5328d856-613d-444a-9ecd-2a5955ae342e",
          "number": 6,
          "title": "Boss Bridge Diagram",
          "slug": "boss-bridge-diagram",
          "folderName": "6-boss-bridge-diagram",
          "description": "",
          "duration": 6,
          "videoUrl": "F5Qap3cnz8I",
          "rawMarkdownUrl": "/routes/security/7-bridges/6-boss-bridge-diagram/+page.md",
          "markdownContent": "---\ntitle: Boss Bridge Diagram\n---\n\n\n\n---\n\n# Understanding Bridges in Ethereum and ZK Sync with Audit Data\n\nHello, everyone! If you've been scrolling through the audit data section of our Git repo, you might have noticed a sketch of the L1-L2 Bridge structure used for transactions, meant to illustrate contract creation and token execution. Let's go through it together!\n\n## The Bridge Structure\n\n![](https://cdn.videotap.com/rIxjCdQQCX2uJutT8w6U-12.43.png)\n\nAs you can see from the image, on the left of this dotted line, we have contracts on the Layer One (L1), while on the right side you can see the contracts yet to be built -- for now, they are only imaginary. They will exist in the future on Layer Two (L2).\n\nThe L1 is where we focus most of our attention. Why? Because this is where we have the Tokenfactory.sol - a pivotal contract whose sole function is to deploy L1 tokens.\n\n### The Role of the Tokenfactory\n\nThe `tokenfactory.sol` is a simple and minimal contract. It's ownable, comes with mappings, and you'll notice it has just one function - `deployToken`. This function deploys a new ERC20 token contract, accepting the contract bytecode as input.\n\n```js\nfunction deployToken(bytes memory bytecode) public onlyOwner returns (address){\n    return _deploy(bytecode);\n    }\n```\n\nThough it is noteworthy that deploying any contract can be hazardous, we'll assume that the `tokenfactory.sol` will correctly hold a copy of the L1 token contract bytecode and not any malicious ERC20.\n\n> - _\"We should note that you can potentially deploy anything with `deployToken()`, which isn't ideal.\"_\n\nYes, as unsettling as it might sound, this token factory could technically deploy any contract. But bear in mind, this is an accepted caveat that was already addressed in the known issues section of the documentation. We will not dwell much on this, as it is within the scope of the project, and any other issue arising would fall out of scope.\n\n### L1 Token - The Bridge\n\nMoving on, we have the `L1Token.sol`. This is a very minimal L1 token with a max supply named Boss Bridge Token (BBT). Its sole purpose is to journey between the L1 and the L2. For instance, your L1 could be something like ETH, and the L2 might be ZKSync, or vice-versa.\n\n![](https://cdn.videotap.com/j1ojbfHNdYgSRmp6YI6u-111.91.png)\n\nIt is important to note that L1 entities will be present on both Ethereum and ZKSync irrespective of the labeling.\n\nThen we have the main contract known as `L1BossBridge.sol`, responsible for facilitating the core operations of the system.\n\n### L1BossBridge - The Main Contract\n\nThe `L1BossBridge.sol` contract has a substantial role and a few capabilities. It can pause and unpause, illustrating some centralized power. Most crucially, it permits users to deposit tokens to L2 and withdraw tokens from the L2 back to the L1.\n\n```js\nfunction sendToL2(address _l2Delegate, address _token, uint256 _amount, uint256 _l2Gas, bytes calldata _data) external whenNotPaused returns (bytes memory){\n    /* (...rest of code...)*/\n}\n```\n\nThe `sendToL2()` function deposits token to L2. Once tokens are sent, they are locked into `L1Vault.sol`. This vault is relatively simple and doesn't really do much other than holding onto the L1 tokens approved by the Boss Bridge.\n\n### How Tokens Travel Between Layers\n\nWhen the Boss Bridge signals, the vault releases the tokens. This mechanism allows tokens to be sent from an L1 to an L2. In practice, if we send 10 tokens into the vault from the L1, these 10 tokens locked into the L1 vault aren't directly transferred to the L2.\n\nInstead, they are locked in another vault on the L2 side, triggering the system to release an equivalent number of tokens (in this case, 10) on the L2. This process of locking and releasing is observed and controlled by a centralized off-chain service.\n\nTo keep this a touch simpler and less technical, bridges usually work this way. You don't transmit tokens directly over the L1. Instead, you lock them into a vault, and the L2 produces an identical version of the token for you to use.\n\nThe final piece of this process involves tokens on L2 being relocked into the L2 vault. These Signers, the centralized units noteworthy for their crucial role, will approve the tokens to be unlocked on L1 again.\n\n```js\nfunction unlockL1(address _l2Delegate, address _token, uint256 _amount, bytes calldata _data) external whenNotPaused returns (bytes memory){\n    /* (...rest of code...)*/\n    }\n```\n\n### The Key Role of Signers\n\nSo these Signers are important because they see who's depositing to either layer and decide when to unlock or relock tokens. As valuable as this function is, it is also an embedded known issue with the protocol due to its centralized nature.\n\nOnce a token in L1 gets locked in the vault, it's liberated to roam in L2. Reversibly, when you lock it back into the L2 vault, Signers get a signal, and the tokens from L1 vault are released.\n\nI hope this makes sense. I hope this helps you understand how the bridge between layers work. If you have any further questions, feel free to drop a comment, and I'll be happy to help!\n",
          "updates": []
        },
        {
          "lessonId": "46830858-6899-4cd0-92df-d010c0f5e01c",
          "number": 7,
          "title": "L1 Token",
          "slug": "l1-token",
          "folderName": "7-l1-token",
          "description": "",
          "duration": 2,
          "videoUrl": "nMraeBRAiIs",
          "rawMarkdownUrl": "/routes/security/7-bridges/7-l1-token/+page.md",
          "markdownContent": "---\ntitle: L1Token.sol\n---\n\n\n\n---\n\n# Diving Deep into the Trenches with Solidity Code\n\nToday, we are armed with an abundance of context, which provides us with a fortified understanding of what this code base embodies. Let's begin!\n\n## Invoking the \"Tincho\"\n\n![](https://cdn.videotap.com/KbfZIIwRu0i6v3I4hHUH-9.1.png)\n\nWe're going to invoke the Tincho method in our exploration - starting with the little ones and progressively getting bigger, like a well-ascended staircase of understanding. And don't worry, we'll make sure to go through a checklist at the end to ensure we've covered all bases.\n\n## Descending to the Code Depths\n\nOur first stop? The smallest code base in our array of documents. Hop onboard, as we open up the file for `Solidity metrics` and navigate towards the seemingly insignificant number seven, `L1Token.sol`. A little intimidating, isn‚Äôt it? But fear not, we‚Äôre just about to dive deep and decipher this \"Bad Larry\".\n\n## Finding the Unexpected in the Expected\n\nUpon inspecting `L1Token.sol`, we find quite a regular landscape - not particularly striking with nothing out of the ordinary. But let's not rush our judgment.\n\nWe're leveraging codes from `OpenZeppelin`. As veterans in this field, we‚Äôre well acquainted with `OpenZeppelin`.\n\n```js\nprivate constant initial_supply;\n```\n\nPrima facie, we encounter a private constant initial supply which seems appropriately allocated. It's multiplied by the decimal representation of ten - a magic number by a certain perspective but just a ten, hence, no alarm bells ringing.\n\n## Unravelling the Tests\n\nDiving deeper, we look for a deploy. Unfortunately, this section seems to be lacking a dedicated deployment component in its structure. There's a `token factory test`, but the sight of `L1Token` tests is scarce.\n\nBut wait, there's a silver lining! There are indeed a few tests conducted on the `L1Token`. For instance, we have a token transfer test.\n\nThis token is utilised in the transfer process, and it seems to deploy a brand-new token. Once again, nothing screams out of place - everything seems quite standard here.\n\n## Final Words\n\nAfter scrutinizing `L1Token.sol`, it appears quite compliant with standard solidity coding practices. Following the Tincho approach has led us to meticulously dissect this small piece of code, to such an extent, that we can confidently say - \"this looks fine\".\n\nContinuing on this journey, we will employ the same procedure to the next segment of the code. Embark on this journey with us as we delve into the eccentric and challenging world of software development, one line of code at a time.\n\n> \"The job of the coder is not just to code. It is to understand and then code.\" - Anonymous Developer\n",
          "updates": []
        },
        {
          "lessonId": "5ac83da6-7426-4962-99c5-4bf246942eff",
          "number": 8,
          "title": "Vault",
          "slug": "vault",
          "folderName": "8-vault",
          "description": "",
          "duration": 4,
          "videoUrl": "0vsRnilzIMA",
          "rawMarkdownUrl": "/routes/security/7-bridges/8-vault/+page.md",
          "markdownContent": "---\ntitle: Vault.sol\n---\n\n\n\n---\n\n# Dive into the L1 Vault of TokenBridge\n\nIn this post, we're going to explore the innards of the Layer 1 (L1) vault, a critical part of the TokenBridge, a network built for token transfers between different blockchain networks.\n\n## The Role of the L1 Vault\n\nTo kick things off, the L1 Vault is essentially a storage box for tokens. It holds tokens when they're not being used or transferred on either L1 or Layer 2 (L2) networks. When needed, these tokens can be unlocked to \"frolic and play\" on the L1 or L2 playgrounds.\n\n![](https://cdn.videotap.com/SPq2DMS4BIdTLOfpIdi6-22.67.png)\n\nLet's dive deeper into the vault itself.\n\n## An Introduction to L1 Vault Structure\n\nThe L1 Vault, as expected, is slightly larger in size but not too big to handle. The vault is 'ownable', meaning it can have designated owners - this could be an individual, a group, or another contract.\n\nThere's a descriptor (NatSpec) on top that indicates the author's identity - Boss Bridge. According to the NatSpec, the contract has two primary responsibilities: locking and unlocking tokens on the L1 or L2, and giving the green light to a bridge so it can move funds to and from this contract.\n\nThe owner of this contract, the note says, should ideally be a bridge.\n\nAnd this sparks off our first question: can we somehow tweak it so that the owner is not the bridge?\n\n## Deployment of the L1 Vault\n\nHowever, the folks at TokenBridge seem to be missing a deploy folder, which is definitely something worth mentioning. How would you deploy your contract without a deploys directory? This could certainly improve.\n\nWe then dig further into how they launch the vault. They've got an initiation sequence where the vault is equated to 'tokenbridge.vault‚Äô, which seems to suggest that the Boss bridge itself is deploying the vault.\n\nTaking a closer look at the L1 Boss Bridge, this assumption is confirmed - the 'vault' is a public, immutable value. It is set to be the 'vault' address during the deployment process, which means there is likely no failure-to-initialize issue here.\n\n## Understanding Ownership in the Contract\n\nNext, we come across the apparent fact that the L1 bridge is ownable. This isn't surprising. A constructor prepares an IERC20 token (a standard interface for tokens within smart contracts). It's worth noting that each vault seems to be working with one token and one bridge.\n\nThe constructor of the contract appears perfectly reasonable. The 'ownable' entity will be message.sender (which will be the Boss bridge). The core purpose of the `approveTo` function seems to be that the bridge is authorized to move funds in and out of the vault.\n\nHowever, one detail stands out - the approval isn't hardcoded to the bridge, but can potentially be granted to anything, which could pose a security risk.\n\n```js\n    function ApproveTwo(address _target, uint256 _amount) external onlyOwner {\n        Token.approve(_target, _amount);\n        }\n```\n\nThese are some initial observations and insights on the L1 vault in the TokenBridge contract. Despite some minor concerns and potential areas for improvement, the contract seems to be well structured and efficient. Up next: exploring Solidity metrics and how they affect the contract.\n\n> \"Each vault works with one token. That's good to know.\"\n",
          "updates": []
        },
        {
          "lessonId": "a7b76821-b434-4f46-ad93-ae8be1a72ed8",
          "number": 9,
          "title": "Yul Opcodes",
          "slug": "yul-opcodes",
          "folderName": "9-yul-opcodes",
          "description": "",
          "duration": 3,
          "videoUrl": "GATOg1lX974",
          "rawMarkdownUrl": "/routes/security/7-bridges/9-yul-opcodes/+page.md",
          "markdownContent": "---\ntitle: Yul & Opcodes Introduction\n---\n\n\n\n---\n\n# How to Inspect Solidity's Token Factory\n\nHey there! Ready to check out some code today? Awesome, let's do this. I hope you're as excited as I am. Let's first check our vault. Looking good! Our token also seems perfectly fine. Now, what‚Äôs next?\n\n## Token Factory Complexity Score\n\nThe next on our list is something with a complexity score of 23. It's the intriguing Solidity contract called `TokenFactory`. Referring to the title, the `TokenFactory` is designed to allow the owner to deploy new ERC20 contracts.\n\nFor clarification, a complexity score is a numerical value that represents the complexity of code. The higher the score, the more complex the code is. It‚Äôs a great tool for identifying areas in your software that could benefit from refactoring to simplify the code and make it easier to maintain.\n\n`TokenFactory` is intended to be deployed on both an L1 and L2 Ethereum layer. Sounds interesting, right?\n\nLet's dive deeper into this 'Token Factory' contract.\n\n![](https://cdn.videotap.com/N7h8lDL4ZkNHmMUJm92I-16.6.png)\n\n## Analyzing The Token Factory Contract\n\nAccording to the documentation, the `TokenFactory` allows you to deploy a new ERC20 contract by passing it a symbol and the byte code of the new token. The symbol and byte code represent the identity of the new token that we want to deploy.\n\nA portion of the code that specifically interests me is the assumption that this is going to be an L1 token byte code. Just the thought of this seems a tad scary.\n\nOne question pops in my head: \"Did they even test this assumption anywhere?\"\n\n![](https://cdn.videotap.com/SXAsB2ew8qmWRUaZnRI6-37.94.png)\n\n## Checking The Test Method\n\nAh! They did. I see that there is a `TokenFactory` test. Now, it‚Äôs critical to remember that we are assuming the test is accurate. Although tests can contain errors too, they give us a good sense of how the software behaves under certain conditions.\n\nWhile the complexity score was discomforting and the code adherence was quite scary to me, the presence of this test somehow eases the discomfort.\n\nHowever, there's a \"Q\" marked on the code here which means \"Query\". It marks a place where the reader has questions or doubts about the code. In this case, it might be fine, but it begs the question - \"Should this query be left out of scope?\"\n\nTo be blunt, there just seems to be some risky business here.\n\n## An Auditor‚Äôs Perspective\n\n‚ÄúAre you sure you should leave this out of scope?‚Äù, I find myself asking. Even though the guidelines say it's okay to exclude this in a competitive audit, in a private audit, I would still strongly recommend addressing this.\n\n> \"You should really secure this code. There might be better ways to implement it.\"\n\nRemember, it's always crucial to double-check everything in your code, especially when it comes to security. Don't take things at face value.\n\nOne of the points that catch my attention is that it doesn't seem efficient. The byte code is stored in memory rather than in call data, which is less gas efficient. Maybe it would be better to refactor the token factory.\n\n![](https://cdn.videotap.com/DwK3ACMPJE6lTsWulD7x-71.14.png)\n\n## Final Thoughts\n\nDoes it all seem a bit scary? Absolutely. But keep in mind that it could also be an excellent opportunity to improve the code. The best code isn't always the most complex one, but the most secure and efficient.\n\nThe challenging but fun part is figuring out the best way to do this. It‚Äôs a never-ending journey of learning and discovery. So, let's learn and discover together!\n\nHappy coding!\n",
          "updates": []
        },
        {
          "lessonId": "736a476f-8947-4e49-b381-5335079ac4c7",
          "number": 10,
          "title": "Unsupported Opcodes",
          "slug": "unsupported-opcodes",
          "folderName": "10-unsupported-opcodes",
          "description": "",
          "duration": 11,
          "videoUrl": "NLLL7VcdjPg",
          "rawMarkdownUrl": "/routes/security/7-bridges/10-unsupported-opcodes/+page.md",
          "markdownContent": "---\ntitle: Exploit - Unsupported Opcodes\n---\n\n\n\n---\n\n# Deep Dive into Assembly Blocks in Solidity\n\nWelcome to another exciting episode in our exploration of Solidity! Today, we're going to be deep-diving into an intriguing aspect of Solidity: Assembly Blocks. So get your coding gloves on and let's start this journey!\n\n## The Assembly Block: An Introduction\n\nAssembly blocks in Solidity offer us lower access level to the Ethereum Virtual Machine (EVM). Though not super low-level as there exists some level of abstraction in assembly (also known as Yul), assembly blocks provide a closer approach to working with EVM opcodes.\n\n![](https://cdn.videotap.com/kygHboewjVz29gEvJnFB-57.14.png)\n\n> \"Assembly in Solidity allows us closer access to the EVM, letting us perform opcodes that could potentially be unsafe.\"\n\nIn the course of this blog, we will be examining the use case of the `Create` opcode in assembly. The `Create` opcode in Yul can be researched further in the [Solidity documentation](https://docs.soliditylang.org/en/v0.8.9/yul.html).\n\n## Diving Into the Code: Exploring `Create` Opcode\n\nOn executing the `Create` opcode, it consumes a value of VPN. To understand the essence of VPN, we actually have to examine the columns at the beginning of the documentation. The explanation column reveals that our `Create` opcode will form a new contract with the specified code and consequently dispatch `Vwei` and return the fresh address. In the event that an error occurs, it returns zero.\n\nLet's now delve more into the assembly block where this opcode is being used. Within this block, the opcode is saying that the contract bytecode. Secondly, it will load the contract bytecode into memory and then proceed to instantiate a contract.\n\nIn programming using Solidity within the EVM, it's commonplace that almost any time you undertake something with contract deployment or variables or even literary reading, it's always necessary to load it into memory first.\n\n## The Nitty-Gritty Details: Loading into Memory\n\nSo how do we go about loading into memory? Fundamentally, you have to specify how much memory to load, from where, and to where. And anytime you're dealing with memory, you have to be very precise about your details.\n\n![](https://cdn.videotap.com/bZJqzJb0Ba8wN3UXX2mL-214.29.png)\n\nIn light of the specifications, it's safe to say that the first chunk of assembly we encounter returns an address. The purpose of the whole block is to create a contract and return the corresponding address.\n\n## The TokenFactory: Its Role and Significance\n\nDelving further, we discover that the token factory keeps track of all tokens it broadcasts. It also emits a token upon being deployed‚Äîan interesting feature! A function, `getTokenAddressFromSymbol`, is also present, but it doesn't seem to be used anywhere within the rest of the code.\n\n```js\nfunction getTokenAddressFromSymbol(string memory _symbol) public view returns (address){\n    return s_TokenToAddress[_symbol];\n    }\n```\n\nConsidering its lack of usage, this function could have likely been more effectively designated as external rather than public.\n\n## Launching a Check on the Opcode: The Checklist Approach\n\nAnd now we arrive at an essential checkpoint: the opcode checklist. By utilizing this checklist, one can discover fascinating things about the opcode. A surprisingly interesting question you might find is whether the `push0` Opcode is supported for Solidity versions above `0.8.20`.\n\nAnother question that pops up is the compatibility of EVM Opcodes and the protocol's operations across all target chains. It brings to mind the compatibility of the `Create` opcode with all our working chains.\n\n![](https://cdn.videotap.com/aypb7Nern5qzvXGaDMLH-385.71.png)\n\nTo unravel this puzzle, a practical step is to utilize the Solidity compiler, Solk, and see what we get after building the contracts and inspecting them. Sure enough, upon exploring the contracts, we will find the `Create` Opcode, which confirms its presence.\n\n## Checking Compatibility Levels: The Ethereum Mainnet and Zksync\n\nAs we've identified the opcode, we have to be sure about its compatibility with our working chains. Ethereum's mainnet is an assured pass, but what about Zksync?\n\nA quick dive into the [`Zksync documentation`](https://zksync.io/) clarifies things a lot. They have a comprehensive FAQ segment that explicates the difference between being 'EVM Compatible' and 'EVM Equivalent'.\n\n> \"EVM Equivalent means a given protocol supports every Opcode of the Ethereum EVM down to the bytecode. EVM Compatible means a percentage of the Ethereum EVM's Opcodes are supported.\"\n\nZksync is optimized to be EVM compatible and not EVM equivalent for a variety of reasons. However, this doesn't clarify the compatibility of the `Create` OpCode.\n\nDelving deeper, it becomes apparent that the EVM constructions `Create` and `Create2` on Zksync only work when the compiler is aware of the contract's bytecode beforehand. If the contract isn't aware of the bytecode prior to deployment, it will fail. This approach is strikingly similar to our example code‚Äîconfirming its potential failure on Zksync.\n\n## Concluding Remarks: The Importance of Compatibility Checks\n\nThis discovery underscores the importance of thorough opcode compatibility checks across all working chains. In fact, there was a well-documented instance of 921 ETH being stuck in a Zksync contract because the transfer function failed.\n\nJust a little foresight to check compatibility would have saved this massive loss! This real-life scenario serves as a solemn reminder of how vital it is always to consider EVM compatibility in our code implementations.\n\nIn conclusion, whenever you embark on security reviews or contract deployments, always remember to refer to your safety checklist. Going through such a checklist not only helps you find hidden oddities but also ensures you're on the safer side of things.\n\nIn all, remember that the devil is in the details. Happy programming!\n",
          "updates": []
        },
        {
          "lessonId": "4b7147fc-142c-4dfc-9f3b-891516b97a0e",
          "number": 11,
          "title": "BossBridge",
          "slug": "bossbridge",
          "folderName": "11-bossbridge",
          "description": "",
          "duration": 3,
          "videoUrl": "wkNKxf8o2yo",
          "rawMarkdownUrl": "/routes/security/7-bridges/11-bossbridge/+page.md",
          "markdownContent": "---\ntitle: BossBridge.sol\n---\n\n\n\n---\n\n# Analyzing and Making Sense of the Boss Bridge\n\nWelcome to another deep dive into the world of blockchain code! Amidst our adventures, we stumbled upon a complex and intriguing beast known as the Boss Bridge. Now it's time to give it a thorough examination. So, let's grab our diving gear, get comfortable and leap straight into the code!\n\n## A Brief Introduction\n\nThe Boss Bridge doesn't have a lot of code, but don't let that mislead you. It's petite stature hides a heart of complex code. We'll deconstruct it piece by piece, so by the end, you're familiar with each line and what it does.\n\n## Code Inspection: Pragma and Imports\n\nFirst off, the top of our file is home to a list of imports and a `pragma solidity` statement, versioned at 0.8.20. That seems up-to-date, which is a good start!\n\n```js\npragma solidity 0.8.20;\n```\n\nMoving on to the imports, we have OpenZeppelin taking up a good portion of the space. As a tried and tested library thoroughly reviewed for security, it's always reassuring to see it.\n\nNext, we have a couple of new imports; namely the `ReentrancyGuard`, `Message`, `HashUtils`, and `ECDSA`. These might not be as familiar as OpenZeppelin, but they're equally important. Here's a closer look at a couple of them.\n\n## Reinforcing the Code with ReentrancyGuard and Understanding Pausable\n\n_Disclaimer:_ This is where it's about to get technical.\n\n### Pausable\n\nFirst up is `Pausable`. As the name suggests, it allows the addition of an emergency stop mechanism to your contracts.\n\n```js\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n```\n\nIt provides modifiers like `whenNotPaused` and `whenPaused` along with `pause` and `unpause` functions.\n\nThe intriguing part is that certain functionality works only when `whenNotPaused` is in effect. Like any responsible coder, I checked whether there's a way to pause the contract by running forge.\n\nGood news: We do have a pause function in here!\n\n### ReentrancyGuard\n\nNext, let's take on `ReentrancyGuard`. It's a fabulous guard against reentrancy attacks.\n\n```js\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n```\n\nThrough the use of a clever system it calls \"mutex locks,\" it ensures that your functions stay clear of reentrancy mischief. It does this by using `nonReentrant`, `nonReentrantBefore`, and `nonReentrantAfter` modifiers.\n\nEssentially, it places a lock onto your function, ensuring that there are no repeated entries during its execution, which could lead to reentrancy attacks.\n\nIn our `BossBridge` contract, the `sendToL1` function is guarded by `nonReentrant`, keeping it safe from potential threats.\n\n## Conclusion\n\nWe made some solid discoveries in our examination of the Boss Bridge's code. We managed to identify important aspects such as the use of the `Pausable` and `ReentrancyGuard` components, as well as confirmed the availability of the `pause` function.\n\nKeep coding and exploring, blockchain adventurers! I'll join you in the next deep-dive session.\n\n> _\"Any fool can write code that a computer can understand. Good programmers write code that humans can understand.\"_ - Martin Fowler.\n",
          "updates": []
        },
        {
          "lessonId": "81494f55-5d9c-48cf-848d-fe09ad1fc05f",
          "number": 12,
          "title": "Signatures",
          "slug": "signatures",
          "folderName": "12-signatures",
          "description": "",
          "duration": 6,
          "videoUrl": "9LMBU3RSjBo",
          "rawMarkdownUrl": "/routes/security/7-bridges/12-signatures/+page.md",
          "markdownContent": "---\ntitle: Signatures Introduction\n---\n\n\n\n---\n\n# Deep Dive into Message Hash Utils: A guide to Signature Message Hash Utilities in Blockchain\n\nIn this post, we're going to delve into signature message hash utilities which are used to produce digests to be consumed by Elliptic Curve Digital Signature Algorithm (ECDSA) for recovery or signing. If you're new to blockchain technology, it might all sound like Greek mythology, but worry not. We're going back to basics - courtesy of the [Anders Brownworth Blockchain demo](https://andersbrownworth.com/blockchain).\n\n## Understanding the Blockchain Demo\n\nAnders Brownworth has created a simple, yet intuitive public-private key demo that has been of great educational help in understanding blockchain better. Unfortunately, the demo has recently been taken down but, the good news is you can find it on [GitHub](https://github.com/anders94/public-private-key-demo).\n\nA simple `git clone` will get you started but ensure that you have node JS installed beforehand.\n\n```bash\ngit clone https://github.com/anders94/public-private-key-demo\ncd public-private-key-demo\nnpm install\n./bin/www\n```\n\nYou're now successfully running the blockchain demo on your local machine! Visit `localhost` on your web browser while the server is still running and TADA, behold the blockchain demo.\n\n## Unraveling Signatures\n\n> \"Signature is a process where a private key is combined with a message to create a unique message signature. The process verifies that the public key and the message match the signature.\"\n\nThis process of signing transactions with private keys is how blockchain works.\n\nExample: When we operate digital wallets, like MetaMask, and make transactions using Ethereum, we sign these transactions and send these signed messages onto the blockchain. Other blockchain nodes verify these messages.\n\nIn the blockchain demo, you can generate a pair of private and public keys. Sign a message using your private key and visually follow the entire process.\n\n![](https://cdn.videotap.com/I31ISMCAE8CABrMXYyaq-89.18.png)\n\n## Exploring Message Hash Utils\n\n`MessageHashUtils` might look a bit confusing, but it's an effort to standardize the messages and hashes in the Ethereum blockchain transactions. Some Ethereum Improvement Proposals (EIPs) have been introduced to enhance this.\n\nThe first one to consider is `ERC-191`, a standard for signed data, and is specifically targeted for signed data in Ethereum Smart contracts. The motive behind this was to establish a common format for all signed data.\n\n![](https://cdn.videotap.com/7kCHT85kigZxan9r7aki-109.png)\n\nAccording to `ERC-191`, the data is arranged in the following manner:\n\n- The start of the signed data is marked by `0x19` (1 byte)\n- It's followed by ‚Äòversion specific‚Äô data (1 byte)\n- Additionally, the generic data to sign\n\nThe next version is the `EIP-712` or the structured data, which we will discuss in details in the later part of this blog.\n\nFor the signed data, all signatures in blockchain comprise of `r, s, and v` parameters.\n\nLet's see an example using Solidity `0.8.0`.\n\n```js\nfunction execute(address target,uint256 nonce,bytes memory payload,uint8 v,bytes32 r,bytes32 s) public {\n    bytes memory data = abi.encode(target,nonce,keccak256(payload),msg.sender);\n    bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\",DOMAIN_SEPARATOR,keccak256(data)));\n    address recoveredAddress = ecrecover(digest, v, r, s);\n    require(recoveredAddress == msg.sender,\"Invalid signature\");\n    (bool success,) = target.call(payload);\n    require(success, \"Execution failed.\");}\n```\n\nIn the code above, `r`, `s`, and `v` are components of the signed data. In order to verify who signed this message, you can use a precompiled function known as `ecrecover`. The `ecrecover` function takes in the parameters `v`, `r`, and `s` and returns the address that was used to sign the hash. The example above checks if the recovered address matches the sender's address, indicating that the sender indeed signed the bytes.\n\nThe function of `ecrecover` is to identify the signer of the hash, i.e, who signed the data. This function is instrumental in Solidity contracts because it helps verify if a certain person signed something.\n\n## Wrapping it up\n\nIn conclusion, message hash utilities are used to enhance transparency and uniformity in signing messages and contracts in the Ethereum blockchain. We also explored how Solidity's `ecrecover` function can be used to identify the signer of data. This essentially aids in the process of verification of a signed contract, thus adding another layer of trust and security to the blockchain technology.\n",
          "updates": []
        },
        {
          "lessonId": "db5df59f-e075-4e05-b165-d7e649cedc6b",
          "number": 13,
          "title": "Signatures Summarized",
          "slug": "signatures-summarized",
          "folderName": "13-signatures-summarized",
          "description": "",
          "duration": 1,
          "videoUrl": "rhLZafJabBg",
          "rawMarkdownUrl": "/routes/security/7-bridges/13-signatures-summarized/+page.md",
          "markdownContent": "---\ntitle: Signatures Summarized\n---\n\n_Follow along with this video:_\n\n\n\n---\n\n# Decoding Cryptographic Signing: Private Keys, Messages, and Signature Verification\n\nIf you're taking your first steps into the world of blockchain or cryptography, you've probably stumbled across the terms private key, messages, digital signatures, etc. In this blog post, we'll break down the fascinating process of signing messages using private keys. No worry if these terms seem to be Greek to you right now, all will get clearer as you read further.\n\n## What Does Signing Messages Actually Mean?\n\nWhen we refer to 'signing' in the context of blockchain and cryptography, we're talking about a process by which we authenticate messages on the blockchain using a private key. It's a crucial aspect of data and transaction security.\n\nNow you might ask, what does signing a message involve and how does it work? Let's break it down a bit.\n\n> Initially, the process starts with two distinct elements: a private key and a message.\n\n![](https://cdn.videotap.com/1RO5OQCrdWw5Vd9SjdCN-14.67.png)\n\nThe content of the messages we refer to usually includes data elements like function signatures, function selectors, parameters, etc.\n\n### The Magic Box: The Elliptic Curve Digital Signature Algorithm\n\nThese components, the private key and message, are then pushed into a fascinating 'algorithmic machine' known as the Elliptic Curve Digital Signature Algorithm (ECDSA). Now, unless you're deeply interested in cryptography, you probably don't need to understand the complex math behind it.\n\nHence, you can imagine the ECDSA as a magic box, a black box if you will. If you're curious about the inner mechanisms of this 'black box', I highly recommend a deep dive into the Elliptic Curve Cryptography- an excellent starting point could be [this link](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography).\n\n![](https://cdn.videotap.com/2RjUzLDQpobVxdX7u9lT-23.83.png)\n\n### The Output: VR and S\n\nOnce we feed the private key and message into the black box, the ECDSA, it gives us two outputs, famously known as VR and S. These components make up our unique Digital Signature.\n\n![](https://cdn.videotap.com/IQH3FxNz2xIA59h8rO4F-29.33.png)\n\n## Full Circle: Verifying the Signature\n\nAmazingly, we can use this digital signature, the VR and S, to verify that a message was, indeed, signed by a specific address. This gives a receiver the confidence that the message they received was indeed from the sender it claims to be.\n\nIn simpler terms, this tells us that the sender of the message is the legitimate owner of the address from which the message was sent, bringing us to the very essence and necessity of cryptographic signing - Authentication and Verification.\n\n![](https://cdn.videotap.com/eNLThyvbZVxz4fr0PJHT-36.67.png)\n\nTo wrap it up, Message Signing and Signature Verification is a simple and secure method to verify the integrity of messages, transactions, and data on the Blockchain. It is an integral part of the blockchain infrastructure, ensuring that addresses and their transactions remain authentic and secure.\n\nIn the fast-evolving world of blockchain and cryptography, understanding such key concepts is not only essential but also engaging. It peels back the layers of the complex systems we often use without understanding and puts power back into the hands of users. Whether it's to enhance your professional knowledge or simply for the thrill of learning something new, delving into the wonder of cryptography is remarkably worthwhile. I highly recommend continuing your cryptographic journey from here, you never know where it might lead you next.\n\nStay curious, keep learning, and until the next post, Happy Cryptography!\n",
          "updates": []
        },
        {
          "lessonId": "226a2d46-7507-450c-97bc-f00a65b744e2",
          "number": 14,
          "title": "EIP-712",
          "slug": "eip-712",
          "folderName": "14-eip-712",
          "description": "",
          "duration": 4,
          "videoUrl": "q2PTslgNVZE",
          "rawMarkdownUrl": "/routes/security/7-bridges/14-eip-712/+page.md",
          "markdownContent": "---\ntitle: EIP-712\n---\n\n\n\n---\n\n# Untangling the Beauty of Smart Contracts: A Dive Into EIP 712 Structured Data\n\nSmart contracts have revolutionized the way we do transactions and communicate data in the blockchain arena. At the crux of it all lies `MessageHashUtils`, a fundamental tool that greatly simplifies our interactions with these contracts. In this post, we'll take a closer look at the EIP 712 and EIP 191 hash functions, and demonstrate their implementation in an actual contract.\n\nRemember, smart contracts and untangling their complexities might feel intimidating, but once you get the hang of it, it's an engaging puzzle worth solving. So let's get started!\n\n## Breaking Down EIP 712 and EIP 191\n\nIntroducing, the **EIP 712** and **EIP 191**! These are hashing and signing standards for Ethereum smart contracts, making the signing process easier for users.\n\nBefore these standards, users were just told 'hey, sign this message,' and a cryptic byte string was shown. With the advent of EIP 712, Ethereum made user experience way better with formatted requests: 'hey, sign this message: from, to, contents'.\n\nAre you a fan of typed, structured data instead of just byte strings? Well, EIP 712 is perfect for you!\n\nFor those who want to do a deep dive, you can read more about the implementation of EIP 712 and EIP 191 [here](https://eips.ethereum.org/EIPS/eip-712) and [here](https://eips.ethereum.org/EIPS/eip-191) respectively.\n\n![](https://cdn.videotap.com/Q9EBgPOu5axhNmcCfrNw-49.3.png)\n\n## Working with EIP 712: An Example\n\nTo illustrate how to work with EIP 712, let's look at a simple example. We've defined a struct `Mail`, with struct `Person`(from, to) and string contents. This is our structured data. After this, we can break the signed message into its essential components - `V`, `R`, and `S`, and verify this signed data using the `verify` function from the EIP 712 hashing contract (refer to the [github repo](https://github.com/Cyfrin/security-and-auditing-full-course-s23)).\n\n![](https://cdn.videotap.com/3vXpOBtPGNOYDzTe7xew-92.43.png)\n\n## Verifying the Magic: EIP 712 Verification\n\nNow that we've signed the data, how do we verify it?\n\nThe `ECRRecover` function of Solidity comes in handy here. The function hashes the data into a format called a 'digest'. The `ECRRecover` then checks whether the 'from' component of the message is correct using specific input parameters.\n\n> Don't miss out on learning more about how important `ecrecover` is by checking out the Solidity documentation [here](https://docs.soliditylang.org/en/v0.8.23/smtchecker.html#function-calls).\n\nNOTES\n\n1. The digest is essentially the hashed data put into a specific format.\n2. Breaking the signed message into `V`, `R`, `S` components forms the input for `ecrecover`.\n\nYou can explore a bit more about this part with a practical example in the `Example.sol` contract in the course's GitHub repository.\n\n![](https://cdn.videotap.com/3Bx9eDqrngeXdafn4LDv-197.19.png)\n\n## Let's Watch a Mistake: Polygon Case Study\n\nOrdinarily, low-level signature signing seems like a tedious task. But here's an interesting case study on how forgetting to double-check a precompiled `ECRRecover` function return value led to an exploitable vulnerability on Polygon...\n\n![](https://cdn.videotap.com/BjhKxp4Deaz9YZi3bwyj-215.68.png)\n\n## Wrapping Up\n\nSo that's a quick run-through on `EIP 712` and `EIP 191`, two important specifications that make handling and signing Ethereum smart contracts a breeze. Though it might seem a little complex, with a bit of practice, you'll find it's not so scary after all! Don't forget to check out the next part where we dive into a Polygon case study. Happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "18c9b150-0b32-4eb9-9372-ce2497d2656b",
          "number": 15,
          "title": "Case Study: Polygon",
          "slug": "polygon",
          "folderName": "15-polygon",
          "description": "",
          "duration": 9,
          "videoUrl": "X-j63QRtB7o",
          "rawMarkdownUrl": "/routes/security/7-bridges/15-polygon/+page.md",
          "markdownContent": "---\ntitle: Case Study - Polygon Precompile\n---\n\n\n\n---\n\n# Hunting for smart contract bugs: How a developer identified a $7 billion exploit\n\nIf you fancy yourself a tech-savvy problem solver or a capable and competent coder, the world of smart contract bug bounties could be your next lucrative adventure. Not only are these exploits well-paying when correctly identified, but they also aid in securing the ecosystem against hackers.\n\nI recently had the occasion to interview a developer who discovered a $7 billion bug and was rewarded with $2.2 million for his conscientious reporting of this vulnerability. By exploring his successful case, we can learn the key strategies and tools you'll need to find your million-dollar bounty.\n\nLet's delve into this intriguing world of hunting for smart contract bugs.\n\n## Matic blockchain, Polygon, and the MRC20 contract\n\nOn May 31, 2020, the Matic blockchain, which later rebranded as the Polygon chain, was launched. An [EVM](https://ethereum.org/en/developers/docs/evm/) compatible blockchain, it's known for its low gas fees, rapid block times, and recent ventures into [ZK technology](https://polygon.technology/polygon-zkevm).\n\nIf we return to the beginning, block zero to be precise, we find ten transactions in this Genesis block. One of these transactions created the MRC20 contract. This contract allowed users to sign a transaction without sending it, meaning they could offset gas costs. For example, somebody else could be responsible for these costs. This technique is referred to as a metatransaction, which is better explained in [EIP 712](https://eips.ethereum.org/EIPS/eip-712). Initiated with almost 10 billion MATIC, this contract facilitated these gasless transactions. However, it concealed a critical exploit, an oversight that could potentially empty the contract of its entire content.\n\n## The discovery of the dormant exploit\n\nOn December 3, 2021, Leon Spacewalker (a pseudonym of our developer hero) submitted a report about this potential vulnerability to Immunify. Less than two days later, another astute individual discovered this exploit. Unfortunately, this other individual was a malicious hacker and successfully pilfered 800,000 MATIC tokens from the contract.\n\nPolygon was forked two days after the initial report, and the contract was swiftly mended. From December 5, 2021, the MRC20 contract was no longer vulnerable to this exploit.\n\nBut what exactly was this bug, and how did it remain unidentified for so long? Let's turn our attention to the function that enabled these gasless transactions.\n\n## Anatomy of the bug - A detailed look\n\nThis function appears benign at first glance. It requires a user's signature, data, and an amount to send, an expiration date, and a recipient for the money. Running certain checks, it retrieves the data hash required for the metatransaction and ensures this data hash hasn't been previously used. Following these steps, it then launches an EC recovery function.\n\nThis recovery function, ecrecover, verifies the origin of a signed transaction. However, should it encounter an error, it simply returns the zero address without viability checks. Even though there is a condition to ensure that this return is not zero, the ececovery function still returns zero upon encountering an error. Herein lies the vulnerability.\n\nIf the function were to check the overall validity of this function and not just the zero address, the problem would've been handled. But alas, that check was overlooked. The transfer function, acting as the last line of defense, should at least verify the 'from' address. But it simply transfers money out of the MRC20 contract without making any such checks.\n\nThe exploit was then straightforward: Just passing a faulty signature, setting any quantity, and denoting a receiver. This method would essentially drain the entire MATIC balance.\n\n### Prevalence of dormant bugs in the tech world\n\nIt's both peculiar and surprising that this bug remained latent for about 1.5 years, only to be discovered by multiple individuals within a short span. After discussing with the Immunified team, they provided a remarkable insight: these sleeping exploit beasts' simultaneous awakenings are a fairly common phenomenon. As soon as media outlets popularize new bugs, bug hunters flock to identify them in other plausible places.\n\nDespite this seemingly random event, we can extract several valuable lessons from this saga.\n\n## Strategies to identify bugs\n\nMy conversation with Leon yielded some precious tips and tricks he employed to discover this and numerous other security loopholes. Note that a basic understanding of Solidity and appropriate smart contract fundamentals are desirable assets in watching your million-dollar bounty surface.\n\n### 1. Distinct advantage - Find your edge\n\nEvery bug bounty hunter must have a unique advantage. Leon's advice to anyone entering this space, hone that specific skill, that edge over other smart contract developers, bug hunters, and protocols.\n\n### 2. Know the subject - Understand the protocol\n\nKnowing the specifics of the protocol in-depth is one of the most common strategies to find bugs. Reading the documentation, experimenting with the protocol implementation, etc., if you grasp every corner of the protocol, you're likely to identify aberrations as well.\n\n### 3. Research and Grow\n\nResearch on specific bugs and uncover projects that have those loopholes. This technique, requiring a solid understanding of diverse exploits and maintaining awareness of unexplored best practices, simplifies your search as you're only seeking a specific chunk of code in a project.\n\n### 4. Speed is key\n\nBeing quick in identifying new bounties and updates surely benefits in this context. Equipped with the right tools, such as Immunified discord BBP notifications, one can always stay ahead.\n\n### 5. Devising unique strategies - Be creative\n\nLeon often visited community forums projecting a potential bug bounty. He would then start exploring their smart contracts even before approval to gain a head start.\n\n### 6. Arm yourself with the right tools\n\nKnowledgeable bug hunters use various helpful tools. Solidity Visual Developer, Hard Hat Foundry, Brownie, Dune Analytics, and Etherscan are a few examples.\n\n### 7. Audited projects are not bug-free\n\nLeon has discovered numerous vulnerabilities in projects that top firms had audited. So, do not be disheartened by audited projects.\n\n### 8. Find your niche\n\nGaining industry-specific knowledge can dramatically improve your ability to uncover bugs.\n\nAlthough the example discussed here is quite specific and outlines a single bug hunt, these tips can be generalized for anyone hopeful of winning a sizeable bug bounty.\n\nAre you prepared to accept the challenge?\n\n![](https://cdn.videotap.com/MuftBpuNZSZv4cmAeOuU-506.03.png)\n",
          "updates": []
        },
        {
          "lessonId": "77477bf0-095d-4ce5-93e0-026c4ba36d8b",
          "number": 16,
          "title": "Signatures Recap",
          "slug": "signature-recap",
          "folderName": "16-signature-recap",
          "description": "",
          "duration": 1,
          "videoUrl": "HCN7w7IZNI0",
          "rawMarkdownUrl": "/routes/security/7-bridges/16-signature-recap/+page.md",
          "markdownContent": "---\ntitle: Signatures Recap\n---\n\n\n\n---\n\n# Understanding the Magic of Digital Signatures and Blockchain: A Simple Tutorial\n\nWelcome back, fellow blockchain enthusiasts. We've covered a lot in our past discussions, and this post will focus on one of the most fundamental aspects of blockchain technology: digital signatures. By the end of this read, you'd be able to comprehend how digital signatures work and how they are minted using Elliptical Curve Digital Signature Algorithm (ECDSA). Don't worry! We've broken it down into the simplest terms possible.\n\n## How Digital Signatures Work\n\nDigital signatures underpin the integrity and security of transactions within a blockchain ecosystem. These contrivances act as a proof of authenticity, confirming that the message has been sent by a verified sender and has not been tampered with, during transmission.\n\n![](https://cdn.videotap.com/jSSntLnGkMJPWVtSFsUs-6.19.png)Here's a simplified snapshot of the digital signature process:\n\n1. Your Private Key + the Message &gt; **ECDSA** &gt; Output (r,s values) = Signature\n2. Signature + Original Message &gt; **ECDSA Verification** &gt; Sender's Public Key\n\n### Elliptical Curve Digital Signature Algorithm\n\nThe core of creating a digital signature is an intelligent mathematical process known as the Elliptical Curve Digital Signature Algorithm, or ECDSA. Essentially, you take the private key and the message and feed them into this algorithm.\n\nThis operation generates a signature in a specific format, often referred to as _r_ and _s_- the crucial parts of your digital signature. These signatures are safe to put on-chain as they do not contain any public information.\n\n### Verifying The Signature\n\nHow can we ensure that the message was indeed signed off by the claimed sender? Verification is the process that answers this question.\n\nYou take the signed message plus the reported _r_ and _s_ values and plug them into the verifying component of the ECDSA. Adding the data they supposedly signed results in the output, which is essentially the signatory of the message.\n\nThis verifying component is known as an `ECR precompile`, a part of the elliptical curve digital signature mechanism.\n\nThe magic happens when `ECR precompile` outputs the same person you expect to have signed the message. If it does, then voila! It's an honest transaction, and that's precisely what we want to achieve.\n\n> \"In the world of cryptography and digital transactions, your signature is the cornerstone of credibility.\"\n\n## Wrapping Up\n\nIn summary, a digital signature is akin to your digital fingerprint. With ECDSA's wizardry, a simple, unique combination of values (comprising of a private key, a message and the _r,s_ values) embodies your authority and ensures the authenticity of transactions. Understanding these fundamentals of how signing and verification work is integral to mastering blockchain technology.\n\nOnwards, to a more secure and transparent future.\n",
          "updates": []
        },
        {
          "lessonId": "0fe0657b-cb48-4847-9ed2-8ac6af842ccc",
          "number": 17,
          "title": "Recon Continued",
          "slug": "recon-continued",
          "folderName": "17-recon-continued",
          "description": "",
          "duration": 6,
          "videoUrl": "yppiWQsrg9k",
          "rawMarkdownUrl": "/routes/security/7-bridges/17-recon-continued/+page.md",
          "markdownContent": "---\ntitle: Recon (continued)\n---\n\n\n\n---\n\n# Decrypting OpenZeppelin's ECDSA Utility Library: An In-Depth Look\n\nIn the vast world of smart contracts, a significant part of understanding how everything works involves understanding Elliptic Curve Digital Signature Algorithm (ECDSA) operations. ECDSA is crucial in secure data transactions in these systems. In this article, we will delve deep into OpenZeppelin's ECDSA assembly code, dissecting its content and functions.\n\n## Understanding ECDSA and OpenZeppelin\n\nECDSA and related technologies help sign and validate data. OpenZeppelin is a comprehensive utility library that provides a plethora of functions to cater to these needs. The given transcript discusses two Ethereum functions written in assembly.\n\n> \"These are all basically ways to help sign and validate data. And this is important for us for reasons you'll see in a bit.\"\n\nFollowing this, we have the ECDSA library, sourced from OpenZeppelin, which focuses on elliptical curve digital signature algorithm operations.\n\n## ECDSA Implementation: Try Recover Function\n\nAs we progress further into the script, we encounter another core utility `Try Recover`. This function extracts the signature constituents `R`, `S` and `V`‚Äî the value components of the signature all housed in a signature with length 65. An understanding of how `Try Recover` operates is significant in achieving signatures and verifications.\n\n![](https://cdn.videotap.com/Groo7EeK5U7DGEFAK2UT-131.57.png)\n\nThe `Try Recover` function retrieves the address responsible for signing a hashed message with a signature or an error, should that arise.\n\n## L One Vault &amp; Signatory Examples\n\nFollowing this, we introduce L One Vault. As part of subsequent steps, we will take you through some signing examples and elaborate on the ins-and-outs of signing.\n\nIf you're not too familiar with signing or cryptography, I recommend `ChatGPT`.\n\n## Deep Diving into the L One Boss Bridge\n\nThe `L1BossBridge` contract uses several features, including Safe ERC20, to process ERC20 tokens smoothly. A feature of this contract is that it deals with only a single token‚Äî `L1Token.sol`.\n\n![](https://cdn.videotap.com/IbRV6yoOBBUIBRWA1Ic2-191.37.png)\n\nThe contract also incorporates a deposit limit mechanism that restricts the number of tokens one can deposit. It operates on principles which allow one bridge per token and one vault per token.\n\n```javascript\n// Immutable vault and token declaration\nIERC20 public immutable token;\nL1Vault public immutable vault;\n```\n\n![](https://cdn.videotap.com/0eRk64LOa0VdtxK4nKoF-227.25.png)\n\nTo facilitate token movement from L1 to L2, certain user accounts are distinguished as signers. The contract also incorporates event triggers and error handling mechanisms to manage prospective situations effectively.\n\n## Contract Approval and Miscellaneous Functions\n\nAnother key feature to note here is the `vault.approveTo` function where the `L1BossBridge` provides max withdrawal power and approves ERC20s inside the vault.\n\n```javascript\n// Vault Approval to handle withdrawals\nvault.approveTo(address(this), type(uint256).max);\n```\n\nIn addition to these, there are more, straightforward functions like `pause` and `unpause` that can halt and resume contract processes.\n\nFinally, the functionality to set signers is available to the owner only. There is also a provision for disabling an account, prompting necessary questions about handling situations where an account is disabled mid-process.\n\n## Conclusion\n\nThrough this exploration, we see the ECDSA utility library's vast potential, specifically OpenZeppelin's library. Not only does it allow for more effective and streamlined worksheet functions within the Ethereum environment, but it also provides a window into secure transactions in the blockchain world.\n\nRemember, just as the speaker in the transcript alluded, there might be bugs related to signatures, so consider delving into these libraries and try deconstructing them yourself to foster your understanding of how they work.\n",
          "updates": []
        },
        {
          "lessonId": "bd0cfce8-5121-4244-8dfa-a76a04d30a38",
          "number": 18,
          "title": "depositTokenToL2",
          "slug": "deposit-token",
          "folderName": "18-deposit-token",
          "description": "",
          "duration": 2,
          "videoUrl": "C4KzcFYc0as",
          "rawMarkdownUrl": "/routes/security/7-bridges/18-deposit-token/+page.md",
          "markdownContent": "---\ntitle: depositTokenToL2\n---\n\n\n\n---\n\n# Understanding the depositTokenToL2 function\n\nIn this blog post, we delve into an essential part of blockchain contract management, especially in relation to the Layer 2 (L2) scaling solutions. One exciting function that facilitates these activities is the `depositTokenToL2` function. It operates in a decentralized environment, orchestrating transactions by locking tokens in the vault and triggering relevant events.\n\n![](https://cdn.videotap.com/pfxr2xqJnxlfGXz1ojht-5.66.png)\n\nThis entry aims at delivering a detailed commentary on how this function works, how to utilize it, and why it is an integral cog in dApp operations.\n\n## An Overview of `depositTokenToL2` Function\n\nThis function is a fundamental aspect of L2 operation. When you call `depositTokenToL2`, there are nodes in waiting to listen and process it, subsequently unlocking the tokens on the L2. This unlocking initiates the minting process on the L2, which is an essential part of the centralized process of the blockchain operation facilitated by this function.\n\nIn simpler terms, it's like we have built a lock (a vault) and unlocked it with a specially designed key (the L2 minting process).\n\nIt's essential to note the three parameters of this function:\n\n1. `from`‚Äì the address of the user depositing the tokens\n2. `L2 recipient` ‚Äì the address of the user receiving the tokens on the L2\n3. `amount` ‚Äì the value of tokens to deposit.\n\nSpecifically, the function accepts these parameters when the system is not paused, adhering to the condition that the sum of `balance(address(vault))` and `amount` must not exceed the deposit limit.\n\n> This function has a limit of 100,000 tokens. This means you can only have a maximum of 100,000 tokens on the Layer 2 network at any given time.\n\nThe function attains token safety through a transfer to the vault's address, scaling the stipulated amount per the deposit limit.\n\n![](https://cdn.videotap.com/VZtxKixeFPCh2aosAGVO-59.4.png)\n\n## The Importance of Emitted Events\n\nThis function's operation is not complete without an integral event emission: the deposit and unlock events.\n\nThese events, if configured correctly, send vital signals to an off-chain service; hence careful attention must be paid to them when coding or interpreting what this function does.\n\nThe events essentially carry these parameters: `from`, `to`, and `amount`. An off-chain service awaits and listens for these events to facilitate the unlocking of tokens on the L2.\n\nWhile this might seem a tad complex, it can be visualized as a messaging system. The function sends messages (events) that inform the system of where it is time to unlock the tokens on L2.\n\n```js\n// Example of the function parameters in solidity\nfunction depositTokenToL2 (address from, address L2Recipient, uint256 amount) external {/* function body*/}\n```\n\n## Wrapping Up\n\nThe `depositTokenToL2` function, with its event emissions and token transfers, is a crucial part of the blockchain's L2 operations. Understanding the principles of such a function can aid anyone on their journey to mastering blockchain contracts and their integration with L2 solutions.\n\nGet familiar with this type of process and continue your exploration in the vast yet thrilling world of blockchain technology.\n",
          "updates": []
        },
        {
          "lessonId": "730a802e-91db-47c4-b9c1-7abdc6fd7e0e",
          "number": 19,
          "title": "Exploit: Arbitrary From",
          "slug": "arbitrary",
          "folderName": "19-arbitrary",
          "description": "",
          "duration": 5,
          "videoUrl": "4CMH67_iy0A",
          "rawMarkdownUrl": "/routes/security/7-bridges/19-arbitrary/+page.md",
          "markdownContent": "---\ntitle: Exploit - Arbitrary \"from\" allows users to steal tokens\n---\n\n\n\n---\n\n# Nail-biting Moments with Slither: Uncovering Critical ERC20 Vulnerabilities\n\nHey You! Welcome back! In this post, we'll dig into the enlightening world of Slither, our good friend from [Trail of Bits](https://trailofbits.com/). It is well-equipped to unearth potential code vulnerabilities, and guess what, we've stumbled upon a dicey one! Exciting, right? Buckle up, let's dive in.\n\n## The Problem Unveil\n\nSo, revisiting where we left off, we managed to arrive at a critical point at our function with the help of Slither. Quite the Sherlock, isn't it? Well, let me just relay the discovered issue. We discovered the issue with the 'bossbridge deposit tokens to l2' which utilizes 'arbitrary from in transfer from'. Sounds gibberish, right? Let's decode it.\n\nThe issue pops up when a detection is made that \"message sender\" is not used in 'from in transfer from'. Don't worry, I will walk you through an exploit scenario for clarity (You wouldn't feel good if we don't decode it, and you know it!).\n\n## The Exploit Scenario\n\nConsider our characters, Alice and Bob. Alice approves her ERC20 tokens to be spent by the contract. Enter a malicious entity, Bob, who utilizes this opportunity to call on the contract and set Alice's address as the '`from`' parameter in 'transfer from'.\n\nCan you guess what happens next?\n\n> 'Bob takes off with Alice's hard-earned tokens owing to the contract permission established by Alice.'\n\nPretty severe, isn't it? This just started becoming more interesting than an Agatha Christie novel!\n\n## The Vulnerability In-Depth\n\nLet's try to visualize this scenario. We have Alice, setting off to perform a transaction after calling '`approve of token to bridge`.' Bob, the opportunist, notices this and decides to make his move. He calls '`depositTokensToL2`', all the while using Alice's address for the '`L2`' recipient, which would now be Bob himself. He sets the amount as all her money (sounds like pure evil!). Alice, unsuspecting, has approved this contract, thus allowing Bob's call to pass.\n\nThis would enable the transfer of all Alice's money to Bob on layer two. A chilling scenario to envision!\n\n## Slither - The Hero Unseen\n\nIf it wasn't for Slither grabbing hold of this at audit, the consequent results would be devastating. Figuring out the severity and impact, it's evidently high - Alice would be losing all her tokens to Bob. Depicting the likelihood reveals another elevated risk - this event can transpire anytime Alice calls 'approve'. Consequently, things are looking upwards of 'super high'. While some may tag this as 'crit', we can unanimously agree on labeling it as a 'high audit' critical issue.\n\n_A critical excerpt from Slither's find - \"If a user approves the bridge, any other user can steal their funds\"._ Quite hair-raising, isn't it? It's an unintended consequence stemming from trust in contracts ‚Äî certainly not a scenario we envision.\n\n## Crafting a Proof of Code\n\nAfter such a thrilling ride, let's take a moment to breathe and give a thought to envisaging the proof of code for our discovery.\n\nStick around for the next part where we dive deep into writing a foolproof, high-safety code, ensuring vulnerabilities like this are effectively mitigated.\n\nWith this, we‚Äôre signing off for now, continue staying curious and happy coding!\\\\\n",
          "updates": []
        },
        {
          "lessonId": "96c18ccd-ac6e-466d-96de-d03f565fcd68",
          "number": 20,
          "title": "Arbitrary From: Poc",
          "slug": "arbitrary-poc",
          "folderName": "20-arbitrary-poc",
          "description": "",
          "duration": 4,
          "videoUrl": "5qlwig6BP_c",
          "rawMarkdownUrl": "/routes/security/7-bridges/20-arbitrary-poc/+page.md",
          "markdownContent": "---\ntitle: Arbitrary POC\n---\n\n\n\n---\n\n# Testing Token Movement In Solidity\n\nIn this blog post, we will delve into a test suite in Solidity, focusing on testing the movement of approved tokens from one user to another. By simulating a situation where a malicious actor can swoop in and steal tokens, we will unearth potential vulnerabilities and show how to spot a high-severity bug with a tool like Slither.\n\n## Writing A Test Suite Function\n\nLet us begin by scrolling down to our current test harness. Our primary objective is to pen a new test suite function; we will adopt the name `testCanMoveApprovedTokensOfOtherUsers` for this function. Our mission is to verify an occurrence ‚Äì the actual transfer or move of tokens from one user to another.\n\nTo achieve this, we will repurpose some sections of our existing test suite.\n\n![](https://cdn.videotap.com/kSIFNqF1jGk1jsDF3enL-24.57.png)\n\nWithin our current test suite, we have entities such as `user`, `deployer`, `operator`, `token`, `tokenBridge`, and `vault`. We also have a user account named Alice, tagged in this context as 'poor Alice'.\n\n## Approving Tokens For Transfer\n\nFirst, Alice has to approve the `tokenBridge` to move her tokens to Layer 2. She will just use the L1 Token object (described in code as `L1Token`) and call the `approve` method, passing in the `tokenBridge‚Äôs` address as well as the maximum token number, expressed as `uint256.max`.\n\n```js\nVM.prank(Alice);\nL1Token.approve(addressTokenBridge, uint256.max);\n```\n\n![](https://cdn.videotap.com/u94ZnNK43eS6i6Y9HY71-58.98.png)\n\n## Defining A Malicious Actor\n\nAfter Alice has approved the Token Bridge to lawfully move her tokens, we introduce 'Bob', who maliciously swoops in to steal and deposit all of Alice's tokens on Layer 2. To do this, we first need to obtain the token balance of Alice.\n\n```js\nuint256 depositAmount = Token.balanceOf(userAlice);\n```\n\nWe now need to create an address for our mischief-maker, Bob. Assuming Bob's address as `attackerAddress`, we start a prank with this address and make Bob execute a `depositTokensToL2` call.\n\n```js\naddress attackerAddress = make.addr(attacker);\nvm.startPrank(attackerAddress);\n```\n\nNow, Bob can steal Alice's tokens by depositing them into his own account on Layer 2.\n\n```js\nTokenBridge.depositTokensToL2(userAlice, attackerAddress, depositAmount);\n```\n\n## Ensuring Data Integrity With Emit\n\nIn this scenario, we need to emit an event since the tokens are being locked into the `vault`. Emitting the correct details in this event serves an important role as the off-chain service, which listens to these events, triggers the unlocking on Layer 2.\n\n```js\nvm.expectEmit(\n  addressTokenBridge,\n  emitDeposit(userAlice, attackerAddress, depositAmount)\n);\n```\n\n## Asserting The State\n\nNow, we make assertions to verify that the token balance of Alice is zero and the token vault's balance equals the `depositAmount`.\n\n```js\nassertEqual(Token.balanceOf(userAlice), 0);\nassertEqual(Token.balanceOf(addressVault), depositAmount);\n```\n\nOnce the verification process is complete, we stop the prank.\n\n```js\nvm.stopPrank();\n```\n\n## Verifying The Test Case\n\nOn running the test suit, we observe that the test case succeeds, indicating that there's a high-severity bug - easy pickings for a malicious actor.\n\nThis explorative approach reveals how even advanced code bases can fall prey to serious issues, and tools like Slither prove indispensable in identifying them. So, let's continue analyzing with Slither and see what other 'goodies' we can find!\n\n> \"Even in some of these more advanced code bases, tools like Slither can find really good issues. So thank you, Slither. Let's keep walking down, Slither. Let's see what other goodies are in here. This turned out to be a high.\"\n",
          "updates": []
        },
        {
          "lessonId": "20c4bf89-7c19-49f0-a902-420d06188892",
          "number": 21,
          "title": "Recon Continued (again)",
          "slug": "recon-continued-again",
          "folderName": "21-recon-continued-again",
          "description": "",
          "duration": 5,
          "videoUrl": "XFoSx067MbI",
          "rawMarkdownUrl": "/routes/security/7-bridges/21-recon-continued-again/+page.md",
          "markdownContent": "---\ntitle: Recon Continued Again\n---\n\n\n\n---\n\n# Auditing For Ethereum Vulnerabilities: A Deep Dive\n\nEver felt like unraveling the intricacies of handling vulnerabilities in Ethereum applications? You're at the right place. Let's go ahead and walk you through the eccentric realm of vulnerability handling using the Slither code analysis tool.\n\nBefore proceeding, bear in mind that this journey does not aim to demoralize the workings of Ethereum applications, but to encourage developers to safeguard and optimize them further.\n\n## Unchecked Return Value: Be diligent or Perilous?\n\nMoving along, our next houseguest is the 'approve' function. This method seems to be ignoring its return value. This irregularity, if unchecked, could lead to catastrophic consequences.\n\nOn investigating, Slither reports that while calling the SafeMath `add` method, we aren't storing the resultant sum, rendering the operation meaningless.\n\nWhile this isn't an issue all the time, for a more secure and tight-knit application, we should validate the return values just to make our code robust.\n\nHowever, going by the information at our disposal, it's not a huge dealbreaker. Next time, Slither, next time.\n\n## Zero Check Madness\n\nSlither is back at it again, pointing out the absence of 'zero check'. Fortunately, we had the foresight to check out the README, which states this clearly: they've deliberately omitted 'zero checks' for input validation to preserve some gas. Nice try Slither, but we're covered.\n\n## Navigating The Detectors: Reading Between The Lines\n\nHere's a fun part: handling reentrancy. This essentially implies an external call not followed by a computation, rather it makes an immediate deposit. Let's take a closer look.\n\nWe found that the L1 BossBridge deposit function does decide to deposit tokens without performing a computation, ergo, no effect. With our code set to accept only our L1 token, one without any attached callback functionality, this poses no significant security threat.\n\nDespite this, we nonetheless note it as being preferable to follow CEI (Check-Effects-Interactions).\n\n## The Unerring Eye Of Slither: Red Flags Galore\n\nSlither, understandably, doesn't like assembly instructions and different versions of Solidity being used. All these are valid concerns and necessitate modifications of their own.\n\nThe 'deposit limit' being mutable is a red flag and it should generally be set as a constant.\n\n```js\n//@Audit Info: Deposit Limit Should Be Constant\n```\n\nThis is one of the real and impactful bugs pointed out by our trusty friend, Slither. While it has led us on a merry chase with some informational stuff and a myriad of future functions, it did deliver in the end, which makes for a fantastic learning experience!\n\n## The Future: A Call To Invariance Testing\n\nTake a step back, and soak in everything that's happened. Before we ride off into the sunset, we'd like to urge you to take the future of protecting codebases very seriously, and commit yourself to write stateful fuzzing and invariance test suites.\n\n\"Pause the video right now, try to write down some invariants. Understand what are the invariants, and then write your own fuzzing test suite.\"\n\nSlither and bossbridge have given us some food for thought and armed us with tools to go fearlessly into the world of Ethereum applications. However, always remember: there's always room to explore, learn, and improve.\n\nHappy coding, my friends! Remember, the codebase is not a minefield if you know where the mines are!\n",
          "updates": []
        },
        {
          "lessonId": "491bf2d2-a33f-42fa-b32b-0e20457c4d4a",
          "number": 22,
          "title": "Vault",
          "slug": "vault",
          "folderName": "22-vault",
          "description": "",
          "duration": 4,
          "videoUrl": "XoIZNk_QUA8",
          "rawMarkdownUrl": "/routes/security/7-bridges/22-vault/+page.md",
          "markdownContent": "---\ntitle: Exploit - Vault can infinite mint unbacked tokens\n---\n\n\n\n---\n\n# A Deeper Dive into the MEV Attack and Uncovering a Major Security Flaw\n\nExciting revelations generally come with a bit of craziness, and today, we bring to you one such incident‚Äîan astonishing vulnerability. At first glance, it appears captivatingly cool, yet incredibly daunting. We reveal a flaw that allows any user to steal funds after the bridge receives approval from someone. This scenario might lead to MEV (Miner Extractable Value) attacks. Intriguing, right? Let's unravel this mystery together.\n\n## Uncovering a Significant Security Threat\n\n![](https://cdn.videotap.com/yngYAVIajAxqq6gSChMU-18.png)\n\nThe perplexing part is when the vault, intending to authenticate the bridge, essentially leads to a chain of apprehensive questions. What happens if the safe haven we call the vault approves the bridge? Does that mean a user can filch funds from the vault? Did we just expose ourselves to another audit? Or is this a 'high'?\n\nWe can't let this issue slide. So, let's explore this further.\n\n## What does Vault's Approval to a Bridge Mean?\n\n```javascript\nfunction testCanTransferFromVaultToVault() {...}\n```\n\nThe vault, as the entity approving the bridge, raises alarming questions. Let's consider a user initiates a transfer from the vault to the attacker. Ambiguously enough, could this process occur for any amount and for any token within the bridge? That would be a disastrous outcome!\n\nOur next step? Writing a test to verify this vulnerability.\n\n## Is There a Limit to Money Minting?\n\n![](https://cdn.videotap.com/bnfWcdfv7XuRYwEfv14a-84.png)\n\nWith our test, we are aiming to transfer from the vault back to itself. When we assert ourselves to be the recipient, the tokenized assets stay within the vault‚Äîthis causes an emission of a deposit event from the vault to the recipient on the L2 layer.\n\nHere's where things become startlingly interesting. If the tokens stay within the vault infinitely, could we mint unlimitedly on the L2 layer? Let's try this out.\n\n## Code Implementation\n\nIn the next set of developments, we need to create an attacker.\n\n```javascript\nuint256 vaultBalance = 500 ether;\nminter.mint(address(token), address(vault), vaultBalance);\n```\n\nLet's assume, for simplification, that our vault already holds some currency. In this example, we let it hold 500 ether. To effectively simulate this situation, we can use Foundry's cheat code which gifts our vault with 500 ethers of a particular token.\n\nFollowing this, we need to direct the trigger towards the deposit event function. This function executes when there's self-transference of tokens to the vault.\n\n```javascript\nemit deposit(address(token), address(vault), address(attacker), vaultBalance);\n```\n\nUnderstandably, it sounds a bit nonsensical. Why are we sending it back to ourselves? However, the objective here is to transfer it to the attacker.\n\n```javascript\ntokenbridge.depositToL2(\n  address(token),\n  address(vault),\n  address(attacker),\n  vaultBalance\n);\n```\n\nNow comes the shocker moment! We can ostensibly perform this operation indefinitely because we're continually sending back the tokens to the vault. Do we just stumble upon a way to mint infinite tokens on the L2 layer? Let's validate this.\n\n...\n\nYikes! We indeed did. We've indeed discovered a loophole that allows users to mint tokens on the L2 layer, theoretically, without limitation, irrespective of whether they could withdraw these tokens or not.\n\nThe realization of this potential for creating an unlimited number of tokens flags a significant issue. It's undeniably a vulnerability of high severity. We won't get into a thorough write-up, but the proof of this code's failure is quite evident from this exploration, reminding us of the constant need to stay vigilant in the technology sector.\n",
          "updates": []
        },
        {
          "lessonId": "795f5011-08d2-489f-9d32-5f0216c39885",
          "number": 23,
          "title": "Why are these not the same finding?",
          "slug": "why-not-the-same",
          "folderName": "23-why-not-the-same",
          "description": "",
          "duration": 2,
          "videoUrl": "rlNx-R3OrB8",
          "rawMarkdownUrl": "/routes/security/7-bridges/23-why-not-the-same/+page.md",
          "markdownContent": "---\ntitle: OracleUpgradeable.sol (Continued)\n---\n\n\n\n---\n\n# Unraveling the Conundrum: Are They Two Separate Bugs, Or Just One?\n\nWhenever you're delving deep into bug relief, it often becomes a question whether to report similar issues separately or bundle them as one. Well, this blog post seeks to clarify these foggy waters, drawing on a practical example involving two similar software functions. Let's dive in, shall we?\n\n## Dissecting the Problem at Hand\n\nOur situation consists of two seemingly identical problems arising from similar functions. You might be asking, as did one of our colleagues, _why are we reporting these as two separate issues? Aren't they the same issue?_.\n\n![](https://cdn.videotap.com/6gzcQPFB2rgdRBI8JFJa-11.36.png)\n\nFair question, right? After all, it's an essential part of troubleshooting to identify the issues accurately, so we can apply correct fixes and prevent future recurrences. Let's start by understanding the root cause of these bugs to see if they are more distinct than they appear.\n\n### The Root Cause\n\n> \"In every complex problem lies an opportunity to learn.\"\n\nLook closely, and we find that the two bugs have slightly different root causes.\n\n**Bug 1:** The problem here is that after 'someone else' approves, a user can surreptitiously 'steal' their funds. This issue essentially arises from an 'arbitrary send' from another user, which isn't supposed to happen in a robust, secure system.\n\n**Bug 2:** We see that while it deals with 'stealing' as well, the issue isn't strictly similar. The problem here essentially arises from the vault always having maximal approvals. This bug, therefore, isn't solely dependent on the thieving user, but also on the software giving unwarranted permissions.\n\n![](https://cdn.videotap.com/l0gRdGu8ti9QkBOZPlHZ-36.92.png)\n\nYes, you could argue that at their core, these issues do outline a 'similar' root cause. This claim holds some merit after all since both problems involve unauthorized access and fund misappropriation. Still, the dramatic differences in the details could be seen as suggesting two separate bugs.\n\n### An Interesting Conundrum\n\nWe stand before an interesting conundrum in software debugging ‚Äî whether to consider identical root causes with different details as a single bug or multiple. Personally, I find these two bugs intriguingly intricate enough to merit separate reports. Of course, as this is not a hard and fast rule, opinions may differ. There's room for a heated debate here, with Technocrat A claiming they're the same issue and Developer B insisting they're two different things.\n\n### The Result: Two Bugs or One?\n\nPutting aside the scholarly debate on debugging philosophy, in practical terms, we have two problems that necessitate separate solutions. Thus, regardless of their identical core, from our perspective, these remain two separate findings.\n\n![](https://cdn.videotap.com/PtXNrChg21iZ1dkXkyTz-53.96.png)\n\n## And We Are 'Cooking'\n\nIn our world of programming, this is called 'cooking.' We take the raw ingredients (issues) and turn them into tasty dishes (resolved problems).\n\nAre there any other issues lurking beneath the surface? Possibly. For now, though, I think we're in good shape having identified these two intriguing bugs. We've ironed out a major part of our problem-solving journey, leaving potentially two more crucial functions to dissect.\n\nSo what's the lesson here? Bugs always aren't what they seem. And, just as crucially, sometimes they are exactly what they seem. But the beauty of it all lies in the exploration and discovery.\n\nStay tuned in to our coding adventures. Let's see what else we discover along the way. Happy 'cooking'!\n",
          "updates": []
        },
        {
          "lessonId": "c5c88396-a8a2-49a8-922b-845543a3b3aa",
          "number": 24,
          "title": "Recon Continued Again (again)",
          "slug": "recon-again-again",
          "folderName": "24-recon-again-again",
          "description": "",
          "duration": 6,
          "videoUrl": "yWaeMeT9eoc",
          "rawMarkdownUrl": "/routes/security/7-bridges/24-recon-again-again/+page.md",
          "markdownContent": "---\ntitle: Recon (Continued) Again\n---\n\n\n\n---\n\n# Understanding Token Withdrawal From L2 to L1 in Blockchain\n\nIn this post, we'll be deep diving into a crucial function that is responsible for the withdrawal of tokens from L2 to L1. Along the way, we will demystify some blockchain terminologies like VR and S, and explore how security mechanisms prevent replay attacks.\n\nIn this process, we are going to look into two essential parameters: VR and S, and the address of the user, and then explore the 'send to l one V, R and S' function. We will also dig a little into gasless transactions and encoding some data in various functions.\n\n## Signature: A Safety Net Against Replay Attacks\n\nThe function we will be examining requires what we refer to as \"signature\" - an essential feature to prevent sketchy replay attacks.\n\n```js\n  function withdrawL2(address _l2Token,address _from,address _to,uint256 _amount,uint32 _l1Gas,bytes calldata _data) external returns (bytes memory){}\n```\n\nHere, `_from` works as the address of the user receiving tokens on L1. `_amount` determines the tokens to withdraw, and `data` emits the signature coming from the signed data. This gives us VR and S.\n\n## Embarking on The Token Withdrawal Journey\n\n![](https://cdn.videotap.com/UsY4cL26EFFcQNaxeMa5-118.72.png)\n\nNow, let's walk through the process of withdrawing tokens from L2 to L1. In the function, it's apparent that anyone can initiate a token withdrawal to L1. Let's analyze the step that happens when we call 'send to l1 V, R and S'.\n\n## Signature Verification and Gasless Transactions\n\nTokens are withdrawn from L2 to L1 upon calling 'send to l1 V, R and S.' ABI encoding (a part of signing in Ethereum) is key to our discussion here. It signs the essential message we will verify for authenticity.\n\n> \"Allowing people to call transactions by signature introduces the beneficial feature of gasless transactions, called relays.\"\n\nWithdrawing tokens via signatures brings many benefits, despite it seeming a bit unusual. For instance, it enables gasless transactions, which can help users save on network gas fees.\n\n## Unravelling the sendToL1 'V, R and S' and ECDSA Recover Function\n\nUpon calling `sendToL1`, we come across V, R and S encoded as bytes in the memory message. Let's now delve into the 'ECDSA Recover' to verify the signer.\n\n```js\nfunction recover(bytes32 hash, bytes memory signature)\n```\n\nInvoking 'recover' in the `sendToL1` function gets the function `Try Recover`, which eventually reaches out to the ECDSA recover at the lower part.\n\nIt's quite confusing, but stay with me!\n\nBehind the scene, the private key and the signed message combine to become the input parameters constituting V, R and S. The chain is verifying the message off-chain.\n\n![](https://cdn.videotap.com/VndGsyKD2Q9sT0kYNAIq-217.66.png)\n\nThe highlighted block of code converts the signed message into a designated format. The `ecrecover` and `hashutils twoethereum` play a significant role in this. Afterward, it calls `ECDSA Recover` to verify the signer.\n\nLet the code tickle your curiosity and compel you to inspect it further. So, let's proceed!\n\n## Ensuring Only Authorized 'Signer' Can Operate\n\nThe above block of code facilitates how the V, R and S signer can withdraw tokens from L2 to L1. This flow makes sense ‚Äìonly an authorized signer should be able to unlock tokens on L2. Any unauthorized access will cause a total system revert.\n\nThe codes continue to decode the message after verifying the 'signer.'\n\n```js\n  (address target, uint256 value, bytes memory data) = abi.decode(_message, (address, uint256, bytes));\n```\n\nThe system finally performs a low-level call, unlocking the token over here. It uses the 'signer' placed in the target call feature with the determined data. If this is not successful, it reverts again.\n\nHere ends our thorough examination of withdrawing tokens from L2 to L1. It can be complicated but don't sweat it; every blockchain pro started from somewhere! Happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "f751fc12-ba83-440b-89aa-c9f884a04542",
          "number": 25,
          "title": "Exploit: Signature Replay",
          "slug": "exploit-replay",
          "folderName": "25-exploit-replay",
          "description": "",
          "duration": 1,
          "videoUrl": "RmXJ8RsU318",
          "rawMarkdownUrl": "/routes/security/7-bridges/25-exploit-replay/+page.md",
          "markdownContent": "---\ntitle: Exploit - Signature Replay Introduction\n---\n\n\n\n---\n\n# Deep Dive Into Blockchain Security: Unraveling possible threats.\n\nOne of the most critical aspects of blockchain technologies is the security of transactions. From initial transaction construction to the validation and final verification, every step needs to be sealed tight against possible leaks and malicious hacks.\n\n![](https://cdn.videotap.com/U6sIP6ZAYI2aZNSWp4tF-3.87.png)\n\nThere is an exciting operation happening here, particularly the part where cryptography plays an integral role in securing these transactions. Yet, can we say with utter certainty that this operation is foolproof? Let us explore this in detail.\n\n## Role of Cryptography in Blockchain Security\n\nPrimarily, a piece of cryptographic math, or simply cryptomath, is used to generate a digital signer, or simply, Signer. The very next step is to verify that this Signer in question is legitimate. Primarily, this is designed to prevent unauthorized users or hackers from tampering with the information or modifying it to their advantage.\n\nBut the crucial question is, is there a way for some other random user, possibly with malicious intent, to bypass this system and pose as the Signer?\n\nTheoretically, let‚Äôs analyze this process in detail.\n\n### Examining the Signature Placement\n\nThink about it like this:\n\nWhen the Verification Result (VR) and Signature (S) are placed on the blockchain, they form what is essentially a 'signature.' Once the signature is up on-chain, it becomes universally visible. It's comparable to a signed message that's been broadcasted across the network.\n\nAs a user, you won‚Äôt have access to the private key, but the signed message is right there, quite visible. Still, unless you misuse this, everything is as safe as it should be, correct?\n\nHere's where things start to become interesting.\n\nConsider this scenario:\n\n_What if another user decided to send the exact same signed message?_\n\nIt does sound a bit nerve-wracking, doesn‚Äôt it?\n\n```js\nif (message.signature === duplicated_message.signature) {\n  console.log(\"Threat detected\");\n}\n```\n\nUpon reflection, this certain aspect reveals the possibility of a potential security breach. An unauthorized user might mimic a legitimate sender by duplicating the signature, consequently causing a remarkably serious issue.\n\n> **Blockquote**: \"He who knows only his side of the case, knows little.\" - John Stuart Mill\n\n## The Vulnerability Verdict: Is Blockchain Security Assured?\n\nSo, putting it bluntly, could this be the Achilles Heel in our otherwise 'unbreakable' blockchain security? It indeed could be! As developers and engineers passionate about blockchain technology, it's critical that we assess and address every overlooked vulnerability. In this context, considering the possibility of a duplicate signed message on-chain could point us to areas of our system that require more robust fortification.\n\nEngaging in such analytical exploration is not just about identifying problems. It's also about fostering a culture of improvement and evolution in the world of blockchain technology. With every obstacle we overcome, we not only make our systems safer; we also contribute to the overall growth and credibility of blockchain technology.\n\n![](https://cdn.videotap.com/0t4sBJFtbzZLfqeahsX4-54.13.png)\n\nIn conclusion, blockchain security depends heavily on its cryptographic standards. Even though the possibility of a breach might be low, as technology progresses and attackers become more sophisticated, possibilities might become realities. Therefore, remaining informed, prepared, and proactive is the key to staying one step ahead!\n",
          "updates": []
        },
        {
          "lessonId": "2068428c-986b-408b-a3d9-afd659319258",
          "number": 26,
          "title": "Signature Replay: Minimizd",
          "slug": "replay-minimizd",
          "folderName": "26-replay-minimizd",
          "description": "",
          "duration": 2,
          "videoUrl": "mZ-iSJA6hiI",
          "rawMarkdownUrl": "/routes/security/7-bridges/26-replay-minimizd/+page.md",
          "markdownContent": "---\ntitle: Exploit - Signature Replay Minimized\n---\n\n\n\n---\n\n# Understanding Signature Replay Attacks: A Critical Look at Contemporary Blockchain Exploits\n\nLet's delve headfirst into one of the most recurrent threats on the blockchain- signature replay attacks. These attacks are unpleasantly commonplace and understanding them thoroughly is paramount in creating a secure, decentralized network. Now, signature replay attacks might sound menacingly complicated at first thought, but trust me, as we go through the concepts and how it actually happens, it will become significantly less intimidating!\n\nIn my quest to provide a hands-on understanding of these signature replay attacks, I have created a fantastic open-source repo, `sc-exploits-minimized`, that will allow you to fiddle with blockchain signatures and remix them as you'd like. It's a great playground to get those hands dirty, but for the sake of understanding, I find it easier to pull up the **SC Exploits Minimized Test Case Unit**, specifically `signatureReplaytest.sol` file, and witness how signature replay attacks unfold in reality.\n\n## The Anatomy of Signature Replay Attacks\n\nHere's a breakdown of how the signature replay attack operates in this particular test case. The process involves a victim and an attacker, each playing their parts in a scenario that very much reflects the real-world possibility of such attacks.\n\nHere's an overview of the function: `testSignatureReplay`.\n\n- Firstly, a victim deposits some funds into the protocol. It's like putting your money in a virtual safe.\n- Once deposited, they engage in all sorts of encoding activities.\n- The victim then signs the digest or the formatted message to get the V, R and S values- These are generated as part of the ECDSA (Elliptic Curve Digital Signature Algorithm) sign message function.\n- After signing the digest, they proceed to call `WithdrawBySIG` to withdraw the required amount.\n\nThis process, even though seems harmless, opens up a large vulnerability for potential attackers to exploit.\n\n```js\nfunction testSignatureReplay() public {\n    /* victim deposits into the protocol */\n    ...\n    /* encoding and digest signing to get V, R and S */\n    ...\n    /* victim calls 'WithdrawbySIG' */\n    ...\n    }\n```\n\n![](https://cdn.videotap.com/FIMkVw05x2zEDqU0YEm8-42.24.png)\n\n## Unpacking The Flaw\n\nSo where does it go wrong? Well, it's the post-withdrawal phase that introduces the opportunity for an attacker to wreak havoc. This is how it goes:\n\n- Upon seeing the V, R and S on-chain, the attacker realizes that there's nothing preventing it from being reused. In essentially, having this crucial V, R and S information plastered on the chain without protections is just begging an attacker to play around with it.\n- The attacker then proceeds to continuously call `WithdrawbySIG` until all the money is missing, effectively draining the victim's funds.\n\nKeep in mind that in this example, the attacker does not steal any money. Their primary goal is to kick the victim out of the protocol permanently, rendering any further transactions or involvement in the system impossible for the victim.\n\nIt‚Äôs essential to note that the lack of mechanism in place to prevent the V, R and S from being reused is the critical flaw in this script.\n\n> **_\"To tackle signature replay attacks effectively, you need to understand that the crux of the problem is the reuse of VR and S with no protective measures.\"_**\n\n## The Bigger Picture\n\nSignature replay attacks expose significant vulnerabilities in the blockchain system, making them a fertile ground for attackers to exploit. By understanding the nuts and bolts of these attacks, you can develop robust systems and strategies to circumvent these risks, contributing to a secure and more decentralized financial network.\n\nAs we dive deeper into this brave, new, decentralized world, remember that understanding is the first step towards prevention. We aren't just tech enthusiasts; we're defenders of the future of finance! Be vigilant and keep learning.\n",
          "updates": []
        },
        {
          "lessonId": "8ffdf897-73ba-4c5c-96c8-aa49a0c6f3ea",
          "number": 27,
          "title": "Signature Replay: Protection",
          "slug": "signature-replay-protection",
          "folderName": "27-signature-replay-protection",
          "description": "",
          "duration": 7,
          "videoUrl": "6zQgZzW83Jg",
          "rawMarkdownUrl": "/routes/security/7-bridges/27-signature-replay-protection/+page.md",
          "markdownContent": "---\ntitle: Signature Replay Protection\n---\n\n\n\n---\n\n# Vulnerabilities Found in the V, R and S: A Deep Dive into Replay Protection\n\nWelcome to another deep dive into smart contract vulnerabilities. We're dissecting V, R and S -- a signature often found in blockchain technology.\n\n![](https://cdn.videotap.com/fepx5pOEwGHrxsJGEs9y-17.14.png)\n\nDuring this long and fascinating journey, we'll be breaking down each step to understand the vulnerabilities at a granular level. In particular, we'll be examining whether this signature benefits from replay protection. Spoiler alert: it doesn't. Let's delve in!\n\n## Crafting a Proof of Concept Code\n\nOur journey starts by raising a sobering question: Can this signature be deployed more than once? To answer this, we put together a proof-of-concept code that shows how this could potentially occur, leading to vulnerabilities.\n\n```javascript\nfunction testSignatureReplay() public {\n    uint vaultInitialBalance = 1000e18;\n    uint attackerInitialBalance = 100e18;\n    address attacker = makeAdr(attacker);\n    deal(address tokenAddress, vault, vaultInitialBalance);\n    deal(address tokenAddress, attacker, attackerInitialBalance);\n    uint v, bytes32 r, bytes32 s = vm.sign(private key ...);\n    bytesmemory message = abi.encode(address token, 0, encodeCall(IERC20.transferFrom(address vault, attacker, attackerInitialBalance) ));//in a loop until vault balance is zero\n    tokenbridge.withdrawTokensToL1(attacker, attackerInitialBalance, V, R, S);\n    assertEqual(token.balanceOf(address attacker), attackerInitialBalance + vaultInitialBalance);\n    assertEqual(token.balanceOf(address. Vault), 0);\n}\n```\n\nLet's break this down.\n\nThe function `testSignatureReplay()` assumes that a vault already holds some tokens. The initial balance of the vault and an attacker are given. The function then carries forth several deals. An attacker is set up who deposits tokens to a layer 2 (L2) chain.\n\n## Signature and Transfer\n\n```javascript\n uint v, bytes32 r, bytes32 s = vm.sign(private key ...);\n```\n\nThis part of our code does a bit of magic by signing the data with a private key. Thanks to Foundry, we can utilise a cheat code `VM.sign` to sign with the operator key, and then hash the actual data.\n\nThe next step is to formulate our `message`.\n\n```javascript\nbytes memory message = abi.encode(address token, 0, encodeCall(IERC20.transferFrom(address vault, attacker, attackerInitialBalance) ));\n```\n\nHere, we're essentially encoding a message instructing a transfer from the vault to the attacker. The signed message containing the V, R, and S values are usually what prompts MetaMask to ask for confirmation.\n\nThe signed message indicates a legitimate deposit of tokens from Layer 1 (L1) to L2. The operator, seeing this as valid, then submits V,R,and S on-chain.\n\nThis is the point where the replay attack becomes feasible. As soon as the operator's signature is placed on-chain, an attacker can simply keep invoking `withdrawTokensToL1` using that very same signature, draining balance from the vault until it's completely empty.\n\n## The Aftermath\n\nAnd how do we know it works? After running this function, we have successfully drained the vault entirely whilst increasing the attacker's balance accordingly:\n\n```javascript\nassertEqual(token.balanceOf(address attacker), attackerInitialBalance + vaultInitialBalance);\nassertEqual(token.balanceOf(address. Vault), 0);\n```\n\nIn short, we've just carried out a successful attack!\n\n## Wrapping up\n\nLooking at the given scenario, it becomes evident how signatures without replay protection, such as the one in our example, can pose significant security risks. Despite its relatively small codebase, such attacks can have substantial consequences. Always remember, when coding smart contracts, always ensure that your code includes mechanisms to prevent a replay attack.\n\nAudit data and additional findings related to the topic can be found in the corresponding Git Repo. Happy coding and be safe!\n\n> \"Security in blockchain technology involves a constant combat against potential threats and vulnerabilities.\"\n",
          "updates": []
        },
        {
          "lessonId": "eb2034da-2814-4886-8a0d-22708017cf33",
          "number": 28,
          "title": "Signature Replay: Prevention",
          "slug": "sig-replay-prevention",
          "folderName": "28-sig-replay-prevention",
          "description": "",
          "duration": 1,
          "videoUrl": "tZvU3fjIz80",
          "rawMarkdownUrl": "/routes/security/7-bridges/28-sig-replay-prevention/+page.md",
          "markdownContent": "---\ntitle: Sig Replay Prevention\n---\n\n\n\n---\n\n# The Art of Preventing Signature Replay Attacks\n\nHello there! In today's digital world, the protection of your data and privacy are of the utmost importance, especially when it comes to the vast field of cryptography. One common area where issues might arise involves signature replay attacks. Before we delve into the prevention methods, it's important to understand what these attacks are.\n\n![](https://cdn.videotap.com/5mzAbV6qyV86T7x1bv34-2.67.png)\n\nA signature replay attack involves an attacker illicitly using a data transmission or digital signature multiple times, potentially leading to fraudulent actions. In order to put a stop to this, the most prevalent method is to utilize something called 'nonces' or include a deadline. Curious to know more? Let's dive in.\n\n## Nonces ‚Äì A Key Combatant Against Replay Attacks\n\nA ‚Äònonce,‚Äô or ‚Äònumber used once,‚Äô is an arbitrary number that can be used precisely one time in a cryptographic communication. It is commonly a random or pseudo-random number, serving as one of the strongest safeguards against signature replay attacks. It's this concept that plays a pivotal role in preventing these types of attacks.\n\nThe mechanism is straightforward: We put some specific parameters into the signature. When the signature gets hashed, or signed, it can only be used one time.\n\n## Ensuring The Authentic Signature Sender\n\nOf course, the nonce method is just the start. To ensure the integrity of our message, it might also be necessary to verify that the initial signature was obtained from the actual sender or originator.\n\nConsider this: The first time a message is signed, it's crucial that the signature be from the _true_ signer. It sounds obvious, right, but how can we make sure of this?\n\nAgain, our solution lies in the way we handle and hash our signatures, in something called a digital signature scheme. A digital signature scheme ensures that each signature made on the same message is unique by varying a part of the cryptographic elements used in the signing process. It might sound a bit complex, but let's break it down with a simple code example:\n\n```js\nfunction sign(message, key, private_param);\nnonce = random.getrandbits(128) // create a 128-bit random nonce\nhashed_private_param = hashlib.sha256(private_param).hexdigest()\nhashlib.sha256(key + nonce + message + hashed_private_param).hexdigest() // hash the key, nonce, message, and hashed private_param, and return as a hex string\n```\n\nIn this code, we‚Äôve added one more parameter in the signing process, a private parameter that is unique for each sender. This element is hashed and added to our overall signature.\n\n## Conclusion\n\n> ‚ÄúAlways make sure your messages and signatures come with a one-time ticket ‚Äì The nonce.\"\n\nThe use of nonces, or one-time use data, in these signatures is a crucial element in ensuring that your digital signatures are protected from being misused. If utilized correctly, they can serve as a solid wall protecting you from the potential signature replay attacks. Generally, it all boils down to integrating this concept into the design and implementation of cryptographic systems.\n\nAs with any other part of cybersecurity, staying one step ahead of possible attackers is the name of the game, so it's essential to keep learning and adapting. Stay tuned for more updates and insights into the realm of cybersecurity!\n",
          "updates": []
        },
        {
          "lessonId": "3a1b25ed-a5e3-4c7b-a2c4-2fe61c02505b",
          "number": 29,
          "title": "Exploit: Low level call to itself",
          "slug": "low-level-exploit",
          "folderName": "29-low-level-exploit",
          "description": "",
          "duration": 2,
          "videoUrl": "WMV_JgAQNwI",
          "rawMarkdownUrl": "/routes/security/7-bridges/29-low-level-exploit/+page.md",
          "markdownContent": "---\ntitle: Low-Level Exploit\n---\n\n\n\n---\n\n# Uncovering Hidden Bugs in Code Base: A Developer's Challenge\n\nToday, let's delve into a particularly intriguing part of the code base that's rife with at least two major bugs. I encourage you to dig deep, find these bugs, and thoughtfully attempt to write them out. If you don't grasp the explanation right away, don't be discouraged - just refer to the GitHub repository linked to this section for a more comprehensive understanding of these bugs.\n\nEven if the bugs are a bit cryptic in nature, Slither ‚Äì our static analysis tool ‚Äì has lobbed a figurative tip-off in our direction, indicating that things aren't all peaches and cream. So, let's proceed to unravel these bugs, shall we?\n\n### When Things Go Wrong\n\nThe first bug we have on our hands isn't as straightforward as it might initially seem. This bug is associated with a code snippet that Slither flagged as suspicious or possibly detrimental.\n\n```js\nsendToL1(Arbitrary_message);\n```\n\nIs Slither's panic alarm warranted in this situation? Unfortunately, the answer, in this case, is a resounding **yes**. The bug is not just bad, it's downright dreadful.\n\n#### Arbitrariness and the Hidden Flaws\n\nWhat's the core problem, you ask? It all pertains to the way the `sendToL1` function passes arbitrary messages. In simple terms, the function is just accepting any given inputs without any verification system, which could be a potential security risk.\n\nTo grasp this problem, we need to understand the `vault` and its `approveTo` function. This particular function can only be called upon by the `bridge`.\n\n```js\nfunction approveTo(Bridge, Token) // Can only be called by the bridge\nif (caller != Bridge){\n    throwToken.totalSupply -= caller.balancecaller.balance = 0\n    }\n```\n\nNow, imagine if someone triggers this `approveTo` function, passing malicious data asking the bridge to approve tokens for a hacker. Then, in record time, the hacker manages to drain all the tokens in the vault. Sounds like a dreadful fate, doesn't it? In the world of coding, this is just as destructive and catastrophic.\n\n> Quote: \"Bugs are like viruses - they can cause a minor irk or lead to a total system downfall.\"\n\n### Slither's Warning: A Red Flag\n\nAside from dire warnings about the first bug, Slither also gives us a prompt about another flaw in the system.\n\nIdentifying these issues is crucial for ensuring that our code remains secure, efficient, and, above all, bug-free. So, let's not sideline Slither‚Äôs red flags, and give them as much attention, if not more, as we would to the other parts of our code base.\n\n## Conclusion\n\nBugs in your code base can range from harmless to a total catastrophe. Understanding them, and more importantly, identifying them before they wreak havoc, is a crucial part of any developer's journey. SO tune in next time when we delve into more bugs and how to debug them efficiently.\n\nStay curious and keep coding!\n\n- Note: In case of any queries or difficulties in understanding the bugs, kindly refer to the associated GitHub repo for further explanation, or feel free to leave your questions in the comment section below.\n",
          "updates": []
        },
        {
          "lessonId": "79c17e62-5cdf-452a-b733-c84207283d0e",
          "number": 30,
          "title": "Exploit: Gas Bomb",
          "slug": "gas-bomb",
          "folderName": "30-gas-bomb",
          "description": "",
          "duration": 1,
          "videoUrl": "lbzFcqkO0oA",
          "rawMarkdownUrl": "/routes/security/7-bridges/30-gas-bomb/+page.md",
          "markdownContent": "---\ntitle: Exploit: Gas Bomb\n---\n\n\n\n---\n\n# Demystifying Gas Bomb and Other Blockchain Vulnerabilities\n\nThe world of blockchain is buzzing with fascinating features and vulnerabilities. One such intriguing element I'd like to shed some light on is the phenomena known as the gas bomb. This seemingly complex occurrence has sparked much debate, and I hope this post will provide you with some clarity on what exactly it is, how it works, and the kind of impact it can have.\n\n## What is a Gas Bomb Anyway?\n\nA gas bomb in blockchain terms is a low-level call where Solidity, the smart contract programming language, and the Ethereum Virtual Machine (EVM), the runtime environment, struggle to estimate the amount of computational effort (gas) needed to execute certain transactions.\n\n![](https://cdn.videotap.com/ffmuYOJbZ3iqYxllhGBD-5.94.png)\n\n> **Note**: Gas refers to the computational effort required to execute an operation in the Ethereum network.\n\nA malicious user can exploit this to trick the network into allocating absurd amounts of gas, and thereby charging other network participants excessively to execute a function.\n\n## Understanding the Implications\n\nWhat's interesting about gas bombs is how they're used in the network. For instance, while some users might employ this method to gain profits, others seem to have darker motivations. Often, these users utilise this exploit for seemingly no tangible benefits. Their motivations? To disrupt the system and cause chaos.\n\n> \"Some people just want to watch the world burn.\"\n\nIt's a poignant phrase that well encapsulates the mentality of these malicious actors. They create chaos without expecting any monetary gain in return. Their goal isn‚Äôt to profit, but simply to disrupt the system - no rhyme, no reason, just pure anarchy.\n\n![](https://cdn.videotap.com/l0jIWaD8hhNflUJypCfy-22.29.png)\n\n## Ready To Dive Deep?\n\nIf by now, you're wrapped in a whirlwind of questions, I'm glad! Because what's learning without a little bit of challenge? But, if you're wondering what the hoo-ha I am talking about, now would be a good time to pause and take a breather.\n\nI encourage you to delve in, try to construct the proof of code for the vulnerabilities we discussed, and even to try your hand at crafting your gas bombs.\n\nTo get started, consider:\n\n1. Studying the structure of a low-level call in Solidity and the EVM,\n2. Understanding the significance of gas in the Ethereum network,\n3. Exploring how it's possible for the network to be fooled into allocating excess gas,\n4. Unveiling the motivations of malicious actors, and\n5. Learning how to protect yourself against such exploits.\n\nTo aid you in your quest, I've left a plethora of resources and exciting ensemble of ideas for you to navigate through in our [GitHub repo](https://github.com/Cyfrin/security-and-auditing-full-course-s23).\n\n![](https://cdn.videotap.com/IqGVeU9yKyYfHHDeOCnY-41.6.png)\n\n## Never Stop Learning\n\nNow, we've been walking through these attacks, learning about them, discussing many proofs of code, and a lot of low-level calls. Remember, we are only at the beginning of our journey. Similar to any other journey you undertake, remember that what matters is your perseverance.\n\n> \"Pretty soon, you're going to need to start jogging or running.\"\n\nThe world of Blockchain is massive and ever-evolving. As we make our way through, be ready to pick up speed and adrenaline, from a casual amble to a determined sprint. I hope you are as excited as I am to continue this journey. Let's learn, explore, and grow together.\n",
          "updates": []
        },
        {
          "lessonId": "92f33e5e-6c4d-405c-8700-d14a85995179",
          "number": 31,
          "title": "Recap",
          "slug": "recap",
          "folderName": "31-recap",
          "description": "",
          "duration": 5,
          "videoUrl": "yULgehzLDa4",
          "rawMarkdownUrl": "/routes/security/7-bridges/31-recap/+page.md",
          "markdownContent": "---\ntitle: Recap\n---\n\n\n\n---\n\n# ![Blockchain](https://images.unsplash.com/photo-1560185004-65a33335a867?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8) GUIDE TO WALLET KEY MANAGEMENT, EVM, DIFF AND THE IMPORTANCE OF POST DEPLOYMENT IN BLOCKCHAIN\n\nHello folks! You're in for an exciting ride as today we'll be diving deeper into the world of blockchain. We've covered a lot, but there's a whole universe waiting to be explored.\n\nBefore we jump into the next section, here's an assignment. Conduct a complete competitive audit. The essence of this exercise is to immerse you in Wallet Key management, which plays a significant role in blockchain.\n\nThere's more! We'll then delve into the depths of the Ethereum Virtual Machine (EVM), Yule, Huff and Opcodes. We will close our session with four of verification and formal verification, symbolic execution - a mandatory code review that will boost your understanding of the subject.\n\nBefore that, let's quickly touch upon a DeFi Stablecoin and discuss the crucial step of post-deployment.\n\nSo let's take a breath, buckle up and review what we have learned so far!\n\n## A Deep Dive into EVM Diff\n\nDid I mention we will be exploring EVM Diff also? It's a fantastic tool that allows for comparison of different chains, say Ethereum to Optimism or Arbitrum, highlighting the nuances between these chains.\n\nThrough EVM Diff, you can observe how the chain IDs, names, block explorers vary, and how precompiles work differently. This makes it a constructive tool to test compatibility across various EVM compatible chains.\n\n![](https://cdn.videotap.com/d3RNbllZQnlENKKuA1Rp-72.28.png)\n\nNow, it's not all smooth sailing. There might be some hiccups, like finding some precompiles in Arbitum which are absent in EVM or Arbitum‚Äôs different transaction and signature types. Plus, their Opcodes function a bit differently, with some key Opcodes like Push Zero being unsupported on Arbitrum.\n\n## Harnessing the Power of Artificial Intelligence\n\n![](https://cdn.videotap.com/swSuUGyJFrnTQu8g4kzs-104.41.png)\n\nWe haven‚Äôt delved too much into AI yet, but it's worth mentioning its relevance especially for the crypto enthusiast. Use AI, like Chat GPT, Elon Musk's new 'Find, Use Grok' to simplify things in blockchain. It can be a helpful tool when decoding intricate patterns or asking pertinent questions.\n\nIn our roadmap, we have upcoming plans for an AI helper for [Cyfrin Updraft](https://updraft.cyfrin.io) that will be a game-changer. So, that's something to look forward to!\n\n## The Importance of Checklist: A Lesson from Tenderly and The Hans\n\nYes, the age-old practice of running through checklists is crucial, even in something as modern as blockchain.\n\nAlthough we didn‚Äôt discuss [Tenderly](https://tenderly.co/), it's a notable tool in this domain. Our focus was on the lessons from 'the Hans' stressing on the essentiality of having a checklist. These lists keep you on track, enabling a methodical approach to your manual review process.\n\n## Understanding Precompiles, Private Keys and Signatures\n\nWe mentioned polygon precompile during our case study, emphasizing on how crucial it is to cross-verify and how failing to do so can be costly.\n\nWe've delved into the concept of public and private keys and how these signatures work on-chain. The importance of nonce in signature replays was discussed - they work as a one-time pass for usage ensuring your signatures don't get misused.\n\nWe touched on several critical aspects, like undertaking low-level calls and dealing with the sign in it, and also brushed up on L1s and L2s.\n\n![](https://cdn.videotap.com/wx8Rvhp7nAsmP3hocQLb-200.78.png)\n\nBy now, you should be competent enough to write your own Proof of Concepts (POCs). The ball is in your court!\n\n## Historic Bridge Hacks - Ronan, Polly Nomad and Wormhole\n\nWe intentionally didn't touch upon these major blockchain hacks. Each of these hacks had a devastating effect, with losses running into hundreds of millions. However, they were mainly due to centralized processes, rather than any significant bug.\n\nReading [Rekt.news](https://www.rekt.news/) articles about these hacks will help you comprehend the magnitude of these events. The rise of protocols like chainlink CCIP is to address these vulnerabilities, aiming to diminish our reliance on centralized technology.\n\nThis is a lot to absorb, but remember, the world of crypto and blockchain is a non-stop learning journey. So keep exploring and evolving.\n",
          "updates": []
        },
        {
          "lessonId": "239c896a-8965-4e4a-93dc-495f581939b1",
          "number": 32,
          "title": "Exercises",
          "slug": "exercises",
          "folderName": "32-exercises",
          "description": "",
          "duration": 2,
          "videoUrl": "a4mvVYS8e1I",
          "rawMarkdownUrl": "/routes/security/7-bridges/32-exercises/+page.md",
          "markdownContent": "---\ntitle: Exercises\n---\n\n\n\n---\n\n# Decoding Blockchain Security: Navigating Attacks, and Ensuring Web Three Safety\n\nThe life of a security researcher is one of constant growth and learning. If you've completed this course and you're looking for the next steps and next actions you can take to better yourself in this space, we've provided some great suggestions:\n\nExercises:\n\n1. [Damn Vulnerable DeFi Challenges](https://www.damnvulnerabledefi.xyz/) 1, 2, 4\n2. Write a tweet thread about an interesting [finding from Solodit](https://solodit.xyz/)\n3. Tweet about how you finished the hardest audit yet!\n4. Read about more historic attacks:\n   - [Signature Replay](https://solodit.xyz/issues/router-signatures-can-be-replayed-when-executing-messages-on-the-destination-domain-spearbit-connext-pdf)\n   - [Merkle tree signature issues](https://solodit.xyz/issues/m-14-merkle-tree-related-contracts-vulnerable-to-cross-chain-replay-attacks-code4rena-factorydao-factorydao-contest-git)\n   - [Polygon Double Spend](https://medium.com/immunefi/polygon-double-spend-bug-fix-postmortem-2m-bounty-5a1db09db7f1)\n   - [Nomad Bridge Hack](https://medium.com/immunefi/hack-analysis-nomad-bridge-august-2022-5aa63d53814a)\n\n## Hands-on Security Research with Solodit\n\nNow to add a little fun to the mix. Visit Solodit, discover something that piques your interest, investigate old reported issues, and get on Twitter to share your findings! Why?\n\nCreating a tweet thread about your discoveries will help you consolidate knowledge, engage with peers and seasoned pros, and gain valuable insights on the topic. Not to mention, you could be setting the foundation for your personal brand in the security research field. So don‚Äôt shy away from sharing; this field thrives on collaborative knowledge sharing ‚Äì the more you share, the more you learn.\n\n## The Journey Through Boss Bridge and Beyond\n\nCongratulations are in order! You've conquered Boss Bridge and are on the brink of completing part one of this extensive dive into blockchain security. This is hard stuff, no doubt. But you're standing tall, arms loaded with hefty concepts, embracing the weird and the wonderful in the world of blockchain security.\n\nThrough this hurdle-ridden journey, you've gleaned a wealth of knowledge, but we're not done just yet. Let's pause for an important interlude - a pit-stop at miner extractable value (MEV).\n\n## The Unskippable Chapter on Miner Extractable Value (MEV)\n\n‚ÄúWhile it's optional to do the Vault guardians audit or security review, learning about the miner extractable value (MEV) is obligatory. All our contracts could be susceptible to MEV-related breaches\" - this just goes to show the significance of understanding miner extractable value (MEV) in the world of blockchain.\n\nIn the sections ahead, we'll dive into what MEV is, why it matters, and how we can fortify our contracts against potential issues stemming from it.\n\nNow, go ahead and take that well-deserved break, grab that cup of coffee or make that gym run. Come back refreshed, because we've got a lot more in store for you!\n\n## Wrapping Up\n\nThe world of technology is akin to a vast ocean, full of wonderful discoveries, but also home to some beastly challenges. This journey isn't meant to be a smooth sail. It's hard, and it‚Äôs meant to be. Embrace this rollercoaster ride and let the knowledge you gain empower you to make Web Three safer for all of us.\n\nSo kudos to you for making it this far; remember to rest and prepare for the next stint. Until then, happy learning!\n",
          "updates": []
        }
      ]
    },
    {
      "sectionId": "ed2143d3-17a0-4394-b225-f930e295ac04",
      "number": 8,
      "title": "MEV & Governance",
      "slug": "mev-and-governance",
      "folderName": "8-mev-and-governance",
      "lessons": [
        {
          "lessonId": "72251a4f-bba8-4c71-a8e6-5df9a58f0517",
          "number": 1,
          "title": "Introduction",
          "slug": "introduction",
          "folderName": "1-introduction",
          "description": "",
          "duration": 5,
          "videoUrl": "nd4rKNSen6s",
          "rawMarkdownUrl": "/routes/security/8-mev-and-governance/1-introduction/+page.md",
          "markdownContent": "---\ntitle: Introduction\n---\n\n_Follow along with this video:_\n\n<!-- TODO -->\n\n\n---\n\n# The Power of Repetition in Cybersecurity Research\n\nHello and welcome back! I certainly hope you've been embarking on the tasks and exercises that we've been laying out because their impact on your skillset cannot be overstated. As we reminded you at the beginning and will reiterate now, *repetition is the mother of skill*. The more time and effort you spend refining your abilities through practical application, the better you will get.\n\n## The Importance of Exercises\n\nDelving into these exercises is not simply a suggestion ‚Äî it's an indispensable step towards heightening your aptitude. They serve as the stepping stones that pave the path to your mastery. So, prioritize these exercises and practice regularly. Their rewards are directly proportionate to the effort you invest.\n\n> \"*The more you do this, the better you will get. Doing these exercises is really important and really going to level you up.*\"\n\nAbundant in the nature of our work as cybersecurity researchers, or, as we like to say, security \"research-ers\", is the onus of extensive research.\n\n## Learning: A Continuous Journey\n\nAs we strive to fortify Web 3.0 and make the Internet safer, truly grasping that learning is not a destination but a continuous journey becomes a fundamental realization. In this pursuit of knowledge and endless learning, honing the skill of learning how to learn is paramount.\n\n> \"In this quest to keep web3 safer, you will be continuously learning. You will always be on the path for learning. So learning how to learn is going to be a great skill for you.\"\n\nEveryone has a unique learning style ‚Äî what works for one person may not work for another. Therefore, it‚Äôs imperative to identify which process best suits your style of learning. Be it visual learning through infographics and diagrams, auditory learning through podcasts and audio lectures, or kinesthetic learning through hands-on, practical tasks, understanding and adapting to your preferred style can significantly contribute to your learning efficiency.\n\nObserve, adapt, and develop a process that works best for you. To retain as much information as possible from each lesson, experiment with different learning strategies and stick to the one with which you resonate the most.\n\n## Wrapping Up\n\nLearning is a continuous journey, especially in the field of cybersecurity where new trends and threats emerge regularly. Embrace the grind, value the process of learning and remember, it's the repetition of efforts that lead to perfection. Each task you complete, every solution you find, and every mistake you learn from takes you one step closer to becoming a seasoned cybersecurity researcher.\n\nSo, let us put these words into action and continue dedicating time to exercises and persistent learning. The path forward is filled with endless knowledge and it's time we kept walking on it.\n\nStay safe, and keep researching!",
          "updates": []
        },
        {
          "lessonId": "ae4c5de7-7f2a-4cc1-ae5d-17419374c389",
          "number": 2,
          "title": "Perseverance",
          "slug": "perseverance",
          "folderName": "2-perseverance",
          "description": "",
          "duration": 3,
          "videoUrl": "xb1wAceJBvY",
          "rawMarkdownUrl": "/routes/security/8-mev-and-governance/2-perseverance/+page.md",
          "markdownContent": "---\ntitle: Perserverance\n---\n\n_Follow along with this video:_\n\n<!-- TODO -->\n\n\n---\n\n\n# Why are we not going to audit Vault Guardians together? \n\nOriginally Section Eight was designed to act as our final boss vault; an encompassing guardians security review or audit. However, upon reflection, I've decided that we're going to break this up and let you into the complexity of this code base one piece at a time. \n\nAnd YOU my friend, you can go back and audit [Vault Guardians yourself](https://github.com/Cyfrin/8-vault-guardians-audit) :) \n\n## Vault Guardians\n\n<img src=\"/security-section-8/2-perserverance/vault-guardians.png\" style=\"width: 100%; height: auto;\" alt=\"vault guardians\">\n\nSo we aren't going to audit this one together, but we are going to go over some of the attack vectors you'll find in this codebase. And after we do that, you can either:\n\n1. Audit Vault Guardians\n2. Start a competitive [CodeHawks](https://www.codehawks.com/) competitive audit\n\n> \"The reason that this is so big and this is such a monster of a final audit or security review is because you will get good and you will have to get good at coming to a code base and saying, I can do this. I can complete this. This looks overwhelming to me, but it's okay because I know I'm going to come out the other side triumphantly.\"\n\n## Teamwork Makes the Dream Work\n\nIn the vast realms of smart contract security, it's not all about solo missions. Teaming up with somebody else is an incredibly powerful move. Find a buddy in the [Codehawks/Cyfrin Discord]() to share your thoughts, brainstorm, and code together. This is not just about sharing the workload but learning how others think about attack vectors, and figuring out different strategies of how they approach this maze of codes. So sync up with someone, share your findings and grow together.\n\nDespite splitting up these sections, Section Eight remains our final boss. We won't go over it in this post, but don't feel left adrift. There's an audit data branch where you can check the answers and use as reference.\n\n## We start with MEV\n\nSo... To recap.\n\n1. We are going over some exploits in this section, in particular:\n   1. MEV\n   2. Governance Attacks\n2. And then, to finish part 1 of the security course, you can either:\n   1. Audit Vault Guardians\n   2. Start a competitive [CodeHawks](https://www.codehawks.com/) competitive audit\n\nSo... LETS GET IT!",
          "updates": []
        },
        {
          "lessonId": "d3108829-ec37-4d38-a00f-af90d5f990d5",
          "number": 3,
          "title": "MEV: Introduction",
          "slug": "mev-introduction",
          "folderName": "3-mev-introduction",
          "description": "",
          "duration": 4,
          "videoUrl": "vtAOnxdFHqg",
          "rawMarkdownUrl": "/routes/security/8-mev-and-governance/3-mev-introduction/+page.md",
          "markdownContent": "---\ntitle: MEV - Introduction\n---\n\n_Follow along with this video:_\n\n<!-- TODO -->\n\n\n---\n\n## What is MEV?\n\nMev stands for \"Maximum Extractable Value\" and it's the value that blockchain node operators and users can extract by ordering transactions in a block in a specific order. \n\nIn order to develop an in-depth understanding, I would highly recommend visiting [Flashbots.net](https://www.flashbots.net/), a research and development organization dedicated to counteracting the negative implications of MEV. Their 'New to MEV' page, in particular, is a fantastic learning resource.\n\n## What is the mempool? \n\n<img src=\"/security-section-8/3-mev-introduction/regular-transaction.png\" style=\"width: 100%; height: auto;\" alt=\"regular transaction\">\n\nWhen a transaction is initiated, it is directed to a specific node which, instead of immediately integrating it into its block, places it into its 'memory pool', or 'mempool'. This constitutes the lower tier of workings that enable blockchain.\n\n<img src=\"/security-section-8/3-mev-introduction/mempool.png\" style=\"width: 100%; height: auto;\" alt=\"mempool\">\n\nAs we know, Ethereum is a Proof-of-stake blockchain and the nodes essentially \"take turns\" building blocks for the blockchain. So if you send your transaction to a single node, the node will have to wait until it's that nodes turn to include your transaction! This could take months! So what the node does is that accepts your transaction, and will often \"fan out\" your transaction to other nodes. \n\nIf it's one of the other nodes turns to build the block, if you sent enough of a tip (gas) with your transaction, the node will include your transaction in the block.\n\nSo this \"mempool\" is like a waiting room for transactions.\n\n## Front-running\n\n<img src=\"/security-section-8/3-mev-introduction/mev.svg\" style=\"width: 100%; height: auto;\" alt=\"front-running\">\n\nSuppose you're a malicious user and want to use this to your advantage. You have the ability to scan the mempool, essentially predicting future transactions. Let's say User A is malicious, and sees someone make a transaction that is going to make them $100. \n\n...Well User A might just say \"Hey! I want to make $100!\"\n\nSo what User A can do is something called *front-running*. They can send their *own* transaction *ahead* of your transaction to extra some value. The only reason they are able to extract this value is because they were able to see your transaction ahead of time. \n\nFront-running is one of the most common forms of MEV.",
          "updates": []
        },
        {
          "lessonId": "79a5fc3d-3b95-40d2-a993-07ac09a132cb",
          "number": 4,
          "title": "MEV: Minimized",
          "slug": "mev-minimized",
          "folderName": "4-mev-minimized",
          "description": "",
          "duration": 1,
          "videoUrl": "9HlscUH6NDI",
          "rawMarkdownUrl": "/routes/security/8-mev-and-governance/4-mev-minimized/+page.md",
          "markdownContent": "---\ntitle: MEV - Minimized\n---\n\n_Follow along with this video:_\n\n<!-- TODO -->\n\n\n---\n\n# MEV - Minimized\n\nWe can take a look at this image to see a minimized visual representation of what MEV looks like. In specific, this kind of MEV is known as \"front-running\".\n\n<img src=\"/security-section-8/4-mev-minimized/minimized.png\" style=\"width: 100%; height: auto;\" alt=\"regular transaction\">\n\n# MEV - Everywhere\n\nBut not only that, ALL of our sections in the security course have been vulnerable to MEV attacks! Let's go over them...",
          "updates": []
        },
        {
          "lessonId": "a8e7cd03-4078-468e-8bd1-6daaa2e043cc",
          "number": 5,
          "title": "MEV: Puppy Raffle",
          "slug": "mev-in-puppy-raffle",
          "folderName": "5-mev-in-puppy-raffle",
          "description": "",
          "duration": 1,
          "videoUrl": "Xu52108DvUo",
          "rawMarkdownUrl": "/routes/security/8-mev-and-governance/5-mev-in-puppy-raffle/+page.md",
          "markdownContent": "---\ntitle: MEV - Minimized\n---\n\n_Follow along with this video:_\n\n<!-- TODO -->\n\n\n---\n\n# Front Running\n\n## The Puppy Raffle Demo\n\nOur Puppy Raffle's core function is `selectWinner`, which allows users to select a winner in any given transaction. While this `selectWinner` transaction is in flight (pending confirmation), it is readable by other parties involved in the transaction. This means they can potentially see that the impending winner is user A (let's call them MevBot for the sake of argument) and then strategize accordingly.\n\n```javascript\nfunction selectWinner() { // Winner selection codewinner = User A\n```\n\n## When Front Running Strikes\n\n<img src=\"/security-section-8/5-puppy-mev/puppy-mev.png\" style=\"width: 100%; height: auto;\" alt=\"puppy raffle mev\">\n\nImagine user B - let's call them the Frontrunner - realizing that they're not about to win the raffle. Naturally, they may not want to continue participating in it. Sensing impending loss, Frontrunner springs into action.\n\n*A simple plan*: Before the `selectWinner` transaction goes through, they initiate another function - `refund` - which allows them to pull out their betted money.\n\n```javascript\nfunction refund() {// Refund code// User B pulls out their betted money}\n```\n\nThey are essentially saying, '*No, not on my watch! I'm getting my refund.*' And voila, Frontrunner's transaction gets refunded, while the `selectWinner` function will eventually be executed resulting in (User A) receiving less money. Why? Because Frontrunner (User B) had effectively front-run them and withdrew their betted money!\n\n## The Full Example: Implications of Front Running\n\nLet's add some numbers to visualize this more clearly:\n\n1. Let's say the Puppy Raffle has a total of 10 ETH.\n2. Frontrunner sees that User A is about to win.\n3. Frontrunner and all their peers launch their own transactions to call the `refund` function, effectively withdrawing a substantial portion of the betted money.\n4. Suddenly, there are only 1 ETH left in the pool, instead of the initial 10 ETH.\n5. Finally, the `selectWinner` transaction goes through, and MevBot ends up with a meager prize of 1 ETH instead of the expected 10 ETH.\n\nHere, front running literally robs User A of their full winnings. Frontrunner ‚Äî observing the transaction in the mempool and acting just in time ‚Äî was able to drastically alter the outcome.\n\n> \"The ability to 'spy' on pending transactions opens up the possibility for opportunists to front-run your transactions. They can swiftly act in ways that are in their favor but can potentially be detrimental to others, as the 'Puppy Raffle' scenario demonstrates.\"",
          "updates": []
        },
        {
          "lessonId": "a1e5c3a3-9f17-46f0-9146-32b2842cd63f",
          "number": 6,
          "title": "MEV: TSwap",
          "slug": "mev-t-swap",
          "folderName": "6-mev-t-swap",
          "description": "",
          "duration": 2,
          "videoUrl": "XSaJTLbtfaM",
          "rawMarkdownUrl": "/routes/security/8-mev-and-governance/6-mev-t-swap/+page.md",
          "markdownContent": "---\ntitle: MEV - T-Swap\n---\n\n_Follow along with this video:_\n\n<!-- TODO -->\n\n\n---\n\n## Exploring the T Swap Issue\n\nWhile working with T swap, there was a prominent issue that surfaced - an issue which was rooted right in the `deposit` function. The problematic player at hand was an unused `deadline` parameter.\n\nTo find the culprit, we navigated to the `SRC` and inspected the `TswapPool.sol` in T swap, where we saw the troublesome `deadline` input parameter laying idly in the `deposit` function.\n\n```javascript\n    function deposit(\n        uint256 wethToDeposit,\n        uint256 minimumLiquidityTokensToMint,\n        uint256 maximumPoolTokensToDeposit,\n        uint64 deadline\n    )\n```\n\nAnd, you ask, what was the consequence of this unutilized parameter? Well, its existence led to a scenario where a deposited transaction could potentially be delayed without encountering a timeout, thereby enabling 'front running'. \n\nA node who receives this transaction could hold your deposit transaction until it benefits them to deposit you in!\n\n## Understand the Impact: An Simple Illustration\n\n<img src=\"/security-section-8/6-tswap-mev/t-swap-mev.png\" style=\"width: 100%; height: auto;\" alt=\"t-swap mev\">\n\nLet's understand the implications with an example. Suppose a user, 'User A', initiates a `deposit` call. However, this call was sent to a particular node connected to an MEV bot, let's call this 'User B'.\n\nThe node, upon receiving the transaction, realizes that the deposit from 'User A' would dwindle its share in the pool. Just by chance, it also knows of certain larger imminent transactions, which will result in big fees. Therefore, the node chooses to stall the transaction from 'User A' temporarily, permitting 'User B' or the MEV bot to collect the big fees ‚Äì effectively front running 'User A'.\n\n## Introducing 'Sandwich attacks'\n\nBeyond just front running, there are worst forms of deceiving manoeuvres - one such issue that potentially arises in T swap is known as 'Sandwich attacks'. These are when someone front-runs you, and then also \"back runs\" you.\n\n```\n-> Their Transaction\n-> Your Transaction\n-> Their Transaction\n```\n\nThey \"sandwich\" you between two of their transactions. One such example looks like such:\n\n1. You send a TX to buy 1 ETH for 1,000 DAI\n2. An MEV bot sees this:\n   1. Buys up all the ETH, pumping the price to 2,000\n   2. Your transaction goes through, buying 1 ETH for 2,000 DAI\n   3. They then sell their ETH for it's inflated price \n\nSeeing your big order of 1 ETH come in, the MEV bot manipulated the market so you paid more, and they profited. ",
          "updates": []
        },
        {
          "lessonId": "0435db83-e395-44dd-9c86-07fd2c736a43",
          "number": 7,
          "title": "MEV: ThunderLoan",
          "slug": "mev-thunder-loan",
          "folderName": "7-mev-thunder-loan",
          "description": "",
          "duration": 2,
          "videoUrl": "l0Wuk4UDDAU",
          "rawMarkdownUrl": "/routes/security/8-mev-and-governance/7-mev-thunder-loan/+page.md",
          "markdownContent": "---\ntitle: MEV - Thunder Loan\n---\n\n_Follow along with this video:_\n\n<!-- TODO -->\n\n\n---\n\nSpeaking of Sandwich Attacks, that's exactly what happens in the Thunder Loan protocol. \n\n## An Introduction to Thunderloan and Potential MEV Issues\n\nThe Thunderloan protocol is a platform where users can take out flash loans, with a fee currently standing at ten USDC. These fees are directly withdrawn from TSWAP pools. However, the protocol's design makes it susceptible to MEV strategies. \n\n## The Sandwich Attack: A Closer Look\n\n<img src=\"/security-section-8/7-mev-thunder-loan/thunder-loan-mev.png\" style=\"width: 100%; height: auto;\" alt=\"t-swap mev\">\n\n\nHere's how it goes:\n\n1. User A makes a request to the Thunderloan protocol for a flash loan.\n2. Seeing the incoming flash loan request, User B, decides to exploit the situation. User B doesn't just want the fee to be high, they want it way higher!\n3. User B then front runs the flash loan function, and spikes the price on Uniswap by taking out a flash loan *themselves* to make the price go higher. Effectively, this swap alters the balances from the initial ten USDC and one ETH to highly skewed figures: perhaps 0.1 ETH and an astronomical amount of USDC (let's say a billion). Since the fee is derived from the T-Swap pool, the Thunder Loan platform now has a way bigger fee, that the user wasn't aware of. \n4. Then, after collecting the fee, User B swaps back to the original ratio of 10 USDC and 1 ETH.\n\n## The Takeaway\n\n> \"Understanding the landscape of MEV vulnerabilities, and how it can lead to 'Sandwich Attacks,' is paramount for DeFi users. Only by identifying potential threats can we begin to devise methods to avoid being sandwiched.\"\n\nThe above exploration of the potential MEV issue in Thunderloan paints a broader picture of potential vulnerabilities in DeFi protocols. By shining light on this issue, we can aspire to ensure safer transactions and reduce the adverse impacts of MEV exploits.\n",
          "updates": []
        },
        {
          "lessonId": "0856ee94-ef38-45d1-91a3-0b56194b3338",
          "number": 8,
          "title": "MEV: BossBridge",
          "slug": "mev-boss-bridge",
          "folderName": "8-mev-boss-bridge",
          "description": "",
          "duration": 1,
          "videoUrl": "xH_obN07jGU",
          "rawMarkdownUrl": "/routes/security/8-mev-and-governance/8-mev-boss-bridge/+page.md",
          "markdownContent": "---\ntitle: MEV - Boss Bridge\n---\n\n_Follow along with this video:_\n\n<!-- TODO -->\n\n\n---\n\n## MEV - Boss Bridge\n\nNow you're starting to see the picture, and the Boss Bridge MEV becomes clear. \n\n<img src=\"/security-section-8/8-mev-boss-bridge/mev-boss-bridge.png\" style=\"width: 100%; height: auto;\" alt=\"boss bridge mev\">\n\nIf you send a transaction with your signature on-chain, someone can easily see that transaction in the mempool, and then send their own transaction with your signature!\n\n## Prevention\n\nTo prevent this, we can do something similar to the Signature Replay protection, where we add a nonce, make sure the first time it's called with the signer, etc. \n\n",
          "updates": []
        },
        {
          "lessonId": "db99bec6-0e4b-4b88-88b1-af410e917a5d",
          "number": 9,
          "title": "MEV: LIVE",
          "slug": "mev-live",
          "folderName": "9-mev-live",
          "description": "",
          "duration": 12,
          "videoUrl": "vM2rXG0bB-w",
          "rawMarkdownUrl": "/routes/security/8-mev-and-governance/9-mev-live/+page.md",
          "markdownContent": "---\ntitle: MEV - LIVE\n---\n\n_Follow along with this video:_\n\n<!-- TODO -->\n\n\n---\n\n# Now, we are going to watch a video of me getting front-ran, LIVE\n\nHere is [the code we are going to use to see it](https://github.com/Cyfrin/sc-exploits-minimized/blob/main/src/MEV/Frontran.sol)\n\n```javascript\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\ncontract FrontRan {\n    error BadWithdraw();\n\n    bytes32 public s_secretHash;\n\n    event success();\n    event fail();\n\n    constructor(bytes32 secretHash) payable {\n        s_secretHash = secretHash;\n    }\n\n    function withdraw(string memory password) external payable {\n        if (keccak256(abi.encodePacked(password)) == s_secretHash) {\n            (bool sent,) = msg.sender.call{value: address(this).balance}(\"\");\n            if (!sent) {\n                revert BadWithdraw();\n            }\n            emit success();\n        } else {\n            emit fail();\n        }\n    }\n\n    function balance() external view returns (uint256) {\n        return address(this).balance;\n    }\n}\n```\n\nWatch the video to see:\n1. Me get front-ran\n2. How we prevent it with [Flashbots Protect](https://docs.flashbots.net/flashbots-protect/overview)\n",
          "updates": []
        },
        {
          "lessonId": "2a8ee81a-1be3-46f5-ba4e-cca550526af3",
          "number": 10,
          "title": "MEV: Live AGAIN",
          "slug": "mev-live-again",
          "folderName": "10-mev-live-again",
          "description": "",
          "duration": 6,
          "videoUrl": "p_hE0sq0uU8",
          "rawMarkdownUrl": "/routes/security/8-mev-and-governance/10-mev-live-again/+page.md",
          "markdownContent": "---\ntitle: MEV - Live AGAIN!\n---\n\n_Follow along with this video:_\n\n<!-- TODO -->\n\n\n---\n\n# Can we obfuscate the transaction?\n\nSo, a lot of people saw me do this and started to theorize.\n\n- \"Hey, could we obfuscate the transaction?\"\n- \"What if there was another contract in the way?\"\n- \"What if it was written in assembly?\"\n\nAnd I'm here to tell you, it doesn't matter. The bots simulate the transaction, and pick out the parts they can use to make money. \n\nWe look at a [modified example](https://github.com/Cyfrin/sc-exploits-minimized/blob/main/src/MEV/Bouncer.sol) where we add a \"bouncer\" contract to try to \"block\" the transactions.\n\n<img src=\"/security-section-8/10-bouncer/bouncer.png\" style=\"width: 100%; height: auto;\" alt=\"bouncer\">\n\n```javascript\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\ninterface IFrontRan {\n    function withdraw(string memory password) external;\n}\n\ncontract Bouncer {\n    error Bouncer__NotOwner();\n    error Bouncer__DidntMoney();\n\n    address s_owner;\n    address s_frontRan;\n\n    constructor(address frontRan) payable {\n        s_owner = msg.sender;\n        s_frontRan = frontRan;\n    }\n\n    function go(string memory password) external {\n        if (msg.sender != s_owner) {\n            revert Bouncer__NotOwner();\n        }\n        IFrontRan(s_frontRan).withdraw(password);\n        (bool success,) = payable(s_owner).call{value: address(this).balance}(\"\");\n        if (!success) {\n            revert Bouncer__DidntMoney();\n        }\n    }\n\n    receive() external payable {}\n}\n```\n\nSo, watch the video above to see, will this contract help block the MEV bots? ",
          "updates": []
        },
        {
          "lessonId": "f89212c6-f10f-42ec-a5f1-cdfeccb54041",
          "number": 11,
          "title": "Case Study: Pashov",
          "slug": "case-study-pashov",
          "folderName": "11-case-study-pashov",
          "description": "",
          "duration": 24,
          "videoUrl": "qgrV89fhhFw",
          "rawMarkdownUrl": "/routes/security/8-mev-and-governance/11-case-study-pashov/+page.md",
          "markdownContent": "---\ntitle: MEV Case Study - Pashov\n---\n\n_Follow along with this video:_\n\n<!-- TODO -->\n\n\n---\n\nTo walk us through some real-world reports where MEV was reported, we have guest lecturuer [Pashov](https://twitter.com/pashovkrum) to walk us through! \n\n\n<img src=\"/security-section-8/11-pashov/pashov.png\" style=\"width: 100%; height: auto;\" alt=\"pashov\">",
          "updates": []
        },
        {
          "lessonId": "1323222f-b81d-4173-b237-f43b130d3042",
          "number": 12,
          "title": "MEV: Prevention",
          "slug": "mev-prevention",
          "folderName": "12-mev-prevention",
          "description": "",
          "duration": 4,
          "videoUrl": "G_I6qKce4lE",
          "rawMarkdownUrl": "/routes/security/8-mev-and-governance/12-mev-prevention/+page.md",
          "markdownContent": "---\ntitle: MEV - Prevention\n---\n\n_Follow along with this video:_\n\n<!-- TODO -->\n\n\n---\n\n## Designing For Protection\n\nOur first line of defense against MEV is to refine our designs. To illustrate this, let's revisit a puppy raffle sample.\n\nWe can shield our raffle from this kind of attack by updating our Solidity code. A simple solution would be to introduce a function, like `endRaffle`, which signifies the completion of the raffle. Once a raffle is `ended` it will enter a new state, where no one can refund or do anything until a winner is picked. Here‚Äôs an example of how we can incorporate additional protections into our smart contract:\n\n<img src=\"/security-section-8/12-mev-prevention/endRaffle.png\" style=\"width: 100%; height: auto;\" alt=\"pashov\">\n\n\nOur contract now includes a `refund` function that checks if the raffle has ended - if it has, it reverts the function, making it impossible for users to refund their bets after peeking into the mempool.\n\n## Private or Dark Mempool\n\nWhen the designs have been beefed up, the next step to consider is the use of a private or \"dark\" mempool, such as [Flashbots Protect](https://docs.flashbots.net/flashbots-protect/overview), MEV Blocker, or a secure RPC.\n\n<img src=\"/security-section-8/12-mev-prevention/flashbots.png\" style=\"width: 100%; height: auto;\" alt=\"pashov\">\n\nInstead of submitting your transaction to a public mempool, you can send your transaction to this private mempool. Unlike the public mempool, this keeps the transaction for itself until it's time to post it on the chain.\n\nDespite its pros, the private mempool requires you to trust that it will maintain your privacy and avoid front-running. Another downside is the slower transaction speed. If you're curious, you can observe this in action by adding an RPC from Flashbots Protect to your MetaMask.\n\n\n\nAs security experts, we should always be advising protocols how they can defend their users against MEV. ",
          "updates": []
        },
        {
          "lessonId": "d66d4e52-3711-4f09-b765-2a6ea6df136d",
          "number": 13,
          "title": "MEV: Recap",
          "slug": "mev-recap",
          "folderName": "13-mev-recap",
          "description": "",
          "duration": 2,
          "videoUrl": "0nFEilLAHAQ",
          "rawMarkdownUrl": "/routes/security/8-mev-and-governance/13-mev-recap/+page.md",
          "markdownContent": "---\ntitle: MEV - Prevention\n---\n\n_Follow along with this video:_\n\n<!-- TODO -->\n\n\n---\n\n# Understanding Mev and How to Mitigate Its Impact\n\nMev refers to the potential reward that a miner, node, or bot could glean from ordering transactions. They often use the information of what's coming from the mempool to make those ording choices. \n\n## Types of Mev Attacks\n- Front-running\n- Backrunning\n- Sandwich \n- Many more...\n\nThere are various ways through which Mev can be exploited to benefit the entity spotting the transaction. Some of the most common types of Mev attacks include:\n\n- *Front Running*: This occurs when an entity spots a pending transaction and then acts quickly to execute another transaction before the victim transaction hits. \n- *Sandwich Attacks*: Similar to front running, this involves an attacker boxing in a user's transaction with their transactions on either side. \n\n## Protecting Against Mev Attacks\n\nWhile the realities of Mev can be daunting, there are ways to mitigate its impact:\n\n1. **Better Design** ‚Äì Constructing the transaction in a manner that makes it harder for bots to gain useful knowledge. This might involve masking critical information or employing other strategic measures.\n2. **Use of Private RPC or Dark Pools** ‚Äì These are networks that allow transactions to be processed outside of the public mempool. Services such as Flashbots Protect, Mev Blocker, and Secure RPC play an essential role in this regard.\n\nWe should note that Mev is not some mythical concept ‚Äì it does have real-world consequences on the Ethereum blockchain. I have witnessed firsthand the material impact of it, even losing real money in the process.\n\n> quoted text\"**Mev bots are real, and they are actively scouting for any opportunity to make money. Consequently, understanding how Mev works and how to protect against it is crucial for anyone operating within the blockchain landscape**.\"\n\nSo, having read this blog post, you should now have a solid grasp of Mev. Here's to smarter and better-secured transactions on the blockchain!\n",
          "updates": []
        },
        {
          "lessonId": "ceb58aa9-58d3-4503-aff4-92ad38a9b4f6",
          "number": 14,
          "title": "Governance Attack: Intro",
          "slug": "governance-attack-intro",
          "folderName": "14-governance-attack-intro",
          "description": "",
          "duration": 7,
          "videoUrl": "ph_xoZaMleU",
          "rawMarkdownUrl": "/routes/security/8-mev-and-governance/14-governance-attack-intro/+page.md",
          "markdownContent": "---\ntitle: Governance Attack - Introduction\n---\n\n_Follow along with this video:_\n\n<!-- TODO -->\n\n\n---\n\nFor this one, sit back and relax as Cyfrin's own [Juliette](https://twitter.com/_juliettech) gives us a walkthrough of governance attacks from a high level. ",
          "updates": []
        },
        {
          "lessonId": "1a7f7d59-f971-4aa0-8085-58514c7f818e",
          "number": 15,
          "title": "Case Study: Bean",
          "slug": "case-study-bean",
          "folderName": "15-case-study-bean",
          "description": "",
          "duration": 20,
          "videoUrl": "4FMwVKaXt6A",
          "rawMarkdownUrl": "/routes/security/8-mev-and-governance/15-case-study-bean/+page.md",
          "markdownContent": "---\ntitle: Case Study - Bean\n---\n\n_Follow along with this video:_\n\n<!-- TODO -->\n\n\n---\n\nAnd now, we have guest lecturer and fellow course creator [JohnnyTime](https://twitter.com/RealJohnnyTime) to walk us through a real-world case study of a governance attack in action.\n\nYou can read more about the [Bean attack in Rekt.](https://rekt.news/beanstalk-rekt/)",
          "updates": []
        },
        {
          "lessonId": "224db888-298d-4ee2-8c67-15fc3cb6eff3",
          "number": 16,
          "title": "End Part 1",
          "slug": "end-part-1",
          "folderName": "16-end-part-1",
          "description": "",
          "duration": 10,
          "videoUrl": "PFV7C4d-EwE",
          "rawMarkdownUrl": "/routes/security/8-mev-and-governance/16-end-part-1/+page.md",
          "markdownContent": "---\ntitle: End of Part 1\n---\n\n_Follow along with this video:_\n\n<!-- TODO -->\n\n\n---\n\n# Congratulations on Nailing Part One of the Security Curriculum: Here's What's Next\n\nHey, friends. Great to see you again. What a journey it's been so far!\n\nGetting through the first part of this majorly intense curriculum deserves a massive round of applause. We've covered a variety of crucial topics. From `Mev signature replays` and `reentrancy attacks`, we've gone over the `audit process`, to `stateful fuzzing`. We've also touched on interesting concepts like `invariants`, `arbitrage`, `DeFi`, `borrowing and lending`, `flash loans`, and much more.\n\nIn just completing the last five security reviews, you've not only established a formidable portfolio but also demonstrated that persistent practice pays off. Remember: repetition is the mother of skill.\n\n\n## You got this\n\nAnd here is the thing, we've just trained you on the EXACT process the professionals do. So you know how to do this!!\n\n## The Game Plan\n\n**1. Scoping**\n\nBegin with scope identification. Determine what you're working with - the commit hash, the compatibilities, the chains, and the tokens.\n\n**2. High-Level Analysis**\n\nNext, aim to understand what the code is supposed to achieve. Read the documentation, discuss with the team, make diagrams, take notes. Dump all your thoughts down on paper.\n\n**3. Code Comprehension**\n\nTime to dive into the code. It‚Äôs okay if you don‚Äôt find anything at first ‚Äì that's normal. Simply aim to interpret the code. Ask yourself: Is the code doing what the protocol intends it to do?\n\n**4. Identifying Vulnerabilities**\n\nYour final mission is the most challenging - finding vulnerabilities. Use your checklist for guidance, looking for any weird ERC20s or potential MEV.\n\n## Testing Your Skills\n\nThe Vault Guardians code base offers greater complexity than any previous codebases. Embrace this new level of difficulty. Seize this opportunity to test your prowess in the face of adversity.\n\nMy suggestion to you: team up with a peer. This vault presents numerous bugs and issues for you to uncover, which will help build your confidence and improve your bug-finding skills.\n\n**And remember: do not proceed to part two just yet.**\n\n## A Valuable Detour\n\nNow, it's time. You have 2 options. \n\n\\**Option 1: Compete in a real competitive audit on platforms like Code Hawks. The excitement of the competition will keep you on edge and the real code base is sure to test all your abilities*.\n\n\\*\\*Option 2: Pair up and tackle the Vault Guardians codebase as a learning experience.\n\n## To Recap:\n\n1. First of all, great job! By just getting this far, you outdo more than 70% of the current security landscape.\n2. Do not move to part two yet. Either try your hand at a Code Hawks competitive audit or complete the Vault Guardians audit with a partner.\n\nRemember your security journey is far from over. Part two is where we (will) dig even deeper into assembly, EVM, formal verification, and more. \n\nSo... We are looking forward to seeing you back for Part 2 after you try your hand at either Vault Guardians or Code Hawks.\n\nGood luck!!",
          "updates": []
        }
      ]
    }
  ],
  "createdAt": "2023-12-14T09:59:03.781Z",
  "updatedAt": "2023-12-14T09:59:03.781Z"
}