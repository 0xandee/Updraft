{
  "courseId": "ec5bc4d6-9638-48da-a92a-d956a4b38003",
  "title": "Foundry Fundamentals",
  "slug": "foundry",
  "folderName": "foundry",
  "lastUpdated": "Mon Dec 11 2023 12:04:14 GMT-0500 (Eastern Standard Time)",
  "trailerUrl": "",
  "previewImg": "https://res.cloudinary.com/droqoz7lg/image/upload/v1701193477/updraft/courses/ccrmrt6nnfgcyuk2o7bu.png",
  "description": "Already know Solidity? Your next step is Foundry! Learn how to manage your dependencies, compile your project, run tests, deploy, and interact with your from the command-line and via Solidity scripts.",
  "path": "content/learning-paths/solidity-developer.json",
  "number": 0,
  "overview": {
    "learnings": "Foundry introduction, smart contracts development, oracles, smart contracts testing, intengration testing, forge test, local smart contracts deployment",
    "preRequisites": [
      "Blockchain basics",
      "Solidity fundamentals"
    ]
  },
  "duration": 10,
  "authors": [
    {
      "author": "content/authors/patrick-collins.json"
    },
    {
      "author": "content/authors/richard-gottleber.json"
    },
    {
      "author": "content/authors/vasiliy-gualoto.json"
    }
  ],
  "sections": [
    {
      "sectionId": "b224a5a3-2e7f-4c8d-b5a2-c95980b6f011",
      "number": 1,
      "title": "Foundry Simple Storage",
      "slug": "foundry-simple-storage",
      "folderName": "1-foundry-simple-storage",
      "lessons": [
        {
          "lessonId": "1583c486-11aa-4273-96e4-69f0b1f86392",
          "number": 1,
          "title": "Introduction - Foundry simple storage",
          "slug": "introduction-foundry-simple-storage",
          "folderName": "1-introduction-foundry-simple-storage",
          "description": "Introduction to transitioning from Remix IDE to Foundry for professional smart contract development, along with resources for troubleshooting.",
          "duration": 7,
          "videoUrl": "i22RLgAu51g",
          "rawMarkdownUrl": "/routes/foundry/1-foundry-simple-storage/1-introduction-foundry-simple-storage/+page.md",
          "markdownContent": "---\ntitle: Foundry Simple Storage Introduction\n---\n\n_Follow along the course with this video._\n\n\n\n# Moving Beyond Remix: The Transition to Professional Smart Contract Development\n\nWelcome to this fascinating journey from _Remix_, a phenomenal integrated development environment (IDE), to a more advanced and professional setup. Our goal is to integrate modern toolsets that are widely adopted within the development community. Although the initial transition process might seem daunting, I promise you, it's an enriching learning curve worth experiencing!\n\n## Conquering the Transition: Being Vigilant and Resourceful\n\nWe all know that setting up your local development environment without using Remix can be a challenging task. So, I urge you to make the most of these following valuable resources for troubleshooting:\n\n- [Chat GPT](https://chat.openai.com/)\n- [Stack Exchange ETH](https://ethereum.stackexchange.com/)\n- [Web three education dev](https://web3education.dev/)\n\n<img src=\"/foundry/1-introduction-foundry/foundry1.png\" style=\"width: 100%; height: auto;\">\n\nAs we embark on this journey, remember, it's okay for things not to work at the first instance. It's absolutely fine! The trick lies in asking **specific** questions related to the errors you encounter. Install these valuable resources and do not let them be an obstacle in your developmental progression.\n\n<img src=\"/foundry/1-introduction-foundry/foundry2.png\" style=\"width: 100%; height: auto;\">\n\nWe're about to take that plunge and learn how to implement these tools in our development environment right now!\n\n## Introducing Foundry: A Professional Smart Contract Development Framework\n\nAlthough we're saying goodbye to Remix, we're switching to an even more powerful tool - [Foundry](https://github.com/foundry-rs/foundry). It's renowned within the developer's community as one of the most popular smart contract development frameworks.\n\nFoundry has numerous pros, such as:\n\n- It's known for its exceptional speed\n- It's entirely Solidity-based, eliminating the need to learn other programming languages\n- Its documentation is comprehensive.\n\nCheekily referred to as Brownie or HardHat, Foundry is an invaluable asset to smart contract developers due to its speed and efficiency.\n\nDon't forget to refer to the project's GitHub repo for additional assistance. It contains all the vital code necessary for the course in handy detail.\n\n### Foundry vs. Remix: Why the Transition?\n\nNow, you might wonder, \"Why do we need to transition to Foundry when Remix appears to be working just fine?\"\n\nAllow me to clarify that. With Remix, we performed many tasks manually, such as compiling or deploying contracts and testing the logic by repeatedly clicking through the UI. If the smart contract contains a large number of functions, the process can quickly escalate, and so can the risk of introducing errors.\n\nOn the other hand, Foundry automates these tasks, reducing the risk of errors and improving workflow efficiency. With Foundry, you can run the tests for all the functions via one single command, which is not possible with Remix due to its manual nature.\n\nFoundry also deserves special mention because it is the preferred choice of Smart Contract security engineers and auditors. I'm eager for you to experience the quick and efficient nature of this smart contract development framework.\n\n## Visual Studio Code: A Powerful Text Editor\n\nNext up, I'll introduce you to Visual Studio Code, one of the most robust code editors out there. If you're already comfortable using Visual Studio Code, feel free to skip this part.\n\n<img src=\"/foundry/1-introduction-foundry/foundry3.png\" style=\"width: 100%; height: auto;\">\n\nPlease, don't confuse this with Visual Studio, a separate application - make sure that your selected version is Visual Studio **Code**.\n\nIn case you prefer working in an environment like Atom, Sublime, or with tools like PowerShell or Terminal, feel free to do so. However, for this course, we'll stick with Visual Studio Code and you will be guided through its setup.\n\n## Installation Instructions: Find the One that Suits You\n\nLastly, we'll go through the installation processes for three different systems:\n\n- Mac and Linux\n- Windows\n- Last-ditch effort: Gitpod installation.\n\nI highly encourage getting everything running natively in your local environment. However, if all else fails, follow the Gitpod installation process.\n\nStay tuned for the next post where we commence with Mac and Linux installations.\n\nThat's all for now, folks. Are you excited to get started on this thrilling journey from Remix to Foundry? Let's forge ahead with a 'learning' and 'growing' mindset!\n",
          "updates": []
        },
        {
          "lessonId": "8cd5e9ef-3879-4af3-b2b2-ba4135ed238e",
          "number": 2,
          "title": "Development environment setup (Mac, Linux)",
          "slug": "development-environment-setup-mac-linux",
          "folderName": "2-Mac-Linux-Install",
          "description": "Guide to setting up a development environment on Mac and Linux, including installing Visual Studio Code (VSCode) and Git.",
          "duration": 3,
          "videoUrl": "hqAtBgSBzPQ",
          "rawMarkdownUrl": "/routes/foundry/1-foundry-simple-storage/2-Mac-Linux-Install/+page.md",
          "markdownContent": "---\ntitle: Mac & Linux Install (VsCode & Git)\n---\n\n_Follow along the course with this video._\n\n\n\n---\n\nWelcome to our step-by-step guide to set up Your Development Environment using Visual Studio Code (VSCode) and Git. Whether you're new to coding or just trying to set up a fresh machine, this guide will get you up and running in no time.\n\n## Downloading Visual Studio Code\n\nLet's start at the very beginning: by downloading Visual Studio Code. You can download for macOS or, if you're on a Linux system, you'll want the Linux installation. After you have this software installed, you’ll be welcomed by a well-structured interface much as below.\n\n<img src=\"/foundry/2-install/install1.png\" style=\"width: 100%; height: auto;\">\n\nFortunately, this friendly code editor doesn’t leave you in the dark but gives you tips to get started. By all means, if you're unfamiliar with VSCode, seize the opportunity to navigate through the \"Get Started\" instructions. These valuable tips could clear many hurdles on your upcoming coding adventures. Additionally, the [Visual Studio Code crash course](https://youtu.be/WPqXP_kLzpo) in the GitHub repository related to this course offers a wealth of concise and handy information.\n\n## Introducing the VSCode Terminal\n\nVSCode offers an immensely helpful feature – the terminal, or command line prompts, providing the backstage entrance to run your scripts. To access it, simply navigate to the 'Terminal' tab in your menu and select 'New Terminal'—you'll be presented with a shell, which could be Bash, ZSH or another type. Regardless of the shell type, they all function pretty similarly.\n\nAt this point, a quick note on navigation helps. For Mac or Linux users, the `CTRL + backtick` command allows you to swiftly toggle between Terminal modes, providing a major productivity boost. It's always beneficial to familiarize yourself with keyboard shortcuts as they enable efficient movement around VSCode. To ease your way into shortcut navigation, here you have a comprehensive list of [keyboard shortcuts](https://code.visualstudio.com/docs/getstarted/keybindings) for VSCode.\n\nMoreover, terminals can easily be deleted and recreated. Simply hit the trash can icon to delete the terminal, then navigate to `Terminal > New Terminal` to reopen a fresh one.\n\n## Installing Git\n\nAs we delve deeper into building your development environment, it's important to introduce Git. While it's not immediately necessary, it’s good practice to install it early on.\n\nIf you're on a Linux system, you're likely to use one of two commands to install Git. On a macOS, a simple `git` command in the terminal should prompt an invitation to install.\n\n<img src=\"/foundry/2-install/install2.png\" style=\"width: 100%; height: auto;\">\n\nOnce the installation is successful, typing `git version` into the command line should give you something that looks similar to this:\n\nFor the macOS folks, there is an easier way by using the macOS Git installer that can be accessed [here](https://git-scm.com/download/mac) to run through the installation process.\n\n## Wrapping Up\n\nCongrats! You have installed Git and Visual Studio Code. With these basics in place, we'll be able to delve into more detailed coding concepts in the next sections of this guide. Please note that if you're working on a platform not covered, like Windows or Gitpod, you might want to skip the next sections.\n\nOur goal is to ease your journey into the coding world, and we're thrilled to help you establish a strong foundation. Hop onto the next sections and let’s continue this exciting journey.\n\n<!-- <img src=\"/foundry/1-introduction-foundry/foundry3.png\" style=\"width: 100%; height: auto;\"> -->\n",
          "updates": []
        },
        {
          "lessonId": "1dc6bc68-2034-4861-a2bd-8b7f96e42f1e",
          "number": 3,
          "title": "Development environment setup (Windows)",
          "slug": "development-environment-setup-windows",
          "folderName": "3-Windows-Install",
          "description": "Tutorial on setting up a development environment on Windows using WSL (Windows Subsystem for Linux) and installing Visual Studio Code.",
          "duration": 8,
          "videoUrl": "4O_GbjwhoFU",
          "rawMarkdownUrl": "/routes/foundry/1-foundry-simple-storage/3-Windows-Install/+page.md",
          "markdownContent": "---\ntitle: Windows Install (WSL)\n---\n\n_Follow along the course with this video._\n\n\n\n---\n\nWe'll be taking a special look at a handy tool known as WSL (Windows Subsystem for Linux). Assisting us in this tutorial is the amazing Basili, a guru in Windows setup who has been tremendously helpful in some of my past training courses.\n\nThis tutorial will be beneficial for anyone using Windows 10 or later versions. We'll begin by installing our code editor - in this specific case, Visual Studio Code.\n\n## Getting Started with Visual Studio Code Installation\n\nTo install Visual Studio Code (VS Code for short) on your machine, begin by opening up your web browser and typing `VS Code` in the search box. Follow these steps:\n\n- Select the VS Code version suited for Windows\n- Choose your desired installation location\n- Save the file\n- After download, proceed with the installation - the same as with any other program installation process\n\nYou'll notice that to install VS Code, you must accept the agreement and then proceed to add the code to your system path, create a desktop icon, and click 'Next' to install. The process won't take much time. After this, you can customize the theme, create shortcuts, and sync VS Code with your other devices.\n\nIf you wish to get a more in-depth understanding of VS Code, I recommend you pause this tutorial right here and explore these options one by one.\n\nAlthough we could proceed to install the rest of our development tools in a Windows environment, you'll find the following section of this tutorial very important. While Microsoft has made significant efforts to further support developers in recent years, the best option to consider still remains WSL, especially when it comes to smart contract development.\n\n## Transitioning to a Better Developer Environment with WSL\n\nThe Windows Subsystem for Linux (WSL) proves to be a considerable game-changer in this scenario. As a developer, you'll often find yourself working with tools and utilities primarily found in Unix-based environments. Windows has made significant strides in supporting developers; however, when setting up the right development environment and running certain command-line tools, some challenges persist.\n\nTo ensure that your code runs on various machines using Unix-based systems like Mac and Linux, you'll find WSL to be immensely beneficial. How exactly does WSL help? By setting up a Linux distribution using WSL, you gain access to a Unix-like console right on your Windows machine.\n\nDon't worry, you don't need to have master-level tech skills to set this up – all it takes is a few easy steps, which we'll cover next in our tutorial.\n\n## Installing WSL and Setting Up a Linux Distribution\n\nLet's start by installing WSL. Head over to the Windows Terminal, a pre-installed application on Windows 11 and easily accessible on Windows 10 via the Microsoft Store. All you have to do is type `WSL --install` and hit Enter. This will trigger the installation process requiring you to reboot your operating system.\n\n```\n# Open the Windows Terminal\n$ Windows Terminal\n# Key in the command to install WSL\n$ wsl --install\n```\n\nAfter your system reboots, the Terminal will open automatically and proceed with the installation. During the setup, you'll need to input a new Unix username - choose one unique to you - and secure it with a password of your choice. And voila, you have an operational Linux terminal on your Windows machine!\n\n## Making Visual Studio Code Compatible with WSL\n\nNow that we have our Linux terminal set up through WSL, we'll need to ensure its compatibility with VS Code.\n\nOpen up VS Code and navigate to the Extensions tab. Here, look for the Remote Development extensions and proceed to install each of them. This will enable VS Code to operate with WSL seamlessly.\n\nOnce this is done, you'll find that a new icon has appeared - 'Open a Remote Window')) which allows you to connect directly to WSL. However, there's an even simpler way to connect– through our Linux terminal!\n\nCreate a new folder in the terminal (for example, a folder named `solidity course`), navigate to this folder, then type `code .` and hit Enter. This command will automatically install the latest server for WSL on VS Code and open a new VS Code instance connected with WSL.\n\nAt this point, you should now see the WSL Ubuntu banner at the bottom of your VS Code window. You have two options to choose from when considering your development needs – either use the Windows Terminal or the integrated terminal that comes with VS Code.\n\n**Please Note:** When you conduct your projects from a folder inside Windows, like `Development` inside your documents, it's crucial to know that the WSL console will only access local files inside the WSL instance. Therefore, it's recommended to keep files inside the WSL instance for faster communication and convenience.\n\n## Preparing for Git Installation\n\nThe final part of our setup involves installing Git. While we won't directly use Git in this course, it is an essential tool for future use. To check if Git is pre-installed, simply run the command `git version`. If Git is not installed yet, you will have to install it independently.\n\nRemember, for those opting to continue with PowerShell or Windows instead of transitioning to WSL, you will need to download and install Git for Windows from the official Git page.\n\nCongratulations if you've managed to set up your developer environment as explained in this elaborate tutorial! With these tools at your disposal, you can develop smart contracts using Windows while experiencing the ease and flexibility Mac and Linux developers are accustomed to. Always ensure that your VS Code is connected to WSL Ubuntu, and feel free to use either a Windows or WSL environment, depending on your preference. Happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "f6c97bd6-2af2-4865-8076-d02bef7f32c9",
          "number": 4,
          "title": "Develop in cloud using Gitpod",
          "slug": "introduction-to-gitpod",
          "folderName": "4-gitpod",
          "description": "Overview of using Gitpod for cloud-based development, highlighting its benefits, limitations, and precautions for usage.",
          "duration": 5,
          "videoUrl": "z4jpbjQVnKQ",
          "rawMarkdownUrl": "/routes/foundry/1-foundry-simple-storage/4-gitpod/+page.md",
          "markdownContent": "---\ntitle: GitPod Setup\n---\n\n_Follow along the course with this video._\n\n\n\n---\n\nIn the vast, ever-evolving world of coding, more and more tools are being developed to facilitate programmers. One such tool is Gitpod, a cloud development environment that enables you to run your code on a remote server. In this blog post, we will guide you through the processes of setting up your development environment using Gitpod, highlighting its pros, cons and tips for smoother running.\n\n## Something About Gitpod\n\nGitpod is similar to Remix IDE and allows you to run Visual Studio code either in the browser or connected to another server. The key benefit of using Gitpod is bypassing the setup process. It spares you the need to conduct installations on any device, as you get to execute all your desired tools on the remote server.\n\nNevertheless, dependent on its status, Gitpod may also limit when you can code. It’s also worth noting that Gitpod is not completely free, which may be discouraging particularly for emerging developers.\n\nFurthermore, for the safety of your cryptocurrency, avoid running any code with a private key containing real money on Gitpod. The reason for this caution is that the remote servers may potentially access your private keys. As long as you don't use a MetaMask or any private key linked to actual funds during this interactive Gitpod setup, everything should work just fine.\n\n## Embarking on Gitpod\n\nTo begin, you will observe an \"Open in Gitpod\" button in all our code repos, starting from lesson five \"Simple Storage on Ethersjs\".\n\n<img src=\"/foundry/4-gitpod/gitpod1.png\" style=\"width: 100%; height: auto;\">\n\nAfter clicking the button, a \"Welcome to Gitpod\" sign appears and you should click on \"Continue with GitHub\". If Gitpod is linked to your GitHub account, it will automatically create a workspace for you, which mimics Visual Studio code.\n\n<img src=\"/foundry/4-gitpod/gitpod2.png\" style=\"width: 100%; height: auto;\">\n\nTo run your Gitpod from your local Visual Studio code :\n\n1. Spot if “Gitpod” is indicated.\n2. Tap the prompted pop-up, \"do you want to open this workspace in Vs code desktop?\"\n3. Install Gitpod extension on your Visual Studio code when prompted.\n4. Click \"Reload Window\" then \"Open\".\n5. The workspace then initiates a connection.\n\nAlternatively, you can manually run it by clicking \"Open in Vs code\" in the bottom left corner of Gitpod.\n\n<img src=\"/foundry/4-gitpod/gitpod3.png\" style=\"width: 100%; height: auto;\">\n\n## Navigating the Workspace\n\nIf you opt for this type of development, remember that you are coding on a remote server, not locally. Hence, never save sensitive data, such as your private keys in this workspace.\n\nThe workspace resembles your typical local setting. You can create new folders and workstations, and run all commands, just like when using Visual Studio.\n\nTo establish a new terminal, simply click on the little bar at the top left part of the screen, go to \"Terminal\" then hit \"new Terminal\". As an alternative, you can use the Control tilde shortcut, similar to macOS and Linux keyboard shortcuts.\n\nThese commands basically create a directory called \"New Folder\" then change the current directory into \"NewFolder\". To verify that you're in the right place, the command \"code .\" can be used. It transports you to the new folder.\n\n## Conclusion\n\nWhile Gitpod is not without its shortcomings, its ability to provide a ready-to-code environment that requires no installation, accessible from anywhere and on any device, makes it stand out. It's a fantastic option if you can't get the installation working.\n\nKeeping Gitpod’s conditions and a few precautions in mind, you're now ready for remote coding. Happy programming!\n\n<img src=\"/foundry/4-gitpod/gitpod4.png\" style=\"width: 100%; height: auto;\">\n\n<!-- <img src=\"/foundry/2-install/install1.png\" style=\"width: 100%; height: auto;\"> -->\n",
          "updates": []
        },
        {
          "lessonId": "e01f8186-fca4-4adc-be04-47d5c0720b66",
          "number": 5,
          "title": "Foundry setup",
          "slug": "foundry-setup",
          "folderName": "5-foundry-install",
          "description": "Step-by-step guide on installing and operating Foundry, a tool for smart contract development, compatible with Windows, Linux, and MacOS.",
          "duration": 8,
          "videoUrl": "VBYFeGO9vWc",
          "rawMarkdownUrl": "/routes/foundry/1-foundry-simple-storage/5-foundry-install/+page.md",
          "markdownContent": "---\ntitle: Foundry Install\n---\n\n_Follow along the course with this video._\n\n\n\n---\n\nWelcome to this handy guide on installing and operating Foundry, a versatile tool that will add a new level of command-line ease to your developer journey. Whether you're running Windows, Linux or MacOS, we've got you covered with instructions and tips. So sit back, grab a cup of coffee, and let's dive in.\n\n## Prepping your Terminal\n\nFirst things first. Before we dive into installing Foundry, make sure you have your terminal set up correctly.\n\nIf you are using Windows, you should see something like `WSL` or `Ubuntu`. Once you have your terminal environment ready, it’s time for some quick tips to help streamline your workflow.\n\n### Keeping your Terminal Clutter-free\n\nWhen commands pile up in your terminal, things can get a little overwhelming. Clear it up by simply typing `clear` and hitting `Enter`. Alternatively, use `Command K` if you're on a Mac or `Control K` if you're on Linux or Windows.\n\n**Pro tip:** This is one of my favorite keyboard shortcuts that I use all the time.\n\n### Understanding the Trash Can and the X\n\n<img src=\"/foundry/5-foundryinstall/foundryinstall1.png\" style=\"width: 100%; height: auto;\">\n\nThe trash can and the X buttons in your terminal perform distinct functions. Hitting `X` simply hides your terminal but retains all the previous lines of code. On the other hand, trashing it essentially deletes whatever is running in it. To open up a clean terminal, hit the trash can and then pull it back using `Toggle` or `Terminal > New Terminal`.\n\n## Installing Foundry\n\nWith our terminal set and some tips up our sleeve, let's progress to installing Foundry. Navigate to the [Foundry website](https://book.getfoundry.sh/getting-started/installation) and from the installation tab, fetch the command to install Foundry.\n\nThe command would look something like this:\n\n```bash\ncurl -L https://foundry.paradigm.xyz | bash\n\n```\n\nHit `Enter` after pasting this in your terminal.\n\n**Note:** You must have Internet access for this to work as it's downloading Foundry from their official website.\n\n## Verifying Your Installation\n\nAfter running the `curl` command, an output will appear at the bottom of your terminal indicating the detected shell and the fact that Foundry has been added to your `Path`.\n\nFor instance, the output can be something like this:\n\n```bash\nDetected your preferred shell is bashrc and added Foundry to Path run:source /home/user/.bashrcStart\na new terminal session to use Foundry\n```\n\nNow, simply type `foundryup` and `Enter` to install and update Foundry to the latest version. Whenever you want to install an update for Foundry, simply run `foundryup` again.\n\nThis will install four components: forge, cast, anvil, and chisel. To confirm the successful installation, run `forge --version`. You should get an output indicating the Forge version as shown below.\n\n```bash\nForge version x.x.x\n```\n\nNow, here's something to remember: when you hit the trash can in the top right, it literally 'removes' the terminal. The X button, in contrast, simply hides it.\n\n### Is Foundry Up Not Running?\n\nDon't panic if this command doesn't run. You might have an issue with your path, and you might need to add Foundry to your path. In case you run into this issue, check lesson 6 of the GitHub repo associated with this course. If no debugging tips are available there, feel free to start a discussion on the course's GitHub repo. Before doing so, make sure to check if a similar discussion already exists.\n\nTry typing `forge --version` into your terminal. Have you received an unwelcome output saying `Forge command found`? This implies that you have to rerun the `source` command that Foundry offered during installation.\n\nNote: Most of the time the `bashrc` file gets loaded automatically. However, if this doesn't apply to your setup, the following lines can add the required command to the end of your `Bash profile`. This will ensure that your `bashrc` file loads by default.\n\n```bash\ncd ~echo 'source /home/user/.bashrc' >> ~/.bash_profile\n```\n\n> this depends on your operating system, please check foundry docs to see detailed instructions.\n\n## Wrapping Up\n\nAnd there we have it! Congratulations on installing Foundry and prepping your terminal to work seamlessly with it. Remember, hitting snags during installation is normal, especially if you're new to this. Don't hesitate to engage with the course community via GitHub if you run into issues.\n\n<img src=\"/foundry/5-foundryinstall/foundryinstall2.png\" style=\"width: 100%; height: auto;\">\n\nHere's to many hassle-free coding sessions with Foundry!\n",
          "updates": []
        },
        {
          "lessonId": "ac591636-d3a2-47be-b1fd-b63e3f30733e",
          "number": 6,
          "title": "Setup your VSCode",
          "slug": "vscode-setup",
          "folderName": "6-vscode-setup-ii",
          "description": "Comprehensive guide on mastering Visual Studio Code and GitHub Copilot for optimizing programming efficiency and project folder organization.",
          "duration": 6,
          "videoUrl": "h9_3Ir-8Q0U",
          "rawMarkdownUrl": "/routes/foundry/1-foundry-simple-storage/6-vscode-setup-ii/+page.md",
          "markdownContent": "---\ntitle: VSCode Setup II\n---\n\n_Follow along the course with this video._\n\n\n\n---\n\n## Mastering Visual Studio Code and GitHub Copilot\n\nAs an ardent coder, mastering your programming environment tools is essential for optimum productivity. Today, our focus lands on Visual Studio Code (Vs code) and a fascinating AI extension – GitHub Copilot. Here's a walkthrough guide on how to optimize these tools effectively.\n\n<img src=\"/foundry/6-vscode-ii/vscode1.png\" style=\"width: 100%; height: auto;\">\n\n## Understanding the Vs code Interface\n\nFirstly, we'll check out some convenient shortcuts and features in Vs code. You might observe me using the `control backtick` command frequently since it quickly toggles terminal visibility. Another shortcut I typically use is `Command J`. This key binding allows a quick toggle for panel visibility — handy when you need to alternate between terminal commands and code writing.\n\nOn the Vs code interface, the Explore button opens up a space where you can create a file. This could be a simple text file or more complex files for your programming language of choice from Python, Java, JavaScript, Solidity, and more.\n\n<img src=\"/foundry/6-vscode-ii/vscode2.png\" style=\"width: 100%; height: auto;\">\n\n### Note on Saving Files\n\nEach open and unsaved file is marked with a small white dot on the tab. Not having your file saved could cause unexpected behavior when you run your code. Therefore, always remember to save your edits with `Command s` (Mac) or `Control s` (Windows and Linux). This key shortcut makes the white dot disappear, indicating your file is saved.\n\nHere's a fun fact: you have the unsaved and saved markers to remind you of your file's state. Ensure to establish a routine of hitting `Command s` after each significant edit to your code – it saves you a lot of time, trust me!\n\nShould you need to delete the file, a simple right click on it and selecting `Delete` gets the job done promptly.\n\n## Adding AI Capabilities with GitHub Copilot\n\nOn the discussion of Vs code features, it's incredible how AI integration in Vs code can significantly improve your coding efficiency. When you click on the Extensions button (it looks like a box), you'll find a search box to install different extensions.\n\nFor AI use, you may want to consider using GitHub Copilot. Although it's a premium service, its intuitive AI-powered code autocomplete feature could be a game-changer for you. Of course, you can choose to go with other AI extensions based on your preferences.\n\nOnce you have installed the [GitHub Copilot extension](https://marketplace.visualstudio.com/items?itemName=GitHub.copilot), you will need to sign in to your GitHub account to activate it on Vs code. Having this set will introduce a flyout on the right that auto-generates code suggestions as you type.\n\n<img src=\"/foundry/6-vscode-ii/vscode3.png\" style=\"width: 100%; height: auto;\">\n\nAs you code, GitHub Copilot offers code suggestions which you can auto-fill by hitting tab. The AI can alternatively present you multiple code solutions if you hit the up and enter keys. You can then select the most suitable option from the code suggestions list.\n\nOn a side note, if you're more conscious about sending data (_telemetry_) to Microsoft through Vs code, you can consider using [VSCodium](https://vscodium.com/). It's an open-sourced version of Vs code that does not send telemetry data to Microsoft.\n\nAlso, if you love the GitHub Copilot, you might want to check out [GitHub Copilot Labs](https://copilot.github.com/) as well. It features the AI's experimental features, which might be worth exploring.\n\n## Setting up a Project Folder\n\nTo set up a new directory for your coding projects, open the terminal and type `mkdir MyProjectFolderName`, then navigate to it with `cd MyProjectFolderName`. Note that you can use tab completion for the folder name.\n\nThe command helps you quickly create and move into a folder where you can store all your repositories.\n\n```bash\n    mkdir FoundryF23\n    cd FoundryF23\n```\n\nAnother cool trick is typing the first few characters of your commands or filenames within your terminal and hitting tab to autocomplete. Get better at identifying which commands or filenames can be autocompleted with practice.\n\nSo, moving forward:\n\n<img src=\"/foundry/6-vscode-ii/vscode4.png\" style=\"width: 100%; height: auto;\">\n\n## Summing Up\n\nUnderutilizing your development environment tools could be costing you precious coding time. It's why I've shared how you can quickly explore files, edit and save files, use shortcuts, and add AI capabilities using GitHub Copilot on Visual Studio Code.Proper utilization of these features is very critical to enhancing your coding experience and productivity.\n\nRemember, in modern-day coding, AI capabilities can be an invaluable resource. Hence, as we move forward, keeping our repositories organized in a single folder will be an enormous boost to efficiently managing our multiple coding projects. Additionally, it makes it easy to reference our projects. Happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "55d7a32c-4040-47d0-81d5-9ca08b816ddf",
          "number": 7,
          "title": "Create a new Foundry project",
          "slug": "create-new-foundry-setup",
          "folderName": "7-foundry-setup",
          "description": "Step-by-step instructions on creating a new simple storage project using Foundry, including project folder setup, terminal tips, and initial project structure.",
          "duration": 8,
          "videoUrl": "v6Srr9C1HRQ",
          "rawMarkdownUrl": "/routes/foundry/1-foundry-simple-storage/7-foundry-setup/+page.md",
          "markdownContent": "---\ntitle: Foundry Setup\n---\n\n_Follow along the course with this video._\n\n\n\n---\n\n## Creating a Simple Storage Project\n\nToday, we'll dive into setting up a simple storage project, but with a twist, we'll be doing this in a professional environment, following the industry's big protocols as exemplified by billion-dollar players like uniswap, Aave, and curve.\n\nA key factor that makes this worth your while is that we'll be using Foundry - a popular tool among auditors - making this a goldmine for budding security researchers. So brace up as we journey into the masterclass prepared with the same toolbox that industry champions rely upon!\n\n## Getting Started: Setting up The Project\n\nIn setting up your environment, you would need to create a new folder. Simply follow these commands:\n\n```bash\n    mkdir foundry-simple-storage-f23\n    cd foundry-simple-storage-f23\n```\n\nYou might observe some differences in our terminal windows, reflecting our unique paths. For this tutorial, an alias, `video_shell`, which only displays the folder path, will be used.\n\n<img src=\"/foundry/7-foundry-setup/setup1.png\" style=\"width: 100%; height: auto;\">\n\n)Still within the folder, typing in `code` followed by a period  (`.`) should lead to a new Visual Studio code. If this doesn't happen, simply navigate to `File` &gt;&gt; `Open Folder` and select your preferred folder, the selected folder will open in a new Visual Studio code.\n\nNow, your terminal should show that we are indeed in our project folder:\n\n<img src=\"/foundry/7-foundry-setup/setup2.png\" style=\"width: 100%; height: auto;\">\n\n## Terminal Tips and Tricks\n\nEveryone's terminal will look slightly different. For this post, we'll be using several Bash (Linux Terminal) commands like `mkdir` and `cd`. If you're unfamiliar with these, I highly recommend checking out [this freeCodeCamp lesson](https://www.youtube.com/watch?v=oxuRxtrO2Ag).\n\nAlternatively, you could harness the power of Artificial Intelligence (AI). AI chatbots like GPT and others are familiar with Bash and Linux commands. They can provide assistance when you encounter challenges.\n\n<img src=\"/foundry/7-foundry-setup/setup3.png\" style=\"width: 100%; height: auto;\">\n\n## Setting Up Local Environments\n\nMoving to the next phase, we'll set up our local environments. This is similar to working with Remix VM. Consistent with the project's title, we'll use `Foundry` to code our simple storage project. This will make our code interactions and deployments more professional.\n\nWe begin by checking the content of our Explorer side bar. You can create a file here by using the `touch` command. This will make the file appear on the left hand side of the explorer. Next, we delete unneeded files with the `rm` command.\n\n## Using Foundry for Project Initialization\n\nWe will start the project by using Foundry to create a new basic project. Foundry's documentation offers a step-by-step guide on creating a new project. However, in our case, we run `forge init`. This should create several folders.\n\nIn case an error pops up because the directory is not empty, we run `forge init --force.` to override this.\n\n```bash\nforge init --force.\n```\n\nThis will override any error related to Git. Be sure to configure your username and email if you encounter errors related to Git configuration.\n\n```bash\n    git config --global user.email \"your_email\"\n    git config --global user.name \"your_username\"\n    forge init\n```\n\n## Walk-through of Initialized Folders\n\nOur folders are now full and we have an initial project ready! The folders include:\n\n1. `.gitHub` workflows file\n2. `lib`\n3. `.script` - contains a file we delete for now\n4. `src` - where we put our smart contracts\n5. `test` - not needed for now\n6. `.gitignore` - files not meant for GitHub\n7. `foundry.toml` - gives configuration parameters for Foundry\n\nThe Source (src) is the main directory that we'll focus on. It's where we'll store the main contracts, whereas Test will hold the files to test the main contracts, and Script will host files to interact with our SRC contracts.\n\nLastly, we'll add a simple storage code into the SRC or Source folder. We can copy all the code from this [Github repository](https://github.com/Cyfrin/foundry-simple-storage-f23/blob/main/src/SimpleStorage.sol), select the code base, then paste it into `src` as `SimpleStorage.sol` file. Hit save, and we're done!\n\nCongratulations, you're now ready to build bigger and better with Foundry! Stay tuned for more exciting tutorials.\n",
          "updates": []
        },
        {
          "lessonId": "ae54a24e-9fce-457f-af4d-b68b7fb6716b",
          "number": 8,
          "title": "VSCode Solidity setup",
          "slug": "vscode-solidity-setup",
          "folderName": "8-formatting-solidity",
          "description": "Tutorial on formatting Solidity code in Visual Studio Code using various extensions and settings, and tips for automatic code formatting and TOML file formatting.",
          "duration": 5,
          "videoUrl": "8l55rHHpta0",
          "rawMarkdownUrl": "/routes/foundry/1-foundry-simple-storage/8-formatting-solidity/+page.md",
          "markdownContent": "---\ntitle: Formatting Solidity in VS Code\n---\n\n_Follow along the course with this video._\n\n\n\n---\n\n# **Improving Code Format in Visual Studio Code**\n\nIn this blog post, we're going to explore how to greatly improve the readability and maintainability of your smart contracts by cleaning up your Solidity code format within Microsoft's Visual Studio Code (VSCode). Let's get started!\n\n<img src=\"/foundry/8-formatting/formatting1.png\" style=\"width: 100%; height: auto;\">\n\n## **Solidity Code Formatting**\n\nWhen you first start, your code might just look like a whole bunch of dull, lifeless, white text. While some cool trinkets are embedded in the code such as the oftentimes cute little ETH logo, deciphering your code becomes a real chore without proper formatting.\n\nLucky for us, there are many wonderful extensions available on VSCode that can format our Solidity code. Simply input \"Solidity\" in the Extensions bar to reveal a treasure trove of options. Out of these, a few worth mentioning:\n\n1. The general \"Solidity\" extension\n2. [Hardhat Solidity](https://marketplace.visualstudio.com/items?itemName=NomicFoundation.hardhat-solidity), a personal favorite, despite being another framework, works wonders in Foundry\n3. Solidity visual developer, another popular choice\n4. And Juan Blanco's [extension](https://marketplace.visualstudio.com/items?itemName=JuanBlanco.solidity), which is probably the most used Solidity extension worldwide\n\nFor this blog, we'll demo the [nomic foundation Solidity Vs code extension](https://marketplace.visualstudio.com/items?itemName=NomicFoundation.hardhat-solidity). Once this extension is installed, your Solidity files should now appear with syntax highlighting, making it vast easier to read and understand.\n\n### **Activating the Extension**\n\nIf the code remains unhighlighted despite having installed the extension, there's a quick solution to that. Press `Command Shift P`, or `Control Shift P` on Windows. This opens up the command bar.\n\nIn the command bar, type in \"Settings\" and select \"Preferences: Open User Settings\". This will open your user settings in JSON format. If you have nothing in there, create a new setting with these brackets `{'{'}...{'}'}` and type in:\n\n```json\n{\n  \"editor.defaultFormatter\": \"NomicFoundation.hardhat\"\n}\n```\n\n..and you're all set! This way every time you open your Solidity code, VSCode will automatically use Hardhat extension for formatting.\n\n## **Formatting TOML Files With Better TOML**\n\nThe good news doesn’t end with Solidity files alone. Even your Foundry TOML files can be formatted for better readability. Again, head over to Extensions and type in TOML.\n\nInstall [Even Better TOML](https://marketplace.visualstudio.com/items?itemName=tamasfe.even-better-toml). This cool extension appropriately highlights your Foundry TOML files, making it much easier to locate and edit keys.\n\n**Pro Tip:** Any time a little dot appears next to the file name on your tab, it means the changes aren’t saved. Make it a habit to frequently save your work with Command S or File -&gt; Save.\n\n## **Automatic Code Formatting**\n\nA great feature of text editors is the ability to format your code automatically. Let's say you have a block of code that's entirely out of whack. You can set your VSCode to automatically format the block once you save it. Here’s how.\n\nRepeating the Command Shift P step brings up the command palette. If you type in 'format document', it will instantly apply the default formatter to the open file. If the auto formatter does nothing, first ensure you've set Hardhat as your default formatter in your settings file.\n\nFor those who prefer automatic formatting, navigate to User Settings and check 'Editor: Format On Save'. This way, every time you save your Solidity code, it automatically gets formatted.\n\nFor cases where you might not want your document formatted, all you have to do is open the command palette (Command Shift p/View -&gt; Command Palette) and type 'save without formatting'. This will save the file without applying any formatting rules. However, remember to turn back on formatting when done.\n\n<img src=\"/foundry/8-formatting/formatting2.png\" style=\"width: 100%; height: auto;\">\n\nIn conclusion, formatting is something we pretty much never want to skip. Even though it might seem inconsequential, a well-formatted code can save a lot of debugging time and make your code way more maintainable and understandable. So start using these principles today and write smarter contracts! Happy hacking!\n",
          "updates": []
        },
        {
          "lessonId": "e1a7e1f7-508a-440c-b39b-7bcbf0c54e07",
          "number": 9,
          "title": "Compile a smart contract using Foundry",
          "slug": "compiling-a-smart-contract-foundry",
          "folderName": "9-compiling-in-foundry",
          "description": "Guide to compiling Solidity smart contracts using Foundry, including steps for using the Foundry console, understanding the 'out' file, and terminal command recall.",
          "duration": 2,
          "videoUrl": "9UYIyBdW1Do",
          "rawMarkdownUrl": "/routes/foundry/1-foundry-simple-storage/9-compiling-in-foundry/+page.md",
          "markdownContent": "---\ntitle: Compiling in Foundry\n---\n\n_Follow along the course with this video._\n\n\n\n---\n\n# Compiling Smart Contracts: A Guide to the Foundry Console Compilation Process\n\nIn this detailed guide, we'll walk you through the intricate process of compiling Solidity smart contracts using the Foundry console, courtesy of Parity. By the end of this blog post, you'll successfully compile a `SimpleStorage.sol` contract within your terminal.\n\n## Getting Started: The Foundry Console\n\nLet's kick things off starting with the installation of the Foundry console. Foundry is an incredibly essential tool that we'll be using to collate our background, so ensure it has been installed correctly on your system to avoid any hitches.\n\nHere's a gentle reminder, just with your existing code and Foundry installed, you're already set to begin the intriguing journey into compiling your `SimpleStorage.sol` smart contract right in your terminal!\n\n## How to Compile Your Code\n\nAfter correctly setting up Foundry, pull up your terminal. In the terminal, key in either `forge build` or `forge compile`. Running either command will immediately trigger the compilation of your code, like so:\n\n```bash\n$ forge build\n```\n\nOr\n\n```bash\n$ forge compile\n```\n\n<img src=\"/foundry/9-compiling/compiling1.png\" style=\"width: 100%; height: auto;\">\n\nLook out for a notable change - the appearance of several new folders. One of them is a file named `out`.\n\n## Understanding the `out` File\n\nQuite noticeable when you compile is the `out` file. To put it simply, the `out` file holds a trove of crucial information similar to what the Remix compiler offers.\n\nIt is within this `out` file that you have access to the `Abi`. For those who haven't encountered it, you're probably wondering what `Abi` is. In the context of this guide, `Abi` refers to the compiled version of your contract. To locate it, navigate your way back to Remix, select the compiler tab, locate one of your written contracts and scroll down.\n\n<img src=\"/foundry/9-compiling/compiling2.png\" style=\"width: 100%; height: auto;\">\n\nIn the Abi section, you'll notice a small dropdown icon placed directly beside it. A simple click on this dropdown button will minimize the Abi, prominently displaying all other details such as bytecode method Identifiers and other sub-sections that we'll delve into later in this guide.\n\n## The `cache` Folder Defined\n\nAnother file that appears upon compilation is the `cache` folder. Generally, this folder is used to basically store temporary system files facilitating the compilation process. But for this guide, you can virtually ignore it.\n\n## Recalling Previously-Run Commands\n\nHere's a productivity-boosting feature in your terminal: the ability to recall and rerun use previously executed commands. The action is simple - just press the up arrow key. This feature proves handy when you need to rerun lengthy commands which previously executed correctly, saving you both time and energy.\n\nFor instance, suppose you've run a long command like `echo`, which is a classic Unix command, and decide to rerun it. All you need to do is press the up arrow key:\n\n```bash\n$ echo \"This is some crazy long command\"\n```\n\n<img src=\"/foundry/9-compiling/compiling3.png\" style=\"width: 100%; height: auto;\">\n\nBy following these steps, you should now have a head start in compiling your Solidity smart contracts. Congratulations on adding a new skill to your programming arsenal! Enjoy your development journey!\n",
          "updates": []
        },
        {
          "lessonId": "46f0d83a-62be-4095-a9e5-d91c37ef111e",
          "number": 10,
          "title": "Deploy a smart contract locally using Ganache",
          "slug": "deploy-smart-contract-locally",
          "folderName": "10-deploying-locally",
          "description": "Guide on deploying smart contracts locally using Ganache and Foundry's Anvil, including setting up Ganache, using MetaMask for custom networks, and integrating Anvil.",
          "duration": 8,
          "videoUrl": "IK2irq6_2fw",
          "rawMarkdownUrl": "/routes/foundry/1-foundry-simple-storage/10-deploying-locally/+page.md",
          "markdownContent": "---\ntitle: Deploying to a Local Blockchain\n---\n\n_Follow along the course with this video._\n\n\n\n---\n\n## Deploying Code to a Virtual Environment with Foundry and Anvil\n\nIn this lesson, we'll explore how you can deploy your code to a Foundry VM or a JavaScript virtual environment using Foundry, Anvil, and the Ganache Ethereum chain.\n\n## Foundry and Anvil: Built-In Virtual Environment\n\nFoundry comes built-in with a virtual environment in its shell, similar to **Remix**, the integrated development environment (IDE) best known for smart contract development and deployment. Inside the virtual environment of foundry, we use **Anvil** to create a fake available accounts, fully equipped with **fake private keys**, a wallet mnemonic, blockchain details, and an RPC URL, which we'll discuss later.\n\nHere's how to launch the Anvil blockchain:\n\n```bash\nanvil\n```\n\nTo end the session, you can press Ctrl+C or close your terminal.\n\n## Deploying with Ganache\n\nGanache is a one-click blockchain. It offers a user interface that gives developers easier access to their transactions.\n\n<img src=\"/foundry/10-deploy-local/deploying1.png\" style=\"width: 100%; height: auto;\">\n\nAfter installing Ganache, you can create a new locally running blockchain by hitting 'Quickstart for Ethereum'. This will generate a list of addresses with individual balances, and dummy private keys.\n\nHere's a glimpse of how Ganache looks:\n\n<img src=\"/foundry/10-deploy-local/deploying2.png\" style=\"width: 100%; height: auto;\">\n\nThe Ganache blockchain is temporary; if it's causing any issues, you can always switch back to Anvil.\n\n<img src=\"/foundry/10-deploy-local/deploying3.png\" style=\"width: 100%; height: auto;\">\n\n## Deploying to Custom Networks with MetaMask\n\nTo deploy to a custom network (like your localhost), you'll need MetaMask. MetaMask is a browser extension that allows you to run Ethereum dApps (decentralized apps) right in your browser.\n\nFollow these steps:\n\n1. Open MetaMask.\n2. Click the three little dots, select 'Expand View'.\n3. Go to 'Settings', then 'Networks'.\n4. Here, you'll see the list of networks (Ethereum, Mainnet, etc.) with plenty of details about each one. Locate the RPC URL - this is key.\n\nThe RPC URL is essentially the endpoint we make API calls to when sending transactions. For every blockchain transaction you execute, you're making an API to whatever is in here.\n\nTo send a transaction to your custom blockchain, you need to add it as a network:\n\n1. Scroll to the bottom of the list of networks.\n2. Hit 'Add Network'.\n3. Enter the details of your local network - the name, RPC URL (you can get this from Ganache or Anvil), chain ID, etc.\n\n<img src=\"/foundry/10-deploy-local/deploying4.png\" style=\"width: 100%; height: auto;\">\n\n4. Save your new network.\n\nOnce your network is added, you should be able to switch to it from the dropdown menu. From here, you can import an account by pasting its private key and hitting 'Import'.\n\nAnd voila! You now know how to deploy code to a virtual environment with Foundry, Anvil, Ganache and MetaMask. Happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "d147ac70-b450-43ae-b1a2-4a0a2a7b5508",
          "number": 11,
          "title": "How to add a new network to Metamask",
          "slug": "how-to-add-a-new-network-to-metamask",
          "folderName": "11-adding-network-metamask",
          "description": "Tutorial on adding new Ganache local chains and EVM compatible chains to MetaMask, including managing private keys and understanding RPC URLs.",
          "duration": 2,
          "videoUrl": "oYBRneM_Oes",
          "rawMarkdownUrl": "/routes/foundry/1-foundry-simple-storage/11-adding-network-metamask/+page.md",
          "markdownContent": "---\ntitle: Adding another Network to MetaMask\n---\n\n_Follow along the course with this video._\n\n\n\n---\n\n## Adding New Ganache Local Chains and Other EVM Compatible Chains\n\nIn this blog post, we delve deep into the world of EVM (Ethereum Virtual Machine) chains. We explore how to add new Ganache local chains and the process of incorporating any EVM compatible chain in the network. Plus, we sprinkle in an introduction on running your own Ethereum nodes. Ready to dive in?\n\n<img src=\"/foundry/11-networks/network1.png\" style=\"width: 100%; height: auto;\">\n\n## Adding New Networks Using MetaMask\n\nConveniently, MetaMask, a browser extension serving as an Ethereum wallet, provides an easy way to add EVM compatible chains. By pre-configuring a host of them, you can add a chain such as the Arbitram One by simply clicking on **Add Network** and proceeding to **Add**. The pleasing part is that MetaMask does all the grunt work, filling in all the necessary information for you. A click on **Approve Network** ensures successful addition of the network.\n\n```js\n    1. Click on Add Network\n    2. Choose your desired EVM compatible chain\n    3. Click on Add\n    4. After ensuring all necessary information is already filled in, click on Approve Network\n```\n\nHowever, what if MetaMask isn't pre-equipped with a chain you wish to add? Well, no need to worry. You would employ the same process we just used to add our new Ganache local chain. This process universally applies to the addition of any EVM compatible chain.\n\n## Understanding Your Connection to a Node: The Role of Endpoint\n\nHeading back to your network settings and selecting the localhost network unveils another crucial aspect- the endpoint. When you set out to send a transaction to a blockchain, you must have a connection to a node. This node connection is vital as it equips you with the ability to send transactions.\n\nLet's say you coveted the thrill of sending transactions to your own node. The process would entail running an execution client like Geth, followed by a consensus client such as Teku or Prism, and finally send your transactions.\n\n<img src=\"/foundry/11-networks/network2.png\" style=\"width: 100%; height: auto;\">\n\nCertainly, running your own Ethereum nodes may seem daunting. However, for a blockchain enthusiast, it can be a fun adventure worth exploring. As a pro tip, run multiple Ethereum nodes for an even better experience.\n\n## Interacting with Ethereum Blockchain Nodes: Different Methods\n\n<img src=\"/foundry/11-networks/network3.png\" style=\"width: 100%; height: auto;\">\n\nVenturing further into the realm of Ethereum, we find that different methods exist for dispatching transactions. Ethereum JSON RPC specification site provides a rundown of these various methods. You just need to be acquainted with APIs and Http endpoints and you’re good to go.\n\nWhen signing and dispatching transactions, it's these method calls that come into play: ETH sign transaction, send transaction, send raw transaction, etc.\n\nHowever, let's make an important clarification. The Forge comes with a built-in facility that manages sending these transactions. So, we don't necessarily have to go the extra mile of direct interaction with these calls.\n\n## Sending Raw Transactions: Different Programming Languages\n\nMoving forward, to learn how to send raw transactions, you would need to make raw API calls to your Ethereum node. This can either be an Ethereum node you provided or an Ethereum node as a service, such as Infura or Alchemy. This interaction would employ different programming languages such as Bash, Python, or JavaScript.\n\nFurther exploration into the complex yet captivating world of Ethereum awaits. Running your own Ethereum nodes and understanding the intricacies of sending transactions brings a whole new level to your blockchain explorations. We hope this guide kindles your curiosity to delve further and cherish the fun of running nodes!\n\nStay tuned for more such excitement in our next lesson!\n",
          "updates": []
        },
        {
          "lessonId": "20ac66c6-015c-4c7a-a2b6-1d98cf01b686",
          "number": 12,
          "title": "Deploy a smart contract locally using Forge",
          "slug": "deploying-locally-forge-foundry",
          "folderName": "12-deploying-locally-ii",
          "description": "Comprehensive guide on deploying smart contracts locally using Forge in Foundry, detailing command line usage, potential issues, and deployment steps.",
          "duration": 5,
          "videoUrl": "U-9vmmu-JFk",
          "rawMarkdownUrl": "/routes/foundry/1-foundry-simple-storage/12-deploying-locally-ii/+page.md",
          "markdownContent": "---\ntitle: Deploying to a Local Blockchain II\n---\n\n_Follow along with this video._\n\n\n\n---\n\n## Deploying a Smart Contract on your Local Blockchain\n\nAre you tired of running into issues deploying your smart contract on your local blockchain? Whether you're using Ganache or Anvil for your blockchain development, we've got you covered. In this comprehensive guide, we're going to walk you through how to deploy contracts in two different ways, using the command line and the integrated Forge framework.\n\n<img src=\"/foundry/12-deploy-local-2/deploying1.png\" style=\"width: 100%; height: auto;\">\n\n## The fundamentals: Your endpoint and private key\n\nSince you already have your endpoint and private key, you now have everything you need to deploy to your own local blockchain. However, just like working with a real blockchain, you need some balance to spend gas to deploy your contract.\n\n## Getting started with the Command Line\n\nTo kick things off, let's dive into the command line approach. This involves familiarizing with the Forge framework.\n\n```bash\nforge help\n```\n\nRunning the command above provides a list of commands built into the Forge. For our cause, we are interested in the 'Create' command. Its function is to deploy a smart contract- exactly what we are looking to do.\n\n```bash\nforge create --help\n```\n\nRunning the command above shows the numerous options available for deploying our contract. Be sure to have your private key ready, which you can copy from Anvil.\n\n**NOTE:** Please refrain from using actual private keys in Vs code or any platform that could potentially share your information unintentionally. Although we're using a fake private key for this exercise, the best practice is to use your terminal.\n\n## Unraveling Potential Issues\n\nWhile trying to deploy our contract - 'Simple Storage' in this case - there is a possibility of running into an error when using the command:\n\n```bash\nforge create SimpleStorage\n```\n\nThe error is due to the fact that the RPC server we are using doesn't coincide with the default Forge RPC server. To fix this, you need to assign the RPC URL manually and ensure it is in lowercase.\n\nIf you forget to input the private key, the command line will remind you with another error! No worries though, just use the 'Up' key and include the 'interactive' option as seen in the command below. Then, follow the prompt to enter your private key.\n\n```bash\nforge create SimpleStorage --rpc_url http://127.0.0.1:7545 --interactive\n```\n\n_Note:_ the URL is the one from ganache.\n\n<img src=\"/foundry/12-deploy-local-2/deploying2.png\" style=\"width: 100%; height: auto;\">\n\nYou should now see your transaction details if you're using Ganache. The transaction and blocks you created beforehand should be visible.\n\n_Blockquote: \"Despite Anvil not showing any transaction details, it serves as a more efficient platform for this procedure. Hence, we will be using it for the rest of this guide.\"_\n\n## Conclusion\n\nThat's it! You've now deployed a smart contract to your local blockchain. Take note that this process may require some tweaking depending on your specific environment or contract. Overall, by following these steps, you will have a robust foundation for deploying more complex smart contracts in your future blockchain projects.\n",
          "updates": []
        },
        {
          "lessonId": "4ca84002-b8be-41ed-9a09-12f9e0e0ebcf",
          "number": 13,
          "title": "Important: private key safety pt.1",
          "slug": "private-key-safety",
          "folderName": "13-private-key-safety",
          "description": "In-depth guide on private key safety for blockchain developers, covering best practices, shell history clearing, and secure methods for handling private keys.",
          "duration": 3,
          "videoUrl": "7ILrx8KiTUQ",
          "rawMarkdownUrl": "/routes/foundry/1-foundry-simple-storage/13-private-key-safety/+page.md",
          "markdownContent": "---\ntitle: Private Key Safety\n---\n\n_Follow along the course with this video._\n\n\n\n---\n\n# Practicing Private Key Safety: A Comprehensive Guide\n\nThe following lesson will take you through the intricacies and dangers of mishandling your Private Key, while also highlighting the key steps you should take to maintain its safety.\n\n## The Importance of Private Key Safety\n\nNow, here's an incredibly important piece of information and one worth your attention:\n\n<img src=\"/foundry/13-private-key-safety/private1.png\" style=\"width: 100%; height: auto;\">\n\nThis goes especially for your production or private keys associated with actual money. This is a serious security risk and a transgression we cannot afford to make. Even though the example presented here involves a dummy private key, this is a practice we should generally steer clear from.\n\n<img src=\"/foundry/13-private-key-safety/private2.png\" style=\"width: 100%; height: auto;\">\n\nOne common oversight lies not in how we treat our private keys, but rather in where we tend to leave them – our shell or Bash history. Here's an example to illustrate the point: once you execute commands in your terminal, a simple upward stroke on your arrow keys will display the previously carried out commands – including your private keys. It is easy to see why this fact poses a risk to private key safety.\n\n## Clearing Your Shell History\n\nTo remove your private key from your history in Bash, execute the following command:\n\n```bash\nhistory -c\n```\n\nThis effectively clears your command history. Try hitting the 'up' arrow on your keyboard - you will not return any previously entered commands. To further test this, you can use the `history` keyword:\n\n```bash\nhistory\n```\n\nThis command will return your entire command history. You can also use the `clear` command to clear your screen and then call `history` again to verify you've purged your command history as desired.\n\n## Your Safety Promise\n\nIt's time now to articulate your promise for maintaining private key safety. Create a file titled 'Promise.md'. In this file, make it a point to write down your promise:\n\n```\nI promise to never use my private key associated with real money in plain text.\n```\n\nIf you feel comfortable doing so, consider tweeting this to affirm and secure your pledge. Tagging me or other experts in the field to hold yourself accountable can be immensely helpful. Remember, this is merely a first step in your commitments towards private key safety - many more promises are to come.\n\nAs we're working with dummy keys for now, this may not seem like a big deal. But I assure you that the safety of your private keys in the future is of utmost importance. I’ve seen multiple multimillion-dollar companies overlook this protocol and, as a result, have their private keys breached.\n\n## Deploying Your Contracts\n\nTo deploy your contracts to any blockchain from a command line, you would generally use the `forge` command as shown below:\n\n```bash\nforge create < name-of-your-contract > add < RPC-URL > < your-private-key >\n```\n\nIn upcoming sections, we will learn how to access RPC URLs for free using Alchemy for any blockchain. We will also delve into exploring safer methodologies for dealing with private keys.\n\nWith this you now have a preliminary understanding of how to deploy your contracts to any blockchain from the command line. This knowledge equips you with the base tools to operate in a more secure digital environment, prioritizing private key safety, cleanliness of your bash history and the right way to deploy contracts to the blockchain.\n\nKeep following along for more tips, tricks, and best practices in maintaining your cyber safety.\n",
          "updates": []
        },
        {
          "lessonId": "5067bfa3-74e2-4129-9135-227e19a335ee",
          "number": 14,
          "title": "Deploy a smart contract locally using Anvil",
          "slug": "deploying-locally-anvil",
          "folderName": "14-deploying-locally-iii",
          "description": "Tutorial on deploying smart contracts locally using Anvil, focusing on script creation, Solidity contract language, and Foundry cheat codes for deployment.",
          "duration": 10,
          "videoUrl": "-PMG_wlBxfY",
          "rawMarkdownUrl": "/routes/foundry/1-foundry-simple-storage/14-deploying-locally-iii/+page.md",
          "markdownContent": "---\ntitle: Deploying to a Local Blockchain III\n---\n\n_Follow along with this video._\n\n\n\n---\n\n## Deploying Contracts on Any Blockchain with Solidity\n\nAfter familiarizing ourselves on how to deploy a contract to any blockchain using the command line, it's time to engage in another method of deploying our contracts. This method is particularly handy because it provides a consistent and repeatable way to deploy smart contracts reliably and its features enhance the testing of both the deployment processes and the code itself.\n\nContrary to the popular command-line approach, we create a script for our code deployment. This method enriches our learning process and makes the entire session enjoyable.\n\n## The Solidity Contract Language\n\nFoundry eases the whole process since it is written in Solidity. This means our deployment scripts will also be in Solidity. It is essential to distinguish Solidity as a contract language from Solidity as a scripting language. Foundry also incorporates elements that enhance our Solidity experience beyond the smart contracts realm. So, let's get started on creating a script to deploy our simple storage contract.\n\n### Creating the Deployment Script\n\nTo create the script, follow these easy steps:\n\n1. Go to our script folder.\n2. Right-click on a new file.\n3. Create the file deploy `DeploySimpleStorage.s.sol`.\n\nThe letter `S` in `s.sol` is a Foundry custom. Usually, scripts bear an `s.sol` extension instead of sol.\n\nInside it, we are going to write our contract in Solidity to deploy our smart contract.\n\nAnd by the way, this script is written in Solidity but should not be considered as a contract for deployment. It is solely for deploying our code. Since it is written in Solidity, we start with the MIT SPDX License Identifier as usual.\n\nCheck out the Foundry documentation for a comprehensive understanding of Solidity scripting in the tutorials section.\n\nTo notify Foundry that our contract `DeploySimpleStorage.s.sol` is a script, we need to import additional code.\n\nHere is the code sample:\n\n```js\n    //SPDX-License-Identifier: MIT\n    pragma solidity ^0.8.18;\n    contract deploySimpleStorage{}\n```\n\nFounder also has a lib folder which entails the Forge STD. Forge STD stands for Forge Standard Library. The library bears numerous beneficial tools and scripts for working with Foundry.\n\nLet's now make our contract `DeploySimpleStorage.s.sol` inherit from the functionality of this script by importing `forge-std/Script.sol` and stating is script. Foundry will then understand that this contract is a script.\n\nFor clarification, our Deploy Simple Storage requires knowledge of our simple storage contract. Therefore, we'll import that too. We must also bear in mind that there is a superior method to run imports, known as named imports.\n\nNow here is where it gets exciting. Every Deploy or script contract should have a primary function known as Run. This function executes when we need to deploy our contract.\n\nHere is the code snippet:\n\n```js\n function run() external returns (SimpleStorage) {\n        vm.startBroadcast();\n\n        SimpleStorage simpleStorage = new SimpleStorage();\n\n        vm.stopBroadcast();\n        return simpleStorage;\n    }\n```\n\n### Using Cheat Codes in Foundry\n\nIn the Run function, we are going to use a distinctive keyword: vm. Foundry has a distinctive feature known as cheat codes. The vm keyword is a cheat code in Foundry, and thereby only works in Foundry. You won't have much success trying it out in Remix or any other framework. Though, if we're inheriting Forge STD code, the vm keyword comes in handy.\n\nYou can learn more about Foundry cheat codes in the Foundry documentation and Forge Standard Library references section.\n\nAre you confused about the vm keyword? No worries! The vm keyword is just a tool for controlling the interactions with Forge's local Ethereum testnet. We're using it here to specify that all the activities within the `startBroadcast` and `stopBroadcast` functions should take place on-chain.\n\nWe deploy our simple storage contract via the `new` keyword. Simple Storage, denotes the contract, and simple storage the variable, are quite different.\n\nThe new keyword in Solidity creates a new contract. It is also going to come up with a new contract amid the vm Star broadcasts. Should you find this a bit confusing, don't worry. We shall delve into the details later in the course. For now, remaining focused is the key. And finally, we can say return Simple Storage.\n\n## Testing the Deployment\n\nNow to the exciting part. It's time to test our script by running it. If Forge is already running, we can kill it using the control C command. Now, let's ru:\n\n```bash\nforge script script/DeploySimpleStorage.s.sol\n```\n\nEnsure you adhere to the Solidity standards for smooth running.\n\nIf an error message pops up about Solidity versions, just change both versions in the code to use the caret (^) symbol in order to allow use of the highest non-breaking version.\n\nOnce everything is set, it's time for the real thing. First, compile the scripts to be deployed and the simple storage contract using version 0.8.19.\n\n## Running Anvil\n\nIf we try to run the Forge script without Anvil, Foundry will automatically deploy the contract or run the script on a temporary Anvil chain.\n\nBut the beauty of Anvil comes in when we wish to simulate on-chain transactions. You can do this by passing an RPC URL when running the script. Once this is done, Anvil keeps records of previous deployments in case you need to refer to them.\n\nA final test is done by deploying the script to the blockchain. You use the `broadcast` command to send this out and also provide a private key to sign the transaction with.\n\nIf all goes successfully, you'll be greeted with the message \"on chain execution complete and successful\".\n\nHope this tutorial was insightful. Let's explore more in our next learning chapter!\n",
          "updates": []
        },
        {
          "lessonId": "48917e07-fc94-487f-a44b-d6ad433b7094",
          "number": 15,
          "title": "What is a transaction",
          "slug": "what-is-a-transaction",
          "folderName": "15-what-is-a-transaction",
          "description": "Exploration of blockchain transactions, including a detailed overview of transaction components, contract deployment, and data fields in Ethereum.",
          "duration": 6,
          "videoUrl": "56tWg7CUVrI",
          "rawMarkdownUrl": "/routes/foundry/1-foundry-simple-storage/15-what-is-a-transaction/+page.md",
          "markdownContent": "---\ntitle: What is a Transaction? But Actually\n---\n\n_Follow along the course with this video._\n\n\n\n---\n\n## Deep Dive into Blockchain Transactions\n\nLet's take a moment to really get to grips with what we're doing when we script and execute blockchain transactions. Many people find this element of blockchain to be a bit of a mystery, so let's pull the curtain back and lay out the steps and elements involved.\n\n## Exploring the Terminal\n\nIn your terminal, you'll see a few different directories. One of which is `dry run` - this is where files end up when there's no active blockchain. When a blockchain is running, the directories are divided by chain ID. Within these directories, such as `dry run` or `run latest`, you'll find detailed information about each transaction that has been executed. This includes information such as the transaction's hash, type, contract, name, address, and more.\n\nIn this section, we can see exactly what's being sent on the chain whenever we use our scripting commands - `forge script` or `forge create`.\n\nThis is the transaction we send to the RPC URL and it contains the relevant API data packaged for https POSTS. In this case, our transaction type is `2`. The `from` address refers to where the transaction is initiated from, and the `gas` is the hex value representing the computational effort the transaction requires.\n\n<img src=\"/foundry/14-transactions/transtactions1.png\" style=\"width: 100%; height: auto;\">\n\nIncluded in the transaction is a `value` field. When you're deploying a contract, this is just another transaction; we can therefore add a value to it if we want. This value can be in the form of the Ethereum blockchain's native currency - Ether. To do this, you just add a `value` field followed by the amount you wish to transact. Note though, in solidity, the `value` option can't be set if the constructor isn't payable.\n\n## Contract Deployment and the Data Field\n\nLet's now focus on the data part of this transaction. In reality, this is the contract deployment code. But there's a bit more to it than that! It also contains the `nonce` value - a unique identifier that's used once for each transaction, and an access list (but we're not going to cover that in this post).\n\nIn addition to the details stored in the transaction, a couple of other values play a part that aren't stored here. These are the `r` and `s` values which are used to generate a signature that makes the transaction valid. When a transaction is sent, it is signed using your private key. This signature then forms part of the transaction data.\n\n<img src=\"/foundry/14-transactions/transactions2.png\" style=\"width: 100%; height: auto;\">\n\nIn terms of the `nonce` or nonce value mentioned earlier, this is managed by your chosen blockchain wallet. Every time a transaction is sent, it is given a nonce that increments after each transaction is sent. Finally, and critically, remember that any time you change the state of the blockchain you do so through a transaction. Each transaction contains an all-important data field, which includes 'opcodes' that tell the blockchain what you'd like it to do. In some cases, this might mean the creation of a new contract. In others, the data is merely associated with a basic transaction.\n\n## Conclusion\n\nThe world of blockchain transactions can seem complicated. By understanding these underlying processes, however, we can get a much richer understanding of how it functions. The powerful part comes when we understand the way transactions work when executing them with tools like Remix. It all comes down to that pivotal data field of a transaction!\n",
          "updates": []
        },
        {
          "lessonId": "220b2276-4fbd-4acc-b754-6b5ca719684f",
          "number": 16,
          "title": "Important: private key safety pt.2",
          "slug": "private-key-safety-part-2",
          "folderName": "16-private-key-safety-ii",
          "description": "Guide on private key safety for interacting with deployed contracts, covering command line interfaces, environment file setup, and secure coding practices.",
          "duration": 11,
          "videoUrl": "yhvxeP1Vkfc",
          "rawMarkdownUrl": "/routes/foundry/1-foundry-simple-storage/16-private-key-safety-ii/+page.md",
          "markdownContent": "---\ntitle: Private Key Safety II\n---\n\n_Follow along the course with this video._\n\n\n\n---\n\n## Interacting with Contract Deployment: Command Line Interface vs. Scripts\n\nHello and welcome back! In this blog post, we'll cover how to interact with deployed contracts on the blockchain. As we've learned previously, we have two methods at our disposal: running scripts and using the command line interface (CLI). In this article, we'll focus primarily on the latter.\n\nLet's get started!\n\n## Getting Started: Make Sure You're Deployed\n\nFirst, we need to confirm that our smart contract has been successfully deployed. From your terminal, bring up your deployment script by hitting the up arrow a few times, then run it again.\n\n## Interacting with Contracts via the Command Line\n\nBy now you may be familiar with Remix, a popular Ethereum IDE, and how it allows us to interact with our contracts by clicking buttons in its GUI. With the CLI, we interact with contracts in a similar manner but, in this case, by entering commands. However, using the CLI is just one of two ways we can interact with contracts.\n\n## Cleaning up the Command Line\n\nWe're going to make the contract interaction process a touch more efficient while also consolidating previously disparate actions. Often, we'd use Forge's command line interface (CLI) to interact with contracts, creating a new interactive CLI session each time and pasting our private key in when prompted. But we can streamline this.\n\nLet's clarify something here first:\n\n<img src=\"/foundry/16-private-key-safety-2/safety1.png\" style=\"width: 100%; height: auto;\">\n\n## Storing Private Keys Safely\n\nThe safer alternative is to first create a **.env** file to store what we call environment variables. These variables contain sensitive information, like your private key, which we don't want to expose publically. Adding private keys or other sensitive data to environment variables in your .env file avoids having to display them in your command line history or elsewhere accidentally.\n\nRemember though, only store test private keys in your .env file, never your actual private key.\n\nHere's a brief demonstration of how to do this.\n\n```bash\n    private key = [your private key]\n    RPC_URL = http://your_rpc_url\n```\n\nNow, we have to load these environment variables into our shell:\n\n```bash\n    source .env\n```\n\nNow we can test out whether our environment variables were added successfully:\n\n```bash\n    echo $PRIVATE_KEY\n    echo $RPC_URL\n```\n\n## Secure Coding: The Next Step\n\nEven though we've made our command line cleaner by removing any direct input of private keys, there's still the worry of having our keys stored in plain text. That's why our next step towards secure coding involves using a keystore.\n\nA keystore is an encrypted file that contains your private key. You'll need a password to decrypt it.Foundry, a blockchain development toolset is in the process of adding a feature that allows developers to use keystores instead of exposing their private keys. Do check their GitHub repo to see the status of this feature.\n\nIn the meantime, it's essential to understand the step we've taken so far: using a .env file to store environment variables is acceptable for `_development_`. It is not the way to go for `_production_`.For production, you'd want to use Foundry's built-in interactive CLI to paste your key in, or use a keystore file with a password once Foundry integrates that function.\n\nSimply put:\n\n- **For Development**: Use environment variables\n- **For Production**: Use interactive CLI or a keystore file\n\n## The Env Pledge: Promote Secure Development\n\nThe `env` pledge is a set of rules focused on promoting secure development practices. It emphasizes using test private keys, ensuring private keys are not posted on any internet platform even momentarily, and taking immediate action if a key is potentially compromised. If you're _certain_ you won't be deploying anything to the mainnet or working with a private key that holds real funds, you can rest easy. But remember, as developers, it's our responsibility to approach key management with utmost caution.\n\nFeel free to share these valuable pledges with other developers on various platforms. The more people aware of these, the better.\n\nI hope this blog post has helped you understand the crucial aspect of interacting with your contracts securely and efficiently. Remember, you're responsible for managing these keys safely, so follow this guide to ensure you're doing it right!\n",
          "updates": []
        },
        {
          "lessonId": "8495d240-3ad3-4d6f-8b88-367728ea4b9a",
          "number": 17,
          "title": "Never Use A Env File",
          "slug": "never-use-a-env-file",
          "folderName": "17-never-use-a-env-file",
          "description": "Lorem ipsum dolor sit amet consectetur adipisicing elit. Quisquam ad porro a iusto rerum sed veniam nisi dolores cupiditate voluptatum?",
          "duration": 0,
          "videoUrl": "",
          "rawMarkdownUrl": "/routes/foundry/1-foundry-simple-storage/17-never-use-a-env-file/+page.md",
          "markdownContent": "---\ntitle: Third Web Deploy\n---\n\n_Follow along the course with this video._\n\n---\n\n# Moving Beyond Environment Variables\n\nA while back, I showed you a method where we utilized an environment variable (.env) to store private keys. However, times have evolved and we've acquired a much safer way to manage and protect those keys. This method involves using the Foundry's built-in ‘**cast**’ command which allows you to work with an encrypted version of the private key, thus avoiding any raw, plain-text encounters. If you're seeking a security review or an audit, and you still have a .env example left hanging around in your git repo, well, prepare yourself for a swift rejection.\n\n## Why Moving Away From Plain Text Keys is Crucial\n\nPreviously, I showed you how to use an Ethereum Private Key RPC URL and Etherscan API key as environment variables. We know, however, that plain texts can be precarious - you might accidentally push this critical piece of information to GitHub, or worse, disclose it in your terminal inadvertently.\n\n<img src=\"/foundry/update-env/env1.png\" style=\"width: 100%; height: auto;\">\n\nTherefore, it is extremely important to ensure the security of your private keys and never leave them open in the text format.\n\n## Solution: Encrypting your Keys Using ERC2335\n\nThe solution to this issue lies in the use of ERC2335. This is nothing but a nifty system that enables us to convert private keys into a secure JSON format.\n\nLet’s assume that your private key is the same as the default key that comes along with the Anvil development package. On running Anvil, you receive an output where you can locate said key.\n\nOnce you have your key, from your terminal, go ahead and run the following command:\n\n```bash\ncast wallet import defaultKey --interactive\n```\n\nA highly recommended practice is **not** to run this in Visual Studio Code, but directly within your terminal or shell instead. This maneuver launches an interactive shell where you can safeguard your details. You may copy-paste your private key here. At this point of execution, you are required to enter a password, which you need to remember whenever you need to use this private key.\n\nOn successful implementation, you will be provided with this message: `default Key store was saved successfully` and you will receive an address.\n\nBefore, we fed our private key directly into our terminal and used a make file to make the operation appear easier. With our private key now securely stored and encrypted in our cast, we can verify its presence using:\n\n```bash\ncast wallet list\n```\n\nAfter this, you can use the following command to run our default script:\n\n```bash\nforge script script/DeployFundMe.s.sol:DeployFundMe --rpc-url http://localhost:8545 --account defaultKey --sender 0xf39...--broadcast -vvvv\n```\n\n<img src=\"/foundry/update-env/env2.png\" style=\"width: 100%; height: auto;\">\n\nThe term 'private key' in this command is replaced with `account defaultKey --sender.` You still however need to copy-paste the address of the sender, AKA the address associated with the private key.\n\nA piece of advice to remember is that anytime you see your private key in plain text, your brain should give off alarm bells. And anytime you have the urge to reveal your private key, you must think twice. Even if you are using a development private key like in this course, when you start to work with real money, I highly encourage you to stick to the encrypted process.\n\nOnce you encrypt your private key, your objective should be to then never revisit it. Always remember, the chances of implications multiply significantly, anytime you expose your private key. Unfortunately, there is still no full-proof method to completely avoid revealing private keys but we can surely minimize the risk by exposing it the least number of times possible.\n\n## Conclusion\n\nTo simplify things to the best level possible, avoid using .env files to store your private key. Instead, opt for encrypting it with **cast wallet import**. While you are at it, use a password or a password file for added security and delete the key from your history after you use it. This would ensure that your private key, especially those with real money associated, are protected most effectively.\n\nFinally, let's take a moment to appreciate the contribution of the people who were instrumental in making Foundry a reality, making our lives as developers easier and more secure.\n\nStay safe, and until next time, happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "5b0806c9-eb4f-4258-aa8c-f5f8e89b32cb",
          "number": 18,
          "title": "Deploy a smart contract using Thirdweb",
          "slug": "thirdweb-deploy",
          "folderName": "18-thirdweb-deploy",
          "description": "Introduction to deploying smart contracts using Thirdweb, including benefits, ease of use, and features for secure and efficient contract deployment.",
          "duration": 5,
          "videoUrl": "6dfV-0Hwft8",
          "rawMarkdownUrl": "/routes/foundry/1-foundry-simple-storage/18-thirdweb-deploy/+page.md",
          "markdownContent": "---\ntitle: Third Web Deploy\n---\n\n_Follow along the course with this video._\n\n\n\n---\n\n# Secure Contract Deployment with Third Web\n\nWhen developing on a blockchain, you inevitably come across challenges – like managing private keys in plaintext – that can potentially compromise the security of your solution. Third Web Deploy, a product of Third Web, offers a hassle-free and secure solution to such challenges.\n\nKira from the Third Web team has provided a comprehensive overview of how Third Web can help you effortlessly deploy contracts on any EVM chain that you prefer. For those unfamiliar with the `npx` command, it comes pre-bundled with the node.js and NPM installation. You can refer to our GitHub repository to learn more. Now, let's dive into Kira’s explanation.\n\n<img src=\"/foundry/17-thirdweb/thirdweb1.png\" style=\"width: 100%; height: auto;\">\n\n## Easy Contract Deployment with a Single Command\n\nTo deploy a contract, generally, you would need to set up hardcoded private keys as well as RPC URLs, and they need some level of scripting. However, with Third Web, you can surpass all these tedious steps for deployment. Since you're not exporting your private key in this process, it enhances your contract's security significantly.\n\nThe deployment process happens through a dashboard UI, enabling you to manage everything right from your wallet. Let's walk through the process of deploying contracts with Third Web.\n\n## Deploying Contracts with Third Web\n\nSuppose you have already cloned a repository, or maybe you've written your contract. This could be any contract; for this walkthrough, I've cloned a simple storage contract.\n\nFor this contract, there's no `.env` file, no RPC URL setup, and I haven't exported my private key. This is one of the fantastic aspects of Third Web - there is absolutely no pre-installation needed, no dependencies whatsoever, making the entire process much more straightforward and less time-consuming.\n\nTo commence the deployment, all you need to do is run the simple command `npx thirdweb deploy`.\n\n## What Happens When You Deploy\n\nOn executing this command, Third Web will ascertain the project type, compile contracts, and permit you to choose the contract you wish to deploy. In this demonstration, I am deploying a simple storage contract.\n\nThis action leads to the contract metadata getting uploaded to IPFS, resulting in automatic contract verification. For those interested in a more in-depth explanation of this mechanism, please visit the [Third Web Developer Docs](https://portal.thirdweb.com/deploy).\n\n<img src=\"/foundry/17-thirdweb/thirdweb2.png\" style=\"width: 100%; height: auto;\">\n\nFollowing these steps, a browser tab will open where you can deploy your contract through a front-end interface. In circumstances where construct params are required (they aren't in this case), you'll be able to fill them out directly.\n\nNext, you select the chain you wish to deploy to. Third Web supports all EVM networks, from the popular ones like Base to custom networks if they aren't listed already. In this case, I selected the Mumbai network for deployment.\n\nThis process triggers two transactions – one, a transaction to deploy the contract, and two, a gasless message that you sign. This message adds your contract to your dashboard, providing a user-friendly interface to interact with the contract, very similar to Remix.\n\nOnce these transactions are completed, your contract is successfully deployed, as simple as that!\n\n## Navigating Third Web's Dashboard\n\nOn successful deployment, the contract address will be visible, which you can copy for future use. The dashboard also offers several features for easy contract management:\n\n- The **Build tab** facilitates effortless front-end interface creation for contracts with easy-to-use hooks in various languages.\n- The **Explorer tab** allows the view and modifies the read and write functions of your contract—essentially, all functions you have in your contract are listed here.\n- You can monitor the events related to your contract and even access the source code.\n\n<img src=\"/foundry/17-thirdweb/thirdweb3.png\" style=\"width: 100%; height: auto;\">\n\nIn a nutshell, Third Web provides a swift, easy, and secure way to deploy contracts. It's a one-stop-shop for your web three development needs with multiple language SDKs, prebuilt contracts, and a solid infrastructure for all your web three development requirements.\n\nFor more information, visit [Third Web](https://www.thirdweb.com/) or refer to their detailed [Documentation](https://docs.thirdweb.com/).\n\n<img src=\"/foundry/17-thirdweb/thirdweb4.png\" style=\"width: 100%; height: auto;\">\n",
          "updates": []
        },
        {
          "lessonId": "1acf7564-9d3d-40b9-8baf-e867f61a589e",
          "number": 19,
          "title": "Interact with a smart contract using the CLI",
          "slug": "interact-with-smart-contract-cli",
          "folderName": "19-cast-send",
          "description": "Comprehensive guide on interacting with smart contracts using CLI and Foundry's Cast tool, detailing command usage for sending transactions and reading blockchain data.",
          "duration": 4,
          "videoUrl": "-qH4FuEUcZ8",
          "rawMarkdownUrl": "/routes/foundry/1-foundry-simple-storage/19-cast-send/+page.md",
          "markdownContent": "---\ntitle: Cast Send\n---\n\n_Follow along the course with this video._\n\n\n\n---\n\n## Interacting With Contract Addresses via Command Line &amp; Foundry's Cast Tool\n\nWhere you new to blockchain or you're just looking to grasp an in-depth understanding of sending transactions and calling functions on a contract through the command line, this article has got you covered.\n\nIn this piece, we will be exploring how to interact with these contracts, beginning with the command line interaction, and later extending that to scripts. Initially, we will interact with our deployed contract called **SimpleStorage contract** using private keys that is set as an environment variable.\n\n## Using Foundry's Cast Tool\n\n<img src=\"/foundry/18-cast/cast1.png\" style=\"width: 100%; height: auto;\">\n\nFoundry has an in-built tool known as the **Cast**. Cast comes loaded with numerous commands to interact with. One such useful command is **'send'** which is designed to sign and publish a transaction. To view help about **'send'**, type `cast send --help`. You will see that the 'send' syntax uses two arguments, namely, signature and the arguments.\n\n_The signature_ is essentially the identifier and docker of the function and its input types whereas _the arguments_ is the data you want to pass to the function.\n\n### Example: Using Cast tool to Interact with Simple Storage Contract\n\nSay, we have our simple storage contract and we deployed it. If we wanted to call our `store` function and send a transaction, we would just add some numbers and then click 'store'. However, if we want to call `store` from the command line, we can do it by passing the address we want, the signature and our desired values to pass to our `store` function.\n\nHere's an example of how you'd use the `cast send` function:\n\n```bash\ncast send <address> store(uint256) <values>\n```\n\n\"_Remember, the function should be followed by its input types in parentheses, and then the values that you want to pass in._\"\n\nThis command won't run immediately as we need to add our private key and RPC URL. So, let's do that. With the command **RPCCast**, the RPC URL can be added. Let's add our private key, too, just after the `RPC URL`.\n\nWith the correct command, we'll get a bunch of data about our transaction back. We'll get the `block hash`, `block number`, `Contract address`, `Logs`, and the `transaction hash`.\n\n### Using Cast Call to Read the Blockchain\n\nThe Cast tool also provides a `call` function which reads off the blockchain. `cast call --help` will reveal that `call`, like `send`, takes two signature and arguments.\n\nThe main difference between them, however, is that `call` is like pressing a view function button - it's not actually sending a transaction.\n\nHere’s an example:\n\n```bash\ncast call <address> retrieve()\n```\n\nWe should get the hex value back from the executed command. From here, we need to convert the hexadecimal back to decimal using the `cast --to-base` function.\n\n```bash\ncast --to-base <hex value copied> decimal\n```\n\nYou can see we get back the same numbers, which we've stored on the chain.\n\n## Updating Stored Values\n\nIf you decide to change the stored values, let's say from 123 to 777, you would send that transaction using the `send` command. Then call the `retrieve` function using the `cast call` like earlier. You should see the new number returned to you in the hexadecimal format. Simply convert the hexadecimal format back to decimal format, and voila - you've successfully interacted with your contract.\n\n```bash\ncast send <address> store(uint256) 777\n```\n\nFollowing this comprehensive guide, you can start interacting with your contracts from the command line smoothly and eventually with scripts. It's worth noting, this same approach can be used to interact with contracts on an actual test net or on an actual main net.\n\nHappy Contract Interactions!\n",
          "updates": []
        },
        {
          "lessonId": "c230292c-5fc1-4d55-9a2e-b86a2413ff0b",
          "number": 20,
          "title": "Deploying a smart contract on testnet (Sepolia)",
          "slug": "deploying-smart-contract-testnet-sepolia",
          "folderName": "20-deploying-to-a-testnet",
          "description": "Step-by-step tutorial on deploying smart contracts to Ethereum's Sepolia testnet using Foundry and Alchemy, including setting up RPC URLs and private keys.",
          "duration": 6,
          "videoUrl": "PTUk1XPPwdA",
          "rawMarkdownUrl": "/routes/foundry/1-foundry-simple-storage/20-deploying-to-a-testnet/+page.md",
          "markdownContent": "---\ntitle: Deploying to a Testnet\n---\n\n_Follow along the course with this video._\n\n\n\n---\n\n## Deploying our Contract to Testnet or Live Network with Foundry and Alchemy\n\nHi, everyone! Are you curious about what your contract would look like on a testnet or a live network? If so, buckle up because this blog post will cover exactly that! We'll walk through the process of updating our Environment Variable (.env) file for an actual testnet.\n\nClearly, we need an actual testnet for a real network. But our trusty Metamask has built-in Infura connections that are incompatible. Why? Because they're tailored specifically for MetaMask. Hence, we need our own Remote Procedure Call (RPC) URL.\n\n## Creating our Own RPC URL for a Testnet\n\n_To create one, we could run our own blockchain node, but let's be honest — many folks prefer avoiding that route. Instead, we utilize Node as a Service (NaaS) applications to expedite the process._\n\nOne promising option is using Alchemy - a free NaaS platform that we can send the transactions to. This procedure resides within the _Deploying to Testnet or Mainnnet_ section in the full course repo of the Foundry.\n\n<img src=\"/foundry/19-testnet-deploy/testnet1.png\" style=\"width: 100%; height: auto;\">\n\nTo access the Alchemy platform, we simply click on the aforementioned function. On the platform, we sign up (I used Google sign-in for this demo).\n\nOur next step is creating a new app in the Alchemy user interface. I named mine _Sepolia Testing_ and kept the description the same, given that our chain will be an Ethereum one based on Ethiopia.\n\nWe can bypass advanced features for now and finalize our app. Now we have the app details needed for our node, including frequency of calls and other details. We also have a new https endpoint by clicking view key, which functions exactly the same way as our ganache or MetaMask endpoint.\n\n## Altering our Private Key\n\nNext, let's do something about our private keys. Our ganache private key will no longer cut it — it has neither real money nor any testnet ETH in it.\n\nOur solution is to use one of our MetaMask private keys. To do this, we switch back to Sepolia in our MetaMask, choose an account with money in it, click on account details, and export the private key. _Remember, never share your real private key!_\n\nUpon confirmation with your password, copy the private key and omit the line in the env file — hashtag or pound sign denoting comments.\n\n## Executing the Transaction\n\nWith our Sepolia RPC URL and private key from MetaMask, executing a transaction now becomes tremendously easier.\n\n```bash\nsource .env\nforge script script deploySimpleStorage.s.sol --rpc_url=$Sepolia_RPC_URL --private-key=$private_key --broadcast\n```\n\nThis command deploys our contract to the testnet, and we can monitor the transaction on our Alchemy dashboard.\n\nWe soon find that our contract, Simple Storage, has been deployed on the Sepolia chain. We can grab our transaction hash and input it into Sepolia etherscan IO to confirm the successful transaction.\n\nAfter we refresh our Alchemy dashboard, we'll verify the requests sent and track the ETH send raw transaction that transmitted our transaction to the blockchain.\n\nSo, this is how we deploy our contract on a real testnet leveraging Foundry and Alchemy!\n\nOur next step will explore adding real-world components to the mix. Stay tuned!\n",
          "updates": []
        },
        {
          "lessonId": "2674ff49-7364-4444-a9a0-7d5fed16a387",
          "number": 21,
          "title": "Verify a smart contract on Etherscan",
          "slug": "verify-smart-contract-etherscan",
          "folderName": "21-manual-verification",
          "description": "Guide on verifying Ethereum smart contracts on Etherscan, covering manual verification steps and the importance of contract readability and accessibility.",
          "duration": 2,
          "videoUrl": "JwYz5kj4FdI",
          "rawMarkdownUrl": "/routes/foundry/1-foundry-simple-storage/21-manual-verification/+page.md",
          "markdownContent": "---\ntitle: Manual Verification\n---\n\n_Follow along the course with this video._\n\n\n\n---\n\n# Verifying Your Ethereum Smart Contracts: A Step-by-Step Guide\n\nEthereum smart contracts are powerful tools for decentralized applications. However, they can seem a bit intimidating when viewed in their raw form, especially for beginners. Today, we're exploring how to navigate these waters by inspecting and verifying smart contracts on Etherscan, a blockchain explorer.\n\nWhen working with Ethereum smart contracts, you'll often come across what seems like an overwhelming bunch of bytecode when examining the contract on Etherscan. Let's fix that.\n\n## The Raw Contract: A Bytecode Jungle\n\n<img src=\"/foundry/20-verification/verification1.png\" style=\"width: 100%; height: auto;\">\n\nAs you dive into your smart contract on Etherscan, you'll be greeted by the contract's bytecode. This usually appears as a jumbled mass of non-readable code, making it challenging to understand the contractual logic contained within.\n\n## Verifying Your Smart Contract: The Hard Way\n\nHere's a step you can take to make the contract more readable; verify the contract. I'll show the hard and manual way first, and then follow up with a simpler, more streamlined method.\n\nTo manually verify a contract on Etherscan or other Block Explorers, follow these steps:\n\n1. Navigate to the 'Verify' option.\n2. Select 'Solidity' as the contract's language.\n3. Since this is a single file contract, choose 'Single File'.\n4. The compiler version we're using for this demonstration is 0.8.19, and our open-source license is MIT. Fill these details accordingly.\n5. Click 'Continue'.\n\nNow, you'll need to copy the entire contract from your 'SimpleStorage.sol' file, paste it in the appropriate dialogue box, select 'Optimization' as 'Yes', and then verify that you're not a robot.\n\n<img src=\"/foundry/20-verification/verification2.png\" style=\"width: 100%; height: auto;\">\n\nEnsure that you leave the boxes for constructor ARGs, contract library addresses, and miscellaneous settings blank. Once done, click 'Verify and Publish'.\n\nAt this stage, the verification process can get a little tricky. But if done correctly, if you click on your contract address, navigate to 'Contract', and then scroll down, the previously unapproachable code is now readable in Etherscan.\n\nBesides making the code legible, this process also provides access to the 'Read' and 'Write' contract buttons, and you can interact with your contract directly from Etherscan or elsewhere.\n\n<img src=\"/foundry/20-verification/verification3.png\" style=\"width: 100%; height: auto;\">\n\n## Verifying Your Smart Contract: The Easy Way\n\nThe manual verification method outlined above can be full of pitfalls. That’s why it's not a recommended method. Instead, I encourage you to conduct programmatic verification of your contracts which removes these barriers - a method I'll be teaching in the near future.\n\nIn the end, verifying your contracts makes working with Ethereum smart contracts significantly more manageable and understandable. Whether you’re a veteran Ethereum developer or a newcomer to the space, having a clear understanding of your contracts is essential for building secure, efficient, and effective decentralized applications.\n\nRemember, Ethereum smart contracts, with their powerful capabilities, form the beating heart of any DApp. So it's critical to learn how to navigate, inspect, and verify your contracts to ensure they are error-free and function as intended. Happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "8df7e063-f1a6-4a5d-8bdd-d9b201f5b5dc",
          "number": 22,
          "title": "Cleaning up the project",
          "slug": "cleaning-up-the-project",
          "folderName": "22-cleaning-up",
          "description": "Tutorial on cleaning up a coding project, emphasizing formatting consistency using Forge and crafting an informative README file with Markdown.",
          "duration": 3,
          "videoUrl": "oqSxjeEy8CU",
          "rawMarkdownUrl": "/routes/foundry/1-foundry-simple-storage/22-cleaning-up/+page.md",
          "markdownContent": "---\ntitle: Cleaning Up\n---\n\n_Follow along the course with this video._\n\n\n\n---\n\n## Mastering a Basic Coding Project: Formatting and README files\n\nHello, we've covered a lot, and are rounding the corner to completion. As we look to wrap things up, let's focus on a couple of aspects that are essential for rounding out any project: Formatting and README files.\n\n## Formatting for Consistency\n\nIn this project, we've been using the powerful tool - Vs code auto-formatter to automatically format our code. This saves us tedium and ensures a consistent style throughout our files. But what happens when someone else comes to our codebase? We want them to apply formatting that aligns with our style. For this, we can use the `forge format command`.\n\nWhen we run `Forge format command`, our code reformats according to predefined rules. This command ensures that all our solidity code adheres to a consistent style.\n\n```bash\nforge fmt\n```\n\nYou'll notice upon running this command that your code moulds itself into a neat and tidy format. Try it out - save without formatting, run the command, and watch your code auto-formatted right before your eyes.\n\n## Crafting a README\n\nEvery code repository isn't complete without a readme. If you want to contribute to open source, you'll find this file in almost every single repo. Your next stop, therefore, should be creating a `README.md` file. We create this by clicking on `right click new file` and then typing `README.md`.\n\nIn this all-important file, you document critical information about your project: what it's about, how it works, instructions for collaborating, contact details, so on.\n\n```bash\ntouch README.md\n```\n\n<img src=\"/foundry/21-clean-up/readme1.png\" style=\"width: 100%; height: auto;\">\n\nTake a look around. README files also contain notes and other bits of important information. I had jotted down some notes about private key usage in my README. Although it's no longer needed, so we'll just delete that for now.\n\nWhile this project isn't headed for GitHub, it's crucial to remember that the README is an invaluable addition when you push your code to platforms like GitHub. We'll get into this more in our next project, where I'll guide you through using version control systems and repositories.\n\n## Marvel at Markdown\n\nREADME files make use of 'Markdown' syntax, a text-to-HTML conversion tool for web writers. Do you remember when we discussed using Markdown syntax to field questions? Guess what, we're back at it again!\n\nA quick run-through: To use markdown in our README, we can use a `#` for headlines, and simple text entry for regular lines. Here's a sneak peek:\n\n```markdown\n# HelloSome text here\n```\n\nTo view what this looks like in HTML form, we can install a handy extension such as 'Markdown all in one' or 'Markdown Preview'.\n\n```bash\nCommand Shift P > View command palette > Markdown preview > Open preview\n```\n\nThis combination gives us a preview replicating how the document might look like on GitHub.\n\n<img src=\"/foundry/21-clean-up/readme2.png\" style=\"width: 100%; height: auto;\">\n\nYou will notice that the headline \"Hello\" is big and bold, while \"Some text here\" retains regular formatting. Moreover, you can add 'backticks' to format a line as code.\n\n```\n `code here`\n```\n\n<img src=\"/foundry/21-clean-up/readme3.png\" style=\"width: 100%; height: auto;\">\n\nPro-tip: A quick `Command Shift V` (or `Control Shift` for Windows and Linux users) opens up Preview mode.\n\n<img src=\"/foundry/21-clean-up/readme4.png\" style=\"width: 100%; height: auto;\">\n\nThat's all for now! Remember, formatting and a well-documented README are integral to any project - big or small. Stay tuned for more tips, tricks, and insights into the exciting world of coding. Happy Coding!\n",
          "updates": []
        },
        {
          "lessonId": "c36079de-f431-4182-a2e2-da18aa6adbb7",
          "number": 23,
          "title": "Introduction to Alchemy",
          "slug": "introduction-to-alchemy",
          "folderName": "23-alchemy-mempool",
          "description": "Introduction to Alchemy, a developer platform for Web3 applications, covering its features, benefits, and steps to create an account and use its services.",
          "duration": 12,
          "videoUrl": "HehY5DCtPWc",
          "rawMarkdownUrl": "/routes/foundry/1-foundry-simple-storage/23-alchemy-mempool/+page.md",
          "markdownContent": "---\ntitle: Alchemy & The Mempool\n---\n\n_Follow along the course with this video._\n\n\n\n---\n\n## Alchemy: A Game Changer for Decentralized Application Development\n\nInnovation in the blockchain industry has come a long way, with powerful tools making their way into the ecosystem to support developers and bring efficiency to their workflows. Among these tools is Alchemy, and today we have Vito, the lead developer experience at Alchemy, to walk us through the platform, its features, and how you can leverage it to exponentially increase your productivity.\n\n## What is Alchemy?\n\nAlchemy is a platform equipped with APIs, SDKs, and libraries to enhance your developer experience while working on Web3 projects. Think of Alchemy as the AWS of Web3. It functions as a node provider and developer tooling platform predominantly used in thousands of Web3 and Web2 applications, including large Web2 corporations like Adobe, Shopify, and Stripe.\n\nThe need for platforms such as Alchemy arises from the fact that, as a developer, you don't usually have to worry about running the servers your code operates on or developing the deployment and integration pipelines for your application. Instead, you use services such as AWS, Azure, and Google Cloud for that—Alchemy does the same but for Web3.\n\n## How Does Alchemy Work?\n\nAlchemy enhances your developer experience through a combination of features. The platform's primary component is the _Supernode_, a proprietary blockchain engine that works as a load balancer on top of your node.\n\nLike its name suggests, the Supernode ensures data from the blockchain is always up-to-date and readily available. Using the Supernode as a foundation, Alchemy has built the _Enhanced APIs_—a set of APIs that makes pulling data from the blockchain a breeze.\n\nTo put it simply, the Alchemy Supernode sits at the core of its ecosystem, powering up functionalities like Enhanced APIs and monitoring tools while supporting multiple chains.\n\nWhat follows is a step-by-step guide on how to create a new account on Alchemy and leverage this platform to its full extent:\n\n## Creating a New Account on Alchemy\n\nCreating an account on Alchemy is not only easy but also completely free. You can also freely scale your applications up using the platform's generous premium plans.\n\n#### Step 1: Navigate to Alchemy.com\n\nHead over to [Alchemy.com](https://www.alchemy.com/) and create a new account.\n\n#### Step 2: Create a New Application\n\nOnce you have signed in, create a new application.\n\nNext, give your application a name and a description. Then, select a chain and network. Alchemy currently supports the majority of EVM-compatible chains, including:\n\n- Ethereum\n- Polygon (POS)\n- Zkevm\n- Optimism\n- Astar\n- Solana (non-EVM chain)\n\n## The Application-Specific Dashboard\n\nOnce your application is up and running, you will have access to the application-specific dashboard. This dashboard provides crucial insights into your application and infrastructure health, such as latency, compute units, and transaction success rate, which can be valuable for debugging and identifying issues.\n\nIf you observe a lower success rate for your transactions, go to the \"Recent Invalid Request\" tab. This will list all unsuccessful requests along with the reasons for their failure, making it easier for you to debug and fix issues.\n\n<img src=\"/foundry/22-alchemy/alchemy1.png\" style=\"width: 100%; height: auto;\">\n\n## Mempool Watcher\n\nAnother powerful tool provided by Alchemy is the Mempool watcher. Picture it as Ethereum's mempool, where all pending transactions reside waiting for validation or mining.\n\nThe Mempool watcher provides extensive details about your transactions, such as:\n\n- Transaction status (mined, pending, dropped, replaced)\n- Gas used\n- Time taken for validation\n- Transaction value\n- Sender's and receiver's address\n\nThis detailed transaction tracking allows you to have a better understanding of each transaction and aids immensely in debugging specific issues related to individual transactions.\n\n## Wrapping Up\n\nTo sum up, Alchemy is a revolutionary platform that brings a plethora of tools to aid your Web3 development experience. From Supernode to Enhanced APIs and crucial troubleshooting tools, Alchemy is undeniably a game changer in the world of decentralized applications.\n\n\"Alchemy can be a powerful asset to any blockchain developer, offering a simplified experience in an inherently complicated Web3 environment.\" – Vito, Lead Developer Experience at Alchemy.\n\nVito suggests that you check out Alchemy's [documentation](https://docs.alchemy.com/) to explore more about the platform, its APIs, SDKs, libraries, and tools. Also, don't forget to follow them on Twitter at [@AlchemyPlatform](https://twitter.com/alchemyplatform) and [@AlchemyLearn](https://twitter.com/alchemyLearn). And if you want to connect directly with Vito, feel free to reach out to him on Twitter at [@VitoStack](https://twitter.com/VittoStack).\n\nAlchemy is revolutionizing the landscape of blockchain development and making it more accessible and efficient for everyone involved. Happy building with Alchemy!\n",
          "updates": []
        },
        {
          "lessonId": "56e13acc-9c52-46bd-adc3-bf8d138c100b",
          "number": 24,
          "title": "Wrap up, congratulations!",
          "slug": "summary-congratulations",
          "folderName": "24-summary-congratulations",
          "description": "Summary and congratulations on completing the Foundry project, highlighting key learnings, tools used, and encouraging continued learning and coding practice.",
          "duration": 3,
          "videoUrl": "kj-E0_uO9i0",
          "rawMarkdownUrl": "/routes/foundry/1-foundry-simple-storage/24-summary-congratulations/+page.md",
          "markdownContent": "---\ntitle: Summary & Congratulations\n---\n\n_Follow along the course with this video._\n\n\n\n---\n\n## Celebrating Milestones in Foundry: A Complete Walkthrough of Our Recent Project\n\nYou should feel a warm sense of accomplishment envelop you. Completing an entire project in Foundry is no mean feat. A hearty congratulation is in order for such an indomitable effort. This article serves as a quick, yet comprehensive, recap of everything we learnt in our project, proceeding into our next engagement. From the onset, rest assured, we are set to advance our Foundry skills, push upcoming projects on GitHub, and familiarize ourselves with advanced tooling.\n\n## A Quick Trip Down Memory Lane: Key Takeaways from the Project\n\nFirstly, we journeyed through the process of creating a new Foundry project using Forge and Knit. These essential tools afforded us a structured, professional environment complete with folders to keep our work organized.\n\nWe not only learnt about Foundry’s basic commands but also their specific functionalities such as:\n\n- **Cast**: interacts with contracts that have been previously deployed.\n- **Forge**: compiles and interacts with our contracts.\n- **Anvil**: deploys a local blockchain, similar to another tool we used, Ganache.\n\nA pivotal part of our learning process was comprehending that sending a transaction via our MetaMask is tantamount to making an HTTP post request to a particular RPC URL. A similar RPC URL can be obtained from a node-as-a-service provider like [Alchemy](https://www.alchemyapi.io/) and used to send transactions directly from our Foundry projects.\n\nWe obtained practical knowledge on how to compile code in Foundry and write a Solidity script for its subsequent deployment. We also find it critical to ensure the security of our private keys. Hence, throughout this course, we will be using an `.env` file. But be warned when dealing with real money, having your private key in plain text is not advisable.\n\n## Understanding Contract Deployment and Interaction on the Blockchain\n\nWe delved into the automation of contract deployments to a blockchain. Post-deployment, we interacted with them using the `Cast` keyword and `send` to make transactions, then `Cast call` to read from those contracts.\n\nMoreover, the knowledge on how to auto format contracts with `Forge format` was acquired. We also learnt the painstaking yet rewarding manual method of verifying our contracts on the blockchain.\n\n```bash\nforge format my_contract.sol\n```\n\n<img src=\"/foundry/23-summary/summary1.png\" style=\"width: 100%; height: auto;\">\n\n## Looking Ahead\n\nWith these tools in your web development arsenal, you've performed exceptionally well – and yes, you should be incredibly proud. Remember, even something as small as installing tools like `Vs code` and `Foundry` can pose great difficulties, so, you're doing fantastic.\n\nTake a breather. Remember, breaks enhance productivity. Till next time, continue to strive for greatness in every line of code you write!\n\n<img src=\"/foundry/23-summary/summary2.png\" style=\"width: 100%; height: auto;\">\n",
          "updates": []
        }
      ]
    },
    {
      "sectionId": "105de61f-72fe-46d3-bfc4-8a2460e38d21",
      "number": 2,
      "title": "Foundry Fund Me",
      "slug": "foundry-fund-me",
      "folderName": "2-foundry-fund-me",
      "lessons": [
        {
          "lessonId": "bba0c0f7-79cc-4a28-a9f8-3b3165ecbb52",
          "number": 1,
          "title": "Fund Me project setup",
          "slug": "fund-me-project-setup",
          "folderName": "1-fund-me-setup",
          "description": "Introduction to the Foundry FundMe project, including setting up GitHub, understanding the FundMe contract, exploring storage and state variables, and creating a new Foundry project folder.",
          "duration": 5,
          "videoUrl": "gXtqmMaBYPw",
          "rawMarkdownUrl": "/routes/foundry/2-foundry-fund-me/1-fund-me-setup/+page.md",
          "markdownContent": "---\ntitle: Welcome & Setup\n---\n\n_Follow along the course with this video._\n\n\n\n---\n\nWelcome to Lesson 7, where we will cover 'Foundry FundMe,' a crucial part of our smart contract journey. The aim of this lesson is to learn how to professionally deploy the code, master the art of creating fantastic tests, and gain insights into advanced debugging techniques.\n\n## Your First GitHub Contribution\n\nThis will be the first codebase that you will be contributing to GitHub yourself. Using a version control system such as GitHub, GitLab, or Radical is integral to being part of the Web Three ecosystem. For this lesson, we will be utilizing GitHub, given its popularity.\n\n## Understanding the Foundry FundMe\n\nWe start by delving into the FundMe contracts that we created previously. The source folder (`src`) contains these contracts, exhibiting the advanced syntax with all caps constants and underscores (`i_`, `s_`) fore immutables and storage/state variables, respectively.\n\nUntil now, we talked a lot about storage and state, but we didn't delve into what they really mean. Through a 'Fun with Storage' example, we will uncover these concepts in this lesson. This will form the backbone of understanding how to make contracts more gas efficient. Hence, making transactions less expensive for users.\n\n## Taking the Plunge\n\nAll right, let's jump into the code!\n\nWe will be working within our VS code, in our Foundry `F23` folder. To date, the only folder we have created is `foundry-simple-storage`. Now we will create a new one called `foundry-FundMe-f23` using the `mkdir` (make directory) command.\n\n```bash\n$ mkdir foundry-FundMe-f23\n```\n\nUsing the `ls` (list) command, we will see these two folders. Following this, we will initiate VS code in the newly created `foundry-FundMe-f23` folder.\n\n```bash\n$ code foundry-FundMe-f23\n```\n\n<img src=\"/foundry-fund-me/1-setup/setup1.png\" style=\"width: 100%; height: auto;\">\n\n\nOnce we set up our new VS code, we can initialize our blank Foundry project using the `forge init` command.\n\n```bash\n$ forge init --force\n```\n\n## Understanding the Fundamentals through Counter.sol\n\nSubsequently, we come across the counter.sol contract within the `src` (source) folder. This is a basic contract that allows us to understand the foundational principles in depth. The contract has a `setNumber` function, an input parameter, `uint256 newNumber`, which modifies the variable as per the new number.\n\nIt also includes an `increment` function employing the `++` syntax equivalent to the expression `number = number + 1`.\n\n\n\n```js\nfunction increment() public {\n    number = number + 1;\n}\n```\n\n## Deploying the Code\n\nFurther, we learn how to deploy this code using Foundry scripts and make it easier to run these contracts on different chains requiring unique addresses. We also acquire insights into how to use Foundry scripting to interact with our contracts in reproducible scripts instead of always from the command line.\n\n## Wrapping Up\n\nBy the end of this lesson, you should have a thorough understanding of this code, how to use it, discuss it effectively, and more importantly, how to write fantastic tests for your contracts. This is a crucial skill for any aspiring smart contract engineer.\n\nUpon completion, you should 100% share the project on your GitHub and social channels. Remember, this lesson is an enormous step in your Smart Contract journey.\n\nKeep learning and let's get started with the Fund Me project!",
          "updates": []
        },
        {
          "lessonId": "23135955-1931-478b-8023-2ebe899162b3",
          "number": 2,
          "title": "Introduction to smart contracts testing",
          "slug": "smart-contract-testing-introduction",
          "folderName": "2-testing-introduction",
          "description": "A guide on testing smart contracts using the `forge test` command and the `counter.t.sol` example, emphasizing the importance of test-driven development in programming.",
          "duration": 2,
          "videoUrl": "-e-ssPkqJUo",
          "rawMarkdownUrl": "/routes/foundry/2-foundry-fund-me/2-testing-introduction/+page.md",
          "markdownContent": "---\ntitle: Testing Introduction\n---\n\n_Follow along the course with this video._\n\n\n\n---\n\nTo stand out from the crowd, one must not only master the development of smart contracts but also proficiency in testing these smart contracts. This not only guarantees you the quality and reliability of your code but also significantly reduces the occurrence of runtime issues that could potentially cost both clients and organization substantial amounts.\n\nIn this blog post, we will take a deep dive into the fascinating world of testing smart contracts, basing our illustrations on `forge test` command and the `counter.t.sol` example file.\n\n\n\n## Wrap Up: Driving Excellence in Blockchain Development\n\n<img src=\"/foundry-fund-me/2-testing-intro/testing1.png\" style=\"width: 100%; height: auto;\">\n\n\n\n\nStart today by adopting test-driven development in your programming regimen. It might seem tedious to begin with, but once you comprehend its value, you will appreciate the increased reliability and robustness it rings to your code.\n\nDon't forget, always run `forge test` to check the health of your smart contract before shipping out your code. Stay tuned for a more detailed exploration of testing and foundry fundamentals in the next lesson.",
          "updates": []
        },
        {
          "lessonId": "d70c58eb-09aa-43d6-8cec-824516710bbb",
          "number": 3,
          "title": "Finishing the setup",
          "slug": "finshing-the-setup",
          "folderName": "3-setup-continued",
          "description": "Continuation of the project setup, including cleaning up unnecessary files, incorporating contracts from Remix, resolving import errors, and directing imports with remappings.",
          "duration": 6,
          "videoUrl": "qF3WqBwisPE",
          "rawMarkdownUrl": "/routes/foundry/2-foundry-fund-me/3-setup-continued/+page.md",
          "markdownContent": "---\ntitle: Setup Continued\n---\n\n_Follow along the course with this video._\n\n\n\n---\n\n\n\n### Necessary Clean-Up\n\nTo begin, we first need to clean up unwanted files in our project directory. Since we will be using our own contracts, we can safely remove any pre-existing counter files.\n\n```shell\n$ rm -f Counter.sol\n```\n\n\n## Incorporating Contracts from Remix\n\nWhen it comes to creating new files for our smart contracts, we will be working from 'lesson four' and 'Remix FundMe'. It's of utmost importance not to copy-paste contracts from our Foundry FundMe file at this point. Instead, we can clone the Remix FundMe file and modify it to facilitate easier composition of tests and interactions.\n\n```bash\n# Create a new file\ntouch FundMe.sol\n# Copy-paste the contracts from Remix FundMe and paste it in this new file \n```\n\nWe will do the same for the 'price converter' contract.\n\n```shell\n# Create a new file\ntouch priceConverter.sol\n# Copy-paste the content of the price converter contract file into this new file\n\n```\n\n\n<img src=\"/foundry-fund-me/3-setup-continued/setup-c1.png\" style=\"width: 100%; height: auto;\">\n\n\n### Resolving Import Issues\n\nWhen we try to compile our newly imported contracts, we might encounter import errors. This happens because while Remix automatically reaches into the NPM package repository to resolve imports, Foundry does not do this. In the context of Foundry, we must specify exactly where the dependencies should be pulled from.\n\n<img src=\"/foundry-fund-me/3-setup-continued/setup-c2.png\" style=\"width: 100%; height: auto;\">\n\n\nLet's install this dependency with the 'forge install' command.\n\n```shell\n# The command is written as follows:\nforge install smartcontractkit/chainlink-brownie-contracts\n```\n\nWe can now view and access these contracts in our local environment. The path to these contracts lies in the newly created 'Lib' folder.\n\n### Redirecting Imports with Remappings\n\nAt this moment, our contracts inaccurately import the 'aggregatorv3interface' from '@chainlink contracts'. To correct this, we need to instruct Foundry that '@chainlink contracts' actually points to our local 'Lib' folder. This can be achieved through a Foundry configuration file known as 'foundry.toml,' where we can establish a conduit, or remapping, to set this path accurately.\n\n<img src=\"/foundry-fund-me/3-setup-continued/setup-c3.png\" style=\"width: 100%; height: auto;\">\n\n\nIn the remapping section, construct this line of text:\n\n```js\nremappings = [\"@chainlink=lib/chainlink-brownie-contracts/contracts\"]\n```\n\nThis tells Foundry to replace '@chainlink contracts' with the path to the local library's chainlink brownie contracts.\n\n### Final Compilation and Potential Errors\n\nFinally, we're ready to compile our contracts!\n\n```shell\n$ forge build\n```\n\n<img src=\"/foundry-fund-me/3-setup-continued/setup-c4.png\" style=\"width: 100%; height: auto;\">\n\n\nIf you encounter errors, which are common in the course of such complex processes, consider labeling them with the contract name – followed by two underscores. It's a nifty convention that quickly helps identify which contracts throw these errors – for instance, here, 'FundMe contract.'\n\nWith these simple steps, you have set up your smart contracts and launched your journey into the innovative world of building decentralized applications!\n\n",
          "updates": []
        },
        {
          "lessonId": "8df6e47f-e894-46cd-b1b7-63cf527f9a7d",
          "number": 4,
          "title": "Writing tests for your Solidity smart contract",
          "slug": "writing-tests-for-solidity-smart-contracts",
          "folderName": "4-tests",
          "description": "Detailed explanation on writing and running tests for Solidity smart contracts, including creating test files, understanding the setup function, and using console logs for debugging.",
          "duration": 9,
          "videoUrl": "eu3Wu9PcsW0",
          "rawMarkdownUrl": "/routes/foundry/2-foundry-fund-me/4-tests/+page.md",
          "markdownContent": "---\ntitle: Testing\n---\n\n_Follow along the course with this video._\n\n\n\n---\n\nIn this post, we will walk you through the entire process of creating robust tests for your smart contracts. Testing is an absolutely crucial step in your smart contract development journey, as the lack of tests can be a roadblock in the deployment stage or during a smart contract audit.\n\nSo, buckle up as we unveil what separates the best developers from the rest: comprehensive, effective tests!\n\n## Test File Creation and Basics\n\nBegin by creating a new file `FundMeTest.t.sol` to compose your tests. The 't' in `.t.sol` represents a convention in Solidity for test files.\n\nOur test will follow the same syntax as any Solidity contract. To start, we will specify the SPDX license and program solidity. We'll be making use of GitHub Copilot, which is useful for providing solid code recommendations.\n\nThe test code initially looks like this:\n\n```js\n// SPDX-License-Identifier: MIT\npragma solidity;contract fundMeTest { }\n```\n\nTo make running our tests easier, we will import a standard contract from the Forge Standard Library. We'll utilize the `test` contract from `std.st`.\n\n```js\nimport {Test} from \"forge-std/Test.sol\";\ncontract FundMeTest is test { }\n```\n\n## Prioritizing Smart Contract Functionality\n\nOur first goal is to ensure our FundMe contract operates effectively. Thus, one of the first tasks is to deploy this contract. We can accomplish this task by initially deploying our contracts directly in the test folder. Ideally, one should import the contract deployment scripts into the test scripts to homogenize the deployment and testing environments.\n\nWhile setting up our test contract, include a function called `setup`. This function is always the first to execute whenever we run our tests. Here's how it should look:\n\n```js\nfunction setup() external { }\n```\n\nOur setup function will deploy our contract. Before that, let's briefly explore what a test might look like. Here's an example:\n\n```js\nfunction testDemo() public { }\n```\n\nUpon executing `forge test`, you will see a successful compiler run, indicating our test passed.\n\n## The Magic of 'Setup' and 'Console'\n\nDo you know why `setup` runs first? Let's break it down with an example:\n\n```js\n    uint256 number = 1;\n    function setup() external {\n        number = 2;\n    }\n    function testDemo() {\n        assertEq(number, 2);\n    }\n```\n\nAbove, we declared `number` as 1. Within `setup`, `number` becomes 2. When we call the `testdemo` function and assert `number` is equal to 2, the test passes.\n\nThe `setup` function allowed us to update `number` before running our tests.\n\nHow about debugging these tests? We can tap into console logging for that.\n\nThe Console is a part of the `test.sol` contract included by default with Forge. The library lets us output print statements from our tests and contracts.\n\nConsider this code snippet:\n\n```js\nfunction testDemo() public {\n    console.log(number);\n    console.log(\"Hello, world!\");\n}\n```\n\nRunning `forge test -vv` prints the current value of `number` and \"Hello, world!\" The `-vv` specifies the verbosity level of the logging, giving us insight into our test results.S\n\n<img src=\"/foundry-fund-me/4-tests/tests1.png\" style=\"width: 100%; height: auto;\">\n\n\n## Deploying the Contract\n\nLet's dive back into our `setup` function and deploy the contract. To accomplish that, the contract should know about `fundMe`.\n\nLet's import it:\n\n```js\nimport \"FundMe\" from \"../src/FundMe.sol\";\n```\n\nNext, we will initialize the `fundMe` contract in the `setup` function:\n\n```js\nFundMe fundMe = new FundMe();\n```\n\nThe contract is now deployed, and we are all set for testing.\n\n## Writing and Running a Test\n\nLet's begin by writing a test that ensures our minimum USD value is five.\n\nConsidering `minimumUSD` is a public variable, we will validate within our `testdemo` function if the value is indeed 5 times 10⁹ or simply 5e18:\n\n```js\nfunction testMinimumDollarIsFive() public {\n    assertEq(fundMe.MINIMUM_USD(), 5e18);\n}\n```\n\nNow, if we run `forge test`, you should see \"compiler run successful\" and that the \"test minimum dollar is five\" has passed.\n\nIf you increase the testing value to 6 and rerun the test, it should fail, as the starting minimum USD is five.\n\nNow, alter the testing value back to five and rerun the test. The compiler should run successfully.\n\nCongratulations! You’ve just run your first basic test. Maintaining this testing practice consistently can help you secure your systems significantly.\n\n## Wrapping Up!\n\nAs technology advances, especially with the introduction of AI, you can go further with testing. With rigorous testing habits, you can ensure that your smart contracts behave as expected and transform from a mediocre developer to a proficient one.\n\n\n\n\n",
          "updates": []
        },
        {
          "lessonId": "b8f5d1cf-2554-41d8-9240-a3069d854c7a",
          "number": 5,
          "title": "Debug your Solidity tests",
          "slug": "debugging-tests",
          "folderName": "5-debugging-tests",
          "description": "A guide to debugging tests in Solidity, including writing and analyzing test functions, using console logs for troubleshooting, and understanding test failures.",
          "duration": 3,
          "videoUrl": "achXgiVg-FA",
          "rawMarkdownUrl": "/routes/foundry/2-foundry-fund-me/5-debugging-tests/+page.md",
          "markdownContent": "---\ntitle: Debugging Tests\n---\n\n_Follow along the course with this video._\n\n\n\n---\n\n#By taking a hands-on approach, we'll write some functional tests to ensure that our code is working as expected and debug potential issues. This blog post is intended for both the seasoned veteran looking to tighten their test suite or a newcomer wanting to know more about the essentials of testing in Solidity.\n\n## Writing the First Test\n\nLet's go ahead and write a new test. This time, we'll examine whether the actual owner of a contract is indeed its message sender. Starting off, we can begin with the following function:\n\n```js\nfunction testOwnerIsMessageSender () public {\n    assertEq(FundMe.i_owner(), msg.sender);\n}\n```\n\nOne of the beneficial aspects of writing descriptive test functions is the role it plays in assisting GitHub Copilot with comprehending your coding intentions.\n\n## Debugging the Test\n\nInevitably, there may be moments where our test fail and present us with an unexpected output. So, how do we determine why this failed or what transpired?\n\nTo debug, we could use numerous techniques we've learned, such as console logs. Let's console log out the literal owner and also the message sender for our starting point.\n\n```js\nconsole.log(FundMe.i_owner());\nconsole.log(msg.sender);\n```\n\nThen, re-run the test to examine the console output. This will allow us to check whether these two addresses are indeed different.\n\n```bash\nforge test -vv\n```\n\n## Understanding Test Failures\n\nNow from the console outputs, the result is that indeed these are two different addresses. This disparity arises because technically, in our setup function, the FundMe test contract is what deploys our FundMe address and would therefore be the owner. The message sender is whoever's making the call to the FundMe test.\n\nIn essence, the process looks something akin to this:\n\n- 'Us' calls the `FundMe test`, which then deploys `FundMe`.\n- The `FundMe test` becomes the owner of `FundMe`, and not 'us'.\n\nWith this newfound understanding, it becomes clear that we shouldn't be checking to see if the `message sender` is the owner, rather we ought to check if `FundMe test` is the owner.\n\n<img src=\"/foundry-fund-me/5-debug-tests/debug1.png\" style=\"width: 100%; height: auto;\">\n\n## Correcting the Test\n\nLet's re-write our test function to reflect this information:\n\n```js\nfunction testOwnerIsMessageSender () public {\n    assertEq(FundMe.i_owner(), address(this));\n}\n```\n\nAfter running the test again, we find that indeed, our assertion was correct. Well done!\n\n## Conclusion on Testing\n\nConsole logs have proven to be a very useful debugging tool when writing tests. Of course, as we progress, we'll uncover more helpful ways to construct our tests. But for now, let's take a pause on these, as we'll return to refactor them soon.\n\nIf you've written just these tests, great job. To challenge yourself, you might want to pause and try to write some additional tests on your own. After all, practice is the key to mastering any programming language – and this holds particularly true for Solidity!\n",
          "updates": []
        },
        {
          "lessonId": "b3ef4b83-29e1-41c9-861b-c62771925dfd",
          "number": 6,
          "title": "Advanced deploy scripts",
          "slug": "advanced-deploy-scripts",
          "folderName": "6-advanced-deploy-scripts",
          "description": "Tutorial on writing advanced deploy scripts for smart contracts in Solidity, focusing on avoiding hardcoded contract addresses and making contracts more dynamic and adaptable.",
          "duration": 3,
          "videoUrl": "vCnt4Cpjuvc",
          "rawMarkdownUrl": "/routes/foundry/2-foundry-fund-me/6-advanced-deploy-scripts/+page.md",
          "markdownContent": "---\ntitle: Advanced Deploy Scripts\n---\n\n_Follow along the course with this video._\n\n\n\n---\n\nWhen crafting code for our blockchain, we encountered a significant obstacle. Our contract address was frequently hard-coded. This wouldn't ordinarily be an issue; however, our contract address merely existed on Sepolia, while we continued our testing phase on our local chain. In this lesson, we'll tackle this issue while simultaneously moving ahead in our coding project, so brace yourselves for an exciting ride. Let's dive in!\n\n## Writing our Deploy Scripts\n\nBefore we tackle our hard-code issue, let's execute an important task that we know is on our to-do list—writing our deploy scripts.\n\nStart by creating a new file named Deployfundme.s.sol. The standalone 'S' signifies the file is a script. Include the same SPDX license identifier, replace MIT with your own, and proceed to declare your contract deploy fund me.\n\n```js\n    SPDX-License-Identifier: MIT\n    pragma solidity 0.8.18;\n    contract DeployFundMe {}\n```\n\nWe're using Foundry, which means we need to import several lines of code, including the forge std script sol, and since we're deploying FundMe, why not import it from SRCF. Next, to run the script, you'll want to use the function. Revisit lesson six if you're finding this step a bit confusing—the function applies an external function for the VM start broadcast, and a FundMe in lower case equals the new FundMe navigated by a VM stop broadcast.\n\n```javascript\n    function run() external{\n        vm.startBroadcast();\n        new FundMe();\n        vm.stopBroadcast();\n    }\n```\n\nFollowing the function run prompts the script to run the `DeployFundMe.s.sol`. Encountering a 'VM' keyword error means you need to use the script. Rectifying this error leads to warnings about an unused local variable. In all probability, you do not even require this line. It's alright to remove it altogether and re-run the script.\n\n<img src=\"/foundry-fund-me/6-advanced-deploy/deploy1.png\" style=\"width: 100%; height: auto;\">\n\n## Overcoming Errors and Ensuring Smooth Running\n\nFollowing these steps should help in successfully running the compiler, with the script showing successful execution. Ensure that you pass an RPC URL if you wish to simulate on-chain transactions.\n\n<img src=\"/foundry-fund-me/6-advanced-deploy/deploy2.png\" style=\"width: 100%; height: auto;\">\n\nThe navigation of these steps indicates the importance of problem-solving in the blockchain coding world. In the upcoming blog posts, we will offer solutions on how to navigate hard-coding challenges in your blockchain coding challenges. Stay tuned for more insights!\n",
          "updates": []
        },
        {
          "lessonId": "8b07077c-a7aa-41d9-86cd-f54d51dc678f",
          "number": 7,
          "title": "Running tests on chains forks",
          "slug": "forked-tests",
          "folderName": "7-forked-tests",
          "description": "Instructions on running tests on forked blockchain chains, ensuring functional price feed integrations, and addressing issues related to non-existent contract addresses.",
          "duration": 9,
          "videoUrl": "de7aY97S3wA",
          "rawMarkdownUrl": "/routes/foundry/2-foundry-fund-me/7-forked-tests/+page.md",
          "markdownContent": "---\ntitle: Forked Tests\n---\n\n_Follow along the course with this video._\n\n\n\n---\n\nAs we delve further into the mechanisms of our evolving FundMe tool, we find ourselves grappling with some indispensable features we need to solidify. What jumps to mind first? Yes, you’re thinking right. It's the FundMe proceeds.\n\nAs developers, we must ensure that our conversion rate is functioning as expected, thereby assuring us that the funding aspect of our tool is reliable. For this, we must ascertain that we can acquire the right version from our aggregator v3 interface and interact with it appropriately.\n\nLet's plunge into this intricate process, taking one step at a time.\n\n### Ensuring Functional Price Feed Integrations\n\nThe first step involves testing our price feed integrations using the `get version` function. We know from Remix that it should return version four.\n\n```javascript\nfunction testPriceFeedVersionIsAccurate() {\n    uint256 version = FundMe.getVersion();\n    assertEq(version, 4);\n}\n```\n\nDelving further into the world of testing, we try running the test with Forge:\n\n```bash\nforge test\n```\n\nAnd lo and behold, we encounter an EVM revert. But why did this happen? To intensify our focus on this particular test and sideline the rest, we use this method:\n\n```javascript\nforge test -m testPriceFeedVersionIsAccurate\n```\n\nBy switching the visibility with three V's, we can acquire more information. We now see that we get what's known as a stack trace of the error, pointing out that our GetVersion call is reverting due to a non-existing contract address. This happens since Foundry automatically sets up an Anvil chain for test runs, deleting it after completion.\n\n```bash\nforge test -vvv\n```\n\n### Addressing Non-Existent Contract Addresses\n\nAt this stage, you might be left wondering how to tackle these non-existent addresses. Can we even test our `testPriceFeedVersion` accurately when it encounters hiccup due to Forge and Anvil? Yes, we can - with a little maneuvering. One way is to use a fork URL. Here, we’ll draw a parallel situation where we use Alchemy to generate an API key.\n\n```bash\nSEPOLIA-RPC-URL=your-alchemy-key\n```\n\nMake sure your .env file exists and is a part of your .gitignore.\n\n```bash\necho $SEPOLIA-RPC-URL\n```\n\nYou can now utilize this RPC URL.\n\n```bash\nforge test -M testPriceFeedVersionIsAccurate --fork-url $SEPOLIA-RPC-URL\n```\n\nThe Anvil spins up but imitates transactions as if they were on the Sepolia chain. Our test's successful run now verifies that our transaction was performed adequately on the Sepolia chain.\n\n<img src=\"/foundry-fund-me/7-forked-tests/forked1.png\" style=\"width: 100%; height: auto;\">\n\n### Balanced Approach: Unit Test, Integration Test, Forked and Staging Test\n\nWhile we tackle and solve the problems at hand, it’s essential to remember that we are learning to maneuver around four main testing approaches. In the journey with FundMe, we will navigate primarily through Unit, Integration, and Forked tests.\n\n1. Unit test - A method of testing a particular code piece or function. In this case, we could argue that `getVersion` function was a unit test.\n2. Integration test - Multi-contract testing to ensure that all interrelated contracts effectively work together.\n3. Fork test - Testing our code in a simulated real environment.\n4. Staging test - Deploying our code to a real environment like testnet or mainnet to validate that everything indeed works as it should.\n\nEach of these tests has its strengths, weaknesses, and ideal usage instances. For instance, maintaining a balance between the number of fork tests versus standard tests is crucial to not overdo API calls to your alchemy node and sending your bill through the roof.\n\n### Conclusion\n\nTesting forms the backbone of the code we write and deploy. It is crucial to comprehend the need for testing coverage for our codes. Writing an extensive set of tests and achieving maximum test coverage lets us confidently deploy our contract to perform as expected.\n\nEnsuring a good level of coverage across the board, unit tests, integration tests, fork tests, and staging tests, can sometimes seem overwhelming. However, the more one works with it, the clearer it seems. I promise you, it's only a matter of learning, doing, and repeating.\n\n<img src=\"/foundry-fund-me/7-forked-tests/forked2.png\" style=\"width: 100%; height: auto;\">\n",
          "updates": []
        },
        {
          "lessonId": "a2e5eb2f-09d0-46c2-833a-26becd480103",
          "number": 8,
          "title": "Refactoring your tests",
          "slug": "refactoring-testing",
          "folderName": "8-refactoring-testing",
          "description": "Guide on refactoring tests for better efficiency and clarity, including updating price converter functions and deploying contracts on different networks with ease.",
          "duration": 8,
          "videoUrl": "bhIb0Jf2qRk",
          "rawMarkdownUrl": "/routes/foundry/2-foundry-fund-me/8-refactoring-testing/+page.md",
          "markdownContent": "---\ntitle: Refactoring I - Testing Deploy Scripts\n---\n\n_Follow along the course with this video._\n\n\n\n---\n\nDid you know that the way you code your smart contracts could cause unnecessary work if you intend to switch chains? Many developers, particularly those familiar with the Solidity development suite, have found themselves enslaved by hardcoded contracts. Sure, they might work perfectly for Sepolia (the current chain of deployment) but they are incredibly restrictive for future use.\n\nWhat happens when you need to switch chains? A total overhaul of your code base, strenuous updates to all the addresses involved...it could take a lot of time and effort to get everything working correctly. In this lesson, we're going to explore an alternative approach to deploying smart contracts. We want to say goodbye to hardcoding and maintenance chaos, and say hello to _modular deployments_.\n\nThis reframed approach to deployment allows us to reference addresses and external systems dynamically. This means that we could potentially move our contracts from network to network with ease. Sure, it will require some refactoring, but in the end, it's going to make our lives a lot easier.\n\n## Refactoring Your Core Code\n\nLet's dive into our core code and decouple its dependency on Sepolia.\n\nTo avoid hardcoding the address of the contract, we're going to pass it as a constructor parameter each time we deploy the contract.\n\nHere's how we can achieve this:\n\n```js\nconstructor(address priceFeed) {\n    s_priceFeed = AggregatorV3Interface(priceFeed);\n}\n```\n\nThis approach means we can adjust the address to match the network we're currently using for deployment. This refactor is essentially reworking the architecture of the code without altering its functionality. It’s a crucial practice among engineers to keep their code maintainable. The addition of a new aggregator interface variable in the state and storage variables, s_priceFeed, provides a place where the address can live after it's passed into the constructor.\n\nThis makes it much easier to reference, especially when we want to deploy on different chains. With this refactor, you're no longer hard-coding the address and can instead call the version function directly on your price feed variable.\n\n```js\nreturn s_priceFeed.version();\n```\n\n## Updating The Price Converter\n\nWe also need to update our price conversion functions to accept an additional parameter: the price feed address passed during deployment.\n\n```js\nfunction getPrice(AggregatorV3Interface priceFeed) internal view returns (uint256){\n    (,int256 answer,,,) = priceFeed.latestRoundData();\n    return uint256(answer * 10000000000);\n}\n\nfunction getConversionRate(uint256 ethAmount, AggregatorV3Interface priceFeed) internal view returns (uint256){\n    uint256 ethPrice = getPrice(priceFeed);\n    uint256 ethAMountInUsd (ethPrice * ethAmount) / 1000000000000000000;\n    return ethAMountInUsd;\n}\n```\n\nWithin these functions, we simply replaced the hardcoded price feed object with the one passed into the function.\n\nHaving a modular approach to deployment makes it possible to deploy contracts to different networks easily, explore different testing environments, and maintain a maintainable and less error-prone code base throughout.\n\n## All's Well That Deploys Well\n\nBy exploring modular deployments, we've been able to overhaul our code architecture and streamline the deployment and testing of our smart contracts across different chains more efficiently.\n\nHowever, refactoring is not without challenges. The modifying of the funder address in our test case from address(this) to msg.sender caused an initial hiccup upon testing. After fixing this, our tests passed.\n\n<img src=\"/foundry-fund-me/8-refactor/refactor1.png\" style=\"width: 100%; height: auto;\">\n\nThe ability to refactor your code for a more flexible, modular deployment system is a skillset that sets you apart from the average solidity developer. There's a bit of a learning curve, but the payoff is enormous both in terms of versatility and maintainability.\n\nSo great job on making it this far. I'm excited for you as you continue to expand your developer toolkit!\n\nNow go out, experiment, refactor, test, and innovate. The world of solidity development is at your fingertips.\n",
          "updates": []
        },
        {
          "lessonId": "39383e0f-19f1-4ba0-a1e7-56daebb424f0",
          "number": 9,
          "title": "Deploy a mock priceFeed",
          "slug": "refactoring-helper",
          "folderName": "9-refactoring-helper",
          "description": "Detailed guide on setting up a mocked environment for local testing of blockchain smart contracts, emphasizing the benefits and steps for creating mock contracts.",
          "duration": 14,
          "videoUrl": "YqnxsefqO5A",
          "rawMarkdownUrl": "/routes/foundry/2-foundry-fund-me/9-refactoring-helper/+page.md",
          "markdownContent": "---\ntitle: Refactoring II - Helper Config\n---\n\n_Follow along the course with this video._\n\n\n\n---\n\nWhen building and testing your blockchain, you've likely found yourself often making calls to your Alchemy node. Furthermore, you may have noticed the undesirable outcome of this, running up your bill with each test suite execution. So, how can you streamline this process for local development and eliminate redundant API calls to Alchemy? The answer lies in creating mock contracts on your local chain.\n\nIn this blog, we'll detail how to set up a mocked environment for local testing and bypass the need to hard-code addresses, while ensuring the functionality remains undisturbed.\n\n### The Importance of Local Testing\n\nBefore we dive into the code, let's emphasize why this practice is so beneficial. By creating a local testing environment, you reduce your chances of breaking anything in the refactoring process, as you can test all changes before they go live. No more hardcoding of addresses and no more failures when you try to run a test without a forked chain. As a powerful yet simple tool, a mock contract allows you to simulate the behavior of a real contract without the need to interact with a live blockchain.\n\n### Creating the Mock Contract\n\nLet's start by creating a new contract called `HelperConfig.s.sol`. This contract serves two main purposes:\n\n1. It deploys mocks when we're on a local anvil chain\n2. Maintains track of contract addresses across various chains\n\n```js\n\nimport {Script} from \"forge-stf/Scripts.sol\"\n\ncontract HelperConfig {}\n```\n\nNow, you'll notice `forge-stf/Scripts.sol` being imported at the start of this contract. This helps us determine whether we're in a local anvil chain so that we can deploy the mock contracts accordingly. Similarly, we keep a tab on contract addresses depending on the chain we're on with the aid of address tracking logic.\n\n### Developing Specific Network Configurations\n\nNext, let's create functions `getSapoliaEthConfig` and `getAnvilEthConfig` that return configurations for the respective chains.\n\n```javascript\n\n    NetworkConfig public activeNetworkConfig;\n\n    function getSepoliaEthConfig() public pure returns (NetworkConfig memory) {\n        NetworkConfig memory sepoliaConfig = NetworkConfig(address);\n        return sepoliaConfig;\n    }\n    function getAnvilEthConfig() public pure returns (NetworkConfig memory) {NetworkConfig memory config = NetworkConfig(address);// other logicreturn config;}\n```\n\nIn this way, you can create multiple network configurations quickly.\n\nHowever, the main challenge arises when you have to decide which configuration to use. For that, we'll create a public variable `activeNetworkConfig`, which gives us an insight into the current network type. Based on the network type, we can set the `activeNetworkConfig` and make our tests much more flexible.\n\n```javascript\nif (block.chainId == 11155111) {\n  activeNetworkConfig = getSepoliaEthConfig();\n} else {\n  activeNetworkConfig = getAnvilEthConfig();\n}\n```\n\nNote that the `block.chainId` equals `11155111` is the specific chain ID for the Sapolia chain. For each chain, you can find their respective IDs using this [chainlist](https://chainlist.org).\n\n### Toward More Effective Testing\n\nWith such an architecture in place, you can now test against a forked Mainnet or any other blockchain you choose to deploy. Import your `HelperConfig` in the test files and set the `activeNetworkConfig` at the beginning of every test suite.\n\n```javascript\n   import HelperConfig from 'HelperConfig.s.sol';\n   HelperConfig helperConfig = new HelperConfig;\n   // then get the price feed address\n   address ethUsdPriceFeed = helperConfig.activeNetworkConfig.priceFeed;\n```\n\nThis setup enables you to check your code against different chains without having to hard-code any addresses.\n\nJust remember to define a new `NetworkConfig` type for every chain you want to test against, and you're good to go.\n\nFor example, if you want to deploy on the Ethereum Mainnet, you can define a dedicated function to get the mainnet's ETH config.\n\n```javascript\n    function getMainnetEthConfig() public pure returns (NetworkConfig memory) {\n        NetworkConfig memory config = NetworkConfig(address);// other logic\n        return config;\n    }\n```\n\nAnd in your constructor, add a new condition to check if the current chain is the Ethereum Mainnet.\n\n```javascript\n   else if (block.chainId == 1) {activeNetworkConfig = getMainnetETHConfig;}\n```\n\nThis modularity ensures that you can run your tests on any chain, simply adding additional network configuration as necessary. Run `forge test, fork URL, mainnetrpcURL`, and get to testing on the Ethereum Mainnet right away.\n\n### Conclusion\n\nIn conclusion, mock contracts are a valuable asset for local development. They enable you to test and refine your contract without the need for constant calls to your Alchemy node, saving you valuable time and resources. Plus, having a well-structured way to manage different configurations for different networks makes running tests and deploying on different chains a breeze.\n\n<img src=\"/foundry-fund-me/9-config/config1.png\" style=\"width: 100%; height: auto;\">\n\nAs we've highlighted here, each blockchain development project can be optimized with a few simple steps. As long as you're armed with the knowledge of your chain's ID and the addresses you need, you can create a local testing environment that aids you in creating a well-structured, efficient, and robust product.\n",
          "updates": []
        },
        {
          "lessonId": "fd09e9da-514c-4146-863d-a9a9659c8c76",
          "number": 10,
          "title": "Refactoring the mock smart contract",
          "slug": "refactoring-mocks",
          "folderName": "10-refactoring-mocks",
          "description": "Comprehensive guide on refactoring mock smart contracts for local network testing, including deploying mock price feed contracts and overcoming common errors.",
          "duration": 5,
          "videoUrl": "7iHW8Ro_eog",
          "rawMarkdownUrl": "/routes/foundry/2-foundry-fund-me/10-refactoring-mocks/+page.md",
          "markdownContent": "---\ntitle: Refactoring II - Mocks\n---\n\n_Follow along the course with this video._\n\n\n\n---\n\nLet's deep-dive into how we can adapt our existing environment, where we grab contract addresses from the live network, to our local network which does not yet have these contracts. For this, we will use the 'anvil config.'\n\nBut before we proceed, a key clarification: a **mock contract** is akin to a placeholder - it's a real contract that we control, but its primary purpose is in testing scenarios. This means, in the context of a local blockchain, we need to deploy these mock contracts manually.\n\n## Broadcasting the Deployment of Mock Contracts with VM\n\nNow, the first step in this journey is to initialize the process for deploying our contracts. Let's take it in stride.\n\nWe'll kick off by incorporating the VM start and stop broadcast within our implementation. These provisions ensure we can deploy the mock contracts to the Anvil chain we're working with:\n\n```javascript\nVM.startBroadcast(); //Block for deploying mock contractsVM.stopBroadcast();\n```\n\nRemember, since we're using this VM keyword, we can't configure this as a public pure and the helper config must be a script to have access to the VM keyword.\n\n## Deploying Price Feed Mock Contract\n\nMoving on, let's delve into deploying our price feed mock contract:\n\n<img src=\"/foundry-fund-me/10-mocks/mocks1.png\" style=\"width: 100%; height: auto;\">\n\nFirst, create a new folder within the test called 'mocks' to store our mock contracts. Then create a new file and name it 'mockv3aggregator.sol.'\n\nInstead of building this file from scratch, reuse the existing mock version already available on chainlink's brownie contracts. But beware, it uses an older version (0.6.0) of Solidity. To save time, fetch the upgraded version from the 'Foundry FundMe F 23' folder:\n\n```shell\ncd FoundryFundMeF23/testFolder\n```\n\nThen copy and paste the content into your project.\n\nThis mock contract contains functions like 'latest round data,' which one might remember from our price converter. Moreover, its constructor allows updates and manipulation during testing, making it perfect for our local Anvil Chain. Now, we have all the necessary provisions to deploy.\n\n```javascript\nimport mockv3aggregator from \"mocks/test/mocks/MockV3Aggregator.sol\";\nmockv3aggregator mockPriceFeed = new mockv3aggregator(8, 2000e8);\n```\n\nThe constructor, as seen in the mock contract, requires decimals (in our case, for ETH/USD, it's 8), and an initial answer, which could be any desired starting price (say, 2000).\n\nAfter deploying our mockPriceFeed contract, the resulting address can be allocated to the network config of the Anvil chain:\n\n```javascript\nnetworkConfig memory anvilConfig = networkConfig(priceFeed: address(mockPriceFeed));\nreturn anvilConfig;\n```\n\nWith this, we've set the stage for deploying your smart contracts and running your tests on a local network. We've seen how to configure and use a mock contract for the price feed, adapting it to our local Anvil chain. These steps can also be applied to deploy any other mock contracts as per your development and testing needs.\n\nStay tuned for more such exciting DevOps adventures with Ethereum, Solidity, and smart contracts!\n",
          "updates": []
        },
        {
          "lessonId": "99094676-7af8-4cce-920e-c1b002502841",
          "number": 11,
          "title": "How to refactor magic number",
          "slug": "magic-numbers",
          "folderName": "11-magic-numbers",
          "description": "Explanation of the concept of magic numbers in Solidity code, their drawbacks, and strategies for avoiding them to maintain code readability and efficiency.",
          "duration": 3,
          "videoUrl": "EQUjA_xM2C8",
          "rawMarkdownUrl": "/routes/foundry/2-foundry-fund-me/11-magic-numbers/+page.md",
          "markdownContent": "---\ntitle: Magic Numbers\n---\n\n_Follow along the course with this video._\n\n\n\n---\n\nWhen diving into the detailed layers of Solidity development, one principle that I keep circling back to is the avoidance of 'magic numbers'. A term that may sound relatively cryptic or even partially endearing, 'magic numbers' actually refer to something quite mundane that can turn out to be enormously inconvenient when dealing with large blocks of code.\n\nHaving repeatedly voiced my intense disdain for magic numbers, I am more than ready to dissect and debunk these pests for you.\n\n## Decoding Magic Numbers\n\nTo be concise, magic numbers are the esoteric, context-less figures that appear within a chunk of code, unrelated to anything else and devoid of any conspicuous significance. Let's illustrate this with an example:\n\n```js\nuint8 public constant DECIMALS = 8;\nint256 public constant INITIAL_PRICE = 2000E8;\n\n\n```\n\nHere, with the number `8` and `2000 E8` dropping in out of nowhere, it's virtually impossible to infer what these numbers represent if you haven't seen the code for a while. This might not seem like much of an issue in this small snippet, but when you're dealing with substantial amounts of code, these magic numbers become an exasperating hindrance.\n\nTo resolve this mystery, you would have to go back to the aggregator – in our case, Mach V3 – and decipher the coding behind these numbers. This becomes tiring and can slow your coding pace considerably.\n\n<img src=\"/foundry-fund-me/11-magic-numbers/magic1.png\" style=\"width: 100%; height: auto;\">\n\nIt's worth noting that my advocacy for avoid magic numbers transcends practicality. Even during audit reports and smart contract audits, I make it a point to highlight such areas for improvement. Maintaining code readability is a critical aspect of efficient coding, which resonates across any language, including Solidity.\n\n## Conclusion\n\nIn conclusion, maintaining readable, explicit and efficient code should always be the goal. Striving to keep magic numbers at bay can significantly contribute towards this endeavor. After all, software development is more an art than a science, and the devil, as they say, is in the details.\n\n<img src=\"/foundry-fund-me/11-magic-numbers/magic2.png\" style=\"width: 100%; height: auto;\">\n",
          "updates": []
        },
        {
          "lessonId": "b00a1337-d0fb-4fb6-a1ea-9df92b026e22",
          "number": 12,
          "title": "Refactoring the mock smart contract pt.2",
          "slug": "refactoring-mocks-2",
          "folderName": "12-refactoring-mocks-2",
          "description": "Continuation of the tutorial on refactoring mock contracts in Solidity, focusing on creating network-agnostic smart contracts for easy deployment across multiple networks.",
          "duration": 5,
          "videoUrl": "6HztoOIetAQ",
          "rawMarkdownUrl": "/routes/foundry/2-foundry-fund-me/12-refactoring-mocks-2/+page.md",
          "markdownContent": "---\ntitle: Refactoring III - Mocking (continued)\n---\n\n_Follow along with this video._\n\n\n\n---\n\nIn this lesson, we're going to examine a useful technique to create network-agnostic smart contracts. This practice can substantially aid in making your contracts more flexible and easily deployable across multiple networks.\n\n## Codifying the Process\n\nThe logic we'll use here revolves around accessing the ​’ActiveNetwork activenetworkconfig' - a price feed we've already established. In our scenario, the guiding condition is whether this feed equals the zero address or not. Here's the snippet of code, we'll focus on:\n\n```js\nif(activeNetworkConfig.priceFeed != address(0) {\n    return ActiveNetworkConfig;\n}\n```\n\nThis segment dictates that we check if the price feed has been initialized yet (i.e., equipped with an address not equal to address zero). If so, we have the green light to return and halt the running process, because no new deployment is needed.\n\n## Naming Conventions in Solidity\n\nAn issue with the function managing this operation is the naming convention; it doesn't clearly denote its duties. The function doesn't just \"get\" the configuration, it \"creates\" them as well. Therefore, \"getOrCreateAnvilETHConfig()\" is a more accurate and more descriptive name.\n\n<img src=\"/foundry-fund-me/12-refactoring-mocks2/refactor1.png\" style=\"width: 100%; height: auto;\">\n\nOnce we have edited this function and put the mechanism into action, we can observe that tests, which would previously fail due to a missing contract, now run without any hassle. This success is because the helper configuration deploys a 'pseudo' price feed which successfully responds to our requests.\n\n## Testing and Results\n\nThere's an exciting aspect of the testing process to mention too:\n\nTypically, if you're using chain forking, you need to perform an API call to fetch the most recent state of the forked chain. This process significantly slows down the operation. However, with our new function, we can bypass this step and dramatically expedite the testing process.\n\n<img src=\"/foundry-fund-me/12-refactoring-mocks2/refactor2.png\" style=\"width: 100%; height: auto;\">\n\nThis streamlined test represents a massive breakthrough, demonstrating how we've made the smart contract network agnostic — able to be deployed on any given network effortlessly.\n\n## Concluding Thoughts and a Job Well Done\n\nAs I always say, honing these skills will make you an absolute standout in the world of Solidity developers. Your understanding of network-agnostic techniques won't just make you a competent smart contract developer, but will elevate the industry standard for smart contract development.\n\nTo pat you all on the back, you've indeed learned something of massive significance here! However, the journey is far from over, and there's still much more to come.\n\nRemember, if any of this seems too much, make use of the course resources at hand and lean on the community forums for support. Your active participation will not only help you but will assist others as well.\n\nStay excited, keep learning, and I am looking forward to our next tutorial. Until then, happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "f7cb3eb9-2da0-4843-b0fb-d6db0a6db13e",
          "number": 13,
          "title": "Foundry tests cheatcodes",
          "slug": "foundr-tests-cheatcodes",
          "folderName": "13-more-cheatcodes",
          "description": "Guide on using Foundry tests cheat codes for efficient and effective testing of smart contracts, focusing on deployment strategies, code coverage, and test understanding.",
          "duration": 13,
          "videoUrl": "pDb8XDYM8w0",
          "rawMarkdownUrl": "/routes/foundry/2-foundry-fund-me/13-more-cheatcodes/+page.md",
          "markdownContent": "---\ntitle: More Cheatcodes\n---\n\n_Follow along with this video._\n\n\n\n---\n\nHello, and welcome back to our advanced blockchain coding series. I hope you've taken a little break, as resting periods especially early in the course- are essential for grasping the plethora of advanced pieces of the blockchain puzzle we're working on.\n\nHere’s a gentle reminder: Spread the course over several days, not a single day. As the saying goes, repetition is the mother of skill; for skill acquisition to be successful, rests are necessary for the body to recuperate.\n\nHaving learned a great deal, we're sailing and doing fantastic.\n\n## Deployment Strategy: FundMe\n\nDid you know you can deploy **FundMe** on any chain with our setup helper config? Isn't it amazing? This feature permits the freedom of focusing solely on writing our tests in any network, with the assurance of our deployment setup working just perfectly.\n\n## Prioritizing Code Coverage\n\nWe emphasize the importance of code coverage throughout the course. Nevertheless, it isn't an end-all. For instance, you should continue coding if you don't attain 100% coverage. However, a figure beneath 10% doesn't spell well either.\n\nLet me provide a perspective: Without testing, there's a high probability of functional errors. Consequently, strive to write tests for as much code as is possible to allow the assurance that our code is indeed functioning as desired.\n\nLet's delve directly into coding using our function, `fund`. The code snippet should look like this:\n\n```js\nfunction testFundFailsWithoutEnoughETH() public {\n  vm.expectRevert(); //the next line should revert\n  // assert(This tx fails/reverts)\n  uint256 cat = 1;\n}\n```\n\n<img src=\"/foundry-fund-me/13-cheatcodes/cheatcode1.png\" style=\"width: 100%; height: auto;\">\n\nThe function checks whether sending insufficient Ether will cause our contract to revert. If you run this code, you will note that it reverts as expected and thus passes the test. Furthermore, it checks that `FundMe.fails` when there is insufficient Ethereum sent, once again illustrating a successful test.\n\n## Honing Your Understanding of Fund Functionality\n\nTo further test our fund function, let's now consider instances where sufficient Ether has been sent:\n\n```js\nfunction testFundUpdatesFundedDataStructure() public {\n    fundMe.fund(value: 10e18);\n    uint256 amountFunded =fundMe.getAddressToAmountFunded(msg.sender);\n    assertEq(amountFunded, 10e18);\n}\n```\n\nThe function above tests whether sending sufficient Ether (more than $5) updates the data structures correctly. This function accesses the contract data that was previously marked as private. This can be achieved by using getter functions, such as `getContractBalance`, instead of accessing the variables directly. This makes the code more readable, secure and efficient.\n\n## The Wrap\n\nCongratulations on completing this part of the course, it's indeed taken significant effort, and you are making progress! Code testing and understanding how it integrates with complex chains is an essential part of mastering advanced blockchain coding. Don't worry about the number of tests conducted; remember that the key is to understand and apply the concepts learned in code coverage.\n\nRemember to keep practicing and reworking the code until you fully understand how it functions. Good luck with your test and happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "5f0631d9-6492-4995-8c79-431140cb12b5",
          "number": 14,
          "title": "Adding more coverage to the tests",
          "slug": "more-coverage",
          "folderName": "14-more-coverage",
          "description": "This lesson delves into advanced Solidity unit testing techniques. It includes writing robust tests for the 'getFunder' function and testing the contract owner's withdrawal function using the Arrange-Act-Assert methodology. The lesson aims to strengthen your code backend, making it almost bulletproof.",
          "duration": 15,
          "videoUrl": "IPgBsxL-SkE",
          "rawMarkdownUrl": "/routes/foundry/2-foundry-fund-me/14-more-coverage/+page.md",
          "markdownContent": "---\ntitle: More Coverage\n---\n\n_Follow along with this video._\n\n\n\n---\n\nLet's delve deeper into Solidity unit testing by testing how our function adds funder to an array of funders. In the following guideline, we'll walk through writing solid unit tests that will make your code backend almost bulletproof.\n\n## Start with a Simple Test\n\nStep one involves writing a simple test to ensure our newly created 'getFunder' function works properly. Here is what your code may look like:\n\n```js\n function testAddsFunderToArrayOfFunders() public {\n        vm.startPrank(USER);\n        fundMe.fund{value: SEND_VALUE}();\n        vm.stopPrank();\n\n        address funder = fundMe.getFunder(0);\n        assertEq(funder, USER);\n    }\n```\n\nThe next step is running the test. You can use any test commands that are already set up on your server, such as `clear forge test` or `paste`. If all is well, proceed to the next step.\n\nTo ensure our data structure is updated correctly, multiple tests with multiple funders can be added. However, for this tutorial, we will settle for our successful single user test run.\n\n## Test the Owner's Withdrawal Function\n\nThe next step is to test our smart contract's owner withdrawal function. Only the owner should be able to call the withdrawal function. Here's a simple way to do that:\n\n```js\n function testOnlyOwnerCanWithdraw() public funded {\n        vm.expectRevert();\n        fundMe.withdraw();\n    }\n```\n\nThe above test ensures that when a non-owner tries to withdraw, the function reverts.\n\n<img src=\"/foundry-fund-me/14-coverage/coverage1.png\" style=\"width: 100%; height: auto;\">\n\n## Arrange-Act-Assert Testing Methodology\n\nThe arrange-act-assert (AAA) pattern is one of the simplest and most universally accepted ways to write tests. As the name suggests, it comprises three parts:\n\n1. **Arrange**: Set up the test by initializing variables, objects and prepping preconditions.\n2. **Act**: Perform the operation to be tested like a function invocation.\n3. **Assert**: Compare the received output with the expected output.\n\nHere is how the AAA methodology fits into our unit testing:\n\n```js\n  function testWithdrawFromASingleFunder() public funded {\n        // Arrange\n        uint256 startingFundMeBalance = address(fundMe).balance;\n        uint256 startingOwnerBalance = fundMe.getOwner().balance;\n\n        // vm.txGasPrice(GAS_PRICE);\n        // uint256 gasStart = gasleft();\n        // // Act\n        vm.startPrank(fundMe.getOwner());\n        fundMe.withdraw();\n        vm.stopPrank();\n\n        // uint256 gasEnd = gasleft();\n        // uint256 gasUsed = (gasStart - gasEnd) * tx.gasprice;\n\n        // Assert\n        uint256 endingFundMeBalance = address(fundMe).balance;\n        uint256 endingOwnerBalance = fundMe.getOwner().balance;\n        assertEq(endingFundMeBalance, 0);\n        assertEq(\n            startingFundMeBalance + startingOwnerBalance,\n            endingOwnerBalance // + gasUsed\n        );\n    }\n\n```\n\n## Testing Withdrawals from Multiple Funders\n\nThe final test in our array of tests will check for withdrawals from multiple funders. This more complex functionality requires us to fund the contract from multiple sources, then check the balances and withdrawal process:\n\n```js\nfunction testWithDrawFromMultipleFunders() public funded {\n        uint160 numberOfFunders = 10;\n        uint160 startingFunderIndex = 2;\n        for (uint160 i = startingFunderIndex; i < numberOfFunders + startingFunderIndex; i++) {\n            // we get hoax from stdcheats\n            // prank + deal\n            hoax(address(i), STARTING_USER_BALANCE);\n            fundMe.fund{value: SEND_VALUE}();\n        }\n\n        uint256 startingFundMeBalance = address(fundMe).balance;\n        uint256 startingOwnerBalance = fundMe.getOwner().balance;\n\n        vm.startPrank(fundMe.getOwner());\n        fundMe.withdraw();\n        vm.stopPrank();\n\n        assert(address(fundMe).balance == 0);\n        assert(startingFundMeBalance + startingOwnerBalance == fundMe.getOwner().balance);\n        assert((numberOfFunders + 1) * SEND_VALUE == fundMe.getOwner().balance - startingOwnerBalance);\n    }\n\n```\n\nAfter writing all your tests, it is good practice to test the coverage of your contracts.\n\nCongratulations, you have successfully learned how to write detailed and thorough tests for your smart contracts in Solidity!\n",
          "updates": []
        },
        {
          "lessonId": "6761590e-d73c-4e18-a19d-730f5b666548",
          "number": 15,
          "title": "Introduction to Foundry Chisel",
          "slug": "introduction-to-foundry-chisel",
          "folderName": "15-chisel",
          "description": "This lesson introduces Chisel, a tool for testing and debugging Solidity code directly in the terminal. It covers the basics of using Chisel, including launching the interactive shell, executing Solidity code, and exploring its functionalities. The lesson is a step-by-step guide to efficient Solidity testing.",
          "duration": 2,
          "videoUrl": "Qfac2hZ3ywA",
          "rawMarkdownUrl": "/routes/foundry/2-foundry-fund-me/15-chisel/+page.md",
          "markdownContent": "---\ntitle: Chisel\n---\n\n_Follow along with this video._\n\n\n\n---\n\n## An Introduction to Chisel\n\nTypically, if we want to rapidly test a snippet of solidity code, we'd navigate over to Remix, an online compiler for Solidity programming language. However, with Chisel, we can directly test Solidity in our terminal swiftly and efficiently. This is a step-by-step guide on how to use Chisel for testing lines of code or debugging our tests.\n\n**Step 1: Launching Chisel**\n\nIt's as simple as typing in the command `chisel` in the terminal. The terminal instantly turns into an interactive shell where we can start testing our solidity code.\n\n```\nchisel\n```\n\n**Step 2: Exploring Chisel**\n\nIf you're unsure about what you can accomplish in this newly opened chisel shell, simply type in `!help`. The terminal will provide a wealth of information relevant to the command line's functionalities.\n\n```\n!help\n```\n\nThis step is not mandatory, but it's handy when you're new to Chisel and want to explore its range of capabilities.\n\n<img src=\"/foundry-fund-me/15-chisel/chisel1.png\" style=\"width: 100%; height: auto;\">\n\n## Writing Solidity with Chisel\n\nChisel allows us to write Solidity directly into our terminal and execute it line by line. Here's an example:\n\n```bash\nuint256 cat = 1;\ncat\n```\n\n<img src=\"/foundry-fund-me/15-chisel/chisel2.png\" style=\"width: 70%; height: auto;\">\n\nThis simplistic code creates a variable `cat` and assigns it a value of `1`. When `cat` is called, the program echoes out `1` as the output.\n\nContinuing with the example, we can perform simple operations too:\n\n```bash\nuint256 catAndThree = cat + 3;\ncatAndThree\n```\n\nThis block creates a new variable `cat_n_three` and assigns it the value of `cat` plus 3. The resultant output when called will be `4`.\n\n<img src=\"/foundry-fund-me/15-chisel/chisel3.png\" style=\"width: 70%; height: auto;\">\n\nThis simplistic yet powerful interaction is what makes Chisel such a powerful tool for debugging and testing small pieces of Solidity code.\n\n<img src=\"/foundry-fund-me/15-chisel/chisel4.png\" style=\"width: 100%; height: auto;\">\n\n## Exiting Chisel\n\nOnce you're done with your session, exiting from this Solidity testing environment is as straightforward as getting into it. Simply type `Control` + `C` to end the chisel session and return to your regular terminal.\n\n```\nControl + C\n```\n\nAll in all, Chisel redefines convenience, offering us a command-line interface to write, test, and debug Solidity. With this exceptional tool, you don't need to toggle between platforms to ensure your code runs smoothly—everything can be done right from the comfort of your terminal. Happy debugging!\n",
          "updates": []
        },
        {
          "lessonId": "b2817d50-67f7-49b7-826c-67021453f75c",
          "number": 16,
          "title": "Calculate Withdraw gas costs",
          "slug": "calculate-solidity-function-gas-costs",
          "folderName": "16-cheaper-withdraw",
          "description": "This lesson focuses on reducing gas consumption in Ethereum smart contracts. It explains how to evaluate gas costs, understand Anvil's zero gas-price, and utilize Solidity's built-in functions to optimize gas usage. The goal is to make contract execution more economical.",
          "duration": 5,
          "videoUrl": "TtEdnlZ2NSc",
          "rawMarkdownUrl": "/routes/foundry/2-foundry-fund-me/16-cheaper-withdraw/+page.md",
          "markdownContent": "---\ntitle: Cheaper Withdraw\n---\n\n_Follow along with this video._\n\n\n\n---\n\nHello folks, let's turn our attention to an absolutely interesting aspect of Ethereum smart contracts - Gas. I'm going to show you the smart way of reducing the amount of gas you spend on executing your smart contracts, which turns out to be a beneficial piece of information, right? As most of us know, Ethereum gas is the fuel spent for every transaction we conduct or deploy on the blockchain. The more complicated our contract gets, the more gas we'll have to shell out. But what if there's a way to make this more economical?\n\n## Evaluating the Gas-cost Benchmark\n\nHow do you even figure out how much gas a transaction will cost you? For instance, let's consider a test for `withdraw` from multiple funders. What we can do is run `forge snapshot -m`, against this test. This call prompts the creation of a handy file named `Gas Snapshot`, which will reveal the exact amount of gas that this specific test will consume.\n\n**Tip:** You can convert between gas and Ether prices to ascertain how much this gas consumption will financially impact you. Optimization begins with identifying your current spending!\n\nWhat we did above is merely to establish a benchmark for our testing, i.e., our `withdraw` from multiple funders costs us so much gas.\n\n## Understanding Anvil's Zero Gas-price\n\nWhile working with Anvil local chains - forked or otherwise - the gas price defaults to zero. So, if we invoke a transaction - say `vm.prank(fundMe.getOwner())`, it should ideally cost us some gas. But when we calculate the final balance (or 'ending owner balance'), gas cost doesn't figure into it, thanks to Anvil's zero gas price. To simulate credible gas prices and consequently, real-world transaction costs, we turn to the helpful cheat code `TX gas price`, which standardizes the gas price for our transaction.\n\n```js\nuint256 constant GAS_PRICE = 1;\n```\n\n## Calculating Actual Gas Usage\n\nIn order to visualize the gas usage, we can leverage Solidity's built-in function `gas left()`. This calculates the remaining gas from a transaction after execution.\n\n```js\nuint256 gasStart = gasleft();\n```\n\nWe can repeat this process with `dash vv` and it will show us how much gas was actually expended in this particular transaction.\n\n## Making Gas Usage Cheaper\n\nNow that we have our gas snapshot and its holistic understanding, the question remains, can we make this cheaper? Yes, we absolutely can and this is where Ethereum's data location - storage - steps in. Long story short, data written in storage is expensive while reading from storage is free. Hence, using storage effectively could significantly reduce your gas usage and consequently, your transaction cost.\n\nStay tuned as we delve into the world of Ethereum storage optimization in the upcoming posts.\n",
          "updates": []
        },
        {
          "lessonId": "fe0f8efa-c582-4a5c-89d3-363fa12e9010",
          "number": 17,
          "title": "Introduction to Storage optimization",
          "slug": "solidity-storage-optimization",
          "folderName": "17-storage",
          "description": "In this lesson, you'll learn about optimizing Ethereum smart contract storage to reduce gas consumption. It covers storage variables, their impact on gas usage, and how to efficiently use storage and memory in Solidity. The lesson also includes practical examples using Anvil.",
          "duration": 10,
          "videoUrl": "8LAeGgkkoYw",
          "rawMarkdownUrl": "/routes/foundry/2-foundry-fund-me/17-storage/+page.md",
          "markdownContent": "---\ntitle: Storage\n---\n\n_Follow along with this video._\n\n\n\n---\n\n## A Look into Ethereum Gas Optimization\n\nIn pursuit of deciphering Ethereum smart contract storage, we need to address gas optimization. The term `gas` refers to the computational efforts needed to execute operations in the Ethereum virtual machine.\n\nNow, let's explore our contract variables and understand how they consume gas.\n\n<img src=\"/foundry-fund-me/17-storage/storage1.png\" style=\"width: 100%; height: auto;\">\n\nIn one of the [freeCodeCamp videos](https://youtu.be/gyMwXuJrbJQ), a simple contract with global variables is analyzed. The objective here is to make our contract more gas-efficient by examining storage variables.\n\n## Breaking Down Storage Variables\n\nStorage variables, also known as state variables or global variables, play a crucial role in our contract's gas usage. These variables are persistent, meaning they retain their values between function calls.\n\nWhen we declare a variable in our contract, this variable gets allotted a spot in storage. It's helpful to visualize storage as a giant, numbered array, where each element comprises a `storage slot` of 32 bytes.\n\nEvery time we add a global variable, it takes up a new slot in this storage array. In the case of dynamic values such as arrays or mappings, these are managed using a hashing function whose specifics can lay hold of in the Solidity documentation.\n\n<img src=\"/foundry-fund-me/17-storage/storage2.png\" style=\"width: 100%; height: auto;\">\n\n## Arrays and Mappings\n\nFor a better grasp, consider a dynamic array named `myArray`. The array length is stored at the array's storage slot, not the entire array.\n\n```js\nmyArray.push(222);\n```\n\nWhen we add an element to the array, it is stored at a specific location based on the aforementioned hashing function.\n\nHow about mappings? Common to arrays, Solidity assigns a storage slot for each mapping. Should the slot be empty, Solidity earmarks it for the mapping's hashing function.\n\nNow, you may wonder, how does Solidity handle constant and immutable variables? As it turns out, it doesn't store these variables. Instead, these variables become part of the bytecode of the contract. Consequently, the variables do not occupy space in the storage.\n\n## Local Variables and Memory Keyword\n\nIn contrast, variables declared within a function do not persist. Once the function finishes running, these variables are discarded. These are stored in a separate memory data structure.\n\nHere, we unearth why we often use the `memory` keyword, especially for strings.\n\n```js\nfunction getString() public pure returns (string memory) {return \"Hello, World!\";}\n```\n\nStrings, at their core, are dynamically sized arrays. Through `memory`, we instruct Solidity to allocate space for the string in the memory location, destined for deletion after usage.\n\n## Exploring Storage with Anvil\n\nAnvil offers an interesting way to inspect the storage of a Solidity contract. Using the command `forge inspect FundMe storageLayout`, we can inspect the storage layout of our contract.\n\nAnother way is through `Cast storage <contract_address> <index>` command. This way, you can fetch the content of a certain storage slot in your contract.\n\n<img src=\"/foundry-fund-me/17-storage/storage3.png\" style=\"width: 100%; height: auto;\">\n\n)## On Blockchain Privacy\n\nLastly, even though we can declare variables as `private` in Solidity, the data isn't truly private. Due to the public nature of blockchains, anyone can read that information off of your or anybody's blockchain.\n\nIn conclusion, understanding how storage works within Ethereum smart contracts is a vital skill for a successful Solidity developer. It helps us write more efficient contracts and enable more cost-effective operations within the Ethereum ecosystem.\n",
          "updates": []
        },
        {
          "lessonId": "f3f4f5a4-ab08-4325-a072-eb9af95ca859",
          "number": 18,
          "title": "Optimise the withdraw function gas costs",
          "slug": "optimise-solidity-function-gas-costs",
          "folderName": "18-cheaper-withdraw-ii",
          "description": "This advanced lesson teaches how to optimize the 'withdraw' function in smart contracts for lower gas costs. It discusses bytecode analysis, storage and memory operations, and practical code changes to reduce gas usage. The lesson includes a comparative analysis of gas usage before and after optimization.",
          "duration": 8,
          "videoUrl": "ST_4j4vsadk",
          "rawMarkdownUrl": "/routes/foundry/2-foundry-fund-me/18-cheaper-withdraw-ii/+page.md",
          "markdownContent": "---\ntitle: Cheaper Withdraw (Continued)\n---\n\n_Follow along with this video._\n\n\n\n---\n\nAs budding young developers navigating through the intricacies of gas optimization in Ethereum, the issue of storage is one area that arguably minces no words. Sure, it could appear all fancy and sophisticated if you squint your eyes at the right angle – but we have to ask ourselves: why all this fuss about storage?\n\nThe reason is hardly elusive: reading and writing from storage is an overwhelming expense on our tightly-strapped gas resources. Unpicking or compressing any data stored in it drains the gas faster than you can imagine.\n\nLet's delve into this a little deeper to help iron out the creases:\n\n## The Web of Bytecode:\n\nWhen you compile your solidity code, it gets whittled down to bytecode per se. This enigmatic-looking bytecode can be unhashed to find the correlation between gas consumption and how storage is utilized when your contract is running on the Ethereum Virtual Machine (EVM). For this, you could simply switch over to [Remix](https://remix.ethereum.org/), hit compile, navigate to the compilation details, and select bytecode.\n\nWhen we scroll down to the end, we'll uncover two vital entities: Object and Opcodes. The object is an intricate pattern of your contract in bytecode, and the Opcodes are simply the bytecode version translated into a rudimentary set of instructions. Each Opcode — the lowest level of computer language — tattoos specific gas costs on each operation it conducts; the costs quickly aggregate to a monumental sum when you perform an operation through EVM.\n\nWe scroll through the Opcodes and observe a pattern in gas costs – most of them like addition, multiplication, and division cost around two or three gas. And then, boom!\n\n<img src=\"/foundry-fund-me/18-cheaper-2/cheaper1.png\" style=\"width: 100%; height: auto;\">\n\n`SLOAD` is the Opcode that reads from storage, and it sets you back by a massive 100 gas. Similarly, S-store saves to storage, costing us the same gargantuan amount of gas. This instantly makes us realize the vast chasm of difference between storage and alternate operations, which usually cost just a few gas.\n\n## Aiming for Optimization:\n\nBut the conversation shouldn’t stop there. The dialogue around storage also goes beyond to unearth the possibility of a memory-load (M-load) and a memory-store (M-store) which cost just three gas each. We’re staring at a stark disproportion here: it’s almost 33 times more expensive to read and write from storage than it is to access memory. So, voila! The most straightforward initiative to optimizing gas is to perform read-write actions from memory, respecting the notion of expensive storage access.\n\nHaving keyed into this knowledge, we spring back to our FundMe contract’s withdrawal function. To dodge ransacking the holistic storage multiple times, we replace the subsequent reads with a prerecorded memory variable. We can quickly establish the new function for cheaper withdrawal. In this manner, we alter the looping process by initially reading from the storage just once and replace further iterated reads with a memory variable.\n\nThis yields the revised code:\n\n```js\nfunction cheaperWithdraw() public onlyOwner {\n        address[] memory funders = s_funders;\n        // mappings can't be in memory, sorry!\n        for (uint256 funderIndex = 0; funderIndex < funders.length; funderIndex++) {\n            address funder = funders[funderIndex];\n            s_addressToAmountFunded[funder] = 0;\n        }\n        s_funders = new address[](0);\n        // payable(msg.sender).transfer(address(this).balance);\n        (bool success,) = i_owner.call{value: address(this).balance}(\"\");\n        require(success);\n    }\n```\n\n## Comparative Testing and Results\n\nWith that code snippet fleshed out, we can simply copy and adapt our previous test function, amending the call to use 'cheaperWithdraw'. Next, we establish a gas snapshot to encapsulate all of our tests. This can be done with the `forge snapshot` command in the terminal. We can then compare the gas usage of the two functions: the original `withdraw` and the optimized `cheaperWithdraw`. Already, we can observe an improvement with an approximate saving of 800 gas.\n\n## Style Guidelines in Etherem Development\n\nThe brandishing of style guides in developmental structure is a cornerstone to efficient coding. While ensuring code readability, it also provides a recognizable attribution to certain key identifiers in a solidity code environment.\n\nIn the Chainlink style guide, for instance, immutable variables are prefixed with `i_` while storage variables bear `s_`. These prefixes act as signals to the coders about the nature of these variable and the subsequent gas costs associated with them. It provides an opportunity for developers to consider cheaper alternatives like memory variables over storage variables.\n\nThe [Solidity Documentation](https://docs.soliditylang.org/en/v0.8.4/style-guide.html) provides a comprehensive guide to code layout, function names, and more. Chainlink has its own style guide, which is linked to the GitHub repo for this article.\n\n## Wrapping Up\n\nThis blog was all about imparting the importance of optimizing storage access in order to conserve gas in contract execution. It’s crucial to adapt to these techniques early on in your career as a blockchain developer. The ability to identify and adapt constructs that optimize gas usage will undoubtedly enhance your proficiency in developing efficient, less costly smart contracts.\n\nRemember that while it might seem like a small gain in the beginning, these savings will aggregate into substantial saving when you’re dealing with larger scale operations. You've done great work today! It's time now to push this code up to your GitHub and celebrate your first smart contract project.\n",
          "updates": []
        },
        {
          "lessonId": "698e9f4a-490b-4d3d-a344-eec70c6c49e7",
          "number": 19,
          "title": "Create integration tests",
          "slug": "solidity-integration-tests",
          "folderName": "19-interactions",
          "description": "Explore the creation of integration tests for Solidity smart contracts. This lesson covers the setup and execution of integration tests, ensuring that contract functions interact correctly with other system parts. It includes practical examples and a guide for setting up a comprehensive test suite.",
          "duration": 15,
          "videoUrl": "5u02NBfV4PY",
          "rawMarkdownUrl": "/routes/foundry/2-foundry-fund-me/19-interactions/+page.md",
          "markdownContent": "---\ntitle: Interactions.s.sol\n---\n\n_Follow along with this video._\n\n\n\n---\n\n## Creating a Project README\n\nFirstly, you'd want to add a README.md file to your project in GitHub. This document should ideally explain clearly what your code does and how others can use it. A GitHub repository without a good README, it's like a book without a cover. Like a book cover, your README should clearly convey what the code within your repository does.\n\nHere's a suggested format for your README.\n\n- **Introduction:** Give a brief explanation of your project.\n- **Getting Started:** List the requirements for running your code.\n- **Quick Start**: Explain different commands and procedures to install and run your code.\n\n## Writing Integration Tests and Scripts\n\nOur steady progression brings us to the next crucial aspect, writing integration tests. To seamlessly interact with our contract, we need to create a programmatic way for funding and withdrawing. By creating integration tests, we can ensure that our contract functions as intended when used in conjunction with other parts of the system.\n\nLet's go through the process of creating a new test file named `Interactions.s.sol` under the `Script` section. We'll be dealing with two primary scripts here: `FundMe.sol` and `WithdrawFundMe.sol`.\n\nNow, let's consider a scenario where we want to fund our most recently deployed contract. For that purpose, we use a tool named Foundry DevOps. You can install it by simply running the following command in your terminal:\n\n```bash\nforge install ChainAccelOrf/foundry-devops --no-commit\n```\n\nIn your `Run` function, you can include the following lines of code to call the `FundFundMe` function:\n\n```javascript\n function fundFundMe(address mostRecentlyDeployed) public {\n        vm.startBroadcast();\n        FundMe(payable(mostRecentlyDeployed)).fund{value: SEND_VALUE}();\n        vm.stopBroadcast();\n        console.log(\"Funded FundMe with %s\", SEND_VALUE);\n    }\n\n```\n\n\"The DevOps tool `mostRecentlyDeployed` is remarkably efficient at retrieving the most recently deployed version of a contract. No more manual hassles!\"\n\nAfter setting up the `FundMe` contract, you should also set up the `WithdrawFundMe` contract in the same way. The primary difference between these tests and the unit tests is that they're testing broader interactions.\n\n## Running and Verifying Tests\n\nUpon setting up the interactions correctly, start running your tests with the `forge test` command.\n\n```bash\nforge test\n```\n\nSeparating your integration tests and unit tests into different folders enhances your project management workflow. For instance, transferring the `FundMeTest.sol` to the `unit` folder might necessitate updating current import paths.\n\nTo validate that your functions integrate and work properly, create an `InteractionsTest.sol`. Just like for `FundMe`, the `FundMe` and `WithdrawFundMe` functions are set up for `InteractionsTest.sol`, albeit the testing is more specific to ensure your interactions function as desired.\n\nBringing it all together, we've now created a comprehensive suite of unit and integration tests that accurately reflects whether your code will function as expected.\n\n## In Conclusion:\n\nBuilding a solid portfolio that showcases your skills as an engineer need not be a strenuous task. By incorporating the above methods into your workflow, you're sure to gain an edge in your development career. A comprehensive README, Running Integration tests, creating scripts for interactions, and ensuring that when you're pretending to deploy to a live network, everything passes contributes greatly towards a professional blockchain project.\n\nSo, let's keep pushing until we get there because that's what awesome engineers do!\n",
          "updates": []
        },
        {
          "lessonId": "ff41ef82-ab94-4081-a724-1a513e9b9a31",
          "number": 20,
          "title": "Automate your smart contracts actions - Makefile",
          "slug": "makefile",
          "folderName": "20-makefile",
          "description": "Learn to streamline your development workflow using Makefiles. This lesson teaches how to automate the building and deployment processes of smart contracts. It includes detailed examples of deploying to networks like Sepolia and setting up a comprehensive Makefile for various development tasks.",
          "duration": 9,
          "videoUrl": "Q3tvdSrm2vI",
          "rawMarkdownUrl": "/routes/foundry/2-foundry-fund-me/20-makefile/+page.md",
          "markdownContent": "---\ntitle: Makefile\n---\n\n_Follow along with this video._\n\n\n\n---\n\nDo you find writing long scripts all the time tedious? Or loathe the idea of having to re-enter your lengthy deployment commands constantly during your project's lifetime? If so, then you're on the right track! As developers, we always strive to work smart, not hard!\n\nAs we continue to discuss creation tests, I suggest a slight detour where we can introduce ways to make these often repeated scripts significantly easier. Our saviour: the _Makefile_.\n\n## A Makefile Primer\n\nA makefile is a text file used by the 'make' utility to automate the building and compiling processes of projects. Makefiles are a popular choice among developers due to their ability to streamline workflow drastically.\n\nIf you have not done so already, create a new file in your project folder called `makefile`. If everything's correctly installed, typing `make` in your terminal will return `no Targets stop`. If you experience any issues, install 'make' first.\n\n<img src=\"/foundry-fund-me/20-makefile/makefile1.png\" style=\"width: 100%; height: auto;\">\n\nMakefiles, besides their main conveniences, also allow us to include environment variables automatically without having to source them every single time using `source env`.\n\nOur makefiles have the ability to create shortcuts. This way, we don't have to write and remember long scripts every single time. Here's an example of a shortcut.\n\n```makefile\n-include .env\nbuild:; forge build\n```\n\nWith this, `make build` in your terminal will execute `forge build`.\n\n## Deploying to Sepolia: A Detailed Example\n\nLet's now take a more comprehensive example: deploying to Sepolia. Here's the code outline for the makefile content:\n\n```makefile\ndeploy-sepolia:\n    forge script script/DeployFundMe.s.sol:DeployFundMe --rpc-url $(SEPOLIA_RPC_URL)\n    --private-key $(PRIVATE_KEY) --broadcast --verify --etherscan-api-key $(ETHERSCAN_API_KEY)\n    --vvvv\n```\n\nThis command is quite extensive, and the last thing you'd want is to type it out every single time. You can now run the whole code with just: `make deploy-sepolia`.\n\nNote that we're deploying to a real network here, which incurs real costs. Therefore, only run this command if you intend to follow along in deploying your contract.\n\n**Important:** All environment variables in makefiles need to be enclosed using dollar signs and parentheses like so: $(variableName).\n\nTo enable automatic verification of our FundMe contracts on EtherScan, we'll need to create our own EtherScan API key. We'll then paste this key and the private key of our dummy account (not your real account), in our `.env file`.\n\nOnce the contract is deployed, and you paste the contract's address in folio, you will see that the contract has already been verified. No need to do it yourself on Etherscan, the script's got it covered!\n\n<img src=\"/foundry-fund-me/20-makefile/makefile2.png\" style=\"width: 100%; height: auto;\">\n\n## A Ready-to-Use Makefile Framework\n\nTo make setting up makefiles a lot easier, I have prepared a ready-to-use framework. It's available on our course-specific [GitHub repo](https://github.com/Cyfrin/foundry-fund-me-f23/blob/main/Makefile).\n\nThis framework is quite expansive and covers a wide range of commonly used make commands. For instance, running `make help` will return a list of command options. To avoid going overboard with detailing makefiles, I strongly recommend you check out the framework and adapt it to your development processes. If you're keen to learn more about makefiles, hop onto your favourite search engine and find some good articles, or simply, Google it!\n\nIn conclusion, makefiles are an incredible tool for developers that help to simplify commands and make our workflows much more efficient. Utilize them, and you'll see a significant boost in your productivity. Happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "1b838275-adc8-4821-90b7-73c28e8b10cd",
          "number": 21,
          "title": "Pushing to Github",
          "slug": "pushing-to-github",
          "folderName": "21-pushing-to-github",
          "description": "This lesson guides you through the process of pushing your Solidity projects to GitHub. It covers best practices for using Git, managing sensitive information, and updating README files. The lesson is crucial for developers looking to showcase their work and collaborate in the crypto-community.",
          "duration": 16,
          "videoUrl": "OlxnxWLC4dQ",
          "rawMarkdownUrl": "/routes/foundry/2-foundry-fund-me/21-pushing-to-github/+page.md",
          "markdownContent": "---\ntitle: Pushing to GitHub\n---\n\n_Follow along with this video._\n\n\n\n---\n\nWelcome fellow developers! In today's lesson, I'll guide you in pushing your work to GitHub using a badass GitHub repo. This action is the concluding step of your project. However, the first thing we want to ensure is that `env` is included in your `.gitignore`. Adding `broadcast` is a personal practice, and I advise you to do the same. The rationale behind this is avoiding a public push of anything inferior to GitHub.\n\nSometimes, it's beneficial to leave `lib` out, something that I plan to do here as well. The key take-home is learning to push code to GitHub. We are employing hardhat freeCodeCamp because it was used in one of my previous videos and we are kick-starting from an entirely blank GitHub.\n\nPlease note that the application of GitHub, coupled with git and version control, is crucial to the majority of crypto-community interactions and collaboration methods.\n\n## Open Source and the Crypto Community\n\n<img src=\"/foundry-fund-me/21-github/github1.png\" style=\"width: 100%; height: auto;\">\n\nWith the open-source nature of web3 and crypto, all the smart contracts you create or use are visible. You can scrutinize the code, learn from it and develop your skills.\n\n<img src=\"/foundry-fund-me/21-github/github2.png\" style=\"width: 100%; height: auto;\">\n\nIf you are eager to contribute, most of these protocols present grants and will recompense you for your contribution to their code. Alternatively, if you're keen on acquiring knowledge, you can generate pull requests to the codebases.\n\nWhen I was new to web three, one of the potent approaches I applied was making contributions to the Brownie Repo, a Pythonic smart contract framework aligned with Foundry. This process accelerated my learning and enabled me to interact and connect with several individuals in the community. Remember, GitHub profiles are crucial when applying for jobs. Hence, do your best to make your profile stand out.\n\n## GitHub and Decentralized Git Solutions\n\nAlthough GitHub is a centralized company, there are several decentralized git solutions presently under development. However, none of these are currently popular. If you want to get started or want a quick start, [GitHub docs](https://docs.github.com/en) provides numerous sets of documentation which you can refer to.\n\nYou should have a GitHub profile already set up. If you want to create a repo, you can utilize the 'Create a repo' section. Here, you'll learn to establish a repo directly via the website.\n\nHowever, creating a repo from the command line is advisable because it enables you to work without logging onto the internet every time you change your code.\n\nThis process involves following a specific documentation called adding locally-hosted code to GitHub. As the name suggests, we want to push our locally-hosted code to GitHub.\n\nBefore proceeding further, ensure that Git is installed on your device. Directions on how to install Git can be found [here](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git)\n\nA successful installation would display the Git version when `git version` is run. In case it doesn't, pause and install Git. You can utilize chatgbt, an AI tool, to help troubleshoot any installation issues.\n\nWith Git installed, you can access all of the features of Git, such as commits and logs. Use `git status` to view your repository status and `git log` to view a history of your commits.\n\n## Pushing Code to GitHub\n\nUse the command `git add .` to add all the folders and all the files to your git status, except for the ones in the git ignore. After adding the files, use `git status` to see what files and folders will be pushed to GitHub. Furthermore, do remember to check if the `env` is included or any sensitive information is included.\n\nThe next step involves committing your tasks. You can use `git commit -m \"your message`\" to commit your tasks. After committing, use `git status` to view your commits. With everything in order, the last step is to push the commit to GitHub using `git push origin main`. In case of any errors, employ chatgbt or any other AI to help troubleshoot the problem.\n\nVoila! By now, your project should be visible on your Github repository.\n\n## Updating the README\n\nAn often overlooked yet important aspect is updating your README file. It should include an 'About' section explaining your project and a 'Getting Started' section detailing the requirements and quick start instructions.\n\nOnce you have filled out your README, commit it to your repository using `git add .`, `git commit -m \"updated README\"`, `git push`.\n\nWithout a doubt, completing these steps successfully is worthy of celebration. Feel free to share your success and excitement with the developer community on social media. Remember, celebrating small wins on your journey is instrumental to maintaining motivation and enjoying your coding journey.\n\nThat's all the instructions you need to push your project on GitHub with Hardhat FreeCodeCamp. Keep practicing, keep pushing code, and soon enough, you'll be confident in using Git!\n",
          "updates": []
        },
        {
          "lessonId": "0f9c4792-c718-4dcc-ad07-95abf11a2481",
          "number": 22,
          "title": "Section recap",
          "slug": "section-recap",
          "folderName": "22-recap",
          "description": "This recap lesson summarizes key points from the course, including professional project setup, codebase refactoring, interaction scripts, gas and storage optimization, Makefiles, and GitHub repositories. It's a comprehensive review of the skills and knowledge gained in the course.",
          "duration": 2,
          "videoUrl": "6Jht0Us1vGw",
          "rawMarkdownUrl": "/routes/foundry/2-foundry-fund-me/22-recap/+page.md",
          "markdownContent": "---\ntitle: Recap & Congratulations\n---\n\n_Follow along with this video._\n\n\n\n---\n\nCongratulations on making it this far on our enlightening journey on articulating how to set up a foundry project professionally! This segment stands colossal indeed, and I am here to take a brief detour and simmer down the plethora of knowledge that we gathered on handling Foundry projects more professionally.\n\n## The Key Takeaways from the Course\n\nSo, sit back, relax, let's take a look back at the phenomenal landscape we painted together on our canvas of a Foundry project.\n\n- **Professional Foundry Project Setup:**\n  Setting up a project is a breeze that we adapt our hands to, but dealing with it professionally? That's where the real challenge kicks in. We have covered how to establish our source folder and accommodate numerous contracts in there.\n\n- **Codebase Refactoring:**\n  We dived in together into the world of making our codebase more modular and learned how to refactor it. Enhancing our `FundMe` contract, we've started working on how to pass in a `price feed`, empowering us to deploy our contract on any desired chain.\n- **Interactions Script Dynamics:**\n  Next, we've talked about an `interactions script` which incorporates `FundMe` and `Withdraw FundMe` contracts. This feature allows us to effortlessly withdraw funds and finance our most recently deployed contract.\n- **Working with Mocks and More:**\n  What's learning without getting hands dirty? Yes! We got involved in working with mocks in testing, we understood how to conduct integration tests and also dove deeper on forking tests.\n- **Getting the grips on Gas and Storage:**\n  A major leap in our education expedition was understanding more about `gas` and `storage`. Grasping these topics gives us the power to handle the energy consumption of Blockchain applications and to persist data on the Ethereum blockchain.\n- **Grasping Makefiles:**\n  We learned a little about makefiles too. A Makefile contains a set of directives used by a make build automation tool to generate a target/goal.\n- **Building GitHub Repositories:**\n  The icing on the cake of our extensive learning was when we built our **first GitHub repository** and pushed it up - a moment that we can incredibly own and rejoice at!\n\n<img src=\"/foundry-fund-me/22-recap/recap1.png\" style=\"width: 100%; height: auto;\">\n\n## What's Next?\n\nNow, isn't it the perfect moment to give yourself a lil' break? After all, you've earned it! Grab that coffee, ice cream and have a walk. Or, simply indulge in any activity for some you-time.\n\nThough, if you wish to further enhance your knowledge and graduate from being 'okay' at this to being an absolute maestro, I urge you to continue this journey with us. We've designed our course to not just educate you but to prepare you for everything that this space has to offer.\n\nSo, see you in the next project!\n\nGoodbye, for now!\n\n---\n\n<img src=\"/foundry-fund-me/22-recap/recap2.png\" style=\"width: 100%; height: auto;\">\n",
          "updates": []
        }
      ]
    },
    {
      "sectionId": "b3b77063-6dfd-43d6-83b6-c0655a81d722",
      "number": 3,
      "title": "Fund Me Frontend",
      "slug": "html-fund-me",
      "folderName": "3-html-fund-me",
      "lessons": [
        {
          "lessonId": "c9498599-1d48-42ab-a184-68cd69834483",
          "number": 1,
          "title": "How Metamask interacts with dapps",
          "slug": "setup",
          "folderName": "1-setup",
          "description": "Introduction to MetaMask interactions with websites, covering the basics of transaction transparency and setting up a basic JavaScript web application.",
          "duration": 4,
          "videoUrl": "883HH60QqDY",
          "rawMarkdownUrl": "/routes/foundry/3-html-fund-me/1-setup/+page.md",
          "markdownContent": "---\ntitle: Setup\n---\n\n_Follow along the course with this video._\n\n\n\n---\n\nHey there! Welcome to Lesson Eight. This session promises to be engaging and insightful as we dive deeper into the world of Development, focusing on MetaMask interactions with websites.\n\n## Maintaining Transparency With Transactions\n\nIt is integral to understand how MetaMask, or any wallet for that matter, interacts with a website. Having this foundational knowledge equips you to ensure that your wallet sends the precise transaction you intend it to broadcast.\n\n<img src=\"/html-fundme/1-setup/setup1.png\" style=\"width: 100%; height: auto;\">\n\n## HTML FundMe F23: A Raw Javascript Full Website Application\n\nThough we won't be delving into building a full-stack application in this lesson, you can find resources and examples for the same in the full blockchain solidity course on Javascript (JS) with Node JS.\n\nWe will, however, discuss HTML FundMe F 23 - a basic raw JavaScript full website application. If you feel crafty, go ahead and replicate it for practical grasp. The objective is to comprehend what happens under the hood when you interact with these websites.\n\n## Diving In Without Prior Introduction\n\nFor a fresh change, we'll readily dive into the heart of the course without going through the customary walkthrough. You've been introduced to Git and GitHub in our previous courses, which will come in handy now.\n\nPull up your code base at Foundry F23, the repository with all our code. Copy the URL and begin working as if you've just downloaded it from GitHub, like this:\n\n```bash\ngit clone git@github.com:username/repo.git\n```\n\nYou'll find a 'Quick Start' section in all of my READMEs for your reference. Use it to clone the repository or open the file.\n\n## Spinning Up The Website\n\nThe HTML FundMe repository has a very basic HTML and JavaScript structure to run a website. You can use an extension called Live Server to run the website. Alternatively, you should be able to open Reveal in Finder or use your file explorer to open it in your browser.\n\n### Here's how it should look:\n\n```bash\ncode html-fund-me-f23\n```\n\nThe website runs on a minimalist architecture, which we're going to use to illustrate how MetaMask interacts with the website.\n\n<img src=\"/html-fundme/1-setup/setup2.png\" style=\"width: 100%; height: auto;\">\n\n## Wrapping Up\n\nHaving understood the fundamental of interactions between MetaMask and websites, you'd be more confident and aware of your transactions. Your coding journey grows with you. See you at the next lesson!\n\nKeep coding and keep exploring!\n",
          "updates": []
        },
        {
          "lessonId": "ae529daa-722d-4124-8222-b631d6a43b0a",
          "number": 2,
          "title": "Introduction to window.ethereum",
          "slug": "metamask",
          "folderName": "2-metamask",
          "description": "Exploration of MetaMask's interaction with JavaScript websites, focusing on the use of the `window.ethereum` object and smart contract interactions.",
          "duration": 13,
          "videoUrl": "PL1H5tXwE3Q",
          "rawMarkdownUrl": "/routes/foundry/3-html-fund-me/2-metamask/+page.md",
          "markdownContent": "---\ntitle: How MetaMask works with the Browser\n---\n\n_Follow along the course with this video._\n\n\n\n---\n\nIn our web development journey, we often interact with JavaScript-enabled websites. But when it comes to dealing with MetaMask -- a cryptocurrency wallet and Ethereum gateway -- things become a little more intriguing. Let's uncover the puzzle and understand how MetaMask works with your website. Moreover, I will guide you on how to interact with such a website connected to a blockchain and a FundMe contract on the Anvil network.\n\n## MetaMask &amp; Its Interaction with Websites\n\nMetaMask is more than just a cryptocurrency wallet -- it acts as an interface that allows websites to interact with the Ethereum blockchain. Notably, these websites interact predominantly with the `window.ethereum` JavaScript object injected into the web browser by MetaMask. By utilizing this object, websites send transactions to MetaMask or any connected wallet.\n\nHowever, keep in mind that if you switch to a browser without MetaMask installed, you won't be able to establish this connection. If you inspect the console and type `window.ethereum`, you'll encounter `undefined`. For detailed information about working with the `window.ethereum` object, refer to the MetaMask documentation [here](https://docs.metamask.io/guide/).\n\n<img src=\"/html-fundme/2-metamask/metamask1.png\" style=\"width: 100%; height: auto;\">\n\n## Establishing Connection with MetaMask\n\nFor your website to interact with MetaMask, you should have a mechanism to establish a connection. In order to do so, most websites feature a 'connect' button that on being clicked initiates the connection.\n\nWhen you click the 'connect' button on your website, MetaMask will prompt you to connect one of your accounts. Once the connection is set up, your website will be able to fetch the account's balance and carry out transactions.\n\nThis JavaScript code shows the process to establish a connection via the 'connect' button. On clicking this button, the function checks if MetaMask is available on the browser. If found, it sends a request to MetaMask to connect one of the existing accounts.\n\n## Interacting with Smart Contracts\n\nOnce the connection is established, we can interact with the functions of deployed smart contracts. For this demonstration, I will show you how to interact with a contract called `FoundryFundMe`. This contract has functions such as `fund`, `withdraw`, and `getBalance`. Here is an example of how to interact with the `getBalance` function:\n\nFirstly, an Ethers provider gets the RPC URL from MetaMask. Secondly, it gets the signer using this provider. The signer, in context, is the connected account. Lastly, it creates a contract instance using the contract address, ABI, and signer.\n\n```js\n// JavaScript code to interact with the `getBalance` function\nlet provider = new ethers.providers.Web3Provider(window.ethereum);\nlet signer = provider.getSigner();\nlet contract = new ethers.Contract(contractAddress, ABI, signer);\n// Retrieve the balance\nlet balance = await contract.getBalance();\n```\n\n## Switching to the Anvil Network\n\nAt some point, you may want to practice interacting with smart contracts on a local Anvil chain instead of the Ethereum Mainnet. Through MetaMask, you can easily shift from the Ethereum Mainnet to the Anvil network.\n\nTo do this, go to `Settings -> Networks -> Add Network`, and manually enter the following network details:\n\n- Network Name: Anvil\n- New RPC URL: \\[RPC-URL-OF-ANVIL-NETWORK\\]\n- Chain ID: 31337\n- Currency Symbol: Eth or whatever you prefer.\n- Block Explorer URL: \\[This field can be left blank\\]\n\nAfter the network is added, you can switch to Anvil chain in MetaMask and start interacting with the smart contracts deployed there.\n\n## Interacting with the `FundMe` Contract\n\nOnce you've switched to the Anvil network, repeating the process as discussed in the previous section, you can deploy the `FundMe` contract and interact with it using MetaMask.\n\nFrom the website, enter an amount in the `fund` section and click `fund`. This will create a transaction sent to MetaMask for you to sign.\n\n```js\n// JavaScript code to interact with the `fund` function\nlet ethAmount = document.getElementById(\"ethAmount\").value;\nlet tx = await contract.fund({ value: ethers.utils.parseEther(ethAmount) });\n```\n\nThrough this process, the website sends a transaction to MetaMask, and MetaMask returns a popup asking whether you want to sign this transaction with your private key.\n\n## Recap and Takeaways\n\nWorking with MetaMask and JavaScript websites might seem daunting at first glance, but breaking it down to basics makes it accessible and transparent. MetaMask acts as a liaison connecting the JavaScript website to the Ethereum blockchain all the while prioritizing the security of your private keys. By comfortably setting up local Anvil chains and interfacing smart contracts via JavaScript functions, you can create an interactive, secure, and real-world-ready dApp.\n",
          "updates": []
        },
        {
          "lessonId": "23b9873a-e58f-4c21-a8db-4d3602e8b214",
          "number": 3,
          "title": "Decoding Ethereum transactions",
          "slug": "function-selectors",
          "folderName": "3-function-selectors",
          "description": "Guide to understanding and decoding Ethereum transaction data using function selectors, with practical examples of verifying transactions.",
          "duration": 8,
          "videoUrl": "qZjLWy9b9hI",
          "rawMarkdownUrl": "/routes/foundry/3-html-fund-me/3-function-selectors/+page.md",
          "markdownContent": "---\ntitle: Function Selectors Introduction\n---\n\n_Follow along the course with this video._\n\n\n\n---\n\n## Decoding Transaction Data With Ethereum: A Step-by-Step Guide\n\nHave you ever found yourself struggling with transaction data in Ethereum? Muddling through raw transaction data can be quite a challenge, especially if you aren't quite certain if the function you're calling is as it appears on the surface. Let's walk through how you can confirm what function is being called, decode Ethereum transactions, and call functions with parameters.\n\n## The Fund Function\n\nPicture this scenario: You have a system encoded with 'fund' and 'steal money' functions. You enter 0.1, hit _fund_, and find your MetaMask filled with data. At first glance, the data suggests it's calling the 'fund' function, but you'd like to precisely know.\n\nProving that the system is indeed calling the 'fund' function involves using function selectors. When solidity functions are transformed into function selectors, the human-readable 'fund' is converted into low-level bytecode or Ethereum Virtual Machine (EVM) code to stimulate Ethereum to grasp the function you're calling.\n\n<img src=\"/html-fundme/3-function-selector/function1.png\" style=\"width: 100%; height: auto;\">\n\n## Function Selectors and Checking Functions\n\nNow, every function selector has its unique low-level hex encoding, and that's where the Cast command comes into play. Running 'cat SIG fund' in your system will return a 'fund' function selector. If you'd like to cross-verify this transaction's function, copy and paste the hex data alongside the expected selector in the console.\n\nIf they're the same, you can have assurance that it is actually calling the 'fund' function. But if you sense something fishy about the website and suspect it's pulling off some treacherous tactic like calling a malicious function like 'steal money', you can run 'Cast SIG steal money'. This will provide you with the 'steal money' function selector.\n\nCopy the function selectors and verify them against the hex data on MetaMask. If they align, unfortunately, your website is calling the 'steal money' function- not the 'fund' function it should ideally be calling.\n\n<img src=\"/html-fundme/3-function-selector/function2.png\" style=\"width: 100%; height: auto;\">\n\n## Functions With Parameters\n\nNow let's consider the scenario of functions with parameters. In such cases, your hex data is bigger, considering you'll have to accommodate data for calling the function. Cast calldata decode comes in handy in such scenarios.\n\nRunning _cast calldata decode_ alongside the call data on the system should reveal all the parameters on a function should they exist. This, however, isn't a perfect example since neither the 'fund' nor the 'steal money' function has any parameters. We'll delve into this a little later.\n\n```\n> Cast calldata decode > paste the call data\n```\n\n## Withdrawing Funds\n\nNow, consider a different scenario where there's a function to withdraw funds. In this case, let's say this specific withdrawal feature is enabled to the account owner only.\n\nEntering 0.1, hitting _fund_, and confirming the transaction sends the function via the API call. Once sent, calling _get balance_ should reveal that the balance has increased.\n\nHeading to 'function withdraw', the system shows that it's an owner function. Making an attempt to withdraw from another (non-owner) account gets an RPC error since the function is limited to the owner.)However, getting back to the owner account gives a different story. Commanding withdraw and conferring the hex data to the earlier Cast SIG withdraw hex, the matching hexes gives the assurance to confirm the withdrawal. Once the mining is done, just as expected, the balance goes back to zero. So mission accomplished!\n\n```\n> Cast SIG withdraw> Withdraw function hex data: copied hex data\n```\n\n## Conclusion\n\nIn summary, understanding and verifying the transaction data we're handling in MetaMask ensures we're in control of our systems and comfortable in knowing no malicious functions are being called. So go out there and put this to good use, knowing exactly where your transactions are heading.\n\nAnd remember,\n\n<img src=\"/html-fundme/3-function-selector/function3.png\" style=\"width: 100%; height: auto;\">\n\nWe will delve into function parameters, calldata, and much more later. Get started, happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "bcb0296e-6981-43c8-9742-1bd4688fca06",
          "number": 4,
          "title": "Section recap",
          "slug": "summary",
          "folderName": "4-summary",
          "description": "Summary of web interactions and transactions, emphasizing the role of function selectors and the importance of secure and intelligent web navigation.",
          "duration": 5,
          "videoUrl": "EDaD5Ln1_u0",
          "rawMarkdownUrl": "/routes/foundry/3-html-fund-me/4-summary/+page.md",
          "markdownContent": "---\ntitle: Summary\n---\n\n_Follow along the course with this video._\n\n\n\n---\n\nHello, there! Today, we had a quick lesson, but it was a vital one as it gives you the real feeling of interacting with websites from a very low level. For those excited about engaging themselves in more complex full-stack work, this post will hopefully whet your appetite.\n\n#### Initiating a Transaction - Making a Connection\n\nA website sends a transaction to your wallet by establishing attachment to the wallet in one way or another. Browser extension injection into your browser is one of the most prevalent methods in use today.\n\n```javascript\nwindow.Ethereum;\n```\n\nThis line of code signals the browser to confirm the presence of the metamask object, an essential step for browsers interacting with wallets such as `wallet connect`, `ledger`, among other types.\n\nWhile on the surface all wallets seem different, they all perform the fundamental function of consolidating a connection object with the website, thus enabling the website to transmit transactions to your browser. The process involves hitting \"connect\" on the website and the wallet confirming the establishment of a successful connection.\n\n<img src=\"/html-fundme/4-summary/summary1.png\" style=\"width: 100%; height: auto;\">\n\n#### Send a Transaction, Keep the Private Key\n\nWhen it comes to sending a transaction to our wallets, the website first extracts the provider or the RPC URL from MetaMask.\n\n<img src=\"/html-fundme/4-summary/summary2.png\" style=\"width: 100%; height: auto;\">\n\nThrough the function signature or function selector, our system helps us verify that the transactions from the website are not counterfeit. Later in our course, we will delve deeper into decoding complex transactions and functions.\n\n<img src=\"/html-fundme/4-summary/summary3.png\" style=\"width: 100%; height: auto;\">\n\n#### Conclusion\n\nThat tips off our lesson for today. It was short but dense with necessary knowledge, especially for learners who are passionate about smart contracts. Understanding web interactions and the intricate operations of websites aids in conducting intelligent work and being on the lookout for potential threats.\n\nThis was a basic introduction to web interactions, and as we continue digging deeper into topics, such as function selectors and signatures, expect to become more proficient in navigating websites. Now would be a perfect time to digest all that we've discussed. Stay tuned for the next lesson. Catch you later!\n",
          "updates": []
        }
      ]
    },
    {
      "sectionId": "31c5e514-7427-479c-ad8c-1aebcf1e45ee",
      "number": 4,
      "title": "Smart Contract Lottery",
      "slug": "smart-contract-lottery",
      "folderName": "4-smart-contract-lottery",
      "lessons": [
        {
          "lessonId": "56f7152b-6ccb-4c0a-be25-fb56cb797b0d",
          "number": 1,
          "title": "Smart contract lottery - Project setup",
          "slug": "setup",
          "folderName": "1-setup",
          "description": "Introduction to building an advanced lottery or raffle smart contract, covering key features like Chainlink automation and random number generation.",
          "duration": 12,
          "videoUrl": "gecEjRVNt34",
          "rawMarkdownUrl": "/routes/foundry/4-smart-contract-lottery/1-setup/+page.md",
          "markdownContent": "---\ntitle: Setup\n---\n\n_Follow along the course with this video._\n\n\n\n---\n\nWelcome back! I hope you enjoyed your break because we're about to dive into project number nine. As always, our goal is not just to teach you to build amazing projects, but to ensure you understand best practices and how to make your code look phenomenal.\n\n## Getting Started\n\nFor the project, we'll be working with an **advanced lottery or raffle smart contract**. This won't just be an exercise in coding, but a chance to learn more about:\n\n- Events\n- Working with true random numbers\n- Working with Modulo\n- Chainlink automation\n- And so much more.\n\nFeel free to explore the code base right in the course down to lesson nine. No need to follow along right now, just watch and get a feel for what we're about to build.\n\n<img src=\"/foundry-lottery/1-setup/setup1.png\" style=\"width: 100%; height: auto;\">\n\n## A Closer Look at the Smart Contract\n\nIn this project, we're introducing some **professional Nat spec for an even better looking codebase**. A key feature here is the raffle or lottery smart contract. This contract includes various functionality such as:\n\n- Enabling users to enter the raffle\n- A unique `checkUpkeep` functionality\n- A `fulfillRandomWords` function that chooses a winner and awards them a sum of money based on the entries\n- Multiple getter functions\n\nHaving made sure our foundational setup is in place with `forge build`, we then move to our make file where we have different commands like deploying our smart contracts and interacting with the Chainlink automation.\n\n## Building From Scratch\n\nOne crucial lesson we should all remember is that repetition is the mother of skill. The more you code, the better you get. As such, it advisable to code along, pausing the tutorial occasionally to try coding on your own.\n\nWe start fresh by creating a new Foundry project. Right before diving into code, it's essential to plan out what you want your project to achieve. Define those goals clearly, while making sure they align with the project's requirements. For the lottery project, the goals include:\n\n- Users should be able to enter the raffle by paying for a ticket\n- The lottery should automatically and programmatically draw a winner after a certain period\n- Chainlink VRF should generate a provably random number\n- Chainlink Automation should trigger the lottery draw regularly\n\n**Rope in Chainlink for the win!**\n\n- Chainlink VRF is an essential tool to instill trust in the lottery process. It generates a provably random number outside of the blockchain, ensuring the process is fair and transparent.- Chainlink Automation, a time-based trigger, eliminates the need for manual trigger of the lottery draw, making the process even smoother.\n\nGiven the goals, the functions necessary to achieve this are `enterRaffle` and `pickWinner`. The `enterRaffle` function allows users to buy a ticket to enter the raffle and the `pickWinner` function randomly picks a winner and awards them the accumulated entry fees.\n\n## The Layout for Your Code\n\nCode layout matters! As they say, \"Clean code is a process, not a point in time.\" We can improve our code's layout and readability with the best practices we have learned.\n\n<img src=\"/foundry-lottery/1-setup/setup2.png\" style=\"width: 100%; height: auto;\">\n\nSo let's get back to our Enter raffle function. You would probably want to set a ticket price or entry fee, right? Therefore, setting up an `entranceFee` state variable promptly at the top of the contract is recommended. We want to be mindful of our gas costs though, hence making the variable immutable.\n\n```js\nuint256 private immutable _entranceFee;\n```\n\nCreating a getter function for the entrance fee allows for transparency since the world can see the fee.\n\n```js\n// Getter functions\nfunction getEntranceFee() external view returns(uint256){\n    return _entranceFee;\n}\n```\n\nWe are just getting warmed up! There’s more to building this lottery contract. No worries, though, the journey to creating a provably fair, a provably random lottery, while learning and implementing best practices to making your code look phenomenal, is going to be amazing.\n\nLet's jump in!\n",
          "updates": []
        },
        {
          "lessonId": "35905d3f-a802-4475-913d-c4af8ae829c8",
          "number": 2,
          "title": "Solidity style guide",
          "slug": "solidity-layout",
          "folderName": "2-solidity-layout",
          "description": "Exploration of Solidity's code layout and function ordering for efficient smart contract development.",
          "duration": 2,
          "videoUrl": "qnmKmB_pBvQ",
          "rawMarkdownUrl": "/routes/foundry/4-smart-contract-lottery/2-solidity-layout/+page.md",
          "markdownContent": "---\ntitle: Solidity Layout\n---\n\n_Follow along the course with this video._\n\n\n\n---\n\nIn one of our previous conversations, we discussed Solidity's style guide, code layouts. However, it's intriguing to note that we didn't fully explore how to properly order our Solidity functions and calls. This article aims to delve deeper into this crucial aspect of the usage of Solidity, the leading programming language for smart contract development.\n\nThe official Solidity docs provide a comprehensive order of layout for a better understanding of the programming organization. The objective is to make your codebase look professional and easy to navigate when working with code.\n\n<img src=\"/foundry-lottery/2-layout/layout1.png\" style=\"width: 100%; height: auto;\">\n\n## The Standard Order for Code Layout in Solidity\n\nStarting with the `Pragma` directive, a typical Solidity code layout follows several steps in a specific order:\n\n1. `Pragma` statement\n2. Import statements\n3. Interfaces and libraries\n4. Contracts\n5. Type declarations within contracts\n6. State variables\n7. Events\n8. Modifiers\n9. Functions\n\nWe've been following the correct procedure with `Pragma` at the very start. However, we currently don't have any import statements, interfaces or libraries. Next up on the list would be contracts, inside which you do type declarations and state variables.\n\nOur first function comes next, where we don't have any events or modifiers in use. The ordering advises that we start from the `constructor` but remember, keep the readability and comprehensibility of your program as a priority.\n\n<img src=\"/foundry-lottery/2-layout/layout2.png\" style=\"width: 100%; height: auto;\">\n\n## A Closer Look at Function Ordering\n\nFunction ordering in Solidity also follows a specific flow. You start with the constructor, then follow it up with the receive and fallback functions. After that, external and public functions come, followed by internal and private functions. Lastly, within a grouping, view and pure functions should be placed.\n\nLet's break down the order in this list:\n\n1. Constructor\n2. Receive\n3. Fallback\n4. External and Public functions\n5. Internal and Private functions\n6. View and Pure functions\n\nEnforcing readability, this order adds to the organization, keeping the code neat and manageable.\n\n## How to Remember the Order\n\nYou might sometimes find you forget to follow this specific order. A helpful tip that I personally use is to paste the code layout order at the top of my code as a quick reference guide. You can find a template of this versioning layout in the GitHub repository associated with this lesson.\n\n<img src=\"/foundry-lottery/2-layout/layout3.png\" style=\"width: 100%; height: auto;\">\n\nGo to the [Github repo](https://github.com/Cyfrin/foundry-smart-contract-lottery-f23/tree/main/src) and copy the code layout. Paste it at the top of your working context. This layout serves as a comprehensive guide we will follow.\n\nFrom there, you can copy and paste it at the top of your working context. This layout serves as a comprehensive guide we will follow.\n\n<img src=\"/foundry-lottery/2-layout/layout4.png\" style=\"width: 100%; height: auto;\">\n\n## Conclusion\n\nIn the end, the Solidity docs' recommended layout is simply a guide - you can opt to follow it or devise your own. After all, the ultimate goal is to create a clean and comprehensible code base regardless of the layout.\n\nBear in mind, though, that when your application scales and interacts with other contracts, Solidity's official documentation's recommended order could save you significant time and confusion. Happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "32c9ad50-2e26-4383-a292-4a57affc9db7",
          "number": 3,
          "title": "Creating custom errors",
          "slug": "solidity-custom-errors",
          "folderName": "3-custom-errors",
          "description": "Guidance on using custom errors in Solidity for gas-efficient and effective error checking.",
          "duration": 5,
          "videoUrl": "Og3_o7kFDRw",
          "rawMarkdownUrl": "/routes/foundry/4-smart-contract-lottery/3-custom-errors/+page.md",
          "markdownContent": "---\ntitle: Custom Errors\n---\n\n_Follow along the course with this video._\n\n\n\n---\n\n## Implementing the Entrance Fee\n\nSo, remember when we said our raffle had an entrance fee? Well, let's get to it and actually start using it to ensure only people who have paid can enter the raffle.\n\nOur entrance raffle function is a `public payable`. However, it might be better to make it `external payable` for better gas efficiency. So, let's make that switch now.\n\nThe shift to `external payable` makes sense since we're highly unlikely to have any internal function calls to `enterRaffle`, and `external payable` functions tend to be slightly more gas-efficient when called from outside the contract. Now that we've done that, let's do a check to ensure the correct quantities are transferred.\n\nHere's where the require statement comes into play.\n\n```js\nrequire(msg.value >= _entranceFee, \"Not enough ETH sent!\");\n```\n\nThis statement checks if the entrance fee meets a certain condition - in this case, that the sent ETH is greater than or equal to the entrance fee. But if it doesn't, our function will revert and throw the user-friendly error message \"Not enough ETH sent!\".\n\nThis leads us to our first major update to our knowledge of Ethereum.\n\n## Custom Errors Vs `Require`\n\nTraditionally, the `require` function in Solidity has been the go-to method for incorporating error checking in the code. But all that changed with Solidity version 0.8.4 which introduced custom errors. This development allows you to define errors with custom names and, more importantly, custom errors happen to be more gas efficient.\n\nHere's how we could use it:\n\n```js\n// Define the custom error at the top of your contract\nerror NotEnoughETHSent();\n// Invoke the custom error\nif (msg.value < _entranceFee) {\n    revert NotEnoughETHSent()\n};\n```\n\nTo give you a practical understanding of the gas saved, let's see an example. Two similar functions coded twice, one using revert with custom error and the other with require.\n\n```js\n// Revert with custom error\nfunction revertWithError() public pure{\n    if(false){\n        revert ExampleRevert_Error();\n    }\n}\n// Revert with require\nfunction revertWithRequire() public pure {\n    require(true, \"ExampleRevert_Error\");\n}\n```\n\nIf we were to deploy both the functions on Remix and execute them, despite both reverting (which inherently costs gas), the function with the custom error (`revertWithError`) turns out to be more gas efficient, costing **142 gas** to the **161 gas** of the `require` based error handling.\n\nSo, in essence, this is a practical example of \"learning something to never use it again\".\n\nThat's it, folks! By now, you know how to work with custom errors and some best practices to consider when writing these reverts. Stay tuned for more Ethereum Smart Contract updates and practical takes. Here's to better (and more gas-efficient) coding!\n",
          "updates": []
        },
        {
          "lessonId": "9d92bd94-45e2-4a05-ac64-b98f3d9fe717",
          "number": 4,
          "title": "Smart contracts events",
          "slug": "solidity-events",
          "folderName": "4-events",
          "description": "In this lesson we'll explore how to use events in Ethereum smart contracts, specifically in a lottery system context.",
          "duration": 12,
          "videoUrl": "69Yl2FEtbjc",
          "rawMarkdownUrl": "/routes/foundry/4-smart-contract-lottery/4-events/+page.md",
          "markdownContent": "---\ntitle: Events\n---\n\n_Follow along with this lesson and watch the video below:_\n\n\n\n---\n\nEver wondered how to track users in an Ethereum lottery? Or how about which data structure to use for storing players addresses in an on-chain lottery system? Well, you're in for a ride as we take a deep dive into these topics and more!\n\n## What's Next? Data Structures to the Rescue!\n\nIn the case of a lottery system on the Ethereum network, we need to store and track all the users participating in each round.\n\nHere, we are confronted with the question of which data structure to choose. Should we use an array or a mapping? Should we use multiple address variables?\n\nTo solve this, we've decided to use a dynamic array, an array that adjusts its size as needed. The reasons for this choice become apparent as you need to randomly pick a winner from the entries. As you may know, mappings can’t be looped through, which poses a problem if we need to randomly select an individual for the winning prize.\n\n```js\naddress[] private s_players;\n```\n\nThe above line is an array of the players in the lottery. Notice the `private` modifier, which means the variable cannot be accessed directly from outside the contract. This variable is dynamic and its value will change frequently as players enter the lottery, leading to more storage operations.\n\nAs we are dealing with Ether which will be paid to these players, we should make it an `address payable` to ensure we can transfer funds to these players.\n\n## Updating Our Lottery\n\nWith our array in place, we can proceed to update our lottery function.\n\n```js\ns_players.push(payable(msg.sender));\n```\n\nWhen users enter the lottery, we add their address into our dynamic array. Using the `push` function, we can add the `msg.sender` to our `s_players` array.\n\n## Emitting Events: Announce It to the World!\n\nA key part of our function is missing: an event. Events in Ethereum are a mechanism to communicate that something has happened in a smart contract. These records can be used by the front-end of your application for various tasks and are also useful in migrating or updating your contracts. An event is typically emitted following any interaction with the contract that modifies its state.\n\nIn our case, we should emit an event when a player enters the lottery. For this, we'll create an event called `EnteredRaffle` which receives an indexed address type parameter. Indexed parameters are parameters that are much easier to search for and much easier to query than non-indexed ones.\n\n```js\n// Event Declaration\nevent EnteredRaffle(address indexed player);\n// Emitting the Event\nemit EnteredRaffle(msg.sender);\n```\n\n## In Conclusion\n\nAt this point, we've determined the data structure to use for our lottery, updated our function with it, and implemented events. The choices we discussed here should make picking a winner from all the participants seamless.\n",
          "updates": []
        },
        {
          "lessonId": "62240b7f-d0a3-4182-9d00-ce5c2e738aba",
          "number": 5,
          "title": "Random numbers - Block Timestamp",
          "slug": "solidity-random-number-block-timestamp",
          "folderName": "5-block-timestamp",
          "description": "Insights into using block timestamps for random number generation in lottery smart contracts.",
          "duration": 4,
          "videoUrl": "0ZAXHzB4YWs",
          "rawMarkdownUrl": "/routes/foundry/4-smart-contract-lottery/5-block-timestamp/+page.md",
          "markdownContent": "---\ntitle: Block Timestamp\n---\n\n_Follow along with this lesson and watch the video below:_\n\n\n\n---\n\nToday, I'll be explaining and walking you through some crucial steps for developing an automatic lottery winner selection function, `pickWinner`.\n\n<img src=\"/foundry-lottery/5-block-timestamp/block1.png\" style=\"width: 100%; height: auto;\">\n\n## The 'pickWinner' Explained\n\nThe `pickWinner` function isn't just about picking the winner but also getting a random number _and_ ensuring automatic selection happens seamlessly and precisely when it should.\n\nHere are a few things we want our `pickWinner` function to do:\n\n- Get a random number.\n- Use the random number to pick a player.\n- Trigger automatically (eliminating the need for manual interaction).\n\nLet's dive right into how we can achieve this. Initially, let's focus on the first two tasks—we can discuss automatic triggering later.\n\n### Getting a Random Number and Picking a Winner\n\nTo create an `external` function that anyone could call to select a random winner, we'd probably want the winner selection to happen when the lottery is ready for its winner. So, how do we know when that time is right? We make sure that enough time has elapsed to pick a winner.\n\n```js\npublic function pickWinner() external {}\n```\n\nWe'd achieve this by creating an `interval` variable, specifying how long our lottery will last before a winner is selected. However, since we wouldn't want to keep changing this value, we'll make it an `immutable` variable, meaning it can only be set in the constructor and remains constant throughout the contract's life.\n\n```js\nconstructor(uint256 entranceFee, uint256 interval) {\n    i_entranceFee = entranceFee;\n    i_interval = interval;\n}\n```\n\nComments are your best friend when reading code. So, don't forget to comment what `i_interval` contains: duration of the lottery in seconds.\n\n```js\n// Duration of the lottery in seconds\nuint256 private immutable i_interval;\n\n```\n\n### The Golden Period: Has Enough Time Passed?\n\nNext, we need to check if this preset interval has passed before invoking the `pickWinner` function. Which leads us into some thorough timestamp comparison, in which we will take block timestamps into account!\n\nThe `block.timestamp` global variable gives us the current time in seconds. Subtracting the previous timestamp from the current block timestamp should ideally be more significant than our preset interval.\n\n```js\nblock.timestamp - s_lastTimestamp > i_interval;\n```\n\nThis condition checks if enough time has passed, let's envision an example:\n\n- When `block.timestamp` is 1000 and `s_lastTimestamp` is 500, the elapsed time equals 500.\n- If the `I_interval` is 600 seconds, meaning that not enough time has passed and therefore, no winner should be picked.\n\nHowever, if the `block.timestamp` is 1200, 1200 - 500 equals 700, which is greater than our `I_interval` of 600. That means, enough time has passed, and it's time to announce a winner!\n\n### The 'Snapshot' of Time\n\nAlso, we would need to take a 'snapshot' of time, which we'll do by creating a `private` state variable that remains in storage—an `S_lastTimestamp`.\n\n```js\nuint256 private s_lastTimestamp;\n```\n\nThe initial `s_lastTimestamp` value would be set right in the constructor as the `block.timestamp` immediately the contract gets deployed, to start the 'interval' clock.\n\n```js\nconstructor() {\n    s_lastTimestamp = block.timestamp;\n}\n```\n\nBelow, in our `pickWinner` function, we'll revert the transaction if the condition doesn't meet, because not enough time would have passed.\n\n```js\nif (block.timestamp - s_lastTimestamp < i_interval) {\n  revert();\n}\n```\n\nOn the last note, while it might seem tempting to add custom errors right now, remember, it's best practice to refactor them eventually. So, for now, let's stick to checking the elapsed time.\n\n**NOTE**: Remember to update `s_lastTimestamp` once the winner has been picked.\n\n```js\ns_lastTimestamp = block.timestamp;\n```\n\nStay tuned for my next blog post, where we take this to the next level and discuss how to make the `pickWinner` function automatically triggered.\n\n**Happy Coding!**\n",
          "updates": []
        },
        {
          "lessonId": "a21bd474-1086-4fe8-8545-33f6c33da57e",
          "number": 6,
          "title": "Random numbers - Introduction to Chainlink VRF",
          "slug": "solidity-random-number-chainlink-vrf",
          "folderName": "6-chainlink-vrf",
          "description": "Introduction to using Chainlink VRF for generating random numbers in blockchain applications.",
          "duration": 11,
          "videoUrl": "A8obi954JXU",
          "rawMarkdownUrl": "/routes/foundry/4-smart-contract-lottery/6-chainlink-vrf/+page.md",
          "markdownContent": "---\ntitle: Chainlink VRF\n---\n\n_Follow along with this lesson and watch the video below:_\n\n\n\n---\n\nWelcome! It's time to explore the tech behind **random number generation** on the blockchain using Chainlink VRF! This post will walk you through the concepts, step by step, aided by a helpful video from Chainlink team. By the end, you will understand how to use Chainlink VRF to draw a random winner for your dApp.\n\n## What is Chainlink VRF?\n\nVRF stands for **Verifiable Random Function**, a technology that enhances cryptographic capabilities. Chainlink's implementation provides developers with improved scalability, flexibility, and usability. According to Richard, a developer advocate at Chainlink Labs, a key element of VRF is its **subscription model**.\n\n<img src=\"/foundry-lottery/6-chainlink-vrf/vrf1.png\" style=\"width: 100%; height: auto;\">\n\n## Walkthrough: Integrating Chainlink VRF\n\nTo wrap our heads around Chainlink VRF, we'll follow a well-detailed example using the Chainlink Labs documentation and one of their setup tutorials. This guide will help you:\n\n- Understand Chainlink VRF.\n- Create and fund a subscription.\n- Deploy a contract that uses VRF.\n- Make a request to draw a random number.\n\n### Getting Started with Chainlink VRF\n\nJump into the [Chainlink Documentation](https://docs.chain.link/) and navigate to the **VRF section**. In this guide, we're skipping everything else to focus on obtaining a random number.\n\n### Create &amp; Fund a Subscription\n\nTo use Chainlink VRF, you need to establish a subscription, which you can visualize as a bucket from which your contracts extract. Navigate to the **Subscription Manager** and create your subscription; you can input an email and project name for personalization.\n\nThe process requires confirmation on a **test network**. For simplicity, this guide uses the Sepolia test network referenced in most Chainlink documentation.\n\nIf you don’t already have ETH and link tokens, you can secure them from [Chainlink Faucets](https://faucets.chain.link/).\n\nOnce you've got your tokens, add funds to the subscription (e.g., 5 link tokens).\n\n### Adding VRF Consumers\n\nAt this point, you've created your subscription, poured in funds, and are ready to deploy your contract.\n\nYou need to let your subscription know about the contract you're deploying and vice versa. To help them work in synchrony, you add consumers to your subscription.\n\n<img src=\"/foundry-lottery/6-chainlink-vrf/vrf3.png\" style=\"width: 100%; height: auto;\">\n\n### Deploying a Chainlink VRF Contract\n\nReturn to the Chainlink documentation and click to open **Remix**, a development environment that enables you to deploy and interact with your contract on the blockchain.\n\nThe Chainlink VRF contract comprises various components:\n\n- **Contract imports**: Coordinator interface, Consumer base and Confirmed owner.\n- **Contract variables**: Subscription ID, Request IDs, Key hash, and more.\n- **Functions**: `RequestRandomWords()`, `FulfillRandomWords()`, `getStatusRequest()` etc.\n\nThe ultimate objective is to use the `RequestRandomWords()` function to call for random values from the Oracle network. Once those values are ready, the `FulfillRandomWords()` function allows you to process those values back in your contract.\n\nTo deploy the contract, specify your **subscription ID** and approve the transaction.\n\n<img src=\"/foundry-lottery/6-chainlink-vrf/vrf2.png\" style=\"width: 100%; height: auto;\">\n\n### Making a Request\n\nOnce you've deployed your contract, copy its address and register it as a consumer in your subscription.\n\nBack in Remix, call the `RequestRandomWords()` function and confirm.\n\nYour request will show as pending on the Subscription page. Completion times can vary based on the number of block confirmations you specified and the network you're using.\n\n### Confirming Request Completion\n\nTo check whether your request has been fulfilled, copy the ID from `lastRequest()` function, then use `getStatusRequest()` to get the current status.\n\n)Once your request is marked as 'Fulfilled,' you've successfully drawn ! your random values using Chainlink VRF.\n\nThe transcript calls a wrap at this point, but now that you know how to generate random numbers on the blockchain, the opportunities are limitless. You can assign random traits to NFTs, determine game asset allocations, and so much more.\n\n_Please note: Cloud-based RNGs are not recommended for high-value use-cases and a combination of on and off-chain RNGs can offer a robust solution._\n\nThat was it for todays lesson! I hope you enjoyed it and learned something new. If you have any questions, don't forget to ask on the Github Forum.\n",
          "updates": []
        },
        {
          "lessonId": "e1986802-cc3d-40ed-8cbc-12e9375eb206",
          "number": 7,
          "title": "Implement the Chainlink VRF",
          "slug": "implementing-chainlink-vrf",
          "folderName": "7-implementing-vrf",
          "description": "Tutorial on deploying and integrating Chainlink VRF in smart contracts for random number generation.",
          "duration": 17,
          "videoUrl": "igV7TVPEIQY",
          "rawMarkdownUrl": "/routes/foundry/4-smart-contract-lottery/7-implementing-vrf/+page.md",
          "markdownContent": "---\ntitle: Implementing Chainlink VRF\n---\n\n_Follow along with this lesson and watch the video below:_\n\n\n\n---\n\nToday, we will explore how to deploy a Chainlink Verifiable Random function (VRF) and integrate it into our existing code. It is a crucial element when we need to generate a random number within a blockchain application.\n\n## A Closer Look at Chainlink VRF\n\nBefore we dive into the process, let's take a closer look at Chainlink and its VRF.\n\nChainlink VRF provides auditable, transparent, and easily verifiable randomness in smart contract use-cases. It employs Verifiable Random Functionality, which takes a seed input to derive a Random output.\n\nThis process is done in a way that a third-party observer can public-verify the result, ensuring randomness that can't be biased or manipulated, because it leverages the security of the blockchain network itself.\n\nBrowse through the official [Chainlink documentation](https://docs.chain.link/docs/get-a-random-number/) to get a good first-hand experience of deploying and using Chainlink VRF. Different forms of usage are listed here, which will be explained below.\n\n## Getting Started with Chainlink VRF\n\nTo get started, fire up Remix and open the Chainlink documentation. Scroll down to the section titled `Get a Random Number` and look for the button labeled 'open in Remix'. This will bring up a code editor for you to modify.\n\nIn Remix, you will find pre-written code that uses the Sepolia chain as its default. Two primary methods are explained in the docs- one is Subscription, and the other is Direct Funding.\n\nSubscription is preferable as it scales better, as the contract pulls the link from a separate fund which you previously loaded up with the link.\n\n<img src=\"/foundry-lottery/7-implement/implement1.png\" style=\"width: 100%; height: auto;\">\n\nAfter setting up the subscription, you will promptly learn how to complete these steps programmatically, avoiding the need for navigating the user interface.\n\nThe primary goal is to add a randomization function. As developing with Chainlink VRF involves two transactions, the random number generation is also completed in two steps.\n\nFirstly, you send a request to generate a random number, followed by a second request to receive that random number. The request function signals Chainlink to select the lottery winner, while Chainlink returns the random number to the `callback` function, which announces the actual winner.\n\n## Implementing Random Number Function\n\nYou will find a code snippet in the 'Get a Random Number' section of the Chainlink documentation that will help you implement this random number fetch process.\n\nThe function call that enables this looks like this:\n\n```js\nuint256 requestId = i_vrfCoordinator.requestRandomWords(\n  keyHash,\n  s_subscriptionId,\n  requestConfirmations,\n  callbackGasLimit,\n  numWords\n);\n```\n\nThis is the code you will insert into the existing code. After pasting the code, you will observe a multitude of red lines- don't worry; these will be resolved shortly.\n\nThis function requires a coordinator address, which is the address of the Chainlink VRF Coordinator to whom the random number is requested. This `keyHash` is your 'gas lane', and is something you can specify if you don't wish to consume much gas. Your `subscriptionId` is essentially the ID that you previously loaded with link to create requests.\n\nThe `requestConfirmations` is the number of block confirmations after which your random number is considered good, and the `callbackGasLimit` ensures you don't overspend on the request. Finally, `numWords` indicates the number of random numbers you require.\n\nOn receiving the request, Chainlink will return a `requestId`.\n\n## Configuring the Constructor\n\nThe `keyhash` is subject to variation depending on the chain, so I prefer calling it the 'gas lane'. As it's a constant in your smart contract, add `gasLane` to the constructor, making it an immutable variable.\n\nYou will need the VRF coordinator's address, which is unique to each chain, and thus needs to be passed through the constructor and made an immutable variable.\n\nYour `subscriptionId` will be specific to your Chainlink VRF subscription often received from the constructor, and the number of confirmations can be set as a constant variable- three confirmations being a common choice. The max gas for the callback function can be limited to prevent excessive gas costs caused by the second transaction when returning the random number.\n\n<img src=\"/foundry-lottery/7-implement/implement2.png\" style=\"width: 100%; height: auto;\">\n\nFinally, since you will only require one random number for selecting a winner, you can set the `numWords` as the constant variable equal to one. Now, when you fire and use Chainlink VRF, you can efficiently make a request.\n\n## Receiving a Response From Chainlink\n\nImplementing randomness into your contract is not simply about making request for a random number from Chainlink, you also need to be set up to receive that number back by implementing the function: `fulfillRandomWords`. This function is called by the Chainlink node, and should be set up to execute a specific action with the received random number- in this context, it will be selecting a lottery winner.\n\n## Wrapping It Up\n\nIn summary, the steps to implement Chainlink VRF are as follows:\n\n1. Make a request to Chainlink for a random number.\n2. Chainlink sends back that random number to a specified function, using VRF.\n3. Use the returned random number to pick a user as the lottery winner.\n\nThis lesson covered a range of helpful tips on how to deploy Chainlink, so feel free to go back through to fully understand the process. Generating secure and verifiable random numbers within the blockchain is an essential capability, and hopefully you now feel comfortable in deploying this for your future smart contracts. As always, happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "023a2d78-25db-4e82-b91d-2e61a0a9ecb6",
          "number": 8,
          "title": "The modulo operation",
          "slug": "solidity-modulo-operation",
          "folderName": "8-modulo",
          "description": "Explanation of using the modulo operation for selecting random winners in smart contract games.",
          "duration": 6,
          "videoUrl": "Yuxpr_hX-lg",
          "rawMarkdownUrl": "/routes/foundry/4-smart-contract-lottery/8-modulo/+page.md",
          "markdownContent": "---\ntitle: Modulo\n---\n\n_Follow along with this lesson and watch the video below:_\n\n\n\n---\n\nIn this lesson, I'll walk you through how to use the modulo function for picking a winner randomly from a list of players in Solidity, a contract-oriented programming language for implementing smart contracts.\n\n## Understanding Modulo\n\nLet's discuss how the modulo function or 'mod' function works. Essentially, this function performs a division operation and returns the remainder after dividing.\n\nConsider the case where we divide 10 by 10 using the mod function. Since there is no remainder, the function returns zero. Conversely, if we divide 10 by 9, 9 out of the 10 are divided evenly leaving one left. In this case, 10 mod 9 equals one.\n\nThis logic can be extended to all numbers:\n\n- 2 mod 2 equals zero because 2 and 2 divide evenly.\n- 2 mod 3 equals one because there's one left over.\n- 2 mod 6 equals zero because 2 divides into 6 evenly.\n- 2 mod 7 equals one because there's one left over after 2 divides into 7 three times.\n\nThrough these examples, we can see that the modulo function helps us find the remainder of a division operation.\n\n## Modulo in Action\n\nLet's put the mod function into practice:\n\n```js\ncontract ExampleModulo {\n    function getModTen(uint _num) public pure returns(uint) {\n        return _num % 10;\n    }\n    function getModTwo(uint _num) public pure returns(uint) {\n        return _num % 2;\n    }\n}\n```\n\nIn this contract, we've got two simple functions, `getModTen` and `getModTwo`, that return the modulo ten and two of the given integer respectively.\n\nFor example, if we pass 123 into getModTen, it would return 3 because 120 divides evenly into ten leaving a remainder of 3. If we have a large number, say 102030405060708090, the function would return 2 because the number divides evenly into ten with a remainder of 2.\n\nUsing mod two gives us a different way to look at numbers. Any even number mod two will result in zero. If the number is odd, the result will be one.\n\n## Picking a Winner\n\nNow we're going to use the mod function to randomly select a winner from an array of players. Let's say `s_players` is of size ten and has ten players. We're generating a random number (RNG) to select the index for our winner.\n\n```js\nuint256 indexOfWinner = randomWords[0] % s_players.length;\n```\n\nIf our RNG is, say, twelve, we'll calculate `12 mod 10`, which equals two, and the player at index two in the array is our winner. Once we have the index of the winner, we write:\n\n```js\naddress payable winner = s_players[indexOfWinner];\n```\n\nThis returns the address of the randomly selected winner.\n\nBesides, we'll also keep track of the most recent winner, which helps in knowing who won most recently.\n\n```js\naddress private s_recentWinner;\ns_recentWinner = winner;\n```\n\n<img src=\"/foundry-lottery/8-modulo/mod1.png\" style=\"width: 100%; height: auto;\">\n\n## Transferring Rewards\n\nNow, let's transfer the winnings to the selected winner.\n\n```js\n(bool success,) = winner.call{value: address(this).balance}(\"\");\n```\n\nHere, we transfer the entire balance of the contract (which are the ticket sales) to the winner.\n\nTo ensure that transfer was successful:\n\n```js\nif (!success) {\n  revert RaffleTransferFailed();\n}\n```\n\nThis reverts the transaction and refunds the gas if the transfer isn't successful, ensuring the winner does not lose out.\n\nTo conclude, the modulo function helps to generate a random index within the length of the players array, resulting in a fair selection of the winner. This can be used in various blockchain-based games and applications to ensure a level playing field.\n\nStay tuned for more posts on coding smart contracts in Solidity!\n",
          "updates": []
        },
        {
          "lessonId": "1adf37cf-e707-49fb-bd19-55505e872df4",
          "number": 9,
          "title": "Implementing the lottery state - Enum",
          "slug": "solidity-enum-lottery-state",
          "folderName": "9-enum",
          "description": "Discussion on using enums to manage different states in a raffle smart contract.",
          "duration": 5,
          "videoUrl": "gIZyar2-zQM",
          "rawMarkdownUrl": "/routes/foundry/4-smart-contract-lottery/9-enum/+page.md",
          "markdownContent": "---\ntitle: Enum\n---\n\n_Follow along with this lesson and watch the video below:_\n\n\n\n---\n\nWhen we delve into developing applications like a raffle, managing the different states of the event is equally critical as the event itself. We will extend our previous discussion about picking a winner in the raffle and lead into governing who can enter the raffle. Of course, if we are currently awaiting a random number to determine the winner, it's not fair for anyone else to enter the raffle then, right?\n\nTo handle these kinds of situations, we need a mechanism in place—a check on the state of the raffle to determine if it's currently open or not. This is where `enums` step into the picture, offering a clean, readable, and maintainable solution.\n\n## An Introduction to the Concept of Enum\n\nBefore we start, a brief introduction to enums seems appropriate. An enum, also known as enumerated type, is a data type consisting of a set of unique elements. Enums provide an effective way to create and manage constant values throughout your contract. In other words, they help avoid scatter variables, such as bool calculating_winner = false, and group them into a single variable of type enum. For more details, [Solidity docs](https://solidity.readthedocs.io) give a glimpse into enum types.\n\n```js\ncontract Example {\n    enum ActionChoices {\n        GoLeft,\n        GoRight,\n        GoStraight,\n        SitStill\n        }\n    }\n```\n\nEvery enum creates a new type, like `ActionChoices` in this example, that can be used throughout the contract.\n\n### Creating Enums for Raffle State\n\nNow, back to our raffle contract. We will create an enum named `RaffleState` with two states—`open` and `calculating`.\n\n```js\nenum RaffleState {\n        OPEN,\n        CALCULATING\n    }\n```\n\nPoint to remember: Enum elements can be converted to integers. So here, `Open` would be 0 and `Calculating` would be 1. Adding more states will increment the integers equivalently.\n\nTo utilize this enum, we will create a `RaffleState` variable, named `s_raffleState`, storing the current state of the raffle.\n\n```js\nRaffleState private s_RaffleState;\n```\n\n### Default Setting and Transitioning States\n\nBy default, let's keep the raffle state `Open` (we do want the participants to rush in, don't we?). So, right in the constructor, assign the default state.\n\n```js\ns_raffleState = RaffleState.Open;\n```\n\nNow, extending our `enterRaffle` functionality, we will include a check to ensure the raffle is not in the `Calculating` state.\n\n```js\nif (s_raffleState != RaffleState.OPEN) {\n    revert Error(\"RaffleNotOpen\");\n}\n```\n\nAnd subsequently, declare this error at the beginning of your contract.\n\n```js\nerror RaffleNotOpen();\n```\n\nNow, no entries can be made while the contract is calculating a winner.\n\n### State Transition during Winner Calculation\n\nWhen it's time to choose the winner (`pickWinner`), we will shift the state to ‘Calculating’.\n\n```js\ns_raffleState = RaffleState.CALCULATING;\n```\n\nRemember, as long as we are waiting for the random number, no one is allowed to enter the raffle.\n\nAnd once we have our lucky winner(s), it's time to switch the raffle state back to `Open` — let the game begin again!\n\n```js\ns_raffleState = RaffleState.OPEN;\n```\n\nSo your raffle is **open** to the public again … the adrenaline rush continues, building up to the next exciting round of winner selection!\n\n## Conclusion\n\nEnums offer a compact, clear way of representing and managing different states within your contracts. In our raffle example, we used this powerful feature to control who can enter the raffle and when. By using enums, we make our contracts more readable and modular and ensure they follow good programming practices. Make sure you use this feature to its fullest when programming your next Solidity contract!\n",
          "updates": []
        },
        {
          "lessonId": "6ded233d-f088-4db0-aa90-aab75f471d44",
          "number": 10,
          "title": "Lottery restart - Resetting an Array",
          "slug": "resetting-array",
          "folderName": "10-resetting-array",
          "description": "Exploration of resetting player arrays in smart contracts to start new game rounds.",
          "duration": 2,
          "videoUrl": "3xHdIO-FCOE",
          "rawMarkdownUrl": "/routes/foundry/4-smart-contract-lottery/10-resetting-array/+page.md",
          "markdownContent": "---\ntitle: Resetting an Array\n---\n\n_Follow along with this lesson and watch the video below:_\n\n\n\n---\n\nIn this lesson, we will delve into the deeper components of smart contract design by focusing on starting a new game or resetting a stage in a lottery game. An essential factor to consider here is to ensure that no old players from the previous round can participate in the new lottery round without entering.\n\n### Resetting the Player Array\n\nFirstly, the player's array, denoted as `s_players`, needs to be reset for every new lottery round. If left untouched, `s_players` would still hold players from the previous lottery, allowing them to participate in new rounds without necessarily entering again – a loophole we definitely want to avoid!\n\nHere's how to do that:\n\n```javascript\n// Initialize new player array\ns_players = new address payable[](0);\n```\n\nThis code resets the `s_players` array into a new empty array. With this, we're all set to start accepting players for the new round!\n\n### Ticking Off The New Round's Timestamp\n\nNext, to keep track of when the new lottery round begins, we update the `s_last_timestamp` with the current block timestamp.\n\n```javascript\n// Update the timestamp\ns_last_timestamp = block.timestamp;\n```\n\nWith the timestamp updated, the clock automatically starts ticking for the new lottery round.\n\n### Emitting an Event on Winner Declaration\n\nAfter successfully resetting the state and declaring a winner, it is generally a good practice to emit a log event. This creates a simple and efficient way to inform anyone interested about the winner and can be useful for debugging or auditing contract executions.\n\nLet's create a new event called `WinnerPicked()`:\n\n```javascript\n// Creating new event\nevent WinnerPicked(address indexed winner);\n```\n\nHowever, to better capture the process, we can change the name from `WinnerPicked` to `PickedWinner`. Sounds more like an action, right?\n\n```javascript\n// Emitting the event\nemit PickedWinner(most_recent_winner);\n```\n\nThis emits a `Picked Winner` log with the winner's address every time a new lottery round begins.\n\nTo conclude,\n\n<img src=\"/foundry-lottery/10-array/array1.png\" style=\"width: 100%; height: auto;\">\n\nWhile there's no standardized naming convention for events in smart contracts, it's a good idea to keep names consistent, meaningful, and action-derived.\n\nThat sums up how to restart a new lottery round in a smart contract. Incorporating these practices in your future Ethereum smart contracts will ensure fair gaming and accurate auditing.\n",
          "updates": []
        },
        {
          "lessonId": "896f5895-3b03-4098-8852-857e03996efd",
          "number": 11,
          "title": "Important: Note on learning by building",
          "slug": "note-on-building",
          "folderName": "11-note-on-building",
          "description": "Insights into the true process of building solidity projects, highlighting the iterative nature of coding.",
          "duration": 2,
          "videoUrl": "DdVkEdkNwT4",
          "rawMarkdownUrl": "/routes/foundry/4-smart-contract-lottery/11-note-on-building/+page.md",
          "markdownContent": "---\ntitle: Note on Building\n---\n\n_Follow along with this lesson and watch the video below:_\n\n\n\n---\n\nWhen it comes to building solidity projects, things may seem a bit too linear or straightforward when you watch a demo or read a tutorial. You may assume that I just go straight from the start to the finish without pausing, but this isn't always the case. In this piece, We aim to peel back the curtain and reveal the actual process — back and forth movements, the surprises, and the frequent pausing for debugging that are the actual hallmarks of building solidity projects effectively.\n\n## Breaking the Illusion of Once-through Coding\n\nFirstly, my seeming seamless way of doing these demos is not indicative of what normally happens when I code. It appears as if I am easily writing this contract from the beginning to the end, but that's far from the reality.\n\nHere, you might be impressed with how quickly and seamlessly we are coding this contract, but don't be fooled - it's not typical to write a contract in one go. In fact, it's not even possible to write a contract in one go. It's a process of writing, testing, and refactoring.\n\nBut the reality behind this façade is that We've carried out such demonstrations repeatedly. We've written this code countless times and spent vast hours refining our skills in solidity.\n\n## \"Piece by Piece\" Methodology\n\nWhen coding, rather than tackling the entire project as a whole, it's often beneficial to break it down. Rather than writing a contract in one go, which can be incredibly challenging, I find myself writing a deploy script and testing individual components of the contract, part by part as I build it.\n\n```markdown\n// As an example, at this point in my coding, I probably would have written tests\n// for various functions such as 'get entrance fee', 'pick winner' and 'enter raffle'.\n```\n\nWriting tests while coding is incredibly beneficial. In fact, it's a necessary practice when writing real projects. However, in this demonstration, I won't be writing tests or deploying scripts immediately.\n\nThe reason isn't that these steps aren't important — they absolutely are — but rather because we'll be performing extensive refactoring as we progress, and it's pointless to write tests for code that will soon be modified or discarded.\n\n## Understanding the Real Coding Project\n\nI must emphasize that this modeling doesn't portray reality accurately. True, it breaks down the functions and processes into understandable pieces. However, it veils the moments of debugging, the constant going back-and-forth, the nights when the code doesn't compile, and you can't figure out why.\n\n```markdown\n// When you're coding a real project, you may encounter setbacks like compilation errors and other bugs\nthat may require you to troubleshoot and refactor your program.\n```\n\nHowever, here is an essential truth:\n\n<img src=\"/foundry-lottery/11-building/build1.png\" style=\"width: 100%; height: auto;\">\n\nSo, as you journey through coding projects, remember to take a deep breath and hop back into it whenever you experience any of these hitches. It's okay, and it's good. It means you're learning, and with every bug fixed or problem solved, you become a better programmer.\n\nSo next time you see me sailing through a demo or tutorial, remember there's more to it than meets the eye. Happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "1eb044f4-5ca5-49ff-a426-2d428dc7db5c",
          "number": 12,
          "title": "The CEI method - Checks, Effects, Interactions",
          "slug": "cei-method-checks-effects-interactions",
          "folderName": "12-cei",
          "description": "An overview of the Checks-Effects-Interactions pattern for secure and efficient smart contract development.",
          "duration": 3,
          "videoUrl": "rGbrYvJtOdc",
          "rawMarkdownUrl": "/routes/foundry/4-smart-contract-lottery/12-cei/+page.md",
          "markdownContent": "---\ntitle: Checks, Effects, and Interactions\n---\n\n_Follow along with this lesson and watch the video below:_\n\n\n\n---\n\nIn this lesson, we'll explore a critical design pattern that every smart contract developer needs to know - the Checks-Effects-Interactions (CEI) pattern. By adhering to this pattern, you'll ensure your smart contracts are more secure and maintainable.\n\n## Understanding the Checks-Effects-Interactions (CEI) Pattern\n\nCoding smart contracts requires a particular style called Checks-Effects-Interactions or CEI. This is one of the several design patterns that smart contract developers need to maintain in their coding processes. Following the CEI pattern increases the overall security of your contracts.\n\nThe CEI pattern involves three detailed steps:\n\n1. **Checks:** This is the initial step where you do all your validations or checks. An example could be your `requires` or `if-then` errors. Generally, it's more efficient to place these checks at the very beginning of your contract. The reason is they are more gas-efficient. In a situation where you need to revert, doing so at this stage will save more gas than performing other computations only to revert later.\n\n   <img src=\"/foundry-lottery/12-cei/cei1.png\" style=\"width: 100%; height: auto;\">\n\n2. **Effects:** In this step, you make changes or \"effects\" within your own contract.\n3. **Interactions:** This final step involves interactions with other contracts. One crucial point to note here is it's best to interact with outside contracts last.\n\nOne of the reasons to follow this pattern is to avoid reentrancy attacks, a common vulnerability in smart contracts. Understanding and implementing the CEI pattern early on means you're proactively safeguarding your contracts from potential attacks.\n\n## Effective Handling of External Interactions and Events\n\nWhile discussing the third step of the CEI pattern – interactions, we should touch on the usage of events and their placement in the code. Emitting an event at the end might seem like an external interaction, but it's not. It would be best to move it before we have any interactions with external contracts.\n\n<img src=\"/foundry-lottery/12-cei/cei2.png\" style=\"width: 100%; height: auto;\">\n\nThere can be a debate about the position of events. Some developers prefer positioning them after the interactions. However, if we take a look from the code review or audit perspective, it's usually recommended to place the event before the external interactions, largely because of several reasons that we'll cover in subsequent blog posts.\n\nIn conclusion, the Checks-Effects-Interactions (CEI) pattern is a cornerstone of secure, gas-efficient smart contract development. Remember this design pattern and apply it consistently when developing your smart contracts: always do your checks first, followed by the effects, and finally perform external interactions. Following this approach is a step in the right direction towards ensuring you're always delivering robust and secure smart contracts.\n",
          "updates": []
        },
        {
          "lessonId": "4ccf702a-906a-4dae-a78d-cc692656a4cd",
          "number": 13,
          "title": "Introduction to Chainlink Automation",
          "slug": "chainlink-automation",
          "folderName": "13-chainlink-automation",
          "description": "This lesson covers the basics of Chainlink Automation, essential for automating the 'Pick Winner' function in a lottery application. It delves into the use of Chainlink VRF for randomness and explores time-based automation and custom logic through Chainlink.",
          "duration": 16,
          "videoUrl": "6-bmw6VHZ6Q",
          "rawMarkdownUrl": "/routes/foundry/4-smart-contract-lottery/13-chainlink-automation/+page.md",
          "markdownContent": "---\ntitle: Chainlink Automation Introduction\n---\n\n_Follow along with this lesson and watch the video below:_\n\n\n\n---\n\nWe've been working towards building a lottery application with Chainlink VRF to handle the randomness needed to pick a winner. So far, we've developed a `Pick Winner` function which initiates a Chainlink VRF call and carries out the `fulfill` function to generate a random number and select a winner from the lot. However, the current flow has an issue; the `Pick Winner` function isn’t called automatically - leaving it up-to manual intervention.\n\nThis is where the beauty of automation kicks in. As software engineers, we aim for efficient and effective solutions. Speaking of efficiency, I’d like to introduce you to **Chainlink Automation**, which will allow us to automatically run our `Pick Winner` function.\n\n## Using Chainlink Automation\n\nThe [Chainlink documentation](https://docs.chain.link/chainlink-automation/introduction) provides a wealth of information when it comes to automation. We can access guides from the `Automation` tab present on the left-hand panel. For our purpose, we'll be exploring the `Time Based` automation and `Custom Logic` sections.\n\nAlthough this guide shows how to work with Chainlink from the UI, we will be primarily approaching this programmatically - remaining true to our prudent working style!\n\nIf we scroll down, we can find an example of a contract named `Create Compatible Contracts` suitable for use with Chainlink automation. Either you can try it out in the Remix IDE yourself or we can collectively go through a video where Richard, one of the developer advocates at Chainlink Labs, explains Chainlink Automation and conducts a demonstration.\n\n## Exploring Automatic Keepers\n\nIn this video, Richard provides a walkthrough on updates to Chainlink’s Keepers, starting with how to connect a wallet from the Chainlink Keepers UI, registering a new upkeep, and implementing time-based trigger mechanisms.\n\nThe `Keepers Chainlink` page has changed a bit, but it’s quite straightforward. Upon registering a new upkeep, you will find the `trigger` option. As Richard explains, this option is extremely useful for implementing timed-based triggers which was formerly achieved by checking upkeep with block hashes.\n\nAfter connecting the wallet and setting up the Keepers, the next step is to work on a simple contract known as `Keeper compatible contracts`. If you’ve worked with previous versions, you'll recognize the `check Upkeep function` and `perform Upkeep function`.\n\n## Modifying the Contract\n\nTime to roll up our sleeves and modify this sample contract. As explained, `Remix` is an online IDE for developing solidity smart contracts, which we will be using to modify our existing contract. We aim to create the same functionality in an easier, more readable way.\n\nStarting with a contract count function that doesn’t require any external input, we aim to increment the counter at regular intervals. Notably, with time-based triggers, we can get rid of the `check upkeep` function and `perform upkeep` function.\n\nUpon getting rid of unnecessary functions, the contract is compiled, displaying a green checkmark for successful compilation. From there, constructor values are set and deployed. In this case, the contract was deployed to the `Fuji Avalanche Test Network`.\n\n## Using Keepers in Practice\n\nNext, we head to the `Keepers` interface and fill necessary details like the address of our contract and schedule for triggering in terms of Cron syntax. Post registration, you may need to receive some link tokens - which you can get from the faucet linked from the register page.\n\nAfter registering and making necessary confirmations, the interface will present a page detailing the upkeep, historical data, and options for editing gas limits or adding more link tokens.\n\nJust like that, using Chainlink Keepers, we're able to automate our smart contracts! Tiny contracts that are easy to understand and cleaner, just how we like them.\n\n<img src=\"/foundry-lottery/13-automation-intro/automation1.png\" style=\"width: 100%; height: auto;\">\n",
          "updates": []
        },
        {
          "lessonId": "28181c1e-a98a-47a4-b2f3-a246b5e6c62f",
          "number": 14,
          "title": "Implementing Chainlink Automation",
          "slug": "implementing-automation-2",
          "folderName": "14-implementing-automation-2",
          "description": "Focusing on implementing Chainlink Automation, this lesson teaches how to use `checkUpkeep` and `performUpkeep` functions for automated execution in Chainlink-powered smart contracts, enhancing their autonomy and efficiency.",
          "duration": 10,
          "videoUrl": "Y-Fl9kQtPHo",
          "rawMarkdownUrl": "/routes/foundry/4-smart-contract-lottery/14-implementing-automation-2/+page.md",
          "markdownContent": "---\ntitle: Implementing Chainlink Automation\n---\n\n_Follow along with this lesson and watch the video below:_\n\n\n\n---\n\n### Defining the Setup Functions\n\nTo implement Chainlink automation, we utilize two key functions: `checkUpkeep` and `performUpkeep`. These functions will allow our Chainlink nodes to automatically start the lottery whenever necessary.\n\nCurrently, our code includes a function named `pickWinner`. We will modify this function to permit Chainlink Automation to initiate contract calls as opposed to the manual initiation process currently in place.\n\n### Creating the `checkUpkeep` function\n\nOur first step is to create a `checkUpkeep` function. This function notifies the Chainlink nodes when it's due time to call `Perform upkeep`.\n\nTypically, the function definition may look something like this:\n\n```js\nfunction checkUpkeep(bytes memory checkData) public view\nreturns (bool upkeepNeeded, bytes memory performData) {}\n```\n\nAt a basic level, the function checks several conditions:\n\n- If the required time interval between raffle games has passed.\n- If the raffle is in the open state\n- If the contract has any ETH (meaning there are players)\n- If the subscription is funded with LINK.\n\n### Creating the `performUpkeep` function\n\nOnce `checkUpkeep()` has determined it's time for an update, it's the `performUpkeep()` function's task to trigger the actual update.\n\nThe performUpkeep function first verifies if it is indeed time to initiate an update by calling `checkUpkeep`. If the check is not passed, it will revert with a custom error called `raffle upkeep not needed`.\n\nHere's a basic implementation of the `performUpkeep` function:\n\n```javascript\nfunction performUpkeep(bytes calldata /* performData */) external override {\n        (bool upkeepNeeded, ) = checkUpkeep(\"\");\n        // require(upkeepNeeded, \"Upkeep not needed\");\n        if (!upkeepNeeded) {\n            revert Raffle__UpkeepNotNeeded(\n                address(this).balance,\n                s_players.length,\n                uint256(s_raffleState)\n            );\n        }\n        s_raffleState = RaffleState.CALCULATING;\n        uint256 requestId = i_vrfCoordinator.requestRandomWords(\n            i_gasLane,\n            i_subscriptionId,\n            REQUEST_CONFIRMATIONS,\n            i_callbackGasLimit,\n            NUM_WORDS\n        );\n        // Quiz... is this redundant?\n        emit RequestedRaffleWinner(requestId);\n    }\n```\n\n### Conclusion\n\nBy setting these functions in your contract, you can make your smart contracts more autonomous and efficient. Eliminating the need for manual interaction with your contracts enhances their performance greatly.\n\nSuccessfully compiling this script demonstrates how Chainlink automation can be adopted to automatically trigger our lottery. Consequently, we can entirely entrust Chainlink to do the heavy lifting of handling our raffle game schedules.\n\n<img src=\"/foundry-lottery/14-automation/auto1.png\" style=\"width: 100%; height: auto;\">\n",
          "updates": []
        },
        {
          "lessonId": "d02f2d11-7ac8-4346-bd99-3a8f3c419fd6",
          "number": 15,
          "title": "Mid section recap",
          "slug": "lottery-mid-lesson-recap",
          "folderName": "15-mid-lesson-recap",
          "description": "A recap of the progress in developing a fair and transparent lottery system using Chainlink's VRF. The lesson revisits key concepts like the raffle contract, buying into the raffle, and the decentralized draw process.",
          "duration": 2,
          "videoUrl": "K253axaJs4k",
          "rawMarkdownUrl": "/routes/foundry/4-smart-contract-lottery/15-mid-lesson-recap/+page.md",
          "markdownContent": "---\ntitle: Mid-Lesson Recap\n---\n\n_Follow along with this lesson and watch the video below:_\n\n\n\n---\n\n# Decoding our Smart Contract: A Dive into Chainlink VRF\n\nCongrats on making it this far! You're earning your stripes as a blockchain developer. Let's take a step back and review what you've accomplished so far, draft a roadmap for what's next, and allow the elegance of your well-written smart contract to sink in.\n\n)## The 'Raffle Contract' - Going Beyond Vanilla\n\nYour robust 'raffle contract' trusts Chainlink's VRF (Verifiable Random Function) to find its random number, ensuring fairness and opacity - the two pillars of any lottery system. Revealing the inner workings, you find a wealth of state variables and a detailed, attention-demanding constructor. Worth noting, this constructor is laying the groundwork for the rest of your smart contract.\n\n## Buying into the Raffle &amp; Ensuring FairPlay\n\nThen comes the 'enter raffle' function, which is instrumental in ticket purchasing while certifying that only players who have paid the appropriate entrance fee can enter, thus maintaining the sanctity of the game. Your players are then added to the list (array) of contestants who are a lucky draw away from the prize.\n\nAfter an adequate timeframe, the 'checkUpkeep' swings into action. Curious how it's signaled when to move? Stick with me! Once certain conditions are met, such as the elapsing of time and players entering the raffle, this function is invoked.\n\n## The Decentralized Draw\n\nHere's where things heat up! If 'checkUpkeep' returns true - indicating that it's time for the lottery draw - Chainlink nodes, working in unison in a decentralized environment, will execute the 'perform upkeep' function, sparking a request to Chainlink.\n\nNow, it's time to wait a couple of blocks. Our VRF does need a moment to crunch those numbers, after all.\n\n## Winner Announcement &amp; Reset\n\nOnce the Chainlink node responds, it triggers the `fulfillRandomness` function. This function embarks on the crucial task of choosing a random winner from our player array. Once the lucky winner is picked, the system resets for the next raffle.\n\nBoom! You've just completed your minimalistic, but provably fair smart contract. And even better, you've got a lottery system that runs on rock-solid principles of fairness.\n\n<img src=\"/foundry-lottery/15-recap/recap1.png\" style=\"width: 100%; height: auto;\">\n\nSo grab yourself a coffee and take a breather, you've done great so far! We'll catch up soon, where we’ll walk through further fascinating aspects of blockchain technology. Not just fair, your code is a work of art - keep it coming!\n\n## Next Steps and Interesting Reads\n\nIn our next module, we'll delve deeper into more advanced blockchain concepts and how to improve upon our existing code. Trust me, the rabbit hole goes much, much deeper! Till then, here are some interesting reads to keep the ball rolling:\n\n- [Understanding ChainLink](https://www.chain.link)\n- [Blockchain and Its Many Uses](https://www.ibm.com/topics/blockchain)\n- [Smart Contracts: The How-To](https://ethereum.org/greeter)\n\nWith this, we wrap up our journey through the 'Raffle Contract.' Here's to more code, more learning, and to building an efficient, fair lottery!\n",
          "updates": []
        },
        {
          "lessonId": "0b490f27-ba53-435f-ac70-a67eb4fe0146",
          "number": 16,
          "title": "Tests and deploy the lotterys smart contract pt.1",
          "slug": "tests-and-deploy",
          "folderName": "16-tests-and-deploy",
          "description": "This lesson emphasizes the importance of testing and deploying smart contracts efficiently. It guides through creating deploy scripts and testing them on various networks, ensuring reliable and secure deployment of lottery contracts.",
          "duration": 8,
          "videoUrl": "u5V49-7YxkQ",
          "rawMarkdownUrl": "/routes/foundry/4-smart-contract-lottery/16-tests-and-deploy/+page.md",
          "markdownContent": "---\ntitle: Test and Deploy Script\n---\n\n_Follow along with this lesson and watch the video below:_\n\n\n\n---\n\nBefore we dive into writing tests to confirm the functionality and performance, We'd like to cover the need for additional getter functions which will make our code even more efficient. However, the main focus will be on developing sound, fail-safe test cases.\n\n## Plan for Writing Test Cases\n\nHere's our comprehensive plan:\n\n1. Write deploy scripts\n2. Write tests that will work on a local chain, a forked testnet, and a forked mainnet in tandem with our deployment scripts.\n\nSo, let's proceed without further ado!\n\n## Writing the Deploy Script\n\nLet's start by creating our deploy script. To do this, simply go to scripts, create a new file and name it: `DeployRaffle.sol`. Here we will define our SPDX license identifier as MIT. We will need to import a script from `forge-std/Script.sol`.\n\nRemember to run a sanity check by building our contract in the terminal. We need to specify our compiler version (0.8.18 in this instance) using the pragma solidity directive for it to work perfectly!\n\n```bash\npragma solidity 0.8.18;\n```\n\n<img src=\"/foundry-lottery/16-deploy/deploy1.png\" style=\"width: 100%; height: auto;\">\n\n## Creating the Run Function\n\nWe need to create a `run` function that will return our `Raffle` contract.\n\n```js\nfunction run() external returns (Raffle, HelperConfig) {}\n```\n\n## Writing the Deployment Script\n\nWhen writing down the deployment script, it's important that we refer back to the `Raffle` contract parameters as they are vital to the process. These parameters include an entrance fee, interval, VRF coordinator, gas lane, subscription ID, and callback gas limit.\n\nAs each of these parameters will vary depending on the chain used, a helper config file needs to be set up. This file will store these parameters, ensuring flexibility for deployment to any chain. Time to create a new file named: `Helperconfig.sol`.\n\n## Creating the HelperConfig Contract\n\nIn `Helperconfig.sol`, we'll create a `struct` called NetworkConfig. This struct will be populated with the parameters needed for each specific network we plan to deploy our protocol on - such as Sepolia and Anvil.\n\n```shell\ncontract HelperConfig is Script {\n     struct NetworkConfig {\n        uint64 subscriptionId;\n        bytes32 gasLane;\n        uint256 automationUpdateInterval;\n        uint256 raffleEntranceFee;\n        uint32 callbackGasLimit;\n        address vrfCoordinatorV2;\n        address link;\n        uint256 deployerKey;\n    }\n}\n```\n\n## Creating Network-Specific Config Functions\n\nFor both Sepolia and Anvil, we'll define corresponding `get` functions, `getSepoliaETHConfig` and `getAnvilETHConfig`, which return network specific configurations.\n\n```js\n function getSepoliaEthConfig()\n        public\n        view\n        returns (NetworkConfig memory sepoliaNetworkConfig)\n    {\n        sepoliaNetworkConfig = NetworkConfig({\n            subscriptionId: 0, // If left as 0, our scripts will create one!\n            gasLane: 0x474e34a077df58807dbe9c96d3c009b23b3c6d0cce433e59bbf5b34f823bc56c,\n            automationUpdateInterval: 30, // 30 seconds\n            raffleEntranceFee: 0.01 ether,\n            callbackGasLimit: 500000, // 500,000 gas\n            vrfCoordinatorV2: 0x8103B0A8A00be2DDC778e6e7eaa21791Cd364625,\n            link: 0x779877A7B0D9E8603169DdbD7836e478b4624789,\n            deployerKey: vm.envUint(\"PRIVATE_KEY\")\n        });\n    }\n\n```\n\nRemember, for the Anvil network, we'll be working with mocks, a kind of 'just-for-test' dummy data that emulates the behavior of real data. This makes the Anvil network a bit more involved, but equally as important.\n\n## Conclusion\n\nThe deployment of intelligent contracts has been simplified through the use of helper function configuration and smart deployment. The key is defining the correct network parameters for the chain of interest, and ensuring accurate deployment, as demonstrated with our Ethereum-based Raffle app. This process, although demanding, ensures that code deployment becomes seamless, regardless of the network chain used.\n\nStay tuned to see how our test cases perform in different network environments!\n\n<img src=\"/foundry-lottery/16-deploy/deploy2.png\" style=\"width: 100%; height: auto;\">\n",
          "updates": []
        },
        {
          "lessonId": "0abda7e1-6960-471e-9109-c23a26d116c1",
          "number": 17,
          "title": "Deploy a mock Chainlink VRF",
          "slug": "deploy-mock-chainlink-vrf",
          "folderName": "17-mock-chainlink-vrf",
          "description": "The focus of this lesson is on deploying a mock Chainlink VRF, vital for testing smart contracts. It provides insights into setting up mock contracts, adjusting parameters, and the importance of Chainlink VRF in blockchain development.",
          "duration": 5,
          "videoUrl": "2LwfdDw43Bk",
          "rawMarkdownUrl": "/routes/foundry/4-smart-contract-lottery/17-mock-chainlink-vrf/+page.md",
          "markdownContent": "---\ntitle: Mock Chainlink VRF\n---\n\n_Follow along with this lesson and watch the video below:_\n\n\n\n---\n\nGreetings, everyone! If you've been following our journey so far, you may recall that we recently moved from creating and running code completely on a chain from scratch, like Sepolia, to trying it out on a forked testnet. Now, our exploration takes us further. The question before us today is -\n\n<img src=\"/foundry-lottery/17-mock/mock1.png\" style=\"width: 100%; height: auto;\">\n\n## The Battle Preparations\n\nTo start with, we need several different contracts. At the very least, we definitely need a VRF (Verifiable Random Function) Coordinator. So, let's dive in and see how we can deploy our own VRF Coordinator.\n\nIn our Lib folder `chainLink-brownie-contracts/contracts/SRC/0.8`, we can start looking for this significant VRF code. This is where we'll find a treasure trove of mocks.\n\n## Unveiling the Mocks\n\nIn fact, there's a specific folder titled `VRFCoordinatorV2Mock` amongst these mocks. The brilliance here is that we can directly use this in our tests, instead of crafting one ourselves. Chainlink VRF has indeed done the job for us.\n\nHence, let's exploit this VRF Coordinator v Two mock that is already in place. The next step in our process is to deploy this mock, which leads us to...\n\n## Deploying the Mock\n\nWe can find the import pathway in the location `@chainlink/contracts/src/v0.8/mocks/VRFCoordinatorV2Mock.sol`.\n\nWith that, we are now equipped to deploy it using a ` vm.stopBroadcast();`. This is vital to deploy to any network.\n\n## Constructor Parameters\n\nDelving into the VRF Coordinator, we are made aware that it requires two important parameters - a base fee and a gas price link. For all your Chainlink VRF interactions, payments are made in Chainlink tokens or link tokens. That is the fundamental principle we are operating upon here.\n\nThe base fee encapsulates a flat fee, while the gas price link represents the amount of link tokens gained for each additional piece of gas you use. It is crucial to remember that when the Chainlink node calls back, the Chainlink node is responsible for the gas costs, and it gets reimbursed in link tokens, based on the gas price link parameter.\n\n## Wrapping Up\n\nAnd voila! We’ve successfully set up a Sepolia config and an anvil config with our mock contracts. The primary variation between Sepolia and Anvil is the different VRF coordinator mocks. This might be a challenging venture if one is new to the crypto world, but with time, patience and a tutorial like this, it becomes more accessible. Tune in next time for more exciting exploration of decentralized digital wonders!\n\nStay curious, stay knowledgeable and happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "6d7b200e-2f00-4f5a-93fc-c11051574b88",
          "number": 18,
          "title": "Tests and deploy the lotterys smart contract pt.2",
          "slug": "tests-and-deploy-2",
          "folderName": "18-tests-and-deploy-2",
          "description": "Continuing from the previous part, this lesson dives deeper into testing and deploying lottery smart contracts. It covers the usage of helper configurations and the integration of network-specific configurations for smooth deployment.",
          "duration": 9,
          "videoUrl": "vhKalATGI40",
          "rawMarkdownUrl": "/routes/foundry/4-smart-contract-lottery/18-tests-and-deploy-2/+page.md",
          "markdownContent": "---\ntitle: Test and Deploy Continued\n---\n\n_Follow along with this lesson and watch the video below:_\n\n\n\n---\n\n## The Helper Configurations\n\nFirstly, we need to import the helper configurations we previously made. We do this by adding:\n\n```js\nimport { HelperConfig } from \"./HelperConfig.s.sol\";\n```\n\nOnce we have the helper configurations in our workspace, we'll use them to deploy a new helper configuration. Here, we'll define `helperConfig` as a new instance of the HelperConfig class. Something like this:\n\n```javascript\n HelperConfig helperConfig = new HelperConfig(); // This comes with our mocks!\n```\n\nOnce the helper configuration is created, we're going to need to pull parameters from it based on the active network config. Here's the interesting part: we'll be deconstructing the `networkConfig` object into underlying parameters. This means extracting individual pieces of information from the network configuration and assigning them to new variables in our current scope.\n\nThe resulting code snippet looks like this:\n\n```javascript\n(\n    uint64 subscriptionId,\n    bytes32 gasLane,\n    uint256 automationUpdateInterval,\n    uint256 raffleEntranceFee,\n    uint32 callbackGasLimit,\n    address vrfCoordinatorV2,\n    address link,\n    uint256 deployerKey\n) = helperConfig.activeNetworkConfig();\n```\n\n## Starting The Virtual Machine Broadcast\n\nNow we have configured the helper configurations and deconstructed into smaller values. Now, we're ready to begin the virtual machine (VM) start broadcast.\n\n```javascript\nVM.startBroadcast();\n```\n\nThe VM will begin by instantiating a new Raffle contract. Parameters for the new Raffle contract are passed to the constructor, in the exact order expected by the constructor. They include `entranceFee`, `interval`, `VRFCoordinator`, `gaslane`, etc.\n\nAfter the new Raffle contract is created, the virtual machine stops the broadcast.\n\n```javascript\nVM.stopBroadcast();\n```\n\nAt this high level, the code should be good to go.\n\n## The Subscription ID\n\nBut we need to clarify one thing. You need a subscription ID. You can either get it from the user interface (UI) or generate it in your deployment script. Being a developer, I would prefer my script does everything for me. But of course, you can fetch it directly from the UI if that works better for you.\n\nHowever, we will pretend for now that this deployment script is working, even though it isn't, and begin writing unit tests.\n\n## Writing Unit Tests\n\nBuckle up, because it's time to write some tests! We'll start by creating two directories - one for unit tests, and another for integration tests.\n\nWithin our `unit_tests` directory, we'll create a new file `RaffleTest.t.sol`. This test file will include all of the necessary components for running a comprehensive test of our deployment script.\n\nThe structure of the test function includes the set up for the test environment, calls the deployment script, and tests to ensure that important variables are outputted correctly.\n\n```javascript\n function setUp() external {\n        DeployRaffle deployer = new DeployRaffle();\n        (raffle, helperConfig) = deployer.run();\n        vm.deal(PLAYER, STARTING_USER_BALANCE);\n\n        (\n            ,\n            gasLane,\n            automationUpdateInterval,\n            raffleEntranceFee,\n            callbackGasLimit,\n            vrfCoordinatorV2, // link\n            // deployerKey\n            ,\n\n        ) = helperConfig.activeNetworkConfig();\n    }\n```\n\nIn addition, we want to create a starting player, with a distinct address and initial balance of 10 ETH, to interact with the Raffle contract.\n\n```javascript\naddress public PLAYER = makeAddr(\"player\");\nuint256 public constant STARTING_USER_BALANCE = 10 ether;\n\n```\n\n## Checking The Deployment\n\nLastly, we want to test our deployments. To do so, we need to get all our parameters from the HelperConfig. Best practice would be to return both the newly deployed Raffle and the HelperConfig variables. That way, our tests have access to the exact same variables that were inputted during the Raffle's deployment.\n\n<img src=\"/foundry-lottery/18-test/test1.png\" style=\"width: 100%; height: auto;\">\n\n## Sanity Check\n\nFinally, let's run a quick sanity test to ensure that our raffle initializes in the `open` state. This can be done with a simple function that asserts that the state of the Raffle contract is `open`.\n\nAside from confirming the successful deployment of our Raffle contract, this test will also help verify that our HelperConfig and deployment script are working as expected.\n\nHere's what the function looks like:\n\n```javascript\n function testRaffleInitializesInOpenState() public view {\n        assert(raffle.getRaffleState() == Raffle.RaffleState.OPEN);\n    }\n```\n\nCongratulations! We've successfully written our deployment script and unit test. Now we can run our test suite and confidently deploy contracts on any specific networks, thanks to our HelperConfig configuration. Well done and stay tuned for the next post in our series!\n",
          "updates": []
        },
        {
          "lessonId": "7be9d513-2092-4406-8eff-045e1589265c",
          "number": 19,
          "title": "Setup the tests",
          "slug": "setup-solidity-lottery-tests",
          "folderName": "19-lots-of-tests",
          "description": "This lesson teaches the setup and execution of tests for smart contracts, emphasizing the significance of forge coverage and the Arrange-Act-Assert methodology to ensure robust and reliable smart contract functionality.",
          "duration": 5,
          "videoUrl": "7YhgCI_x_x4",
          "rawMarkdownUrl": "/routes/foundry/4-smart-contract-lottery/19-lots-of-tests/+page.md",
          "markdownContent": "---\ntitle: Lots of Tests\n---\n\n_Follow along with this lesson and watch the video below:_\n\n\n\n---\n\nLet's shift our focus towards a programmatic approach to software development. One of the best ways to write robust, reliable code begins with writing some solid tests for it. At this point in your development journey, you may be thinking, \"Where do I start?\" Let's dive into creating tests with forge coverage.\n\nBefore starting, it's worth mentioning that coverage isn't the be-all and end-all of software testing, but the more you practice writing tests, the better your software will be. Along the way, you'll also pick up nifty tips and tricks that will help you write better code and better tests.\n\n## Start with Simple Test: Validate `EnterRaffle` Function\n\nAs an initial step, we'll start with creating tests for the `EnterRaffle` function.\n\n```javascript\nfunction enterRaffle() public payable {...}\n```\n\nHere is how we create a basic test:\n\n```javascript\n   function testRaffleRevertsWHenYouDontPayEnought() public {\n        // Arrange\n        vm.prank(PLAYER);\n        // Act / Assert\n        vm.expectRevert(Raffle.Raffle__SendMoreToEnterRaffle.selector);\n        raffle.enterRaffle();\n    }\n```\n\nThe name of the method here explains the test’s aim–to verify whether entering a raffle without sufficient payment results in an error. This test follows the Arrange-Act-Assert methodology.\n\n## Arrange-Act-Assert: A Closer Look\n\nAlthough it isn't necessary to type out 'Arrange-Act-Assert' every time you write a test, it cannot be overstated how crucial this concept is to write effective tests.\n\n1. **Arrange**: This section sets up the necessary conditions for the test. In this case, it involves setting up a scenario where a user tries to enter the raffle without paying enough.\n2. **Act**: We enact the circumstance we are testing– in this case, trying to access the raffle without the necessary funds.\n3. **Assert**: The assert phase is where your tests confirm if the actual result meets the expected outcome.\n\n<img src=\"/foundry-lottery/19-testing/testing1.png\" style=\"width: 100%; height: auto;\">\n\n## Running the Test\n\nTo test this function, run the command `forge test -m \"[Title of your test]\"`. If written correctly, the test should pass.\n\n<img src=\"/foundry-lottery/19-testing/testing2.png\" style=\"width: 100%; height: auto;\">\n\n## Further Testing: Record Player Entrance\n\nAnother essential aspect to test is if our `players` array is being updated whenever a player enters the raffle successfully.\n\n```javascript\n function testRaffleRecordsPlayerWhenTheyEnter() public {\n        // Arrange\n        vm.prank(PLAYER);\n        // Act\n        raffle.enterRaffle{value: raffleEntranceFee}();\n        // Assert\n        address playerRecorded = raffle.getPlayer(0);\n        assert(playerRecorded == PLAYER);\n    }\n```\n\nSimilar to our first test, we create a scenario where a player enters the raffle and pays the required fee. The expected outcome would be that the `players` array records the player's address. However, since there is no way to access the `players` array as it is, we need to add an accessor function named `getPlayer`.\n\n```javascript\n    function getPlayer(uint256 index) public view returns (address) {\n        return s_players[index];\n    }\n```\n\nThis function allows us by giving the index number of the player we want to get.\n\nThe final step would be to add the assertion which would verify if the `players` array recorded the player in the index we specified.\n\nRemember to run the `forge test -m \"[Title of your test]\"` command to check if your test passes.\n\nUsing these foundational principles, we're well on our way to creating a battery of tests.\n\nStay tuned for our upcoming posts where we'll dive deeper into writing more sophisticated tests for different scenarios, learning about function selectors and more. Happy testing!\n",
          "updates": []
        },
        {
          "lessonId": "5dda3821-5257-4e10-8980-e5e97370ea15",
          "number": 20,
          "title": "Testing events",
          "slug": "testing-events-solidity",
          "folderName": "20-testing-events",
          "description": "A detailed guide on testing events emitted by smart contracts, highlighting the use of Foundry's `expectEmit` function. The lesson focuses on ensuring correct event emissions, crucial for smart contract validation.",
          "duration": 4,
          "videoUrl": "jFsQeUAHLC0",
          "rawMarkdownUrl": "/routes/foundry/4-smart-contract-lottery/20-testing-events/+page.md",
          "markdownContent": "---\ntitle: Testing Events\n---\n\n_Follow along with this lesson and watch the video below:_\n\n\n\n---\n\nAs developers, it's essential to be thorough in our testing process, especially when developing smart contracts. Recently, I (Patrick) found myself pondering, \"What else do we need to test?\" After testing several lines within my code, it struck me! Testing the events emitted by functions; an important but often overlooked area of smart contract testing.\n\nIn Immutable Foundries, this can be a bit tricky, so today, let's conquer this vital frontier of blockchain development! Let's delve deep into our code cavern to ensure that our contract is emitting the correct events at the right time.\n\n## Triggering Events: The Expect Emit Function\n\nTesting smart contract event emissions in Foundry involves this secret maneuver I call _the cheat code_; named as such because it manipulates the runtime environment to accomplish our mission. It's a neat trick provided to us by Foundry's Virtual Machine, and it's called `expectEmit`.\n\nThis `expectEmit` function takes a few parameters:\n\n- A collection of Booleans that represent your indexed parameters (also known as topics in solidity event emissions).\n- Check data, usually checked Boolean values.\n- The address of the emitter (smart contract).\n\nThe function works as follows:\n\n```javascript\n      function testEmitsEventOnEntrance() public {\n        // Arrange\n        vm.prank(PLAYER);\n\n        // Act / Assert\n        vm.expectEmit(true, false, false, false, address(raffle));\n        emit RaffleEnter(PLAYER);\n        raffle.enterRaffle{value: raffleEntranceFee}();\n    }\n```\n\n- We declare that we expect a certain emit to match the parameters provided. This declaration flags the next instantiation of the function we’re about to run to emit an event.\n- Following the expectEmit declaration, we run the function that should cause the event emission.\n- We're saying \"this next emit that I do manually; I expect that to happen in this upcoming transaction.\"\n\n<img src=\"/foundry-lottery/20-events/event1.png\" style=\"width: 100%; height: auto;\">\n\nThis declaration should look like this:\n\n```javascript\nvm.expectEmit(true, false, false, false, address(raffle));\n```\n\nThe `vm.expectEmit` contains:\n\n- One `true`, signifying one indexed parameter or topic present in the event.\n- Following three `false`', indicating there are no additional parameters.\n- The address of the smart contract is `address(raffle)`.\n\n## Emulating Events in Tests: Redefine Them\n\nAs smooth as the `expectEmit` function makes the testing process, the inconvenience is the necessity to redefine events in our tests. Events in Solidity are not like enums or structures. We can't import them frugally across our application.\n\nInstead, we have to redefine these events within our individual tests.\n\n```javascript\n     modifier raffleEntered() {\n        vm.prank(PLAYER);\n        raffle.enterRaffle{value: raffleEntranceFee}();\n        vm.warp(block.timestamp + automationUpdateInterval + 1);\n        vm.roll(block.number + 1);\n        _;\n    }\n```\n\nAfter redifining the contract event, you emit it manually with correct parameters and proceed to call the function that you expect will emit such an event during a transaction.\n\nFinally, after setting up our test function with the VM prank, supplying transaction parameters, and redefining the event, we can proceed to run the test.\n\n```bash\n    forge test -m <function name>\n```\n\nAnd Voila! Now you have a thorough test for your event emissions, increasing the robustness of your smart contract. Don't skip this step in your tests. Event emission testing not only ensures correct data transaction but also achieves an effective means of logging and monitoring data flow during runtime. Happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "09041b73-1723-40e6-b3fa-5f5907280e23",
          "number": 21,
          "title": "Using vm.roll and vm.wrap",
          "slug": "vm-roll-warp",
          "folderName": "21-vm-roll-warp",
          "description": "Exploring the use of `vm.roll` and `vm.wrap` in smart contract testing, this lesson demonstrates how to adjust block time and number for testing various states and transitions in smart contracts.",
          "duration": 3,
          "videoUrl": "ydPyediH7qU",
          "rawMarkdownUrl": "/routes/foundry/4-smart-contract-lottery/21-vm-roll-warp/+page.md",
          "markdownContent": "---\ntitle: VM.Roll adn VM.Warp\n---\n\n_Follow along with this lesson and watch the video below:_\n\n\n\n---\n\nAfter successfully entering the raffle, the next step involves kicking off a 'perform upkeep'. This function changes the state of the raffle to ‘calculating’. To do this, the 'checkUpkeep' function will have to return a value of true.\n\nEnough time must pass for this state transition to occur. In the context of working on a forked or local blockchain chain, things become interesting, and slightly tricky. On these chains, it's possible to modify the block time and block number. This can be achieved using the cheat codes 'VM warp' and 'VM roll'.\n\n**Adjusting the Block Time**\n\n```shell\nvm.warp(block.timestamp + automationUpdateInterval + 1);\n```\n\n**Modifying the Block Number**\n\n```shell\nvm.roll(block.number + 1);\n```\n\nIn the above code, 'VM warp' sets the block timestamp, while 'VM roll' modifies the block number. By adding '1' to each of these instances, the bonus block in the test ensures that the required time exceeds the interval.\n\nHowever, an important note: **Remember to always pass some empty data while calling 'performUpkeep'**.\n\n```shell\nraffle.performUpkeep(\"\");\n```\n\n## Testing the Calculating State\n\nAt this stage, the raffle should now be in the calculating state, so attempts to enter the raffle should fail. This can be simulated through the 'expect revert' function which expects the new attempt to join the raffle to be rejected by the contract.\n\n```shell\nvm.expectRevert(Raffle.Raffle__RaffleNotOpen.selector);\n```\n\nTo test this, we'll be pranking the player with the next real call to revert. This can be achieved by invoking 'VM Prank Player' with the next real call to the raffle's 'enter' function.\n\n```shell\nvm.prank(PLAYER);\n```\n\n## Takeaways\n\nTesting your smart contracts allows you to uncover potential bugs or loopholes in your code. Leveraging local blockchains provides an advantage of tweaking parameters like block time and number. Remember to be patient and thorough in your process, as this improves the reliability of the contracts you write. Happy testing!\n",
          "updates": []
        },
        {
          "lessonId": "336dea6a-f38c-4e01-9845-d1551f1325fa",
          "number": 22,
          "title": "Subscribing to events",
          "slug": "create-subscriptions",
          "folderName": "22-create-subscriptions",
          "description": "This lesson covers the process of deploying contracts, creating, and managing Chainlink VRF subscriptions. It focuses on resolving common errors and efficiently managing Chainlink VRF in smart contracts.",
          "duration": 12,
          "videoUrl": "oLvQR5FNCu0",
          "rawMarkdownUrl": "/routes/foundry/4-smart-contract-lottery/22-create-subscriptions/+page.md",
          "markdownContent": "---\ntitle: Create Subscriptions\n---\n\n_Follow along with this lesson and watch the video below:_\n\n\n\n---\n\nHave you ever encountered an `invalid consumer error` while deploying your raffle contracts using Chainlink VRF? Maybe you aren't familiar with the subscription model that Chainlink VRF uses, or perhaps you're uncertain about testing your contract. In this post, we'll guide you through the process of deploying raffle contracts, creating and funding a subscription, and adding a raffle contract as a consumer to the subscription.\n\nBy the end of this tutorial, you should be able to handle Chainlink VRF deployment with confidence. Let's dive right in!\n\n## Debugging: Invalid Consumer Error\n\nLet's start by adding some variables to see what's causing the problem. After adding five variables, we encountered an `invalid consumer error` on our VRF Coordinator mock. On opening the `VRFCoordinatorV2Mock.sol` file, we discovered a modifier named `only valid consumer`.\n\nThis modifier only allows operations if a consumer is added. This requirement hints at the subscription model that Chainlink VRF uses.\n\nHere’s a brief overview of the Chainlink VRF subscription model. When working with it, you'll need to follow these steps:\n\n1. Create a subscription\n2. Fund the subscription\n3. Add the raffle contract as a consumer to the subscription\n\nThe subscription model prevents random people from using your subscription. We learned this process by watching a video walkthrough that demonstrates how to perform all these steps via UI.\n\n## Improving the Deployment Script\n\nOur existing deployment script needs to ensure a valid subscription upon deployment. Each raffle contract we deploy needs to be added as a consumer to our subscription. On a real test network (testnet), we can perform these operations in the UI. However, for testing purposes, we need to do this programmatically.\n\nRather than tweaking the VRF Coordinator mock to automatically add a consumer, we opted for a more thorough solution. Refactoring our `DeployRaffle.s.sol` script allows us to run tests to simulate real usage. We're going to implement this process step-by-step below.\n\n## Refactoring to Create Subscription\n\nThe first change we make is to check the subscription ID. If it's absent or defaults to zero, calls to the function won't go through. We need a valid subscription ID from the helper configuration or from creating a new subscription manually.\n\nThe script below can identify whether we have a subscription ID or not:\n\n```javascript\n if (subscriptionId == 0) {\n            CreateSubscription createSubscription = new CreateSubscription();\n            subscriptionId = createSubscription.createSubscription(\n                vrfCoordinatorV2,\n                deployerKey\n            );\n\n            FundSubscription fundSubscription = new FundSubscription();\n            fundSubscription.fundSubscription(\n                vrfCoordinatorV2,\n                subscriptionId,\n                link,\n                deployerKey\n            );\n        }\n```\n\nThe rest of the `DeployRaffle.s.sol` script will be housed in the `Interactions.s.so` contract, which includes a `createSubscription` function:\n\n```javascript\n function createSubscription(\n        address vrfCoordinatorV2,\n        uint256 deployerKey\n    ) public returns (uint64) {\n        console.log(\"Creating subscription on chainId: \", block.chainid);\n        vm.startBroadcast(deployerKey);\n        uint64 subId = VRFCoordinatorV2Mock(vrfCoordinatorV2)\n            .createSubscription();\n        vm.stopBroadcast();\n        console.log(\"Your subscription Id is: \", subId);\n        console.log(\"Please update the subscriptionId in HelperConfig.s.sol\");\n        return subId;\n    }\n```\n\nFor the `createSubscription` function, we'll be using the helper `config` to get the `VRF Coordinator` address, allowing us to create the subscription.\n\nTo call the `CreateSubscription` function, we use a `broadcast`. This action calls the `createSubscription` function on the `VRFCoordinator` mock:\n\n```javascript\nCreateSubscription createSubscription = new CreateSubscription();\nsubscriptionId = createSubscription.createSubscription(\n    vrfCoordinatorV2,\n    deployerKey\n);\n```\n\n<img src=\"/foundry-lottery/22-subscriptions/subscription1.png\" style=\"width: 100%; height: auto;\">\n",
          "updates": []
        },
        {
          "lessonId": "588706e2-4bd4-4f14-863f-e8b666222610",
          "number": 23,
          "title": "Creating the subscription UI",
          "slug": "subscription-ui",
          "folderName": "23-subscription-ui",
          "description": "A guide to creating and managing front-end subscriptions for Ethereum Blockchain, this lesson covers steps from transaction initiation to automatic link token funding, emphasizing user interface interactions.",
          "duration": 4,
          "videoUrl": "WvxP4Lc2RBo",
          "rawMarkdownUrl": "/routes/foundry/4-smart-contract-lottery/23-subscription-ui/+page.md",
          "markdownContent": "---\ntitle: Create Subscription UI\n---\n\n_Follow along with this lesson and watch the video below:_\n\n\n\n---\n\nOne of the crucial aspects of developing on the Ethereum Blockchain is to harness the power of front-end subscriptions. In the course of this guide, we'll take you through creating and funding a subscription, even on the testnet.\n\nThis might entail a considerable waiting time, courtesy of the testnets. However, we'll make the wait worth your while by diving deep into each step until you achieve automatic link token funding.\n\n## Creating a Subscription\n\nWhether you're a newbie or a seasoned coder, running transactions in the front end can be a rewarding and exciting task. Here’s how I go about it:\n\n```markdown\nApprove transaction > Calling Create Subscription > Await creation > View transaction\n```\n\nWhen you complete this transaction, you can then create a subscription with a unique ID. This ID becomes handy when you're about to add to your helper config or run your script.\n\nOften you'd remark:\n\n<img src=\"/foundry-lottery/23-subscription-ui/subs1.png\" style=\"width: 100%; height: auto;\">\n\n## Funding Your Subscription\n\nNow that you have your subscription, it’s time to get some Link tokens under your belt! Here's how you can do it:\n\n1. Initiate **Actions** &gt; **Fund Subscription**.\n2. Ensure you have the Link in your wallet. If not, head over to the Faucets Chain Link.\n3. Select the number of links you'd like to acquire, I recommend 20 test links for a start.\n4. Confirm you're not a bot and input your address.\n5. Send the request and wait for the popup notification confirming your request.\n\n<img src=\"/foundry-lottery/23-subscription-ui/subs2.png\" style=\"width: 100%; height: auto;\">\n\nOnce you've covered these steps, you'll receive the tokens in your wallet. But remember, certain tokens like ERC20 and ERC677 don't automatically show in your MetaMask wallet.\n\n<img src=\"/foundry-lottery/23-subscription-ui/subs3.png\" style=\"width: 100%; height: auto;\">\n\n## Adding Tokens to MetaMask\n\nAfter refreshing your UI, you should see your active subscription. However, to see your tokens, you need to add them to your MetaMask. You can do this in a few steps:\n\n1. Navigate to **Docs chain link &gt; Get Started &gt; Link Token Contracts &gt; Sepolia Testnet.**\n2. Copy the address or click **Add to Wallet** to instruct your MetaMask to import these tokens.\n3. Hit **Import Tokens** &gt; **Paste address** &gt; **Add custom tokens** &gt; **Import tokens**.\n\n<img src=\"/foundry-lottery/23-subscription-ui/subs4.png\" style=\"width: 100%; height: auto;\">\n\nSee how simply you added Sepolia ETH and Abraham Lincoln? Now you have your tokens imported to MetaMask and are ready to fund your subscription.\n\n## Transferring Your Tokens\n\nWith your loaded MetaMask wallet, you can transfer funds to your subscription. Here’s how you can do it:\n\n1. Initiate **Actions** &gt; **Fund Subscription**.\n2. Specify the numbers of links you want to transfer.\n3. Confirm your transaction.\n\n<img src=\"/foundry-lottery/23-subscription-ui/subs5.png\" style=\"width: 100%; height: auto;\">\n\nInteresting to note here is that the function prompted in this process is not on your VR app but on the Link Token contract. We're actually transferring tokens to a subscriptions contract and using the 'Transfer and Call' function on our contract to do so.\n\n## Conclusion\n\nWhile this guide didn’t actually call the function, it's imperative to highlight that a balance of zero is absolutely alright. In fact, we'll cover adding Link to your ID in Solidity in the next lessons. Until then, remember:\n\n<img src=\"/foundry-lottery/23-subscription-ui/subs6.png\" style=\"width: 100%; height: auto;\">\n\nKeep experimenting, keep learning!\n",
          "updates": []
        },
        {
          "lessonId": "73f1f9fb-9394-4e32-bb6d-e06009e3babc",
          "number": 24,
          "title": "Fund subscription",
          "slug": "fund-subscription",
          "folderName": "24-fund-subscription",
          "description": "This lesson teaches how to create and execute a contract script to fund blockchain subscriptions, detailing the parameters needed and the process of funding subscriptions using mock functions.",
          "duration": 13,
          "videoUrl": "DgPYEyiE8NQ",
          "rawMarkdownUrl": "/routes/foundry/4-smart-contract-lottery/24-fund-subscription/+page.md",
          "markdownContent": "---\ntitle: Fund Subscriptions\n---\n\n_Follow along with this lesson and watch the video below:_\n\n\n\n---\n\n## Creating a New Contract\n\nFirst things first. Head over to the Interactions section, and create a new contract, named `FundSubscription`. This contract script, residing within `interactions.s.sol`, will allow you to select an amount and fund your subscription.\n\nRemember, the amount has to be a `uint96` , but let's keep things simple for now and set a public constant `FUND_AMOUNT` to three ether.\n\n```js\nuint96 public constant FUND_AMOUNT = 3 ether;\n```\n\n## Setting the Parameters\n\nTo fund your subscription, you will need three important elements:\n\n- Subscription ID\n- VRF Coordinator V2 address\n- Link address\n\nStart by specifying the `VRFCoordinator` address and the `uint64` `subId`. The `subID` corresponds to the subscription you want to fund.\n\n```js\nHelperConfig helperConfig = new HelperConfig();\n        (\n            uint64 subId,\n            ,\n            ,\n            ,\n            ,\n            address vrfCoordinatorV2,\n            address link,\n            uint256 deployerKey\n        ) = helperConfig.activeNetworkConfig();\n```\n\nFor these configurations, you'll use the already existing `HelperConfig.s.sol`. However, you'll notice, it doesn't yet include a link token. Adding a link token will facilitate funding the subscription as it forms the basis of the contract call.\n\nThe link tokens for Sepolia already exist, and they can be easily found and added.\n\nNext, for Anvil, you'll need to deploy a mock link token. To ease the process, simply rewrite the link contract for a newer version of Solidity. This can be easily done using my Foundry smart contract lottery F23.\n\n## Funding the Subscription\n\nNow that the `link_address` is ready, go back to your interactions and create a new function named `fund_subscription`. The function should have three inputs: `VRF_Coordinator`, `sub_ID`, and `link`.\n\n```js\ncontract FundSubscription is Script {\n    uint96 public constant FUND_AMOUNT = 3 ether;\n\n    function fundSubscriptionUsingConfig() public {\n        HelperConfig helperConfig = new HelperConfig();\n        (\n            uint64 subId,\n            ,\n            ,\n            ,\n            ,\n            address vrfCoordinatorV2,\n            address link,\n            uint256 deployerKey\n        ) = helperConfig.activeNetworkConfig();\n        fundSubscription(vrfCoordinatorV2, subId, link, deployerKey);\n    }\n```\n\nThis function works in much the same way as the front-end does to fund subscriptions. However, remember that the VRF Coordinator Mock interacts with the link token transfers in a different way than the actual contract, hence the mock's funding subscription mechanism is different.\n\nWhen you're testing your code on your local chain, you can call the `VM_Start_Broadcast` function before and `VM_Stop_Broadcast` function after the line of code which contains the `fundSubscriptionUsingConfig` method.\n\n```js\nif (subscriptionId == 0) {\n            CreateSubscription createSubscription = new CreateSubscription();\n            subscriptionId = createSubscription.createSubscription(\n                vrfCoordinatorV2,\n                deployerKey\n            );\n\n            FundSubscription fundSubscription = new FundSubscription();\n            fundSubscription.fundSubscription(\n                vrfCoordinatorV2,\n                subscriptionId,\n                link,\n                deployerKey\n            );\n        }\n\n```\n\nFinally, compile all the contracts using forge build. If everything compiles successfully, your contract has been created and is ready to perform transactions!\n\n## A Final Comment\n\nThe above steps outline a process whereby you can automate the process of funding blockchain-based subscriptions. Remember, this is not the final product, but an intermediary step in the development of a blockchain-based subscription service. Please do not use this code in a production environment without further testing and validation.\n\nRemember, it's always better to test your code in a secure environment before deploying it. The world of coding is vast, and there's so much more to explore. Happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "f29c650a-74b8-4a00-8fb2-b3aa5b81c732",
          "number": 25,
          "title": "Adding a consumer",
          "slug": "add-consumer",
          "folderName": "25-add-consumer",
          "description": "Focusing on adding a consumer to a subscription, this lesson explains the process of adding a consumer contract to a Chainlink VRF subscription, using scripting to simplify the deployment and management.",
          "duration": 10,
          "videoUrl": "VxdPI856Ck4",
          "rawMarkdownUrl": "/routes/foundry/4-smart-contract-lottery/25-add-consumer/+page.md",
          "markdownContent": "---\ntitle: Add Consumer\n---\n\n_Follow along with this lesson and watch the video below:_\n\n\n\n---\n\n## Adding the Consumer\n\nWe can execute code snippets similar to the ones we used earlier while adding the consumer.\n\n```shell\ncontract AddConsumer is Script {}}\n```\n\nTo add a consumer, we need to write the `addConsumer` function, which will do most of the operations we've previously executed.\n\n```javascript\nfunction addConsumer(\n        address contractToAddToVrf,\n        address vrfCoordinator,\n        uint64 subId,\n        uint256 deployerKey\n    ) public {\n        console.log(\"Adding consumer contract: \", contractToAddToVrf);\n        console.log(\"Using vrfCoordinator: \", vrfCoordinator);\n        console.log(\"On ChainID: \", block.chainid);\n        vm.startBroadcast(deployerKey);\n        VRFCoordinatorV2Mock(vrfCoordinator).addConsumer(\n            subId,\n            contractToAddToVrf\n        );\n        vm.stopBroadcast();\n    }\n```\n\nNow we can create a function to create a consumer based on the config like this:\n\n```js\n function addConsumerUsingConfig(address mostRecentlyDeployed) public {\n        HelperConfig helperConfig = new HelperConfig();\n        (\n            uint64 subId,\n            ,\n            ,\n            ,\n            ,\n            address vrfCoordinatorV2,\n            ,\n            uint256 deployerKey\n        ) = helperConfig.activeNetworkConfig();\n        addConsumer(mostRecentlyDeployed, vrfCoordinatorV2, subId, deployerKey);\n    }\n```\n\nThis function calls the `addConsumer` function using the subscription ID and the address of the raffle contract. The subscription ID is retrieved from the config while the contract address is passed directly to the function.\n\n## Testing the Script\n\nNow comes the most awaited part - testing our creation! And guess what? It passes with flying colors!\n\nIt's such a thrill to see our creation fare so well. And the best part? We no longer require any manual inputs or interactions with the UI. We've reduced the entire contract deployment and management to just one command. Brilliant, isn't it?\n\n<img src=\"/foundry-lottery/25-consumer/consumer1.png\" style=\"width: 100%; height: auto;\">\n\n## On a Concluding Note\n\nKudos on keeping up with this journey! Done for the day and might be feeling overwhelmed at the volume of data thrown at you? Feel free to take a well-earned break.\n\nRemember to savor the win. Pull yourself a pint of ice cream or some sushi, my personal favourite. Come back when your mind is fresh, open and ready to tackle the next set of challenges.\n\nHere's a virtual tap on the back for making it this far. Your effort is really commendable. Keep up the good work and remember to take care of your \"giant muscle\" that is your brain. Don't hesitate to voice your doubts either to your AI buddy or the discussions forum. And remember -\n\n<img src=\"/foundry-lottery/25-consumer/consumer2.png\" style=\"width: 100%; height: auto;\">\n\nSee you soon, folks! Keep your queries coming and the enthusiasm flowing.\n",
          "updates": []
        },
        {
          "lessonId": "c3314def-303b-4994-ac86-0999bf5b7b2f",
          "number": 26,
          "title": "Adding more tests",
          "slug": "more-tests",
          "folderName": "26-more-tests",
          "description": "A continuation of developing comprehensive tests for smart contracts, this lesson focuses on enhancing code coverage and efficiency in testing, particularly for the `check upkeep` function.",
          "duration": 7,
          "videoUrl": "VgkTCfdufBI",
          "rawMarkdownUrl": "/routes/foundry/4-smart-contract-lottery/26-more-tests/+page.md",
          "markdownContent": "---\ntitle: More Tests\n---\n\n_Follow along with this lesson and watch the video below:_\n\n\n\n---\n\nAlright, welcome back! Let's dive right into writing tests for our smart contracts with an emphasis on code coverage and efficiency. Hope you had a little break because, remember, breaks are essential for productivity and focus. Let's continue with our mission to enhance our test coverage.\n\nRunning `forge coverage` produces somewhat less-than-satisfactory results. So we need to push on and try to ramp up our coverage.\n\n## Check Upkeep Tests\n\nFirst up on our list is the `check upkeep` function from the raffle contract. This crucial method oversees the contract's health, and it's time that we provide solid tests for it. To start, do a bunch of slashes followed by `check upkeep` just to keep things tidy!\n\nRemember, we have numerous scenarios to verify for the `check upkeep` function. For example, the method should return false if the contract lacks a balance, isn't open, or when enough time hasn't passed.\n\n### Scenario I: Test Check Upkeep Returns False When Contract Has No Balance\n\n```js\nfunction testCheckUpkeepReturnsFalseIfItHasNoBalance() public {\n        // Arrange\n        vm.warp(block.timestamp + automationUpdateInterval + 1);\n        vm.roll(block.number + 1);\n\n        // Act\n        (bool upkeepNeeded, ) = raffle.checkUpkeep(\"\");\n\n        // Assert\n        assert(!upkeepNeeded);\n    }\n```\n\nIn this particular test, we're mainly focused on the scenario where the contract doesn't have a balance. We're ensuring that all other conditions are met and verifying that lacking balance results in the function returning false.\n\nWe arrange our test by ensuring that sufficient time has passed by implementing `VM.warp` with the current `block.timestamp`, increased by the `interval`, then some and carry out `VM.roll` with `block.number + 1`.\n\nThe act section employs the `checkUpkeep` method and assigns the result to the `upkeep_needed` variable. Finally, we assert that not `upkeep_needed` equals true, confirming that the function returns false in this scenario.\n\n### Scenario II: Test Check Upkeep Returns False When Raffle Isn't Open\n\n```js\nfunction testCheckUpkeepReturnsFalseIfRaffleIsntOpen() public {\n        // Arrange\n        vm.prank(PLAYER);\n        raffle.enterRaffle{value: raffleEntranceFee}();\n        vm.warp(block.timestamp + automationUpdateInterval + 1);\n        vm.roll(block.number + 1);\n        raffle.performUpkeep(\"\");\n        Raffle.RaffleState raffleState = raffle.getRaffleState();\n        // Act\n        (bool upkeepNeeded, ) = raffle.checkUpkeep(\"\");\n        // Assert\n        assert(raffleState == Raffle.RaffleState.CALCULATING);\n        assert(upkeepNeeded == false);\n    }\n```\n\nThe second scenario we're testing looks at the situation where the raffle isn't open. We arrange this by first entering the raffle with a stipulated entrance fee, after pretending to be the player with `VM.frank(player)`. We then kick off `performUpkeep` to initiate the calculating mode. Our function should return false at this point because the raffle is in the calculating state.\n\nOnce again, the `act` section involves running the `checkUpkeep` method, and we use `assert(upkeepNeeded == false);` or `assert not upkeep_needed` to confirm our expectation in the `assert` section.\n\n### More Tests and Debug Mode\n\nWe still have more tests to write, and to get a clearer idea of the coverage required; consider running `forge coverage` in debug mode. This command will generate an output telling you exactly which lines haven't been covered.\n\n```bash\nforge coverage --report debug > coverage.txt\n\n\n```\n\nBy outputting the report into a file called `coverage.txt`, we can then review the generated report. This output details the precise lines of code not covered for each section.\n\n## Challenge\n\nNow that you're well-versed in the dynamics of testing for contract health, I challenge you to write two more tests:\n\n1. `function testCheckUpkeepReturnsFalseIfEnoughTimeHasntPassed`: This checks if enough time has passed before performing assertions.\n\nFeel free to compare these tests with the ones available on the linked GitHub repository for this course. Happy testing!\n",
          "updates": []
        },
        {
          "lessonId": "6b573f84-8ab8-4eec-881f-c0d71cf12ca9",
          "number": 27,
          "title": "Testing and refactoring the performUpkeep",
          "slug": "test-and-refactor-perform-upkeep",
          "folderName": "27-perform-upkeep",
          "description": "This lesson delves into writing tests for the `performUpkeep` function, emphasizing the need for thorough testing and refactoring to ensure the reliability and efficiency of smart contracts.",
          "duration": 5,
          "videoUrl": "EIYRoNCkUz0",
          "rawMarkdownUrl": "/routes/foundry/4-smart-contract-lottery/27-perform-upkeep/+page.md",
          "markdownContent": "---\ntitle: Perform Upkeep\n---\n\n_Follow along with this lesson and watch the video below:_\n\n\n\n---\n\nToday we'll be specifically digging into `PerformUpkeep` tests. Writing and testing functions within your code are vital to a healthy codebase. This post will walk you through the process, step-by-step, using JavaScript, making sure to cover every detail the original transcript provides.\n\n## Function Test: `Perform Upkeep` can only run if `check upkeep` is true\n\nOur journey starts with the function test `Perform Upkeep can only run if check upkeep is true`. Here's how you should go about it:\n\n```javascript\nfunction testPerformUpkeepCanOnlyRunIfCheckUpkeepIsTrue() public {\n        // Arrange\n        vm.prank(PLAYER);\n        raffle.enterRaffle{value: raffleEntranceFee}();\n        vm.warp(block.timestamp + automationUpdateInterval + 1);\n        vm.roll(block.number + 1);\n\n        // Act / Assert\n        // It doesnt revert\n        raffle.performUpkeep(\"\");\n    }\n```\n\nTo validate this function, you simply need to run it since, in Foundry, there's no `expect not revert`. Thus, if the transaction doesn't revert, the test is considered to be passed. Here's how:\n\n```shell\nforge test -m testPerformUpkeepCanOnlyRunIfCheckUpkeepIsTrue\n```\n\nIf everything is set correctly, your test will pass. If for example, some parameters were commented out, it would inevitably fail because the `Perform upkeep` would fail. This prompts an error message stating 'Raffle upkeep not needed'.\n\n<img src=\"/foundry-lottery/27-upkeep/upkeep1.png\" style=\"width: 100%; height: auto;\">\n\nThe completion of these steps has yielded a well-rounded test that allows you to screen for potential errors. To run this final version, you need to open your terminal and run the following command:\n\n```shell\nforge test -m [paste your function here]\n```\n\nOur programming journey, although complex, is also exciting. Stride forward with confidence, knowing that every error is a stepping stone to more robust code.\n",
          "updates": []
        },
        {
          "lessonId": "63c994b2-6e8e-4c73-ab50-1b4ec593c5c1",
          "number": 28,
          "title": "Refactoring events data",
          "slug": "event-data",
          "folderName": "28-event-data",
          "description": "A guide to refining the use of emitted events in smart contracts, this lesson covers extracting and utilizing event data, with a focus on testing and improving code efficiency.",
          "duration": 9,
          "videoUrl": "nliBD510_ck",
          "rawMarkdownUrl": "/routes/foundry/4-smart-contract-lottery/28-event-data/+page.md",
          "markdownContent": "---\ntitle: Getting Event Data Into Foundry\n---\n\n_Follow along with this lesson and watch the video below:_\n\n\n\n---\n\n## Part 1: Emit - Necessary or Redundant?\n\nConsider this situation: We have a function, `performUpkeep`, and we want to learn more about it by giving it an extra emit. We'll write an event `requestedRaffleWinner`. This event will get emitted when we call the `performUpkeep` function, with an associated variable, Request ID.\n\nBut wait, is this redundant?\n\nThe way to find out if this is redundant or necessary is by checking our existing contract. We'll look up the `VRFCoordinatorMock` function and search for `requestRandomWords`. If there is an event `randomWordsRequested` which already includes the 'Request ID', then emitting the Request ID again would indeed be redundant.\n\nHowever, in this article, we'll follow through with the redundancy to simplify our testing process.\n\n<img src=\"/foundry-lottery/28-event-data/eventdata1.png\" style=\"width: 100%; height: auto;\">\n\nEven though this might seem like lousy form, retreading this process is crucial, especially when we test for outputs from events. A prime example is the ChainlinkVRF, which functions by listening to this event that gets emitted.\n\n## Part 2: Writing Tests and Refactoring\n\nNow that we've covered the grounds, let's head straight into writing test cases for `Perform Upkeep` and refactor some parts of our code to improve efficiency.\n\nWe'll start with a Function Test for Perform Upkeep and declare it as Public. Then we do the same with VM Warp and VM Roll―quite repetitive, isn't it? Ideally, these should be refactored into a modifier to reduce redundancy and enhance code readability.\n\nHere's our new modifier `RaffleEnteredAndTimePassed`:\n\n```js\nmodifier raffleEntered() {\n        vm.prank(PLAYER);\n        raffle.enterRaffle{value: raffleEntranceFee}();\n        vm.warp(block.timestamp + automationUpdateInterval + 1);\n        vm.roll(block.number + 1);\n        _;\n    }\n\n```\n\nThen, we move right along to create our raffle. The intent is to capture the emitted request ID, which is not accessible by the Raffle Contract. From here, we need to learn how to get the output of these events while testing.\n\nFor that, we use our trusty friend, `recordLogs`. This function records all emitted events, which we can then access using `getRecordedLogs`.\n\nOur next step is to introduce a new type of list to store the emitted events― `Vm.Log Array`.\n\n```js\n Vm.Log[] memory entries = vm.getRecordedLogs();\n```\n\nAgain, to make use of `Vm`, you'll have to import it from `forge-std/Vm.sol`.\n\n## Part 3: Request ID &amp; Working with Emitted Events\n\nNow that we have our recorded logs, we can extract the Request ID using this list of emitted events.\n\nNow remember, this list contains all the events that were emitted during the process. Therefore, understanding the transaction and recognizing the events is crucial in this step.\n\nUsing the debugger, we skip ahead and identify that our requested event 'Raffle Winner' is the second event emitted in this transaction.\n\n```js\nbytes32 requestId = entries[1].topics[1];\n```\n\nThe zeroth index would refer to the event `randomWordsRequested` in the mock. The first index refers to our requested event.\n\nThe last step involves creating a True/False condition to confirm if the Request ID was correctly generated.\n\n```js\nassert(uint256(requestId) > 0);\n```\n\nThus, ensuring the Request ID is not default and zero.\n\nFor a more foolproof test, also check the Raffle state equals one for calculating, increasing the robustness of your function.\n\nFinally, when you run the test cases in your terminal, you should get successful outputs.\n\n## Congrats\n\nThat's all for now, developers. Keep on coding—until next time!\n",
          "updates": []
        },
        {
          "lessonId": "6ee77112-cfa6-4c19-837e-7efcb03f8faf",
          "number": 29,
          "title": "Intro to fuzz testing",
          "slug": "intro-smart-contract-fuzz-testing",
          "folderName": "29-intro-fuzz-testing",
          "description": "Introducing fuzz testing in blockchain development, this lesson explores using random inputs for testing smart contracts, emphasizing the importance of mock functions and fuzz testing for secure and stable systems.",
          "duration": 4,
          "videoUrl": "aCY7nIMVLSY",
          "rawMarkdownUrl": "/routes/foundry/4-smart-contract-lottery/29-intro-fuzz-testing/+page.md",
          "markdownContent": "---\ntitle: Intro to Fuzz Testing\n---\n\n_Follow along with this lesson and watch the video below:_\n\n\n\n---\n\nIn this lesson, we will dive deep into the world of testing in blockchain development, focusing on using \"mock functions\" and a technique called \"fuzz testing.\" These tools are essential for ensuring that your code is functioning as expected and you're creating a secure, stable system.\n\n## Understanding Mock Functions\n\nFirst, let's dig into the concept of using a mock function for our tests.\n\n```java\nfunction testFulfillRandomWordsCanOnlyBeCalledAfterPerformUpkeep()\n        public\n        raffleEntered\n        skipFork\n    {\n        // Arrange\n        // Act / Assert\n        vm.expectRevert(\"nonexistent request\");\n        // vm.mockCall could be used here...\n        VRFCoordinatorV2Mock(vrfCoordinatorV2).fulfillRandomWords(\n            0,\n            address(raffle)\n        );\n\n        vm.expectRevert(\"nonexistent request\");\n\n        VRFCoordinatorV2Mock(vrfCoordinatorV2).fulfillRandomWords(\n            1,\n            address(raffle)\n        );\n    }\n```\n\nThis script describes a test for a mock functionality we're planning to incorporate into our project. We want to ascertain that the `fulfillRandomWords` function can only be called after `performUpkeep` has been executed. It's crucial that we navigate how the tests operate and how to write such tests that guarantee our systems indeed work.\n\n<img src=\"/foundry-lottery/29-fuzz/fuzz1.png\" style=\"width: 100%; height: auto;\">\n\nIn order to mimic a situation where we actually call `fulfillRandomWords` and observe a failed test, we are going to use another mock function. We will endeavor to make sure that calling `fulfillRandomWords` on the mock invariably reverts.\n\nThis script denotes the process of utilizing the `fulfillRandomWords` function with a fictitious request ID and an address of a consumer. We expect this to fail since `performUpkeep` hasn't been executed yet.\n\n## What is Fuzz Testing?\n\nWhen testing, it's unrealistic to test every single possible variable input to a function, especially when the valid input number is enormous. This is where fuzz testing comes in.\n\nFuzz testing is an approach that helps us generate random inputs to our test. Instead of us inputting manual entries like 0, 1, 2... etc., we utilize a random generator that provides these entries for us.\n\nSo, through the magic of fuzz testing, Foundry will generate random numbers and run this test many times with many random numbers, consistently checking if `nonexistentRequest` error occurs.\n\n```\nforge test -m\n```\n\nRunning this test, we'll find that the function passed, and upon inspecting the test output, we'd get 256 runs, meaning that Foundry generated 256 random numbers and ran the test with those parameters.\n\nThese techniques — mocking and fuzz testing, come in handy when upping the security of your contract and improving your testing skills. If any of these concepts don't yet fully make sense, don't fret.\n\nThe goal isn't to perfect the art immediately but to gradually become familiar with the use of smart tests in your smart contracts and get better over time. As always, continue experimenting and happy testing!\n\n<img src=\"/foundry-lottery/29-fuzz/fuzz2.png\" style=\"width: 100%; height: auto;\">\n",
          "updates": []
        },
        {
          "lessonId": "0e5e5907-79e4-44a5-810b-b2cc31b46b3f",
          "number": 30,
          "title": "One Big Test",
          "slug": "one-big-test",
          "folderName": "30-one-big-test",
          "description": "This lesson focuses on creating a comprehensive function test for a Raffle contract in a blockchain environment, covering the entire lifecycle of a raffle including entry, drawing, and prize distribution, and integrating Chainlink VRF in a test environment.",
          "duration": 11,
          "videoUrl": "rr4xH7YAQXc",
          "rawMarkdownUrl": "/routes/foundry/4-smart-contract-lottery/30-one-big-test/+page.md",
          "markdownContent": "---\ntitle: One Big Test\n---\n\n_Follow along with this lesson and watch the video below:_\n\n\n\n---\n\nToday, we delve into the function-testing sphere of smart contract development by focusing on our Raffle contract functionality.\n\nThis guide will explore the construction and execution of extensive functionality tests through writing a big, novel function in a smart contract.\n\n## Constructing the Test Function\n\nLet's start off by creating a function titled `testFulfillRandomWordsPicksAWinnerResetsAndSendsMoney`.\n\nThis function will simulate a complete raffle lifecycle in a public setting. We'll adhere to our contract rules; enter the lottery several times, speed up the time, and operate routine maintenance. We also include a call to the Chainlink node to procure a random number.\n\nHere is what the function set-up looks like:\n\n```js\n function testFulfillRandomWordsPicksAWinnerResetsAndSendsMoney()\n        public\n        raffleEntered\n        skipFork\n    {}\n```\n\n## Mocking the Chainlink VRF\n\nWithin this function, an important call to the `fulfillRandomWords` function occurs. However, the intricacies of running on a local fake chain require us to impersonate the Chainlink VRF to call `fulfillRandomWords`.\n\n<img src=\"/foundry-lottery/30-big-test/test1.png\" style=\"width: 100%; height: auto;\">\n\nConsequently, we work within our local test environment and set up a pretend Chainlink node to call `fulfillRandomWords`.\n\n## Adding Multiple Lottery Entries\n\nOnce this is set up, we add multiple entries to the lottery. We start with five additional entrants and a starting index of one because index zero does not apply here.\n\n```js\n  // Arrange\n    uint256 additionalEntrances = 3;\n    uint256 startingIndex = 1;\n\n```\n\nTo make our raffle interesting, we create random entrants and generate unique addresses for each. We proceed to give each of them 1 ether using the Hoax cheat code and let them join the raffle.\n\nIn code, this looks like:\n\n```js\n for (\n            uint256 i = startingIndex;\n            i < startingIndex + additionalEntrances;\n            i++\n        ) {\n            address player = address(uint160(i));\n            hoax(player, 1 ether); // deal 1 eth to the player\n            raffle.enterRaffle{value: raffleEntranceFee}();\n        }\n```\n\n## Engaging the Chainlink VRF\n\nNow that we have a raffle filled with players, it's time to call in Chainlink VRF to generate a random number which we then use to pick a winner. We then assert various conditions to ensure all elements of the raffle have been reset and the winner is given the prize money.\n\n## Debugging Failing Tests\n\nDuring the initial test run, we faced an assertion violation. When writing code, it's inevitable that you'll encounter debugging issues. In our case, the issue originated from a balance comparison discrepancy due to not considering the entry fee paid by the player.\n\nWhen revising our test, we accounted for the entrance fee and once we implemented those changes, our test yielded a pass result.\n\nOur final test function may look a bit daunting at first, but each step within it serves important functionality and ensures our contract behaves as expected. And there you have it, a full testing function for entering, drawing, and resetting a raffle!\n\nBut we're not quite done yet; testing the coverage of our contract revealed a percentage coverage, with room for improvement. However, it was significantly better than the initial coverage. Despite this, our journey towards perfect function coverage continues...\n\nThis is how the final test looks like:\n\n```js\nfunction testFulfillRandomWordsPicksAWinnerResetsAndSendsMoney()\n        public\n        raffleEntered\n        skipFork\n    {\n        address expectedWinner = address(1);\n\n        // Arrange\n        uint256 additionalEntrances = 3;\n        uint256 startingIndex = 1; // We have starting index be 1 so we can start with address(1) and not address(0)\n\n        for (\n            uint256 i = startingIndex;\n            i < startingIndex + additionalEntrances;\n            i++\n        ) {\n            address player = address(uint160(i));\n            hoax(player, 1 ether); // deal 1 eth to the player\n            raffle.enterRaffle{value: raffleEntranceFee}();\n        }\n\n        uint256 startingTimeStamp = raffle.getLastTimeStamp();\n        uint256 startingBalance = expectedWinner.balance;\n\n        // Act\n        vm.recordLogs();\n        raffle.performUpkeep(\"\"); // emits requestId\n        Vm.Log[] memory entries = vm.getRecordedLogs();\n        bytes32 requestId = entries[1].topics[1]; // get the requestId from the logs\n\n        VRFCoordinatorV2Mock(vrfCoordinatorV2).fulfillRandomWords(\n            uint256(requestId),\n            address(raffle)\n        );\n\n        // Assert\n        address recentWinner = raffle.getRecentWinner();\n        Raffle.RaffleState raffleState = raffle.getRaffleState();\n        uint256 winnerBalance = recentWinner.balance;\n        uint256 endingTimeStamp = raffle.getLastTimeStamp();\n        uint256 prize = raffleEntranceFee * (additionalEntrances + 1);\n\n        assert(recentWinner == expectedWinner);\n        assert(uint256(raffleState) == 0);\n        assert(winnerBalance == startingBalance + prize);\n        assert(endingTimeStamp > startingTimeStamp);\n    }\n\n```\n\nIn conclusion, writing a successful test suite is an iterative process, whether it's adjusting code or debugging errors, achieving a fully functional contract with a high coverage is definitely a satisfying feat!\n\nGreat job for sticking with it thus far, and happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "c19283e4-ea96-419c-ae38-49d3ad8dfb3b",
          "number": 31,
          "title": "Forked test environment and dynamic private keys",
          "slug": "passing-private-key",
          "folderName": "31-passing-private-key",
          "description": "A guide on running tests in a forked test environment, addressing the challenges and solutions related to deployer identification. It covers the dynamics of testing smart contracts on different blockchain environments and the importance of dynamic deployer keys.",
          "duration": 15,
          "videoUrl": "SiO9HENjSl8",
          "rawMarkdownUrl": "/routes/foundry/4-smart-contract-lottery/31-passing-private-key/+page.md",
          "markdownContent": "---\ntitle: Passing the Private Key in\n---\n\n_Follow along with this lesson and watch the video below:_\n\n\n\n---\n\n## Setting up the Fork Test\n\nThe goal is to try running our tests on a **forked test environment**. Before that, we have successfully run it on our local environment, the anvil. But now, we want to see how our code performs when running on a fork test. Depending on your expectation, jot down what you think would happen.\n\n```bash\nforge test --fork-url $SEPOLIA_RPC_URL\n```\n\nNow, if your prediction was an error message, then you are correct! We got an error right during setup. But why is this failing? Let's dive deeper into this.\n\n### Analyzing the Error\n\nWhen we run our forged test with multiple verbosity `-vvvv`, we can see the specific error: `must be sub owner when we try to add a consumer`. This problem arises when our test setup calls `Deployer Run`, which runs our Deploy Raffle and tries to add a consumer with our subscription ID.\n\nThe crux of the issue lies in the identification of the deployer. This error means only the person who launched the subscription can do this. So, to solve this, we need to refactor our code so that it works no matter the environment.\n\n```bash\nforge build\n```\n\n### Resolving the Error - Deployer Identification\n\nTo correct this issue, we need to make `deployer key` dynamic, depending on whether we're in a local or a non-local environment. In a local environment like Anvil, we use a default key whereas on a network like Sepolia we use a real key given by an environment variable.\n\nThis refactoring also involves modifying the Add Consumer to include the `deployer key`. This way, we ensure that we use the same key as the deployer when adding a consumer to start broadcasting.\n\n```bash\nforge test --fork-url $SEPOLIA_RPC_URL\n```\n\nNow, when we run the code, we find two failing tests regarding fulfilling random words after performing upkeep. This is because the actual contract requires different inputs than the local environment.\n\n### Skipping Fork\n\nThe easier way around these final two failing tests is to add a `skip fork` modifier to run these tests only on an anvil chain. There exists another, more complex solution to this; involving the recreation of code to generate the proof and request commitment, essentially replicating much of the codebase of the actual chain-link node. However, as the purpose of this post is to demonstrate testing code failures and rectification, we opted for the simpler solution.\n\n```js\n modifier skipFork() {\n        if (block.chainid != 31337) {\n            return;\n        }\n        _;\n    }\n\n```\n\nNow that we have added the `skip fork` modifier to prevent these tests from running on a forked setup, we should no longer get an error during the test.\n\nAt this stage, you can uncomment your code to rerun the tests and this time, you should not encounter any error - both on the local and the forked test.\n\nCongratulations, you have now successfully rectified an error on a forked test!\n\n## Coverage Reports\n\nAfter successfully running our tests on both local and forked environments, we then look at our **coverage results**. Coverage testing helps to identify areas of the codebase without test coverage, which are potentially risky and can affect the functionality.\n\n```bash\nforge coverage\n```\n\nThis command generates a coverage report, and once we run it, we see that we have a higher coverage percentage than before. You do have the option to run `forge coverage report` to evaluate in detail the components lacking test coverage.\n\nAs a golden rule, your code is ready to move onto the next stage, or even for an audit only if you are confident about the coverage testing results.\n\n## Conclusion\n\nIn this blog post, we saw how to test code in different environments - the local anvil and a fork environment, and tackled a common error associated with deployer identification. We analyzed, refactored the code, inserted a skip fork modifier, and surveyed our test coverage. Remember that, in software development, it is never about the code working locally, but it's more about its ability to adapt and work well in any environment it may find itself operating in.\n\n<img src=\"/foundry-lottery/31-private-key/private1.png\" style=\"width: 100%; height: auto;\">\n\nRemember, testing your code under different scenarios and environments is crucial for robust and reliable software delivery. Being comfortable with rewriting, refactoring, and updating your tests is a significant part of your journey as a competent developer.\n\nKeep learning ans we will see you in the next lesson!\n",
          "updates": []
        },
        {
          "lessonId": "1b90aea4-ceb7-4a6a-9aee-3b5f5301a2c4",
          "number": 32,
          "title": "Creating integration tests",
          "slug": "solidity-integration-tests",
          "folderName": "32-integration-tests",
          "description": "This lesson transitions from unit testing to integration testing in smart contract development, highlighting the significance of deploying and testing on testnets and mainnets. It offers insights into the practical aspects of ensuring smart contracts function as intended in a live blockchain environment.",
          "duration": 4,
          "videoUrl": "q_0eIzwxcrc",
          "rawMarkdownUrl": "/routes/foundry/4-smart-contract-lottery/32-integration-tests/+page.md",
          "markdownContent": "---\ntitle: Integration Tests\n---\n\n_Follow along with this lesson and watch the video below:_\n\n\n\n---\n\nYes, you've guessed it correctly. It's another installation on testing! We've discussed unit tests in our previous articles, but today, we're going a notch higher. We are diving deep into integration tests with a special focus on smart contracts. Moreover, we will discover the significance of testnets and their roles in deployment and testing. Let's get into it!\n\n## The Transition from Unit to Integration Tests\n\nI know, we just covered unit tests, but we're not even close to done. The world of testing in blockchain development is wide, and it's split into categories. To begin with, there are unit tests, and then we transition into our focus for today: integration tests.\n\nIntegration tests involve testing our deploy scripts along with various components of our smart contracts. This way, we ensure that each piece of the puzzle fits together to form our desired application or system. Exciting, right?\n\nLet's jump into some coding. To move our interactions test (test.sol) to integration, simply grab it and move it up into the integration section.\n\n<img src=\"/foundry-lottery/32-integration/integration1.png\" style=\"width: 100%; height: auto;\">\n\nAnd there you have it! You're now working in the realm of integration tests!\n\n<img src=\"/foundry-lottery/32-integration/integration2.png\" style=\"width: 100%; height: auto;\">\n\n## Flying with Testnets\n\nAs opposed to just performing unit and integration tests, it's also worth considering whether you should deploy your smart contracts to a testnet or even a mainnet. By doing so, you expose your contracts to a live environment. This will help you understand the real-life performance of your contract.\n\nSome people would even go as far as deploying their contracts to [Polygon](https://polygon.technology/), a cheap live network, to test their contracts in a production environment.\n\nCoincidentally, some blockchain networks like [Polkadot](https://polkadot.network/) have their unique staging blockchain known as Kusama.\n\n<img src=\"/foundry-lottery/32-integration/integration3.png\" style=\"width: 100%; height: auto;\">\n\n## Writing and Running Integration Tests\n\nNow, let's write some integration tests and run the deploy script. You'll have a chance to see the lottery in action on a testnet.\n\nRemember, seeing is often believing, but testnets can sometimes be fickle. They can test your patience, but seeing your contract perform in a testnet environment can be a solid reassurance that it works!\n\n## Considerations and Conclusion\n\nWith testing, it's essential to be thorough, but we should also consider the limitations of our testing environments. For instance, Foundry, though a fantastic framework for smart contract testing, can be a bit challenging when dealing with off-chain systems. That's why we're skipping a lot of staging tests.\n\nHowever, fear not! With a well-done job on unit and integration tests, we're off to a great start. Here's where I leave it to you. Try running the test suite ensuring the deploy raffle is all green, and if you're feeling ambitious, aim to get that interactions test suite up and running as well.\n\nHappy testing!\n",
          "updates": []
        },
        {
          "lessonId": "a5038a9e-e70b-4db1-b087-a1c9855e7a5d",
          "number": 33,
          "title": "Deploy the lottery on the testnet pt.1",
          "slug": "testnet-demo",
          "folderName": "33-testnet-demo",
          "description": "In this lesson, learners are guided through deploying a smart contract onto a testnet, using a Makefile for automation, and interacting with the live contract on Etherscan. It emphasizes the real-world application and testing of smart contracts.",
          "duration": 8,
          "videoUrl": "9h98l1o6Oqc",
          "rawMarkdownUrl": "/routes/foundry/4-smart-contract-lottery/33-testnet-demo/+page.md",
          "markdownContent": "---\ntitle: Testnet Demo with a Makefile\n---\n\n_Follow along with this lesson and watch the video below:_\n\n\n\n---\n\nThe value of testing cannot be overstated when it comes to developing robust and reliable code. We've been discussing the importance of intensive testing, but today, we will explore whether the code we've been testing actually works on a real main net, or a real test net. Let's dive right in!\n\n## Let's Run Our Forge Script\n\nUsually, we'd opt to run our forge script to verify if our test data holds up on actual main or test nets. However, in this case, we're taking a slightly different route because we can automate this process using a `Makefile`.\n\n```makefile\n-include .env\n\n.PHONY all test deploy\n\n```\n\n## Automating Tasks with Makefile\n\nThe idea behind using a Makefile is to define all the commands we want to execute in our file. Including `env` allows our Makefile to be aware of our EMV environment variable. The `phony` all test deploy ensures that these are targets for our Makefile.\n\n### Adding a Help Function to Our Makefile\n\nA Makefile can get complicated as we add more commands and scripts. To help newbies or even ourselves in the future, we can add a small `help` command that explains how to use the Makefile.\n\n```makefile\n    help: @echo \"Usage:\"\n          @echo \"make deploy [ARGS=...]\"\n```\n\nCalling `make help` in the terminal will now provide a quick usage guide. Pro-tip: make sure to spell 'usage' correctly!\n\n## Building the Project\n\nIn the Makefile, adding a target `build` allows us to compile or build our project with `make build` or `forge build`. Remember, `:` and `;` mean the command is equivalent to a new line command.\n\n```makefile\nbuild:; forge build\n```\n\nThe Makefile will produce an error if we haven't set the version of solidity in the 'interaction test t sol file. Therefore, we do that with `Pragma solidity 0.8.18 build`.\n\n## Installing Dependencies\n\nWe also need to add an `install` command in the Makefile. This function lets anyone who clones our project know what dependencies they need to install. Here's how you can add this to your Makefile:\n\n```makefile\ninstall :; forge install Cyfrin/foundry-devops@0.0.11 --no-commit && forge install smartcontractkit/chainlink-brownie-contracts@0.6.1 --no-commit && forge install foundry-rs/forge-std@v1.5.3 --no-commit && forge install transmissions11/solmate@v6 --no-commit\n```\n\nAs we want the resultant text to be clean, we can use the 'toggle word wrap' option. This operation wraps any long command into multiple lines, giving the appearance of multiple different lines, whereas it technically remains a single line command.\n\nPulling up the terminal with `make install` reinstalls all the packages we ran with `forge install`, aiding efficiency of our process.\n\n## The Test and Deploy Targets\n\nHere, we add a `test` target, a necessary function in our Makefile, which simply calls `forge test.` Then, we define the `deploy` target.\n\n```makefile\ntest :; forge test\ndeploy:\n\t@forge script script/DeployRaffle.s.sol:DeployRaffle $(NETWORK_ARGS)\n```\n\nThis makes our deployment process easier and organized as opposed to running a giant line command each time we need to deploy our contracts. Note that `forge script` followed by the path tells Foundry to use the `run` function in whichever contract we've specified.\n\n<img src=\"/foundry-lottery/33-makefile/makefile1.png\" style=\"width: 100%; height: auto;\">\n\n## If Else Statement in Makefile\n\nWe want our Makefile to select a different chain based on the ARGS we pass. Thus, we define an `if else` statement that checks for network Sepolia. If it exists, the Makefile uses Sepolia; otherwise, it defaults to Anvil.\n\n```makefile\nifeq ($(findstring --network sepolia,$(ARGS)),--network sepolia)\n\tNETWORK_ARGS := --rpc-url $(SEPOLIA_RPC_URL) --private-key $(PRIVATE_KEY) --broadcast --verify --etherscan-api-key $(ETHERSCAN_API_KEY) -vvvv\nendif\n```\n\nWe can verify if this works by running `make deploy` in the terminal, which should display the actual script output. Suppose we choose not to pass the network, Anvil will be selected by default. Adding \"@\" prevents the command from being printed, thus protecting the security of our private key.\n\n## Conclusion\n\nTesting may seem tedious and kind of 'too much hassle' to put into our efforts, but it's worth it. Not only does it save us from dire situations, but it also gives an assurance that our code is strong enough to perform in real-life scenarios.\n\nMakefile provides a great way to automate many of these testing processes and to make your life much easier. In future posts, we'll delve deeper into the power of Makefiles. For now, experiment with testing, and happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "6cce2a3f-4ff2-467b-ad07-6e69500bdb7f",
          "number": 34,
          "title": "Deploy the lottery on the testnet pt.2",
          "slug": "the-demo",
          "folderName": "34-the-demo",
          "description": "This lesson covers the deployment of a smart contract on the Sepolia testnet, including how to use a makefile for efficient deployment, verification, and interaction with the contract on Etherscan. It also discusses the role of Chainlink in the contract.",
          "duration": 7,
          "videoUrl": "jCOaOV_dzm4",
          "rawMarkdownUrl": "/routes/foundry/4-smart-contract-lottery/34-the-demo/+page.md",
          "markdownContent": "---\ntitle: Testnet Demo... The Demo\n---\n\n_Follow along with this lesson and watch the video below:_\n\n\n\n---\n\nBeing able to deploy smart contracts to a real testnet is a crucial skill for any blockchain developer. If you ever find yourself at a loss trying to deploy your contract, this comprehensive guide has got you covered. We will be deploying a contract onto network Sepolia, using a makefile that conveniently eliminates the need for running `source .env`. Ultimately, we will interact with our live contract directly on Etherscan!\n\n## The Deployment and Verification Process\n\nInitiate the deployment by using the `make deploy` code. The deployment will result in a series of logs being printed out, reassuring you about the success of the scripts. The transactions will then appear on-chain, marked by the statement `Execute. Completely successful.`.\n\n```bash\nmake deploy ARGs=\"--network sepolia\"\n```\n\n### Addressing Foundry\n\nAs of the time of writing, Foundry, a development tool for Substrate, has a known bug where it deploys libraries along with on-chain deployments.\n\n### Accessing the Contract on Sepolia\n\nThe second contract address on Sepolia can be accessed by pasting it on the given network. Once navigated to the contract, you should find it already verified.\n\n### Understanding Chainlink\n\nNavigating to VRF Chainlink Sepolia 1893, if you have already subscribed and funded, you will find your latest consumer already added. In our case, it was the raffle contract we had just launched.\n\nDon't forget: for the contract to work, ensure you have sufficient LINK in your deploying wallet!\n\n```bash\nVRF Chainlink Sepolia 1893\n```\n\n## Write More Interactions for Your Contract\n\nOnce the contract is deployed, new interactions can be written, examples being `enter lottery`, `wait for a winner`, etc. Ethereum's Etherscan allows for connecting and interacting directly with contracts on the platform.\n\nThis guide focuses on using Etherscan, but for those who prefer good ol' Badass, the `cast` command works perfectly fine too.\n\n### Coming Face-to-Face with Raffle\n\nUnder the \"write contract\" tab on Etherscan, connect to Web3 and navigate to the `enter raffle` command. Select `write contract` and enter the amount you'd like for the transaction.\n\nGo to the `read contract` to check the contract's current state. Here, you can view the `recent winner`, `players`, `raffle state`, `entrance fee`, amongst other variables.\n\n### Registering a New Upkeep with Chainlink\n\nCreate and register a new upkeep on Chainlink, either manually or programmatically. Connect your wallet and fill in the contract address. After entering the desired `gas limit` and `starting balance`, click on 'register'.\n\nThe reason we have to register again is because our raffle has a `check upkeep` and `perform upkeep`, which can be called by anyone provided the conditions are met. To have the Chainlink network automatically perform these functions without interaction, create a subscription with Chainlink's network.\n\nA subscription can be set up on-chain and would be added to the active drawing upon sufficient funding. The Chainlink VRF would kick off when `performupkeep` runs.\n\n### Checking the Recent Winner\n\nWhile waiting for the VRF response, head back to the contract on Etherscan. Click 'refresh', connect to Web3 again, and scroll down to find the `recent winner`.\n\n<img src=\"/foundry-lottery/34-demo/demo1.png\" style=\"width: 100%; height: auto;\">\n\nAlternatively, transactions can be sent via Cast, which can be added to our makefile. Use the `cast call` command for calls not needing transaction publication. For the `get recent winner` parameter, use the `cast call` command. Don't forget the RPC URL, which in our case, is the Sepolia RPC URL.\n\n```bash\ncast call --help\n```\n\n```bash\ncast call [Lottery Address]\n```\n\n```bash\nsource .env\n```\n\nWith the contract address copy-pasted, the result is zero-padded. By trimming off the excess zeroes, you can confirm that it is indeed your contract address. Congratulations, you won your own lottery!\n",
          "updates": []
        },
        {
          "lessonId": "b92cbae2-aed6-4176-9787-c66526feb836",
          "number": 35,
          "title": "Implementing console log in your smart contract",
          "slug": "solidity-console-log-debug",
          "folderName": "35-console-log-debug",
          "description": "Focusing on debugging techniques in Solidity, this lesson teaches the implementation of console.log for debugging smart contracts. It highlights the importance of removing console logs before deploying to mainnet or testnet to save Ether and maintain efficiency.",
          "duration": 2,
          "videoUrl": "Xqe5x6LcgWA",
          "rawMarkdownUrl": "/routes/foundry/4-smart-contract-lottery/35-console-log-debug/+page.md",
          "markdownContent": "---\ntitle: Console.log Debugging\n---\n\n_Follow along with this lesson and watch the video below:_\n\n\n\n---\n\nTechnology is not always without complications. Bugs and glitches are common occurrences in the field of program writing. But if there is a problem, then a solution exists. Especially when working with Solidity in the Ethereum blockchain, it's critical to have a firm grip on debugging techniques. Today, I'm going to walk you through an additional tool you can use when debugging Solidity projects. From showing stack traces to logging console messages, we're going to cover it all. Buckle up!\n\n## The Power of Forge\n\nThe key lies in a command we ran during our tests - `forge test -vv` or `forge test -vvv`. The beauty of this command lies in its ability to show us the _stack trace_ of our output.\n\nWhen we write our tests, one way we've handled debugging in the past is by utilizing the `console` function in our contracts. For instance, let's consider a Raffle function we'd set up.\n\n```js\nimport { console } from \"forge-std/console.sol\";\n```\n\nWith this line of code, we import the `console` bit right at the start of our Raffle. Then, we proceed to apply the `console.log` command to any function we please, as demonstrated below:\n\n```js\nconsole.log(\"Hi\");\n```\n\nIn any test, where we call Enter Raffle, the console will log the message we've inserted.\n\n## A Crucial Word of Warning\n\n<img src=\"/foundry-lottery/35-debug/debugging1.png\" style=\"width: 100%; height: auto;\">\n\nHere's a heads up: always ensure to remove these console log commands before deploying to a mainnet or a testnet. Here's why:\n\n<img src=\"/foundry-lottery/35-debug/debugging2.png\" style=\"width: 100%; height: auto;\">\n\nIn other words, remember to delete the console actions post-debugging. While it might seem trivial, adhering to this practice could save you a considerable amount of Ether.\n\n## Conclusion\n\nAnd there you have it - an extra instrument in your programming toolkit. Concealed within the tangle of coding constructs and Solidity conventions, the `console.log` command could make your debugging journey smoother.\n\nSo the next time you grind through your lines of Solidity code, remember that the console's got your back! It might just be the help that you needed all along. Happy coding!\n",
          "updates": []
        },
        {
          "lessonId": "546efd1b-ad91-41e9-b7ab-641fb7c49ff9",
          "number": 36,
          "title": "Debug using forge test",
          "slug": "forge-test-debug",
          "folderName": "36-forge-test-debug",
          "description": "Introducing the Forge Debug Tool, this lesson explains how to use the debug functionality in Forge for in-depth analysis and step-through of smart contract code. It emphasizes the tool's utility in understanding specific elements in code for advanced debugging.",
          "duration": 2,
          "videoUrl": "EfoL48ZM2uM",
          "rawMarkdownUrl": "/routes/foundry/4-smart-contract-lottery/36-forge-test-debug/+page.md",
          "markdownContent": "---\ntitle: Forge Test --Debug\n---\n\n_Follow along with this lesson and watch the video below:_\n\n\n\n---\n\nIn the wide universe of tools available for debugging code in Opcodes, there's one that's proven to be both robust and in-depth. Say hello to the Forge Debug Tool - a dynamic tool designed to make your experience with Opcodes more hands-on and lucid. While it may seem intimidating at first, in this post, we're going to gently introduce you to this tool and its more granular aspects.\n\n## What Makes the Forge Debug Tool Stand Out?\n\nLet's get the ball rolling by showing you how it operates so you can understand why you might want to use it.\n\nInstead of running the conventional `forge test`, you'll have to run `forge test debug`, followed by the function you intend to debug. If executed correctly, this command will usher you into an interactive step-through of your code.\n\n```bash\n$ forge test --debug testRaffleRecordsPlayerWhenTheyEnter\n```\n\nOnce you're in, you gain access to a live playthrough of the specific Opcodes of your contract. Much like taking an exploratory dive into the inner workings of your code. This prompt should result in the help section popping up at the screen's lower part. It's a bit like calling for backup; the help section provides clarifications about the different features of the debug tool.\n\n## Diving Deeper: A Tug of War between Opcodes\n\nAfter initializing the help option, the real fun begins. When you type `J`, you'll be able to navigate through your function Opcode by Opcode.\n\n```bash\n$ J\n```\n\n<img src=\"/foundry-lottery/36-forge-debug/debug1.png\" style=\"width: 100%; height: auto;\">\n\nNow, treading through your code like this might seem like an endeavor fit for a painstakingly detailed person. That's because it is. Inspecting your code this way offers a highly granular and detailed way of debugging.\n\n<img src=\"/foundry-lottery/36-forge-debug/debug2.png\" style=\"width: 100%; height: auto;\">\n\nThe Forge Debug Tool puts the crystalline probe of understanding into your hands, allowing you to pinpoint specific elements in your code. So, while this method seems tedious, it’s incredibly helpful when the code's integrity is of utmost importance.\n\n## The Caveat: Timing Matters.\n\nSo, should you begin your coding journey with this method? Probably not. But, trust that as you get more advanced, the necessity for something like this will start to reveal itself. In those times when understanding why code behaves a certain way feels like cracking a code, this tool will come in handy.\n\nHowever, remember that there is no need to go overboard with it in the early learning stages. It's an advanced utility that's designed to aid advanced problems, and during your course's initial stages, it's best to stick to the basics.\n\n## Towards the Future: Assembly and Security Course\n\nThis blog post was meant to be an introduction to the Forge Debug Tool and won't dive into the details. You don't have to be a pro with this tool now, but being aware of its existence and what it can do for your code is essential.\n\nBy the way, there's also some exciting news for those passionate about assembly and security in coding. We are currently working on crafting an assembly and security course for you. This forthcoming course will further expand on the Forge Debug Tool and various other essential aspects of learning advanced programming languages.\n\nSo, keep an eye out!\n\n## Wrapping Up\n\nDespite being an advanced tool, the Forge Debug Tool can be an invaluable commodity as your understanding of Opcodes evolves and becomes more nuanced. Used correctly and at the right time, it can transform the tedious debugging phase into a phase of meaningful learning. Don't be afraid to explore it, but do so when the time is right!\n",
          "updates": []
        },
        {
          "lessonId": "3349af70-4777-4e65-9af8-ad603cae3313",
          "number": 37,
          "title": "Section recap",
          "slug": "recap",
          "folderName": "37-recap",
          "description": "A comprehensive recap of creating a provably fair lottery on the blockchain. The lesson revisits key components like custom errors, enums, private variables, constructor verbosity, raffle and Chainlink automation, and deployment on testnet, culminating in a complete overview of the project.",
          "duration": 6,
          "videoUrl": "fMDhz3CnIpQ",
          "rawMarkdownUrl": "/routes/foundry/4-smart-contract-lottery/37-recap/+page.md",
          "markdownContent": "---\ntitle: Recap\n---\n\n_Follow along with this lesson and watch the video below:_\n\n\n\n---\n\n# Building a Provably Fair Lottery on the Blockchain\n\nToday, let's do a recap of a project we recently accomplished — creating a provably fair lottery using blockchain technology! This might sound complex (and it is!), but it's exciting news. Let's understand why.\n\nEver thought of why you should use any other lottery system that's not blockchain-based? To be honest, the answer is a definite 'No.' The most compelling reason being that no other lottery provides you with the same level of randomness and transparency as blockchain does.\n\nSo, buckle up! Let's dive into this tutorial and take apart every component of our blockchain lottery contract.\n\n## Custom Errors, Enums and Private Variables\n\nIn our lottery contract, we kicked things off with some custom gas-efficient errors, including errors that accept multiple parameters. Part of the code we utilized was the type declarations. We took advantage of enums, assigning them different values and wrapping them as unsigned integers.\n\nOne essential part of our lottery contract was our beautiful, private state variables—part of our strong privacy practice. Additionally, we created getters for any variables we wanted to expose.\n\n## Verbose Constructor\n\nOne particular feature is that the constructor of our contract is verbose. By adjusting the deployment parameters accordingly, we are able to deploy this contract on any chain, ensuring flawless functionality. This holds true whether we're forking a testnet or a mainnet. The only thing required to accommodate a different network is a distinct network configuration.\n\n## Raffle and Chainlink Automation\n\nWe designed a raffle that emits a log, streamlining migrations and frontend indexing. We also learned about and integrated the Chainlink automation to automatically call our smart contracts.\n\nThe automation upkeep of our smart contracts led to an amazing result—it ran once because the perform upkeep requirement was met.\n\n## Smart Contract Execution and Testing\n\nOnce triggered, the Chainlink network replies by calling the `fulfill random words` function, which selects our random winner. We got a good look into the CEI - checks effects interactions pattern, where we implement checks, conduct effects and eventually process our external interactions outside of the smart contracts.\n\nWe provided several getter functions. Surprisingly, the codebase for this project is only about 200 lines long, but it felt much longer because of the advanced scripting and deployment methods we had to learn.\n\nWe deployed our contract using a helper configuration file. This ensured that this deployment will function flawlessly on whatever chain it's deployed. To bridge interactions with actual blockchain, while testing, we deployed mock contracts.\n\n## Broadcasting and Interaction via Command Line\n\nOnce the mockup and initial stage were completed, we began broadcasting and deploying our Raffle. Subsequently, we added our consumer to the VRF programmatically.\n\nAdditionally, we devised an interactions script to make it easier for us to run commands for adding consumers, creating, or funding subscriptions from our command line. This is way more straightforward than having to interact with cast.\n\n## Testing and Debugging\n\nDuring the process, we wrote comprehensive unit tests, though we intentionally left some areas that you can explore to level up your skill sets. For example, we tested with mock Chainlink tokens and learned some exciting testing techniques like capturing the event outputs to reuse later in our tests.\n\nWe also worked a lot with modifiers and expected a revert with this `abi encoder` thing. Understanding that will be a task for later.\n\nFinally, we deployed this lottery on an actual testnet chain, funding our automation subscription and our VRF subscription with Link. We observed chainlink nodes handling all this with no issues.\n\n## Recap\n\nThis has been a massive project, filled with learnings and hands-on coding experience. If you've followed through, congratulate yourself. This is the perfect time to take a break, soak up some sun, or binge on your favorite treats.\n\nRemember to post about this amazing project on Twitter, link it to your GitHub and give yourself a pat on the back. Progressing this far is a significant achievement.\n\nAs we advance through this course, you can broaden your technical knowledge related to the Web3 ecosystem. I look forward to your being a part of the remaining exciting lessons in this course. Till then, happy coding!\n\n## Congratulations\n\nYou've completed the course! You're now ready to build your own blockchain applications. Now you are ready to delve into advanced chapters of this course. Take a break, and then come back to learn more about the Web3 ecosystem.\n",
          "updates": []
        }
      ]
    }
  ],
  "createdAt": "2023-12-15T07:38:20.422Z",
  "updatedAt": "2023-12-15T07:38:20.422Z"
}